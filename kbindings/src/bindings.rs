/* automatically generated by rust-bindgen 0.72.1 */
use core::ffi;

type __kernel_size_t = usize;
type __kernel_ssize_t = isize;
type __kernel_ptrdiff_t = isize;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 4;
pub const CONFIG_GENERIC_PHY_MIPI_DPHY: u32 = 1;
pub const CONFIG_SPI_CADENCE_QUADSPI_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: u32 = 1;
pub const CONFIG_PINCTRL_SOPHGO_CV1800B: u32 = 1;
pub const CONFIG_BALLOON_COMPACTION: u32 = 1;
pub const CONFIG_MMC: u32 = 1;
pub const CONFIG_GPIOLIB: u32 = 1;
pub const CONFIG_SOC_STARFIVE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_UNCOMPRESSED: u32 = 1;
pub const CONFIG_NFS_V3: u32 = 1;
pub const CONFIG_VIDEO_DEV_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSEMI: u32 = 1;
pub const CONFIG_NET_VENDOR_NI: u32 = 1;
pub const CONFIG_USB_ROLE_SWITCH_MODULE: u32 = 1;
pub const CONFIG_NET_HANDSHAKE: u32 = 1;
pub const CONFIG_LIBFDT: u32 = 1;
pub const CONFIG_R8169: u32 = 1;
pub const CONFIG_PAGE_SHIFT: u32 = 12;
pub const CONFIG_PINCTRL_SOPHGO_SG2002: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_IKCONFIG: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_SAMPLE_RUST_DRIVER_PCI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_SCHED_CLOCK: u32 = 1;
pub const CONFIG_CRC_CCITT_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_PREEMPT_NONE_BUILD: u32 = 1;
pub const CONFIG_CRYPTO_GCM_MODULE: u32 = 1;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_SERIAL_8250_DEPRECATED_OPTIONS: u32 = 1;
pub const CONFIG_DMA_NONCOHERENT_MMAP: u32 = 1;
pub const CONFIG_ARCH_HAS_BINFMT_FLAT: u32 = 1;
pub const CONFIG_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_V4L2_FWNODE_MODULE: u32 = 1;
pub const CONFIG_INIT_STACK_ALL_ZERO: u32 = 1;
pub const CONFIG_SERIAL_SIFIVE: u32 = 1;
pub const CONFIG_ACPI_FAN: u32 = 1;
pub const CONFIG_RANDSTRUCT_NONE: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_FUNCTION_ALIGNMENT_4B: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_MMC_SDHCI_OF_K1: u32 = 1;
pub const CONFIG_RISCV_IOMMU_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_USB_MUSB_SUNXI_MODULE: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_SYS: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: u32 = 1;
pub const CONFIG_RISCV_INTC: u32 = 1;
pub const CONFIG_NET_VENDOR_ASIX: u32 = 1;
pub const CONFIG_ERRATA_THEAD_MAE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MODULE: u32 = 1;
pub const CONFIG_FB_DEVICE: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_PINCTRL_SOPHGO_CV1812H: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_BLOCK_LEGACY_AUTOLOAD: u32 = 1;
pub const CONFIG_DWMAC_GENERIC_MODULE: u32 = 1;
pub const CONFIG_SPI_SUN6I: u32 = 1;
pub const CONFIG_NETFS_SUPPORT: u32 = 1;
pub const CONFIG_GPIO_DWAPB: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_MODULE: u32 = 1;
pub const CONFIG_IP_VS_MH_TAB_INDEX: u32 = 12;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_RISCV_ISA_XTHEADVECTOR: u32 = 1;
pub const CONFIG_OF_IRQ: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 5;
pub const CONFIG_CRYPTO_ECB_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSOFT: u32 = 1;
pub const CONFIG_ARCH_RV64I: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_SLAB_OBJ_EXT: u32 = 1;
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_DRM_FBDEV_EMULATION: u32 = 1;
pub const CONFIG_USER_NS: u32 = 1;
pub const CONFIG_GENERIC_HWEIGHT: u32 = 1;
pub const CONFIG_ACPI_AC: u32 = 1;
pub const CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_INET_ESP_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_DRM_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_STMMAC_ETH_MODULE: u32 = 1;
pub const CONFIG_DMA_BOUNCE_UNALIGNED_KMALLOC: u32 = 1;
pub const CONFIG_NET_VENDOR_VERTEXCOM: u32 = 1;
pub const CONFIG_DMIID: u32 = 1;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_STAT: u32 = 1;
pub const CONFIG_NET_VENDOR_DAVICOM: u32 = 1;
pub const CONFIG_PINCTRL_SOPHGO_CV18XX_OPS: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_HID_CYPRESS: u32 = 1;
pub const CONFIG_ERRATA_THEAD: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_PHY_STARFIVE_JH7110_PCIE_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_VULNERABILITIES: u32 = 1;
pub const CONFIG_RISCV: u32 = 1;
pub const CONFIG_SND_SOC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE_MODULE: u32 = 1;
pub const CONFIG_PNP: u32 = 1;
pub const CONFIG_SATA_AHCI: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6_MODULE: u32 = 1;
pub const CONFIG_SUN20I_D1_CCU: u32 = 1;
pub const CONFIG_CRYPTO_RNG_MODULE: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG: u32 = 5;
pub const CONFIG_CRYPTO_HMAC_MODULE: u32 = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS: u32 = 1;
pub const CONFIG_REGULATOR_FIXED_VOLTAGE: u32 = 1;
pub const CONFIG_PGTABLE_HAS_HUGE_LEAVES: u32 = 1;
pub const CONFIG_CRYPTO_AES_MODULE: u32 = 1;
pub const CONFIG_PAGE_SIZE_4KB: u32 = 1;
pub const CONFIG_I2C_CHARDEV_MODULE: u32 = 1;
pub const CONFIG_AF_UNIX_OOB: u32 = 1;
pub const CONFIG_MMC_SPI: u32 = 1;
pub const CONFIG_DMI: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_EXPORT_BINARY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_CRASH_DUMP: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_CC_IS_CLANG: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_ARCH_HAS_MEMBARRIER_CALLBACKS: u32 = 1;
pub const CONFIG_ARCH_ANDES: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_FB_SYS_COPYAREA: u32 = 1;
pub const CONFIG_RESET_SPACEMIT: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_NET_VENDOR_CORTINA: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDMI_HELPER: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_RISCV_PMU: u32 = 1;
pub const CONFIG_COMPACT_UNEVICTABLE_DEFAULT: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_WX: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_USB_XHCI_PLATFORM: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_INLINE_SPIN_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_INET_TCP_DIAG: u32 = 1;
pub const CONFIG_DRM_EXEC_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_ARCH_WANT_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TFTP_MODULE: u32 = 1;
pub const CONFIG_USB_CDNS3_GADGET: u32 = 1;
pub const CONFIG_ACPI_DEBUG: u32 = 1;
pub const CONFIG_VIDEO: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_BINDGEN_VERSION_TEXT: &[u8; 15] = b"bindgen 0.72.1\0";
pub const CONFIG_XFRM_ESP_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PAGE_TABLE_CHECK: u32 = 1;
pub const CONFIG_OF_FLATTREE: u32 = 1;
pub const CONFIG_RISCV_ISA_V: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_INPUT_FF_MEMLESS: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_CC_HAS_NO_PROFILE_FN_ATTR: u32 = 1;
pub const CONFIG_USB_U_SERIAL_MODULE: u32 = 1;
pub const CONFIG_ACPI_SPCR_TABLE: u32 = 1;
pub const CONFIG_RISCV_TIMER: u32 = 1;
pub const CONFIG_OF_GPIO: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 21;
pub const CONFIG_RCU_TRACE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_USB_CONFIGFS_OBEX: u32 = 1;
pub const CONFIG_AS_HAS_OPTION_ARCH: u32 = 1;
pub const CONFIG_SENSORS_SFCTEMP_MODULE: u32 = 1;
pub const CONFIG_LZO_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: u32 = 1;
pub const CONFIG_HID_SUPPORT: u32 = 1;
pub const CONFIG_MACB: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_FONT_8x8: u32 = 1;
pub const CONFIG_EFIVAR_FS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_TIME_NS: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_MEMTEST: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_SANE_FUNCTION_ALIGNMENT: u32 = 1;
pub const CONFIG_STACKDEPOT_MAX_FRAMES: u32 = 64;
pub const CONFIG_FB_CFB_FILLRECT: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4_MODULE: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_NETFILTER_ADVANCED: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_USB_CONFIGFS_NCM: u32 = 1;
pub const CONFIG_RISCV_ALTERNATIVE: u32 = 1;
pub const CONFIG_PCI_DOMAINS_GENERIC: u32 = 1;
pub const CONFIG_PCIE_STARFIVE_HOST_MODULE: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_MMU_GATHER_RCU_TABLE_FREE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PER_VMA_LOCK: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 64;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 17;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_NET_9P: u32 = 1;
pub const CONFIG_DRM_DW_HDMI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_CAN_DEV_MODULE: u32 = 1;
pub const CONFIG_ERRATA_THEAD_PMU: u32 = 1;
pub const CONFIG_REGULATOR_AXP20X: u32 = 1;
pub const CONFIG_EVENT_TRACING: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_VOUT_MODULE: u32 = 1;
pub const CONFIG_LOCKD: u32 = 1;
pub const CONFIG_RPMSG_CTRL: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_FB_CFB_IMAGEBLIT: u32 = 1;
pub const CONFIG_COMPAT_BRK: u32 = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_GENERIC_IRQ_IPI: u32 = 1;
pub const CONFIG_PWRSEQ_EMMC: u32 = 1;
pub const CONFIG_FUTEX_PRIVATE_HASH: u32 = 1;
pub const CONFIG_VXLAN_MODULE: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_OF_EARLY_FLATTREE: u32 = 1;
pub const CONFIG_FB_DMAMEM_HELPERS_DEFERRED: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE: u32 = 1;
pub const CONFIG_CRYPTO_ENGINE_MODULE: u32 = 1;
pub const CONFIG_BLK_ICQ: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_PLL: u32 = 1;
pub const CONFIG_RING_BUFFER: u32 = 1;
pub const CONFIG_PCIE_FU740: u32 = 1;
pub const CONFIG_LLC_MODULE: u32 = 1;
pub const CONFIG_MFD_SYSCON: u32 = 1;
pub const CONFIG_GPIOLIB_FASTPATH_LIMIT: u32 = 512;
pub const CONFIG_GENERIC_IRQ_SHOW_LEVEL: u32 = 1;
pub const CONFIG_RESET_CONTROLLER: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_HUGETLBFS: u32 = 1;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_DRM_GPUVM_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_DIRTY_RING: u32 = 1;
pub const CONFIG_PINCTRL_TH1520: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_HARDIRQS_SW_RESEND: u32 = 1;
pub const CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT: u32 = 1;
pub const CONFIG_DRM_SUN4I_MODULE: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_RISCV_SBI: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_64KB: u32 = 1;
pub const CONFIG_VLAN_8021Q_MODULE: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_PNFS_FILE_LAYOUT: u32 = 1;
pub const CONFIG_EFI_EARLYCON: u32 = 1;
pub const CONFIG_GPIOLIB_LEGACY: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_DWMAC_THEAD_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_CRYPTO_SIG_MODULE: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_CAN_GW_MODULE: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_PAHOLE_VERSION: u32 = 125;
pub const CONFIG_MEDIA_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_PLATFORM: u32 = 1;
pub const CONFIG_DWMAC_STARFIVE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_TRACE_CLOCK: u32 = 1;
pub const CONFIG_ACPI_BUTTON: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_FB_NOTIFY: u32 = 1;
pub const CONFIG_TASKS_RCU_GENERIC: u32 = 1;
pub const CONFIG_PREEMPT_NOTIFIERS: u32 = 1;
pub const CONFIG_PINCTRL_SUNXI: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_MMC_SDHCI_CADENCE: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS: u32 = 1;
pub const CONFIG_DRM_PANEL_ORIENTATION_QUIRKS_MODULE: u32 = 1;
pub const CONFIG_MTD_GEN_PROBE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_ARCH_HAS_TICK_BROADCAST: u32 = 1;
pub const CONFIG_KVM_GENERIC_HARDWARE_ENABLING: u32 = 1;
pub const CONFIG_PWRSEQ_SIMPLE: u32 = 1;
pub const CONFIG_ARCH_HAS_PREPARE_SYNC_CORE_CMD: u32 = 1;
pub const CONFIG_PCIE_DW_HOST: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_DWMAC_SUN8I_MODULE: u32 = 1;
pub const CONFIG_KVM_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 4096;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR: u32 = 1;
pub const CONFIG_NFS_V4: u32 = 1;
pub const CONFIG_KCMP: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_CH7006_MODULE: u32 = 1;
pub const CONFIG_XFRM_ALGO_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_BUILD_SALT: &[u8; 1] = b"\0";
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_AS_HAS_ULEB128: u32 = 1;
pub const CONFIG_IP_PNP_BOOTP: u32 = 1;
pub const CONFIG_MODPROBE_PATH: &[u8; 15] = b"/sbin/modprobe\0";
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_HAVE_CLK: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_RT: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_RISCV_PROBE_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_SERIAL_SIFIVE_CONSOLE: u32 = 1;
pub const CONFIG_ARCH_HAS_CURRENT_STACK_POINTER: u32 = 1;
pub const CONFIG_FB_SYSMEM_HELPERS: u32 = 1;
pub const CONFIG_SERIAL_8250_PNP: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_TOOLCHAIN_HAS_VECTOR_CRYPTO: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_MODULE: u32 = 1;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_STACKDEPOT: u32 = 1;
pub const CONFIG_USB_CDNS_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_IP_VS_MODULE: u32 = 1;
pub const CONFIG_UNION_FIND: u32 = 1;
pub const CONFIG_BTRFS_FS_MODULE: u32 = 1;
pub const CONFIG_KVFREE_RCU_BATCHED: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: u32 = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: u32 = 1;
pub const CONFIG_LEGACY_DIRECT_IO: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_NVME_CORE_MODULE: u32 = 1;
pub const CONFIG_SKB_EXTENSIONS: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_MMC_SUNXI: u32 = 1;
pub const CONFIG_PWM_PXA_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_SND_SOC_SDCA_OPTIONAL: u32 = 1;
pub const CONFIG_SERIAL_MCTRL_GPIO: u32 = 1;
pub const CONFIG_CLK_SIFIVE: u32 = 1;
pub const CONFIG_GENERIC_GETTIMEOFDAY: u32 = 1;
pub const CONFIG_SND_USB: u32 = 1;
pub const CONFIG_PCS_XPCS_MODULE: u32 = 1;
pub const CONFIG_ND_CLAIM: u32 = 1;
pub const CONFIG_GPIO_CDEV_V1: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_CRYPTO_SHA3_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_SND: u32 = 1;
pub const CONFIG_CRYPTO_AEAD_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_THROTTLING: u32 = 1;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_PROC_CHILDREN: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_CORE_BEFORE_USERMODE: u32 = 1;
pub const CONFIG_RISCV_COMBO_SPINLOCKS: u32 = 1;
pub const CONFIG_CMDLINE: &[u8; 1] = b"\0";
pub const CONFIG_INITRAMFS_PRESERVE_MTIME: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_DMA_ENGINE: u32 = 1;
pub const CONFIG_IRQ_STACKS: u32 = 1;
pub const CONFIG_ARCH_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C_MODULE: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_USB_F_NCM_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_BPF_UNPRIV_DEFAULT_OFF: u32 = 1;
pub const CONFIG_CGROUP_BPF: u32 = 1;
pub const CONFIG_ARCH_WEAK_RELEASE_ACQUIRE: u32 = 1;
pub const CONFIG_SUN8I_DE2_CCU_MODULE: u32 = 1;
pub const CONFIG_LOCK_DEBUGGING_SUPPORT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE: u32 = 256;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_FB_SYSMEM_FOPS: u32 = 1;
pub const CONFIG_DRM_SUN8I_TCON_TOP_MODULE: u32 = 1;
pub const CONFIG_RUSTC_SUPPORTS_RISCV: u32 = 1;
pub const CONFIG_PAGE_REPORTING: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_RUST_OVERFLOW_CHECKS: u32 = 1;
pub const CONFIG_VIRTIO_MENU: u32 = 1;
pub const CONFIG_NET_VENDOR_CADENCE: u32 = 1;
pub const CONFIG_SPLIT_PTE_PTLOCKS: u32 = 1;
pub const CONFIG_BLK_DEV_WRITE_MOUNTED: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KSTACK_ERASE: u32 = 1;
pub const CONFIG_RISCV_ISA_FALLBACK: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_DRM_SUN8I_MIXER_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_RUST_MISC_DEVICE_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_NET_SELFTESTS: u32 = 1;
pub const CONFIG_RISCV_ISA_VENDOR_EXT_ANDES: u32 = 1;
pub const CONFIG_AS_HAS_NON_CONST_ULEB128: u32 = 1;
pub const CONFIG_LLD_VERSION: u32 = 140000;
pub const CONFIG_CRYPTO_HASH_MODULE: u32 = 1;
pub const CONFIG_GROUP_SCHED_BANDWIDTH: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC_MODULE: u32 = 1;
pub const CONFIG_DRM_CLIENT_LIB_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_DAX: u32 = 1;
pub const CONFIG_MEMREGION: u32 = 1;
pub const CONFIG_NETFILTER_EGRESS: u32 = 1;
pub const CONFIG_GPIOLIB_IRQCHIP: u32 = 1;
pub const CONFIG_INLINE_READ_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_SUNRPC: u32 = 1;
pub const CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS: u32 = 0;
pub const CONFIG_USB_CDNS_HOST: u32 = 1;
pub const CONFIG_JH71XX_PMU: u32 = 1;
pub const CONFIG_FS_STACK: u32 = 1;
pub const CONFIG_GENERIC_CPU_DEVICES: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB: u32 = 1;
pub const CONFIG_ARCH_WANT_FRAME_POINTERS: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_MTD_CFI: u32 = 1;
pub const CONFIG_GENERIC_IRQ_IPI_MUX: u32 = 1;
pub const CONFIG_CAN_MODULE: u32 = 1;
pub const CONFIG_PM_CLK: u32 = 1;
pub const CONFIG_NET_XGRESS: u32 = 1;
pub const CONFIG_SATA_HOST: u32 = 1;
pub const CONFIG_SND_PCM_TIMER: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_USB_F_MASS_STORAGE_MODULE: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS_OF: u32 = 1;
pub const CONFIG_GPIO_SIFIVE: u32 = 1;
pub const CONFIG_HAVE_KVM_MSI: u32 = 1;
pub const CONFIG_ARCH_KEEP_MEMBLOCK: u32 = 1;
pub const CONFIG_CRYPTO_HASH2_MODULE: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_SND_SOC_WM8978_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_GF128MUL_MODULE: u32 = 1;
pub const CONFIG_SPLIT_PMD_PTLOCKS: u32 = 1;
pub const CONFIG_HID_MICROSOFT: u32 = 1;
pub const CONFIG_USB_MUSB_DUAL_ROLE: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_TRACEFS_AUTOMOUNT_DEPRECATED: u32 = 1;
pub const CONFIG_RISCV_ISA_ZICBOP: u32 = 1;
pub const CONFIG_IO_URING_ZCRX: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH_DEFAULT: u32 = 1;
pub const CONFIG_CLK_SOPHGO_SG2042_RPGATE: u32 = 1;
pub const CONFIG_VIRTIO_ANCHOR: u32 = 1;
pub const CONFIG_SND_TIMER: u32 = 1;
pub const CONFIG_NETLINK_DIAG: u32 = 1;
pub const CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_VIRTIO_BLK: u32 = 1;
pub const CONFIG_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_SOCK_RX_QUEUE_MAPPING: u32 = 1;
pub const CONFIG_AUXILIARY_BUS: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_RISCV_ISA_V_UCOPY_THRESHOLD: u32 = 768;
pub const CONFIG_NLS_ISO8859_1_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_DTC: u32 = 1;
pub const CONFIG_SIFIVE_CCACHE: u32 = 1;
pub const CONFIG_PATA_TIMINGS: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_RESET_SIMPLE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_PCI_HOST_GENERIC: u32 = 1;
pub const CONFIG_STANDALONE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_EEM: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO: u32 = 1;
pub const CONFIG_ARCH_STARFIVE: u32 = 1;
pub const CONFIG_SCSI_VIRTIO: u32 = 1;
pub const CONFIG_RISCV_IMSIC: u32 = 1;
pub const CONFIG_I2C_HID: u32 = 1;
pub const CONFIG_SAMPLE_RUST_MINIMAL_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &[u8; 6] = b"cubic\0";
pub const CONFIG_SUNXI_WATCHDOG: u32 = 1;
pub const CONFIG_ERRATA_SIFIVE_CIP_453: u32 = 1;
pub const CONFIG_MTD_CFI_UTIL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_SILABS: u32 = 1;
pub const CONFIG_HAVE_KERNEL_ZSTD: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_SPI_MEM: u32 = 1;
pub const CONFIG_MMC_BLOCK: u32 = 1;
pub const CONFIG_GCC_NO_STRINGOP_OVERFLOW: u32 = 1;
pub const CONFIG_PHY_STARFIVE_JH7110_USB_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ATTR_SET: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_SPI_PL022_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: u32 = 1;
pub const CONFIG_ARCH_HAS_KERNEL_FPU_SUPPORT: u32 = 1;
pub const CONFIG_HOTPLUG_CORE_SYNC: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_VIRTIO_MMIO: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_BLK_PM: u32 = 1;
pub const CONFIG_VHOST_ENABLE_FORK_OWNER_CONTROL: u32 = 1;
pub const CONFIG_LEGACY_PTY_COUNT: u32 = 256;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_SUN20I_PPU: u32 = 1;
pub const CONFIG_OF_PMEM: u32 = 1;
pub const CONFIG_DYNAMIC_SIGFRAME: u32 = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK: u32 = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_DRM_CLIENT_DEFAULT: &[u8; 6] = b"fbdev\0";
pub const CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB_LEGACY: u32 = 1;
pub const CONFIG_COMMON_CLK: u32 = 1;
pub const CONFIG_PHYLINK: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_UTILS_MODULE: u32 = 1;
pub const CONFIG_CACHESTAT_SYSCALL: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ACM: u32 = 1;
pub const CONFIG_SPI_SIFIVE: u32 = 1;
pub const CONFIG_NFS_DISABLE_UDP_SUPPORT: u32 = 1;
pub const CONFIG_MAX_SKB_FRAGS: u32 = 17;
pub const CONFIG_CRYPTO_ACOMP2_MODULE: u32 = 1;
pub const CONFIG_INET_TABLE_PERTURB_ORDER: u32 = 16;
pub const CONFIG_VIRTIO_INPUT: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_NF_CONNTRACK_FTP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_JH7110_PWMDAC_MODULE: u32 = 1;
pub const CONFIG_RISCV_PMU_SBI: u32 = 1;
pub const CONFIG_MMU_GATHER_TABLE_FREE: u32 = 1;
pub const CONFIG_CMODEL_MEDANY: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN_VMALLOC: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_HID_MONTEREY: u32 = 1;
pub const CONFIG_NET_VENDOR_PACKET_ENGINES: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_USB_XHCI_PCI: u32 = 1;
pub const CONFIG_HAVE_FTRACE_GRAPH_FUNC: u32 = 1;
pub const CONFIG_SCHED_INFO: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_DEBUG_MEMORY_INIT: u32 = 1;
pub const CONFIG_MEDIA_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_ACPI_MCFG: u32 = 1;
pub const CONFIG_MFD_AXP20X: u32 = 1;
pub const CONFIG_DMA_DIRECT_REMAP: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_HAS_LTO_CLANG: u32 = 1;
pub const CONFIG_I2C_MUX_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_DMADEVICES: u32 = 1;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_TIMER_OF: u32 = 1;
pub const CONFIG_USB_UAS: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256: u32 = 1;
pub const CONFIG_SERIAL_8250_DMA: u32 = 1;
pub const CONFIG_RISCV_SCALAR_MISALIGNED: u32 = 1;
pub const CONFIG_TUNE_GENERIC: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL: u32 = 1;
pub const CONFIG_HAVE_PCI: u32 = 1;
pub const CONFIG_ARCH_HAS_HW_PTE_YOUNG: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_DRM_MIPI_DSI: u32 = 1;
pub const CONFIG_CRYPTO_RNG2_MODULE: u32 = 1;
pub const CONFIG_MMC_DW_PLTFM: u32 = 1;
pub const CONFIG_CRYPTO_DEV_ALLWINNER: u32 = 1;
pub const CONFIG_USB_CDNS3_PCI_WRAP_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_RUST_DRIVER_AUXILIARY_MODULE: u32 = 1;
pub const CONFIG_ND_BTT: u32 = 1;
pub const CONFIG_PHY_SUN6I_MIPI_DPHY_MODULE: u32 = 1;
pub const CONFIG_RUNTIME_KERNEL_TESTING_MENU: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_CAN_CALC_BITTIMING: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_IP_PNP: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_PURGATORY: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_GPIO_SPACEMIT_K1: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_OF_ADDRESS: u32 = 1;
pub const CONFIG_USB_CONFIGFS_RNDIS: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_THERMAL_HWMON: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_NET_VENDOR_FUNGIBLE: u32 = 1;
pub const CONFIG_GENERIC_PINCONF: u32 = 1;
pub const CONFIG_MOUSE_PS2: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_PCPU_DEV_REFCNT: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_IP_VS_RR_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_POWERSAVE_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_OPEN_TIMEOUT: u32 = 0;
pub const CONFIG_BUILDTIME_TABLE_SORT: u32 = 1;
pub const CONFIG_E1000E: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_VIRTIO_NET: u32 = 1;
pub const CONFIG_PINMUX: u32 = 1;
pub const CONFIG_CRYPTO_SIG2_MODULE: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_ENABLE_OBSOLETE: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_PNP_DEBUG_MESSAGES: u32 = 1;
pub const CONFIG_ARCH_MICROCHIP_POLARFIRE: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQ_ROUTING: u32 = 1;
pub const CONFIG_TOOLS_SUPPORT_RELR: u32 = 1;
pub const CONFIG_PCIE_XILINX: u32 = 1;
pub const CONFIG_BRIDGE_IGMP_SNOOPING: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB_QXFER_PKT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_PCI_LABEL: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OPTIONAL: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKS: u32 = 64;
pub const CONFIG_DM_BUFIO_MODULE: u32 = 1;
pub const CONFIG_DEBUG_MISC: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_CPU_FREQ: u32 = 1;
pub const CONFIG_KEYBOARD_SUN4I_LRADC_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &[u8; 10] = b"iso8859-1\0";
pub const CONFIG_PREEMPT_NONE: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_CFS_BANDWIDTH: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const CONFIG_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_DWMAC_SOPHGO_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_LOCK_MM_AND_FIND_VMA: u32 = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: u32 = 1;
pub const CONFIG_REGULATOR_GPIO: u32 = 1;
pub const CONFIG_BLK_MQ_STACKING: u32 = 1;
pub const CONFIG_HAVE_KERNEL_XZ: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI2_MODULE: u32 = 1;
pub const CONFIG_CPU_MITIGATIONS: u32 = 1;
pub const CONFIG_RAID6_PQ_MODULE: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_PROC_MEM_ALWAYS_FORCE: u32 = 1;
pub const CONFIG_PINCONF: u32 = 1;
pub const CONFIG_FUNCTION_ALIGNMENT: u32 = 4;
pub const CONFIG_SND_DESIGNWARE_I2S_MODULE: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_CAN_BCM_MODULE: u32 = 1;
pub const CONFIG_RPMSG: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_USB_GADGET_VBUS_DRAW: u32 = 2;
pub const CONFIG_NFS_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_NET_9P_FD: u32 = 1;
pub const CONFIG_LSM: &[u8; 49] = b"landlock,lockdown,yama,loadpin,safesetid,ipe,bpf\0";
pub const CONFIG_FB_CFB_COPYAREA: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI_MODULE: u32 = 1;
pub const CONFIG_KVM_XFER_TO_GUEST_WORK: u32 = 1;
pub const CONFIG_DWMAC_SUNXI_MODULE: u32 = 1;
pub const CONFIG_RESET_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_DYNAMIC_EVENTS: u32 = 1;
pub const CONFIG_SAMPLE_RUST_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_CLONE_BACKWARDS: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_PCI_HOST_COMMON: u32 = 1;
pub const CONFIG_THERMAL: u32 = 1;
pub const CONFIG_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_NETFILTER_BPF_LINK: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_RISCV_ISA_ZICBOZ: u32 = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_SND_DRIVERS: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_RUSTC_VERSION: u32 = 107800;
pub const CONFIG_MTD_BLKDEVS: u32 = 1;
pub const CONFIG_KERNEL_GZIP: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_PINCTRL_STARFIVE_JH7110_SYS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_EEPROM_93CX6: u32 = 1;
pub const CONFIG_IP_PNP_DHCP: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_CRYPTO_GHASH_MODULE: u32 = 1;
pub const CONFIG_ARCH_OPTIONAL_KERNEL_RWX: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_NET_UDP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_HZ_250: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS: u32 = 1;
pub const CONFIG_ARCH_HAS_SYSCALL_WRAPPER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_DMA_COHERENT_POOL: u32 = 1;
pub const CONFIG_CLANG_SUPPORTS_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_HAVE_GUP_FAST: u32 = 1;
pub const CONFIG_HAVE_64BIT_ALIGNED_ACCESS: u32 = 1;
pub const CONFIG_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_NET_VENDOR_WANGXUN: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_PM_OPP: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_NVMEM_LAYOUTS: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_IIO: u32 = 1;
pub const CONFIG_PINCTRL_SOPHGO_COMMON: u32 = 1;
pub const CONFIG_ARCH_CANAAN: u32 = 1;
pub const CONFIG_DRM_SUN6I_DSI_MODULE: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_HZ: u32 = 250;
pub const CONFIG_TRACING: u32 = 1;
pub const CONFIG_ACPI: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_CHECKPOINT_RESTORE: u32 = 1;
pub const CONFIG_BLK_DEV_DM_MODULE: u32 = 1;
pub const CONFIG_KVM_COMMON: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_DRM_RADEON_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_FS: u32 = 1;
pub const CONFIG_RISCV_ISA_SUPM: u32 = 1;
pub const CONFIG_IPV6_SIT: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_STARFIVE_JH8100_INTC: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_MFD_CORE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_IPVLAN_L3S: u32 = 1;
pub const CONFIG_CRYPTO_XXHASH_MODULE: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_RTC_HCTOSYS_DEVICE: &[u8; 5] = b"rtc0\0";
pub const CONFIG_GENERIC_VDSO_TIME_NS: u32 = 1;
pub const CONFIG_SND_JACK_INPUT_DEV: u32 = 1;
pub const CONFIG_DRM_CLIENT_SETUP: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_NET_VENDOR_META: u32 = 1;
pub const CONFIG_IKCONFIG_PROC: u32 = 1;
pub const CONFIG_SECURITY_PATH: u32 = 1;
pub const CONFIG_USB_OTG: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MULTI_HANDLER: u32 = 1;
pub const CONFIG_FB_CORE: u32 = 1;
pub const CONFIG_DRM_GEM_DMA_HELPER_MODULE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: u32 = 1;
pub const CONFIG_PROBE_EVENTS: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS: u32 = 9;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMALLOC: u32 = 1;
pub const CONFIG_ARCH_SUNXI: u32 = 1;
pub const CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_PARANOID_LOAD: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_MODULE: u32 = 1;
pub const CONFIG_CLKSRC_MMIO: u32 = 1;
pub const CONFIG_AS_IS_LLVM: u32 = 1;
pub const CONFIG_IP_VS_PROTO_UDP: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_XZ_DEC_ARM64: u32 = 1;
pub const CONFIG_LOCALVERSION: &[u8; 1] = b"\0";
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_IOSCHED_BFQ: u32 = 1;
pub const CONFIG_CPUFREQ_DT: u32 = 1;
pub const CONFIG_SUN50I_IOMMU: u32 = 1;
pub const CONFIG_POWER_RESET_SYSCON: u32 = 1;
pub const CONFIG_REGMAP_MMIO: u32 = 1;
pub const CONFIG_IP_PNP_RARP: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_KMS: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_RISCV_DMA_NONCOHERENT: u32 = 1;
pub const CONFIG_STACKPROTECTOR: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_IP_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_HID_KENSINGTON: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT: u32 = 1;
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_HID_A4TECH: u32 = 1;
pub const CONFIG_ACPI_CPPC_CPUFREQ_MODULE: u32 = 1;
pub const CONFIG_USB_F_FS_MODULE: u32 = 1;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_SND_PROC_FS: u32 = 1;
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_CRYPTO_CTR_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_PCILIB: u32 = 1;
pub const CONFIG_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_VHOST_MENU: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_CRYPTO_CBC_MODULE: u32 = 1;
pub const CONFIG_SND_PCM: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZO: u32 = 1;
pub const CONFIG_CGROUP_WRITEBACK: u32 = 1;
pub const CONFIG_HOTPLUG_CORE_SYNC_DEAD: u32 = 1;
pub const CONFIG_EFI_GENERIC_STUB: u32 = 1;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_RISCV_PMU_LEGACY: u32 = 1;
pub const CONFIG_PINCTRL_STARFIVE_JH7110_AON: u32 = 1;
pub const CONFIG_SYSCTL_ARCH_UNALIGN_ALLOW: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_HAVE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_ACPI_MDIO: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM: u32 = 1;
pub const CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE: u32 = 1;
pub const CONFIG_MMC_SDHCI_PLTFM: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_RESET_STARFIVE_JH71X0: u32 = 1;
pub const CONFIG_XOR_BLOCKS_MODULE: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_MEDIA_SUBDRV_AUTOSELECT: u32 = 1;
pub const CONFIG_MACVLAN_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC: u32 = 1;
pub const CONFIG_CC_HAS_INT128: u32 = 1;
pub const CONFIG_SIFIVE_PLIC: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_ARCH_SPACEMIT: u32 = 1;
pub const CONFIG_RISCV_ISA_ZBA: u32 = 1;
pub const CONFIG_FB_SYS_FILLRECT: u32 = 1;
pub const CONFIG_XARRAY_MULTI: u32 = 1;
pub const CONFIG_CLK_THEAD_TH1520_AP: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON_RISCV_SBI: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_FILE: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_PWM: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_CONFIGFS_FS_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_INIT: &[u8; 1] = b"\0";
pub const CONFIG_LD_IS_LLD: u32 = 1;
pub const CONFIG_SND_SPI: u32 = 1;
pub const CONFIG_ATA_ACPI: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_RAID6_PQ_BENCHMARK: u32 = 1;
pub const CONFIG_OF_RESERVED_MEM: u32 = 1;
pub const CONFIG_RISCV_ISA_ZAWRS: u32 = 1;
pub const CONFIG_REALTEK_PHY: u32 = 1;
pub const CONFIG_CRYPTO_KPP2_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_ARCH_SUPPORTS_CFI_CLANG: u32 = 1;
pub const CONFIG_DRM_TTM_HELPER_MODULE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_SUN6I_RTC_CCU: u32 = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: u32 = 1;
pub const CONFIG_MMC_DW: u32 = 1;
pub const CONFIG_RUSTC_LLVM_VERSION: u32 = 180102;
pub const CONFIG_EXTCON: u32 = 1;
pub const CONFIG_ARCH_HAS_PTDUMP: u32 = 1;
pub const CONFIG_DMA_ACPI: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_GENERIC_IDLE_POLL_SETUP: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER: u32 = 1;
pub const CONFIG_XZ_DEC_RISCV: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_RD_ZSTD: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA512_MODULE: u32 = 1;
pub const CONFIG_DM_THIN_PROVISIONING_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_VCPU_ASYNC_IOCTL: u32 = 1;
pub const CONFIG_HAVE_RSEQ: u32 = 1;
pub const CONFIG_REGMAP_IRQ: u32 = 1;
pub const CONFIG_HAVE_KCSAN_COMPILER: u32 = 1;
pub const CONFIG_IPVLAN_MODULE: u32 = 1;
pub const CONFIG_GCC10_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_SPI_DYNAMIC: u32 = 1;
pub const CONFIG_ARCH_DMA_DEFAULT_COHERENT: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: u32 = 1;
pub const CONFIG_VT_HW_CONSOLE_BINDING: u32 = 1;
pub const CONFIG_I2C_ALGOBIT_MODULE: u32 = 1;
pub const CONFIG_HAVE_RETHOOK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_CLK_SIFIVE_PRCI: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: u32 = 1;
pub const CONFIG_CPUFREQ_DT_PLATDEV: u32 = 1;
pub const CONFIG_SAMPLE_RUST_DRIVER_FAUX_MODULE: u32 = 1;
pub const CONFIG_FWNODE_MDIO: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_RISCV_APLIC: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 4;
pub const CONFIG_NO_HZ_IDLE: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_USB_STORAGE: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_ARCH_MICROCHIP: u32 = 1;
pub const CONFIG_CRYPTO_RSA_MODULE: u32 = 1;
pub const CONFIG_INLINE_READ_UNLOCK: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_WATCHDOG_CORE: u32 = 1;
pub const CONFIG_ARCH_FLATMEM_ENABLE: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_IO_URING: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_PHY_SUN4I_USB_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_RISCV_VECTOR_MISALIGNED: u32 = 1;
pub const CONFIG_RISCV_ISA_VENDOR_EXT_THEAD: u32 = 1;
pub const CONFIG_MTD_BLOCK: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_NFS_V4_2: u32 = 1;
pub const CONFIG_DW_AXI_DMAC: u32 = 1;
pub const CONFIG_MFD_AXP20X_I2C: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_DRM_TTM_MODULE: u32 = 1;
pub const CONFIG_MMC_DW_STARFIVE: u32 = 1;
pub const CONFIG_MTD_CFI_I2: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_SIL164_MODULE: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_RISCV_NONSTANDARD_CACHE_OPS: u32 = 1;
pub const CONFIG_ARCH_HAS_MMIOWB: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_POWER_RESET_SYSCON_POWEROFF: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_SUNRPC_BACKCHANNEL: u32 = 1;
pub const CONFIG_BLOCK_HOLDER_DEPRECATED: u32 = 1;
pub const CONFIG_GENERIC_IRQ_ENTRY: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_VIDEO_CADENCE_CSI2RX_MODULE: u32 = 1;
pub const CONFIG_USB_AUTOSUSPEND_DELAY: u32 = 2;
pub const CONFIG_CRYPTO_SEQIV_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 17;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_BFQ_GROUP_IOSCHED: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_MMC_BLOCK_MINORS: u32 = 8;
pub const CONFIG_CRYPTO_USER_API_HASH_MODULE: u32 = 1;
pub const CONFIG_SUN6I_MSGBOX: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS_SLEEP: u32 = 1;
pub const CONFIG_HID_CHICONY: u32 = 1;
pub const CONFIG_PCI_ECAM: u32 = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 24;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_RISCV_SBI_CPUIDLE: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_BPF_SYSCALL: u32 = 1;
pub const CONFIG_SND_PCI: u32 = 1;
pub const CONFIG_USB_EHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_RISCV_ISA_ZBB: u32 = 1;
pub const CONFIG_NFS_V4_2_SSC_HELPER: u32 = 1;
pub const CONFIG_MTD_CFI_I1: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_FB_SYS_IMAGEBLIT: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ACPI: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_OSR: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_SPACEMIT_CCU: u32 = 1;
pub const CONFIG_PNFS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_V4L2_ASYNC_MODULE: u32 = 1;
pub const CONFIG_AUDIT_GENERIC: u32 = 1;
pub const CONFIG_ACPI_VIDEO_MODULE: u32 = 1;
pub const CONFIG_IO_WQ: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: u32 = 1;
pub const CONFIG_VDSO_GETRANDOM: u32 = 1;
pub const CONFIG_AS_VERSION: u32 = 180108;
pub const CONFIG_BLK_CGROUP_PUNT_BIO: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_BTT: u32 = 1;
pub const CONFIG_NFS_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_MD_BITMAP_FILE: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_SUN20I_D1_R_CCU: u32 = 1;
pub const CONFIG_PCIE_PLDA_HOST: u32 = 1;
pub const CONFIG_RUST_IS_AVAILABLE: u32 = 1;
pub const CONFIG_TOOLCHAIN_HAS_V: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HELPER_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE_MULTIPLE_DRIVERS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 18;
pub const CONFIG_PCIE_DW: u32 = 1;
pub const CONFIG_ARCH_DEFAULT_CRASH_DUMP: u32 = 1;
pub const CONFIG_GENERIC_PINCTRL_GROUPS: u32 = 1;
pub const CONFIG_NF_CT_PROTO_UDPLITE: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_NFS_V4_2_READ_PLUS: u32 = 1;
pub const CONFIG_SND_SOC_SPDIF_MODULE: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_BRIDGE_VLAN_FILTERING: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &[u8; 10] = b"iso8859-1\0";
pub const CONFIG_DMA_NEED_SYNC: u32 = 1;
pub const CONFIG_RESET_SUNXI: u32 = 1;
pub const CONFIG_REGULATOR: u32 = 1;
pub const CONFIG_ACPI_I2C_OPREGION: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKSIZE: u32 = 32;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_HAVE_MOVE_PMD: u32 = 1;
pub const CONFIG_RISCV_APLIC_MSI: u32 = 1;
pub const CONFIG_FAILOVER: u32 = 1;
pub const CONFIG_PAGE_MAPCOUNT: u32 = 1;
pub const CONFIG_LINEAR_RANGES: u32 = 1;
pub const CONFIG_NFS_V4_1: u32 = 1;
pub const CONFIG_RTC_DRV_GOLDFISH: u32 = 1;
pub const CONFIG_VIRTIO_DMA_SHARED_BUFFER_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALLWINNER: u32 = 1;
pub const CONFIG_HID: u32 = 1;
pub const CONFIG_NET_VENDOR_HISILICON: u32 = 1;
pub const CONFIG_ACPI_REDUCED_HARDWARE_ONLY: u32 = 1;
pub const CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM: u32 = 1;
pub const CONFIG_CRYPTO_LIB_UTILS_MODULE: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS: u32 = 1;
pub const CONFIG_BLK_CGROUP_RWSTAT: u32 = 1;
pub const CONFIG_USB_CDNS3_MODULE: u32 = 1;
pub const CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_RPMSG_CHAR: u32 = 1;
pub const CONFIG_ARCH_HAS_DMA_PREP_COHERENT: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_SCHED_MM_CID: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_CPU_PM: u32 = 1;
pub const CONFIG_GPIO_ACPI: u32 = 1;
pub const CONFIG_XFRM_USER_MODULE: u32 = 1;
pub const CONFIG_USB_DEFAULT_AUTHORIZATION_MODE: u32 = 1;
pub const CONFIG_ACPI_THERMAL: u32 = 1;
pub const CONFIG_NET_VENDOR_ENGLEDER: u32 = 1;
pub const CONFIG_TRACEPOINTS: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &[u8; 1] = b"\0";
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_DMA_DECLARE_COHERENT: u32 = 1;
pub const CONFIG_DRM_SUBALLOC_HELPER_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET: u32 = 1;
pub const CONFIG_ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP: u32 = 1;
pub const CONFIG_MEMORY_BALLOON: u32 = 1;
pub const CONFIG_EXECMEM: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_OVERLAY_FS_MODULE: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_LIBNVDIMM: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 8;
pub const CONFIG_SUN55I_PCK600: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_MSEAL_SYSTEM_MAPPINGS: u32 = 1;
pub const CONFIG_HID_REDRAGON: u32 = 1;
pub const CONFIG_SECURITYFS: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_ARCH_HAS_VDSO_ARCH_DATA: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_MICROSEMI_PHY: u32 = 1;
pub const CONFIG_BTRFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_ACPI_GENERIC_GSI: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_HAVE_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_DRM_FBDEV_OVERALLOC: u32 = 100;
pub const CONFIG_SECRETMEM: u32 = 1;
pub const CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING: u32 = 1;
pub const CONFIG_LTO_NONE: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_FPU: u32 = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: u32 = 1;
pub const CONFIG_CAN_NETLINK: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER_MODULE: u32 = 1;
pub const CONFIG_EPROBE_EVENTS: u32 = 1;
pub const CONFIG_USB_F_EEM_MODULE: u32 = 1;
pub const CONFIG_SUSPEND_FREEZER: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW: u32 = 1;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_DRM_SUN8I_DW_HDMI_MODULE: u32 = 1;
pub const CONFIG_SAMPLES_RUST: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_X: u32 = 1024;
pub const CONFIG_PINCTRL: u32 = 1;
pub const CONFIG_STP_MODULE: u32 = 1;
pub const CONFIG_RESET_STARFIVE_JH7110: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_USE_4K_SECTORS: u32 = 1;
pub const CONFIG_MEDIA_CONTROLLER: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_IDLE: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MODULE: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_HW_RANDOM_VIRTIO: u32 = 1;
pub const CONFIG_IP_VS_TAB_BITS: u32 = 12;
pub const CONFIG_RISCV_ISA_VENDOR_EXT_SIFIVE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_SERIAL: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const CONFIG_NET_FAILOVER: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_ACPI_CPPC_LIB: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_GENERIC_IOREMAP: u32 = 1;
pub const CONFIG_ARCH_USE_MEMTEST: u32 = 1;
pub const CONFIG_HID_GENERIC: u32 = 1;
pub const CONFIG_USB_PHY: u32 = 1;
pub const CONFIG_CAN_RAW_MODULE: u32 = 1;
pub const CONFIG_CRC_OPTIMIZATIONS: u32 = 1;
pub const CONFIG_SAMPLE_RUST_PRINT_MODULE: u32 = 1;
pub const CONFIG_PORTABLE: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_ERRATA_THEAD_GHOSTWRITE: u32 = 1;
pub const CONFIG_DRM_SCHED_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_DIMLIB: u32 = 1;
pub const CONFIG_HAVE_KVM_READONLY_MEM: u32 = 1;
pub const CONFIG_SERIAL_OF_PLATFORM: u32 = 1;
pub const CONFIG_LEGACY_PTYS: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_Y: u32 = 768;
pub const CONFIG_MEMCG: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS: u32 = 1;
pub const CONFIG_MAILBOX: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_SUSPEND: u32 = 1;
pub const CONFIG_IOMMU_DEFAULT_DMA_STRICT: u32 = 1;
pub const CONFIG_GRACE_PERIOD: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ARG_ACCESS_API: u32 = 1;
pub const CONFIG_ERRATA_THEAD_CMO: u32 = 1;
pub const CONFIG_CC_IMPLICIT_FALLTHROUGH: &[u8; 23] = b"-Wimplicit-fallthrough\0";
pub const CONFIG_FB_DMAMEM_HELPERS: u32 = 1;
pub const CONFIG_USB_F_RNDIS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_GENERIC_VDSO_DATA_STORE: u32 = 1;
pub const CONFIG_USB_U_ETHER_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_FB_DEFERRED_IO: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_TIMER_PROBE: u32 = 1;
pub const CONFIG_PCC: u32 = 1;
pub const CONFIG_POWER_SUPPLY_HWMON: u32 = 1;
pub const CONFIG_SUNXI_SRAM: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_CONSERVATIVE_MODULE: u32 = 1;
pub const CONFIG_ZSTD_COMMON: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_DAC: u32 = 1;
pub const CONFIG_WATCHDOG: u32 = 1;
pub const CONFIG_BRIDGE_NETFILTER_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_NVMEM_SUNXI_SID: u32 = 1;
pub const CONFIG_IRQCHIP: u32 = 1;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA512_ARCH: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_CC_HAS_RANDSTRUCT: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_AON_MODULE: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_SUN4I_TIMER: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MMU_LAZY_TLB_REFCOUNT: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_ACPI_BATTERY: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_BUFFER_HEAD: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_PATTERN: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_CORE: u32 = 1;
pub const CONFIG_PINCTRL_SUN20I_D1: u32 = 1;
pub const CONFIG_DMA_OF: u32 = 1;
pub const CONFIG_FB_SYSMEM_HELPERS_DEFERRED: u32 = 1;
pub const CONFIG_DUMMY_MODULE: u32 = 1;
pub const CONFIG_DM_BIO_PRISON_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_IO_ACCESSORS: u32 = 1;
pub const CONFIG_TASKS_TRACE_RCU: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_MEDIA_HIDE_ANCILLARY_SUBDRV: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_BUDDY: u32 = 1;
pub const CONFIG_PAGE_POOL: u32 = 1;
pub const CONFIG_MII_MODULE: u32 = 1;
pub const CONFIG_OF_MDIO: u32 = 1;
pub const CONFIG_NVMEM_SYSFS: u32 = 1;
pub const CONFIG_SCSI_COMMON: u32 = 1;
pub const CONFIG_SPARSEMEM_EXTREME: u32 = 1;
pub const CONFIG_RSEQ: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_SERIAL_8250_PERICOM: u32 = 1;
pub const CONFIG_KVM_MMIO: u32 = 1;
pub const CONFIG_PADATA: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_SPECIAL: u32 = 1;
pub const CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const CONFIG_SATA_AHCI_PLATFORM: u32 = 1;
pub const CONFIG_FB: u32 = 1;
pub const CONFIG_GENERIC_SYSCALL: u32 = 1;
pub const CONFIG_HAS_SECURITY_AUDIT: u32 = 1;
pub const CONFIG_HW_RANDOM_JH7110_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_SUN6I: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_USB_F_SERIAL_MODULE: u32 = 1;
pub const CONFIG_NEED_TASKS_RCU: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_POWER_RESET: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_GENERIC_ARCH_TOPOLOGY: u32 = 1;
pub const CONFIG_MTD_CFI_ADV_OPTIONS: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_MPILIB_MODULE: u32 = 1;
pub const CONFIG_FIRMWARE_TABLE: u32 = 1;
pub const CONFIG_SND_DMAENGINE_PCM: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_USB_F_SUBSET_MODULE: u32 = 1;
pub const CONFIG_ACPI_CPPC_CPUFREQ_FIE: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_RISCV_ISA_C: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_HID_EZKEY: u32 = 1;
pub const CONFIG_GPIO_CDEV: u32 = 1;
pub const CONFIG_RUST: u32 = 1;
pub const CONFIG_SAMPLE_RUST_DRIVER_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_ISP_MODULE: u32 = 1;
pub const CONFIG_USB_F_OBEX_MODULE: u32 = 1;
pub const CONFIG_DT_IDLE_STATES: u32 = 1;
pub const CONFIG_RISCV_ISA_VENDOR_EXT: u32 = 1;
pub const CONFIG_CLK_SOPHGO_SG2042_PLL: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_DIRECT_MAP: u32 = 1;
pub const CONFIG_RUSTC_VERSION_TEXT: &[u8; 36] = b"rustc 1.78.0 (9b00956e5 2024-04-29)\0";
pub const CONFIG_CLK_STARFIVE_JH71X0: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 3;
pub const CONFIG_NET_CRC32C: u32 = 1;
pub const CONFIG_ARCH_SOPHGO: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_HAVE_MOVE_PUD: u32 = 1;
pub const CONFIG_ARCH_VIRT: u32 = 1;
pub const CONFIG_PER_VMA_LOCK: u32 = 1;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_I2C_MV64XXX_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_RUST_DMA_MODULE: u32 = 1;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_GCC_VERSION: u32 = 0;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA1: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_NET_VENDOR_XILINX: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_GPIO_GENERIC: u32 = 1;
pub const CONFIG_PM_SLEEP_SMP: u32 = 1;
pub const CONFIG_POWER_RESET_GPIO_RESTART: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_NET_L3_MASTER_DEV: u32 = 1;
pub const CONFIG_NET_SOCK_MSG: u32 = 1;
pub const CONFIG_EFI_PARAMS_FROM_FDT: u32 = 1;
pub const CONFIG_MTD_CFI_NOSWAP: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_BACKLIGHT: u32 = 1;
pub const CONFIG_USB_CDNS3_STARFIVE_MODULE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_SND_JACK: u32 = 1;
pub const CONFIG_SERIAL_8250_16550A_VARIANTS: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_9P_FS: u32 = 1;
pub const CONFIG_MOUSE_PS2_SMBUS: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 2048;
pub const CONFIG_LD_VERSION: u32 = 0;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_I2C: u32 = 1;
pub const CONFIG_SND_SOC: u32 = 1;
pub const CONFIG_USB_MUSB_HDRC_MODULE: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_NET_VENDOR_ADI: u32 = 1;
pub const CONFIG_SND_SOC_JH7110_TDM_MODULE: u32 = 1;
pub const CONFIG_PM_SLEEP: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_CLK_ANALOGBITS_WRPLL_CLN28HPC: u32 = 1;
pub const CONFIG_THERMAL_OF: u32 = 1;
pub const CONFIG_VMAP_STACK: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA512_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_GOOGLE: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_ACPI_THERMAL_LIB: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_OID_REGISTRY_MODULE: u32 = 1;
pub const CONFIG_CLK_SOPHGO_CV1800: u32 = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_STARFIVE_WATCHDOG: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_SUNXI_CCU: u32 = 1;
pub const CONFIG_NETFILTER_FAMILY_BRIDGE: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_IDLE: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_USB_CDNS3_HOST: u32 = 1;
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_PHY_STARFIVE_JH7110_DPHY_RX_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPI: u32 = 1;
pub const CONFIG_DRM_DISPLAY_DP_HELPER: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER_MODULE: u32 = 1;
pub const CONFIG_HID_ITE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_FREGS: u32 = 1;
pub const CONFIG_PCP_BATCH_SCALE_MAX: u32 = 5;
pub const CONFIG_PM_GENERIC_DOMAINS: u32 = 1;
pub const CONFIG_THREAD_SIZE_ORDER: u32 = 2;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN: u32 = 1;
pub const CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT: u32 = 1;
pub const CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_RISCV_IOMMU: u32 = 1;
pub const CONFIG_ACPI_PPTT: u32 = 1;
pub const CONFIG_HAVE_CLK_PREPARE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MASS_STORAGE: u32 = 1;
pub const CONFIG_HAVE_RUST: u32 = 1;
pub const CONFIG_BLK_DEV_BSG_COMMON: u32 = 1;
pub const CONFIG_SPACEMIT_K1_CCU: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_GENERIC_CSUM: u32 = 1;
pub const CONFIG_CRYPTO_GENIV_MODULE: u32 = 1;
pub const CONFIG_FTRACE: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_SUNRPC_GSS_MODULE: u32 = 1;
pub const CONFIG_PAGE_BLOCK_MAX_ORDER: u32 = 10;
pub const CONFIG_ERRATA_SIFIVE_CIP_1200: u32 = 1;
pub const CONFIG_VIDEOMODE_HELPERS: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_SPI_MASTER: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_MTD_SPI_NOR: u32 = 1;
pub const CONFIG_ERRATA_ANDES: u32 = 1;
pub const CONFIG_MMIOWB: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_SOUND: u32 = 1;
pub const CONFIG_LOCALVERSION_AUTO: u32 = 1;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2_MODULE: u32 = 1;
pub const CONFIG_DM_PERSISTENT_DATA_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_ARCH_STACKWALK: u32 = 1;
pub const CONFIG_SPI: u32 = 1;
pub const CONFIG_PINCTRL_SPACEMIT_K1: u32 = 1;
pub const CONFIG_PINCTRL_STARFIVE_JH7110: u32 = 1;
pub const CONFIG_DEBUG_INFO_NONE: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: u32 = 1;
pub const CONFIG_MOTORCOMM_PHY: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_256KB: u32 = 1;
pub const CONFIG_HAS_IOPORT: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_CLANG_VERSION: u32 = 180108;
pub const CONFIG_SECURITY_APPARMOR_INTROSPECT_POLICY: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN: &[u8; 11] = b"kernel.org\0";
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_CRC7: u32 = 1;
pub const CONFIG_ARCH_THEAD: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQCHIP: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN_LEVEL: &[u8; 5] = b"warn\0";
pub const CONFIG_USB_OHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_OUTPUT: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM_SUBSET: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_ISO9660_FS: u32 = 1;
pub const CONFIG_PHY_PACKAGE: u32 = 1;
pub const CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS: u32 = 2;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_BLK_CGROUP: u32 = 1;
pub const CONFIG_HAVE_ARCH_KFENCE: u32 = 1;
pub const CONFIG_DECOMPRESS_ZSTD: u32 = 1;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: u32 = 1;
pub const CONFIG_MDIO_BUS_MUX_MODULE: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_SPARSEMEM_MANUAL: u32 = 1;
pub const CONFIG_CLK_SOPHGO_SG2042_CLKGEN: u32 = 1;
pub const CONFIG_COMPAT_32BIT_TIME: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7100_AUDIO_MODULE: u32 = 1;
pub const CONFIG_USB_LIBCOMPOSITE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_PENSANDO: u32 = 1;
pub const CONFIG_BLK_DEV_NVME_MODULE: u32 = 1;
pub const CONFIG_RISCV_MISALIGNED: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_HID_CHERRY: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_CC_CAN_LINK: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO_BARE: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_SERIO_SERPORT: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_HAVE_PAGE_SIZE_4KB: u32 = 1;
pub const CONFIG_VIDEO_V4L2_I2C: u32 = 1;
pub const CONFIG_MSDOS_FS: u32 = 1;
pub const CONFIG_IP_VS_SH_TAB_BITS: u32 = 8;
pub const CONFIG_CRC_ITU_T: u32 = 1;
pub const CONFIG_DT_IDLE_GENPD: u32 = 1;
pub const CONFIG_RPMSG_NS: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_OF_IOMMU: u32 = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_UPROBE_EVENTS: u32 = 1;
pub const CONFIG_ROOT_NFS: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &[u8; 7] = b"(none)\0";
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_FRAME_POINTER: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7110_STG_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_SPARSEMEM: u32 = 1;
pub const CONFIG_RISCV_PROBE_VECTOR_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &[u8; 5] = b"rtc0\0";
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_AUTOFS_FS: u32 = 1;
pub const CONFIG_ARCH_WANTS_NO_INSTR: u32 = 1;
pub const CONFIG_USB_HID: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER2_MODULE: u32 = 1;
pub const CONFIG_MTD: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_HAVE_GENERIC_VDSO: u32 = 1;
pub const CONFIG_WLAN_VENDOR_PURELIFI: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_IRQ_MSI_LIB: u32 = 1;
pub const CONFIG_DRM_CLIENT_DEFAULT_FBDEV: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_RISCV_ISA_SVNAPOT: u32 = 1;
pub const CONFIG_BLK_DEV_NULL_BLK_MODULE: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_DEVFREQ_THERMAL: u32 = 1;
pub const CONFIG_ARCH_HAS_PREEMPT_LAZY: u32 = 1;
pub const CONFIG_SERIAL_8250_DW: u32 = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: i64 = -2401263026318606336;
pub const CONFIG_ARCH_HAS_SETUP_DMA_OPS: u32 = 1;
pub const CONFIG_GROUP_SCHED_WEIGHT: u32 = 1;
pub const CONFIG_UPROBES: u32 = 1;
pub const CONFIG_AS_HAS_INSN: u32 = 1;
pub const CONFIG_ARCH_SIFIVE: u32 = 1;
pub const CONFIG_DRM_CLIENT: u32 = 1;
pub const CONFIG_GENERIC_PHY: u32 = 1;
pub const CONFIG_GUEST_PERF_EVENTS: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_ARM_AMBA: u32 = 1;
pub const CONFIG_ERRATA_SIFIVE: u32 = 1;
pub const CONFIG_SAMPLES: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_CPU_FREQ_THERMAL: u32 = 1;
pub const CONFIG_CPU_THERMAL: u32 = 1;
pub const CONFIG_CRYPTO_SHA256_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256_ARCH: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_NET_DEVMEM: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_RISCV_ISA_V_DEFAULT_ENABLE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD: u32 = 1;
pub const CONFIG_HAVE_CFI_ICALL_NORMALIZE_INTEGERS_CLANG: u32 = 1;
pub const CONFIG_ARCH_USE_SYM_ANNOTATIONS: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_RISCV_ISA_SVPBMT: u32 = 1;
pub const CONFIG_RCU_EXP_CPU_STALL_TIMEOUT: u32 = 0;
pub const CONFIG_OF: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 18;
pub const CONFIG_ARCH_WANT_OPTIMIZE_DAX_VMEMMAP: u32 = 1;
pub const CONFIG_CRYPTO_BLAKE2B_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_OF_DWCMSHC: u32 = 1;
pub const CONFIG_ATA_FORCE: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_NET_VENDOR_NETERION: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_USB_F_ECM_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SUPPORT_FILTER: u32 = 1;
pub const CONFIG_CRYPTO_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP: u32 = 1;
pub const CONFIG_RESET_POLARFIRE_SOC: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_SND_CTL_FAST_LOOKUP: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_PM_DEVFREQ: u32 = 1;
pub const CONFIG_DRM_CLIENT_SELECTION_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_SOPHGO_SG2000: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_NF_CT_PROTO_SCTP: u32 = 1;
pub const CONFIG_BLK_DEV_PMEM: u32 = 1;
pub const CONFIG_BPF_EVENTS: u32 = 1;
pub const CONFIG_GENERIC_ENTRY: u32 = 1;
pub const CONFIG_MEDIA_PLATFORM_SUPPORT: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_HID_BELKIN: u32 = 1;
pub const CONFIG_RPMSG_VIRTIO: u32 = 1;
pub const CONFIG_NOP_USB_XCEIV_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_SUN20I: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG_DEFAULT: u32 = 3;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC_KEY: u32 = 1;
pub const CONFIG_INET_DIAG: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_FB_IOMEM_HELPERS: u32 = 1;
pub const CONFIG_INPUT_VIVALDIFMAP: u32 = 1;
pub const CONFIG_IP_VS_PROTO_TCP: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_ASN1_MODULE: u32 = 1;
pub const CONFIG_MCHP_CLK_MPFS: u32 = 1;
pub const CONFIG_MMC_CQHCI: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const CONFIG_ACPI_PCC: u32 = 1;
pub const CONFIG_INET_TUNNEL: u32 = 1;
pub const CONFIG_DMA_SUN6I_MODULE: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_RTC_HCTOSYS: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &[u8; 1] = b"\0";
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_PNPACPI: u32 = 1;
pub const CONFIG_GOLDFISH: u32 = 1;
pub const CONFIG_SERIAL_8250_DWLIB: u32 = 1;
pub const CONFIG_OF_KOBJ: u32 = 1;
pub const CONFIG_USB_F_ACM_MODULE: u32 = 1;
pub const CONFIG_NOP_TRACER: u32 = 1;
pub const CONFIG_HAVE_KVM_DIRTY_RING_ACQ_REL: u32 = 1;
pub const CONFIG_MICREL_PHY: u32 = 1;
pub const CONFIG_PNFS_FLEXFILE_LAYOUT: u32 = 1;
pub const CONFIG_GENERIC_PINMUX_FUNCTIONS: u32 = 1;
pub const CONFIG_VETH_MODULE: u32 = 1;
pub const CONFIG_IP_VS_NFCT: u32 = 1;
pub const CONFIG_NET_VENDOR_LITEX: u32 = 1;
pub const CONFIG_VIDEO_V4L2_SUBDEV_API: u32 = 1;
pub const CONFIG_VIRTIO_BALLOON: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_PINCTRL_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_DRM_GEM_SHMEM_HELPER_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_CRYPTO_LIB_AES_MODULE: u32 = 1;
pub const CONFIG_LEGACY_TIOCSTI: u32 = 1;
pub const CONFIG_NF_LOG_SYSLOG_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_FB_IOMEM_FOPS: u32 = 1;
pub const CONFIG_FW_CACHE: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE: u32 = 1;
pub const CONFIG_REGMAP_I2C: u32 = 1;
pub const CONFIG_STMMAC_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_RISCV_ALTERNATIVE_EARLY: u32 = 1;
pub const CONFIG_CC_VERSION_TEXT: &[u8; 86] =
    b"Ubuntu clang version 18.1.8 (++20240731024944+3b5b5c1ec4a3-1~exp1~20240731145000.144)\0";
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_DEBUG_FS_ALLOW_ALL: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT_MULTI: u32 = 1;
pub const CONFIG_MEMFD_CREATE: u32 = 1;
pub const CONFIG_RISCV_ISA_ZICBOM: u32 = 1;
pub const CONFIG_MTD_OF_PARTS: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const KASAN_ABI_VERSION: u32 = 5;
pub const ASM_INPUT_G: &[u8; 3] = b"ir\0";
pub const ASM_INPUT_RM: &[u8; 2] = b"r\0";
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const ENOPARAM: u32 = 519;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const ENOGRACE: u32 = 531;
pub const BITS_PER_BYTE: u32 = 8;
pub const KCSAN_ACCESS_WRITE: u32 = 1;
pub const KCSAN_ACCESS_COMPOUND: u32 = 2;
pub const KCSAN_ACCESS_ATOMIC: u32 = 4;
pub const KCSAN_ACCESS_ASSERT: u32 = 8;
pub const KCSAN_ACCESS_SCOPED: u32 = 16;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const UINTPTR_MAX: i32 = -1;
pub const IORESOURCE_BITS: u32 = 255;
pub const IORESOURCE_TYPE_BITS: u32 = 7936;
pub const IORESOURCE_IO: u32 = 256;
pub const IORESOURCE_MEM: u32 = 512;
pub const IORESOURCE_REG: u32 = 768;
pub const IORESOURCE_IRQ: u32 = 1024;
pub const IORESOURCE_DMA: u32 = 2048;
pub const IORESOURCE_BUS: u32 = 4096;
pub const IORESOURCE_PREFETCH: u32 = 8192;
pub const IORESOURCE_READONLY: u32 = 16384;
pub const IORESOURCE_CACHEABLE: u32 = 32768;
pub const IORESOURCE_RANGELENGTH: u32 = 65536;
pub const IORESOURCE_SHADOWABLE: u32 = 131072;
pub const IORESOURCE_SIZEALIGN: u32 = 262144;
pub const IORESOURCE_STARTALIGN: u32 = 524288;
pub const IORESOURCE_MEM_64: u32 = 1048576;
pub const IORESOURCE_WINDOW: u32 = 2097152;
pub const IORESOURCE_MUXED: u32 = 4194304;
pub const IORESOURCE_EXT_TYPE_BITS: u32 = 16777216;
pub const IORESOURCE_SYSRAM: u32 = 16777216;
pub const IORESOURCE_SYSRAM_DRIVER_MANAGED: u32 = 33554432;
pub const IORESOURCE_SYSRAM_MERGEABLE: u32 = 67108864;
pub const IORESOURCE_EXCLUSIVE: u32 = 134217728;
pub const IORESOURCE_DISABLED: u32 = 268435456;
pub const IORESOURCE_UNSET: u32 = 536870912;
pub const IORESOURCE_AUTO: u32 = 1073741824;
pub const IORESOURCE_BUSY: u32 = 2147483648;
pub const IORESOURCE_SYSTEM_RAM: u32 = 16777728;
pub const IORESOURCE_IRQ_HIGHEDGE: u32 = 1;
pub const IORESOURCE_IRQ_LOWEDGE: u32 = 2;
pub const IORESOURCE_IRQ_HIGHLEVEL: u32 = 4;
pub const IORESOURCE_IRQ_LOWLEVEL: u32 = 8;
pub const IORESOURCE_IRQ_SHAREABLE: u32 = 16;
pub const IORESOURCE_IRQ_OPTIONAL: u32 = 32;
pub const IORESOURCE_IRQ_WAKECAPABLE: u32 = 64;
pub const IORESOURCE_DMA_TYPE_MASK: u32 = 3;
pub const IORESOURCE_DMA_8BIT: u32 = 0;
pub const IORESOURCE_DMA_8AND16BIT: u32 = 1;
pub const IORESOURCE_DMA_16BIT: u32 = 2;
pub const IORESOURCE_DMA_MASTER: u32 = 4;
pub const IORESOURCE_DMA_BYTE: u32 = 8;
pub const IORESOURCE_DMA_WORD: u32 = 16;
pub const IORESOURCE_DMA_SPEED_MASK: u32 = 192;
pub const IORESOURCE_DMA_COMPATIBLE: u32 = 0;
pub const IORESOURCE_DMA_TYPEA: u32 = 64;
pub const IORESOURCE_DMA_TYPEB: u32 = 128;
pub const IORESOURCE_DMA_TYPEF: u32 = 192;
pub const IORESOURCE_MEM_WRITEABLE: u32 = 1;
pub const IORESOURCE_MEM_CACHEABLE: u32 = 2;
pub const IORESOURCE_MEM_RANGELENGTH: u32 = 4;
pub const IORESOURCE_MEM_TYPE_MASK: u32 = 24;
pub const IORESOURCE_MEM_8BIT: u32 = 0;
pub const IORESOURCE_MEM_16BIT: u32 = 8;
pub const IORESOURCE_MEM_8AND16BIT: u32 = 16;
pub const IORESOURCE_MEM_32BIT: u32 = 24;
pub const IORESOURCE_MEM_SHADOWABLE: u32 = 32;
pub const IORESOURCE_MEM_EXPANSIONROM: u32 = 64;
pub const IORESOURCE_MEM_NONPOSTED: u32 = 128;
pub const IORESOURCE_IO_16BIT_ADDR: u32 = 1;
pub const IORESOURCE_IO_FIXED: u32 = 2;
pub const IORESOURCE_IO_SPARSE: u32 = 4;
pub const IORESOURCE_ROM_ENABLE: u32 = 1;
pub const IORESOURCE_ROM_SHADOW: u32 = 2;
pub const IORESOURCE_PCI_FIXED: u32 = 16;
pub const IORESOURCE_PCI_EA_BEI: u32 = 32;
pub const PAGE_POISON: u32 = 170;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const KEY_DESTROY: u32 = 189;
pub const RISCV_PTR: &[u8; 7] = b".dword\0";
pub const RISCV_SZPTR: &[u8; 2] = b"8\0";
pub const RISCV_LGPTR: &[u8; 2] = b"3\0";
pub const CUT_HERE: &[u8; 38] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BUGFLAG_NO_CUT_HERE: u32 = 8;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_RANDSTRUCT: u32 = 17;
pub const TAINT_TEST: u32 = 18;
pub const TAINT_FWCTL: u32 = 19;
pub const TAINT_FLAGS_COUNT: u32 = 20;
pub const TAINT_FLAGS_MAX: u32 = 1048575;
pub const KERN_SOH: &[u8; 2] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &[u8; 3] = b"\x010\0";
pub const KERN_ALERT: &[u8; 3] = b"\x011\0";
pub const KERN_CRIT: &[u8; 3] = b"\x012\0";
pub const KERN_ERR: &[u8; 3] = b"\x013\0";
pub const KERN_WARNING: &[u8; 3] = b"\x014\0";
pub const KERN_NOTICE: &[u8; 3] = b"\x015\0";
pub const KERN_INFO: &[u8; 3] = b"\x016\0";
pub const KERN_DEBUG: &[u8; 3] = b"\x017\0";
pub const KERN_DEFAULT: &[u8; 1] = b"\0";
pub const KERN_CONT: &[u8; 3] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const __ALIGN_STR: &[u8; 10] = b".balign 4\0";
pub const __USER_HZ: u32 = 100;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const _Q_LOCKED_OFFSET: u32 = 0;
pub const _Q_LOCKED_BITS: u32 = 8;
pub const _Q_PENDING_OFFSET: u32 = 8;
pub const _Q_PENDING_BITS: u32 = 8;
pub const _Q_TAIL_IDX_OFFSET: u32 = 16;
pub const _Q_TAIL_IDX_BITS: u32 = 2;
pub const _Q_TAIL_CPU_OFFSET: u32 = 18;
pub const _Q_TAIL_CPU_BITS: u32 = 14;
pub const _Q_TAIL_OFFSET: u32 = 16;
pub const _Q_LOCKED_VAL: u32 = 1;
pub const _Q_PENDING_VAL: u32 = 256;
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const DEFAULT_RATELIMIT_INTERVAL: u32 = 1250;
pub const DEFAULT_RATELIMIT_BURST: u32 = 10;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &[u8; 17] = b"[Firmware Bug]: \0";
pub const FW_WARN: &[u8; 18] = b"[Firmware Warn]: \0";
pub const FW_INFO: &[u8; 18] = b"[Firmware Info]: \0";
pub const HW_ERR: &[u8; 19] = b"[Hardware Error]: \0";
pub const DEPRECATED: &[u8; 15] = b"[Deprecated]: \0";
pub const RISCV_ISA_EXT_BASE: u32 = 26;
pub const RISCV_ISA_EXT_SSCOFPMF: u32 = 26;
pub const RISCV_ISA_EXT_SSTC: u32 = 27;
pub const RISCV_ISA_EXT_SVINVAL: u32 = 28;
pub const RISCV_ISA_EXT_SVPBMT: u32 = 29;
pub const RISCV_ISA_EXT_ZBB: u32 = 30;
pub const RISCV_ISA_EXT_ZICBOM: u32 = 31;
pub const RISCV_ISA_EXT_ZIHINTPAUSE: u32 = 32;
pub const RISCV_ISA_EXT_SVNAPOT: u32 = 33;
pub const RISCV_ISA_EXT_ZICBOZ: u32 = 34;
pub const RISCV_ISA_EXT_SMAIA: u32 = 35;
pub const RISCV_ISA_EXT_SSAIA: u32 = 36;
pub const RISCV_ISA_EXT_ZBA: u32 = 37;
pub const RISCV_ISA_EXT_ZBS: u32 = 38;
pub const RISCV_ISA_EXT_ZICNTR: u32 = 39;
pub const RISCV_ISA_EXT_ZICSR: u32 = 40;
pub const RISCV_ISA_EXT_ZIFENCEI: u32 = 41;
pub const RISCV_ISA_EXT_ZIHPM: u32 = 42;
pub const RISCV_ISA_EXT_SMSTATEEN: u32 = 43;
pub const RISCV_ISA_EXT_ZICOND: u32 = 44;
pub const RISCV_ISA_EXT_ZBC: u32 = 45;
pub const RISCV_ISA_EXT_ZBKB: u32 = 46;
pub const RISCV_ISA_EXT_ZBKC: u32 = 47;
pub const RISCV_ISA_EXT_ZBKX: u32 = 48;
pub const RISCV_ISA_EXT_ZKND: u32 = 49;
pub const RISCV_ISA_EXT_ZKNE: u32 = 50;
pub const RISCV_ISA_EXT_ZKNH: u32 = 51;
pub const RISCV_ISA_EXT_ZKR: u32 = 52;
pub const RISCV_ISA_EXT_ZKSED: u32 = 53;
pub const RISCV_ISA_EXT_ZKSH: u32 = 54;
pub const RISCV_ISA_EXT_ZKT: u32 = 55;
pub const RISCV_ISA_EXT_ZVBB: u32 = 56;
pub const RISCV_ISA_EXT_ZVBC: u32 = 57;
pub const RISCV_ISA_EXT_ZVKB: u32 = 58;
pub const RISCV_ISA_EXT_ZVKG: u32 = 59;
pub const RISCV_ISA_EXT_ZVKNED: u32 = 60;
pub const RISCV_ISA_EXT_ZVKNHA: u32 = 61;
pub const RISCV_ISA_EXT_ZVKNHB: u32 = 62;
pub const RISCV_ISA_EXT_ZVKSED: u32 = 63;
pub const RISCV_ISA_EXT_ZVKSH: u32 = 64;
pub const RISCV_ISA_EXT_ZVKT: u32 = 65;
pub const RISCV_ISA_EXT_ZFH: u32 = 66;
pub const RISCV_ISA_EXT_ZFHMIN: u32 = 67;
pub const RISCV_ISA_EXT_ZIHINTNTL: u32 = 68;
pub const RISCV_ISA_EXT_ZVFH: u32 = 69;
pub const RISCV_ISA_EXT_ZVFHMIN: u32 = 70;
pub const RISCV_ISA_EXT_ZFA: u32 = 71;
pub const RISCV_ISA_EXT_ZTSO: u32 = 72;
pub const RISCV_ISA_EXT_ZACAS: u32 = 73;
pub const RISCV_ISA_EXT_ZVE32X: u32 = 74;
pub const RISCV_ISA_EXT_ZVE32F: u32 = 75;
pub const RISCV_ISA_EXT_ZVE64X: u32 = 76;
pub const RISCV_ISA_EXT_ZVE64F: u32 = 77;
pub const RISCV_ISA_EXT_ZVE64D: u32 = 78;
pub const RISCV_ISA_EXT_ZIMOP: u32 = 79;
pub const RISCV_ISA_EXT_ZCA: u32 = 80;
pub const RISCV_ISA_EXT_ZCB: u32 = 81;
pub const RISCV_ISA_EXT_ZCD: u32 = 82;
pub const RISCV_ISA_EXT_ZCF: u32 = 83;
pub const RISCV_ISA_EXT_ZCMOP: u32 = 84;
pub const RISCV_ISA_EXT_ZAWRS: u32 = 85;
pub const RISCV_ISA_EXT_SVVPTC: u32 = 86;
pub const RISCV_ISA_EXT_SMMPM: u32 = 87;
pub const RISCV_ISA_EXT_SMNPM: u32 = 88;
pub const RISCV_ISA_EXT_SSNPM: u32 = 89;
pub const RISCV_ISA_EXT_ZABHA: u32 = 90;
pub const RISCV_ISA_EXT_ZICCRSE: u32 = 91;
pub const RISCV_ISA_EXT_SVADE: u32 = 92;
pub const RISCV_ISA_EXT_SVADU: u32 = 93;
pub const RISCV_ISA_EXT_ZFBFMIN: u32 = 94;
pub const RISCV_ISA_EXT_ZVFBFMIN: u32 = 95;
pub const RISCV_ISA_EXT_ZVFBFWMA: u32 = 96;
pub const RISCV_ISA_EXT_ZAAMO: u32 = 97;
pub const RISCV_ISA_EXT_ZALRSC: u32 = 98;
pub const RISCV_ISA_EXT_ZICBOP: u32 = 99;
pub const RISCV_ISA_EXT_XLINUXENVCFG: u32 = 127;
pub const RISCV_ISA_EXT_MAX: u32 = 128;
pub const RISCV_ISA_EXT_SxAIA: u32 = 36;
pub const RISCV_ISA_EXT_SUPM: u32 = 89;
pub const INSN_R_FUNC7_SHIFT: u32 = 25;
pub const INSN_R_RS2_SHIFT: u32 = 20;
pub const INSN_R_RS1_SHIFT: u32 = 15;
pub const INSN_R_FUNC3_SHIFT: u32 = 12;
pub const INSN_R_RD_SHIFT: u32 = 7;
pub const INSN_R_OPCODE_SHIFT: u32 = 0;
pub const INSN_I_SIMM12_SHIFT: u32 = 20;
pub const INSN_I_RS1_SHIFT: u32 = 15;
pub const INSN_I_FUNC3_SHIFT: u32 = 12;
pub const INSN_I_RD_SHIFT: u32 = 7;
pub const INSN_I_OPCODE_SHIFT: u32 = 0;
pub const INSN_S_SIMM7_SHIFT: u32 = 25;
pub const INSN_S_RS2_SHIFT: u32 = 20;
pub const INSN_S_RS1_SHIFT: u32 = 15;
pub const INSN_S_FUNC3_SHIFT: u32 = 12;
pub const INSN_S_SIMM5_SHIFT: u32 = 7;
pub const INSN_S_OPCODE_SHIFT: u32 = 0;
pub const RISCV_PAUSE: &[u8; 17] = b".4byte 0x100000f\0";
pub const ZAWRS_WRS_NTO: &[u8; 18] = b".4byte 0x00d00073\0";
pub const ZAWRS_WRS_STO: &[u8; 18] = b".4byte 0x01d00073\0";
pub const RISCV_NOP4: &[u8; 18] = b".4byte 0x00000013\0";
pub const STANDARD_EXT: u32 = 0;
pub const SI_LOAD_SHIFT: u32 = 16;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const ARCH_DMA_MINALIGN: u32 = 64;
pub const ARCH_KMALLOC_MINALIGN: u32 = 8;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const PR_SET_PDEATHSIG: u32 = 1;
pub const PR_GET_PDEATHSIG: u32 = 2;
pub const PR_GET_DUMPABLE: u32 = 3;
pub const PR_SET_DUMPABLE: u32 = 4;
pub const PR_GET_UNALIGN: u32 = 5;
pub const PR_SET_UNALIGN: u32 = 6;
pub const PR_UNALIGN_NOPRINT: u32 = 1;
pub const PR_UNALIGN_SIGBUS: u32 = 2;
pub const PR_GET_KEEPCAPS: u32 = 7;
pub const PR_SET_KEEPCAPS: u32 = 8;
pub const PR_GET_FPEMU: u32 = 9;
pub const PR_SET_FPEMU: u32 = 10;
pub const PR_FPEMU_NOPRINT: u32 = 1;
pub const PR_FPEMU_SIGFPE: u32 = 2;
pub const PR_GET_FPEXC: u32 = 11;
pub const PR_SET_FPEXC: u32 = 12;
pub const PR_FP_EXC_SW_ENABLE: u32 = 128;
pub const PR_FP_EXC_DIV: u32 = 65536;
pub const PR_FP_EXC_OVF: u32 = 131072;
pub const PR_FP_EXC_UND: u32 = 262144;
pub const PR_FP_EXC_RES: u32 = 524288;
pub const PR_FP_EXC_INV: u32 = 1048576;
pub const PR_FP_EXC_DISABLED: u32 = 0;
pub const PR_FP_EXC_NONRECOV: u32 = 1;
pub const PR_FP_EXC_ASYNC: u32 = 2;
pub const PR_FP_EXC_PRECISE: u32 = 3;
pub const PR_GET_TIMING: u32 = 13;
pub const PR_SET_TIMING: u32 = 14;
pub const PR_TIMING_STATISTICAL: u32 = 0;
pub const PR_TIMING_TIMESTAMP: u32 = 1;
pub const PR_SET_NAME: u32 = 15;
pub const PR_GET_NAME: u32 = 16;
pub const PR_GET_ENDIAN: u32 = 19;
pub const PR_SET_ENDIAN: u32 = 20;
pub const PR_ENDIAN_BIG: u32 = 0;
pub const PR_ENDIAN_LITTLE: u32 = 1;
pub const PR_ENDIAN_PPC_LITTLE: u32 = 2;
pub const PR_GET_SECCOMP: u32 = 21;
pub const PR_SET_SECCOMP: u32 = 22;
pub const PR_CAPBSET_READ: u32 = 23;
pub const PR_CAPBSET_DROP: u32 = 24;
pub const PR_GET_TSC: u32 = 25;
pub const PR_SET_TSC: u32 = 26;
pub const PR_TSC_ENABLE: u32 = 1;
pub const PR_TSC_SIGSEGV: u32 = 2;
pub const PR_GET_SECUREBITS: u32 = 27;
pub const PR_SET_SECUREBITS: u32 = 28;
pub const PR_SET_TIMERSLACK: u32 = 29;
pub const PR_GET_TIMERSLACK: u32 = 30;
pub const PR_TASK_PERF_EVENTS_DISABLE: u32 = 31;
pub const PR_TASK_PERF_EVENTS_ENABLE: u32 = 32;
pub const PR_MCE_KILL: u32 = 33;
pub const PR_MCE_KILL_CLEAR: u32 = 0;
pub const PR_MCE_KILL_SET: u32 = 1;
pub const PR_MCE_KILL_LATE: u32 = 0;
pub const PR_MCE_KILL_EARLY: u32 = 1;
pub const PR_MCE_KILL_DEFAULT: u32 = 2;
pub const PR_MCE_KILL_GET: u32 = 34;
pub const PR_SET_MM: u32 = 35;
pub const PR_SET_MM_START_CODE: u32 = 1;
pub const PR_SET_MM_END_CODE: u32 = 2;
pub const PR_SET_MM_START_DATA: u32 = 3;
pub const PR_SET_MM_END_DATA: u32 = 4;
pub const PR_SET_MM_START_STACK: u32 = 5;
pub const PR_SET_MM_START_BRK: u32 = 6;
pub const PR_SET_MM_BRK: u32 = 7;
pub const PR_SET_MM_ARG_START: u32 = 8;
pub const PR_SET_MM_ARG_END: u32 = 9;
pub const PR_SET_MM_ENV_START: u32 = 10;
pub const PR_SET_MM_ENV_END: u32 = 11;
pub const PR_SET_MM_AUXV: u32 = 12;
pub const PR_SET_MM_EXE_FILE: u32 = 13;
pub const PR_SET_MM_MAP: u32 = 14;
pub const PR_SET_MM_MAP_SIZE: u32 = 15;
pub const PR_SET_PTRACER: u32 = 1499557217;
pub const PR_SET_CHILD_SUBREAPER: u32 = 36;
pub const PR_GET_CHILD_SUBREAPER: u32 = 37;
pub const PR_SET_NO_NEW_PRIVS: u32 = 38;
pub const PR_GET_NO_NEW_PRIVS: u32 = 39;
pub const PR_GET_TID_ADDRESS: u32 = 40;
pub const PR_SET_THP_DISABLE: u32 = 41;
pub const PR_GET_THP_DISABLE: u32 = 42;
pub const PR_MPX_ENABLE_MANAGEMENT: u32 = 43;
pub const PR_MPX_DISABLE_MANAGEMENT: u32 = 44;
pub const PR_SET_FP_MODE: u32 = 45;
pub const PR_GET_FP_MODE: u32 = 46;
pub const PR_FP_MODE_FR: u32 = 1;
pub const PR_FP_MODE_FRE: u32 = 2;
pub const PR_CAP_AMBIENT: u32 = 47;
pub const PR_CAP_AMBIENT_IS_SET: u32 = 1;
pub const PR_CAP_AMBIENT_RAISE: u32 = 2;
pub const PR_CAP_AMBIENT_LOWER: u32 = 3;
pub const PR_CAP_AMBIENT_CLEAR_ALL: u32 = 4;
pub const PR_SVE_SET_VL: u32 = 50;
pub const PR_SVE_SET_VL_ONEXEC: u32 = 262144;
pub const PR_SVE_GET_VL: u32 = 51;
pub const PR_SVE_VL_LEN_MASK: u32 = 65535;
pub const PR_SVE_VL_INHERIT: u32 = 131072;
pub const PR_GET_SPECULATION_CTRL: u32 = 52;
pub const PR_SET_SPECULATION_CTRL: u32 = 53;
pub const PR_SPEC_STORE_BYPASS: u32 = 0;
pub const PR_SPEC_INDIRECT_BRANCH: u32 = 1;
pub const PR_SPEC_L1D_FLUSH: u32 = 2;
pub const PR_SPEC_NOT_AFFECTED: u32 = 0;
pub const PR_SPEC_PRCTL: u32 = 1;
pub const PR_SPEC_ENABLE: u32 = 2;
pub const PR_SPEC_DISABLE: u32 = 4;
pub const PR_SPEC_FORCE_DISABLE: u32 = 8;
pub const PR_SPEC_DISABLE_NOEXEC: u32 = 16;
pub const PR_PAC_RESET_KEYS: u32 = 54;
pub const PR_PAC_APIAKEY: u32 = 1;
pub const PR_PAC_APIBKEY: u32 = 2;
pub const PR_PAC_APDAKEY: u32 = 4;
pub const PR_PAC_APDBKEY: u32 = 8;
pub const PR_PAC_APGAKEY: u32 = 16;
pub const PR_SET_TAGGED_ADDR_CTRL: u32 = 55;
pub const PR_GET_TAGGED_ADDR_CTRL: u32 = 56;
pub const PR_TAGGED_ADDR_ENABLE: u32 = 1;
pub const PR_MTE_TCF_NONE: u32 = 0;
pub const PR_MTE_TCF_SYNC: u32 = 2;
pub const PR_MTE_TCF_ASYNC: u32 = 4;
pub const PR_MTE_TCF_MASK: u32 = 6;
pub const PR_MTE_TAG_SHIFT: u32 = 3;
pub const PR_MTE_TAG_MASK: u32 = 524280;
pub const PR_MTE_TCF_SHIFT: u32 = 1;
pub const PR_MTE_STORE_ONLY: u32 = 524288;
pub const PR_PMLEN_SHIFT: u32 = 24;
pub const PR_PMLEN_MASK: u32 = 2130706432;
pub const PR_SET_IO_FLUSHER: u32 = 57;
pub const PR_GET_IO_FLUSHER: u32 = 58;
pub const PR_SET_SYSCALL_USER_DISPATCH: u32 = 59;
pub const PR_SYS_DISPATCH_OFF: u32 = 0;
pub const PR_SYS_DISPATCH_EXCLUSIVE_ON: u32 = 1;
pub const PR_SYS_DISPATCH_INCLUSIVE_ON: u32 = 2;
pub const PR_SYS_DISPATCH_ON: u32 = 1;
pub const SYSCALL_DISPATCH_FILTER_ALLOW: u32 = 0;
pub const SYSCALL_DISPATCH_FILTER_BLOCK: u32 = 1;
pub const PR_PAC_SET_ENABLED_KEYS: u32 = 60;
pub const PR_PAC_GET_ENABLED_KEYS: u32 = 61;
pub const PR_SCHED_CORE: u32 = 62;
pub const PR_SCHED_CORE_GET: u32 = 0;
pub const PR_SCHED_CORE_CREATE: u32 = 1;
pub const PR_SCHED_CORE_SHARE_TO: u32 = 2;
pub const PR_SCHED_CORE_SHARE_FROM: u32 = 3;
pub const PR_SCHED_CORE_MAX: u32 = 4;
pub const PR_SCHED_CORE_SCOPE_THREAD: u32 = 0;
pub const PR_SCHED_CORE_SCOPE_THREAD_GROUP: u32 = 1;
pub const PR_SCHED_CORE_SCOPE_PROCESS_GROUP: u32 = 2;
pub const PR_SME_SET_VL: u32 = 63;
pub const PR_SME_SET_VL_ONEXEC: u32 = 262144;
pub const PR_SME_GET_VL: u32 = 64;
pub const PR_SME_VL_LEN_MASK: u32 = 65535;
pub const PR_SME_VL_INHERIT: u32 = 131072;
pub const PR_SET_MDWE: u32 = 65;
pub const PR_MDWE_REFUSE_EXEC_GAIN: u32 = 1;
pub const PR_MDWE_NO_INHERIT: u32 = 2;
pub const PR_GET_MDWE: u32 = 66;
pub const PR_SET_VMA: u32 = 1398164801;
pub const PR_SET_VMA_ANON_NAME: u32 = 0;
pub const PR_GET_AUXV: u32 = 1096112214;
pub const PR_SET_MEMORY_MERGE: u32 = 67;
pub const PR_GET_MEMORY_MERGE: u32 = 68;
pub const PR_RISCV_V_SET_CONTROL: u32 = 69;
pub const PR_RISCV_V_GET_CONTROL: u32 = 70;
pub const PR_RISCV_V_VSTATE_CTRL_DEFAULT: u32 = 0;
pub const PR_RISCV_V_VSTATE_CTRL_OFF: u32 = 1;
pub const PR_RISCV_V_VSTATE_CTRL_ON: u32 = 2;
pub const PR_RISCV_V_VSTATE_CTRL_INHERIT: u32 = 16;
pub const PR_RISCV_V_VSTATE_CTRL_CUR_MASK: u32 = 3;
pub const PR_RISCV_V_VSTATE_CTRL_NEXT_MASK: u32 = 12;
pub const PR_RISCV_V_VSTATE_CTRL_MASK: u32 = 31;
pub const PR_RISCV_SET_ICACHE_FLUSH_CTX: u32 = 71;
pub const PR_RISCV_CTX_SW_FENCEI_ON: u32 = 0;
pub const PR_RISCV_CTX_SW_FENCEI_OFF: u32 = 1;
pub const PR_RISCV_SCOPE_PER_PROCESS: u32 = 0;
pub const PR_RISCV_SCOPE_PER_THREAD: u32 = 1;
pub const PR_PPC_GET_DEXCR: u32 = 72;
pub const PR_PPC_SET_DEXCR: u32 = 73;
pub const PR_PPC_DEXCR_SBHE: u32 = 0;
pub const PR_PPC_DEXCR_IBRTPD: u32 = 1;
pub const PR_PPC_DEXCR_SRAPD: u32 = 2;
pub const PR_PPC_DEXCR_NPHIE: u32 = 3;
pub const PR_PPC_DEXCR_CTRL_EDITABLE: u32 = 1;
pub const PR_PPC_DEXCR_CTRL_SET: u32 = 2;
pub const PR_PPC_DEXCR_CTRL_CLEAR: u32 = 4;
pub const PR_PPC_DEXCR_CTRL_SET_ONEXEC: u32 = 8;
pub const PR_PPC_DEXCR_CTRL_CLEAR_ONEXEC: u32 = 16;
pub const PR_PPC_DEXCR_CTRL_MASK: u32 = 31;
pub const PR_GET_SHADOW_STACK_STATUS: u32 = 74;
pub const PR_SET_SHADOW_STACK_STATUS: u32 = 75;
pub const PR_SHADOW_STACK_ENABLE: u32 = 1;
pub const PR_SHADOW_STACK_WRITE: u32 = 2;
pub const PR_SHADOW_STACK_PUSH: u32 = 4;
pub const PR_LOCK_SHADOW_STACK_STATUS: u32 = 76;
pub const PR_TIMER_CREATE_RESTORE_IDS: u32 = 77;
pub const PR_TIMER_CREATE_RESTORE_IDS_OFF: u32 = 0;
pub const PR_TIMER_CREATE_RESTORE_IDS_ON: u32 = 1;
pub const PR_TIMER_CREATE_RESTORE_IDS_GET: u32 = 2;
pub const PR_FUTEX_HASH: u32 = 78;
pub const PR_FUTEX_HASH_SET_SLOTS: u32 = 1;
pub const PR_FUTEX_HASH_GET_SLOTS: u32 = 2;
pub const PTRACE_GETFDPIC: u32 = 33;
pub const PTRACE_GETFDPIC_EXEC: u32 = 0;
pub const PTRACE_GETFDPIC_INTERP: u32 = 1;
pub const RISCV_MAX_VLENB: u32 = 8192;
pub const SATP_MODE_SHIFT: u32 = 60;
pub const SATP_ASID_BITS: u32 = 16;
pub const SATP_ASID_SHIFT: u32 = 44;
pub const IRQ_S_SOFT: u32 = 1;
pub const IRQ_VS_SOFT: u32 = 2;
pub const IRQ_M_SOFT: u32 = 3;
pub const IRQ_S_TIMER: u32 = 5;
pub const IRQ_VS_TIMER: u32 = 6;
pub const IRQ_M_TIMER: u32 = 7;
pub const IRQ_S_EXT: u32 = 9;
pub const IRQ_VS_EXT: u32 = 10;
pub const IRQ_M_EXT: u32 = 11;
pub const IRQ_S_GEXT: u32 = 12;
pub const IRQ_PMU_OVF: u32 = 13;
pub const IRQ_LOCAL_MAX: u32 = 14;
pub const EXC_INST_MISALIGNED: u32 = 0;
pub const EXC_INST_ACCESS: u32 = 1;
pub const EXC_INST_ILLEGAL: u32 = 2;
pub const EXC_BREAKPOINT: u32 = 3;
pub const EXC_LOAD_MISALIGNED: u32 = 4;
pub const EXC_LOAD_ACCESS: u32 = 5;
pub const EXC_STORE_MISALIGNED: u32 = 6;
pub const EXC_STORE_ACCESS: u32 = 7;
pub const EXC_SYSCALL: u32 = 8;
pub const EXC_HYPERVISOR_SYSCALL: u32 = 9;
pub const EXC_SUPERVISOR_SYSCALL: u32 = 10;
pub const EXC_INST_PAGE_FAULT: u32 = 12;
pub const EXC_LOAD_PAGE_FAULT: u32 = 13;
pub const EXC_STORE_PAGE_FAULT: u32 = 15;
pub const EXC_INST_GUEST_PAGE_FAULT: u32 = 20;
pub const EXC_LOAD_GUEST_PAGE_FAULT: u32 = 21;
pub const EXC_VIRTUAL_INST_FAULT: u32 = 22;
pub const EXC_STORE_GUEST_PAGE_FAULT: u32 = 23;
pub const PMP_R: u32 = 1;
pub const PMP_W: u32 = 2;
pub const PMP_X: u32 = 4;
pub const PMP_A: u32 = 24;
pub const PMP_A_TOR: u32 = 8;
pub const PMP_A_NA4: u32 = 16;
pub const PMP_A_NAPOT: u32 = 24;
pub const PMP_L: u32 = 128;
pub const HSTATUS_VSXL_SHIFT: u32 = 32;
pub const HSTATUS_VGEIN_SHIFT: u32 = 12;
pub const HGATP32_MODE_SHIFT: u32 = 31;
pub const HGATP32_VMID_SHIFT: u32 = 22;
pub const HGATP64_MODE_SHIFT: u32 = 60;
pub const HGATP64_VMID_SHIFT: u32 = 44;
pub const HGATP_PAGE_SHIFT: u32 = 12;
pub const HGATP_VMID_SHIFT: u32 = 44;
pub const HGATP_MODE_SHIFT: u32 = 60;
pub const VSIP_TO_HVIP_SHIFT: u32 = 1;
pub const TOPI_IID_SHIFT: u32 = 16;
pub const TOPI_IPRIO_BITS: u32 = 8;
pub const TOPEI_ID_SHIFT: u32 = 16;
pub const ISELECT_IPRIO0: u32 = 48;
pub const ISELECT_IPRIO15: u32 = 63;
pub const HVICTL_IID_SHIFT: u32 = 16;
pub const ENVCFG_CBIE_SHIFT: u32 = 4;
pub const SMSTATEEN0_AIA_IMSIC_SHIFT: u32 = 58;
pub const SMSTATEEN0_AIA_SHIFT: u32 = 59;
pub const SMSTATEEN0_AIA_ISEL_SHIFT: u32 = 60;
pub const SMSTATEEN0_HSENVCFG_SHIFT: u32 = 62;
pub const SMSTATEEN0_SSTATEEN0_SHIFT: u32 = 63;
pub const CSR_CYCLE: u32 = 3072;
pub const CSR_TIME: u32 = 3073;
pub const CSR_INSTRET: u32 = 3074;
pub const CSR_HPMCOUNTER3: u32 = 3075;
pub const CSR_HPMCOUNTER4: u32 = 3076;
pub const CSR_HPMCOUNTER5: u32 = 3077;
pub const CSR_HPMCOUNTER6: u32 = 3078;
pub const CSR_HPMCOUNTER7: u32 = 3079;
pub const CSR_HPMCOUNTER8: u32 = 3080;
pub const CSR_HPMCOUNTER9: u32 = 3081;
pub const CSR_HPMCOUNTER10: u32 = 3082;
pub const CSR_HPMCOUNTER11: u32 = 3083;
pub const CSR_HPMCOUNTER12: u32 = 3084;
pub const CSR_HPMCOUNTER13: u32 = 3085;
pub const CSR_HPMCOUNTER14: u32 = 3086;
pub const CSR_HPMCOUNTER15: u32 = 3087;
pub const CSR_HPMCOUNTER16: u32 = 3088;
pub const CSR_HPMCOUNTER17: u32 = 3089;
pub const CSR_HPMCOUNTER18: u32 = 3090;
pub const CSR_HPMCOUNTER19: u32 = 3091;
pub const CSR_HPMCOUNTER20: u32 = 3092;
pub const CSR_HPMCOUNTER21: u32 = 3093;
pub const CSR_HPMCOUNTER22: u32 = 3094;
pub const CSR_HPMCOUNTER23: u32 = 3095;
pub const CSR_HPMCOUNTER24: u32 = 3096;
pub const CSR_HPMCOUNTER25: u32 = 3097;
pub const CSR_HPMCOUNTER26: u32 = 3098;
pub const CSR_HPMCOUNTER27: u32 = 3099;
pub const CSR_HPMCOUNTER28: u32 = 3100;
pub const CSR_HPMCOUNTER29: u32 = 3101;
pub const CSR_HPMCOUNTER30: u32 = 3102;
pub const CSR_HPMCOUNTER31: u32 = 3103;
pub const CSR_CYCLEH: u32 = 3200;
pub const CSR_TIMEH: u32 = 3201;
pub const CSR_INSTRETH: u32 = 3202;
pub const CSR_HPMCOUNTER3H: u32 = 3203;
pub const CSR_HPMCOUNTER4H: u32 = 3204;
pub const CSR_HPMCOUNTER5H: u32 = 3205;
pub const CSR_HPMCOUNTER6H: u32 = 3206;
pub const CSR_HPMCOUNTER7H: u32 = 3207;
pub const CSR_HPMCOUNTER8H: u32 = 3208;
pub const CSR_HPMCOUNTER9H: u32 = 3209;
pub const CSR_HPMCOUNTER10H: u32 = 3210;
pub const CSR_HPMCOUNTER11H: u32 = 3211;
pub const CSR_HPMCOUNTER12H: u32 = 3212;
pub const CSR_HPMCOUNTER13H: u32 = 3213;
pub const CSR_HPMCOUNTER14H: u32 = 3214;
pub const CSR_HPMCOUNTER15H: u32 = 3215;
pub const CSR_HPMCOUNTER16H: u32 = 3216;
pub const CSR_HPMCOUNTER17H: u32 = 3217;
pub const CSR_HPMCOUNTER18H: u32 = 3218;
pub const CSR_HPMCOUNTER19H: u32 = 3219;
pub const CSR_HPMCOUNTER20H: u32 = 3220;
pub const CSR_HPMCOUNTER21H: u32 = 3221;
pub const CSR_HPMCOUNTER22H: u32 = 3222;
pub const CSR_HPMCOUNTER23H: u32 = 3223;
pub const CSR_HPMCOUNTER24H: u32 = 3224;
pub const CSR_HPMCOUNTER25H: u32 = 3225;
pub const CSR_HPMCOUNTER26H: u32 = 3226;
pub const CSR_HPMCOUNTER27H: u32 = 3227;
pub const CSR_HPMCOUNTER28H: u32 = 3228;
pub const CSR_HPMCOUNTER29H: u32 = 3229;
pub const CSR_HPMCOUNTER30H: u32 = 3230;
pub const CSR_HPMCOUNTER31H: u32 = 3231;
pub const CSR_SCOUNTOVF: u32 = 3488;
pub const CSR_SSTATUS: u32 = 256;
pub const CSR_SIE: u32 = 260;
pub const CSR_STVEC: u32 = 261;
pub const CSR_SCOUNTEREN: u32 = 262;
pub const CSR_SENVCFG: u32 = 266;
pub const CSR_SSTATEEN0: u32 = 268;
pub const CSR_SSCRATCH: u32 = 320;
pub const CSR_SEPC: u32 = 321;
pub const CSR_SCAUSE: u32 = 322;
pub const CSR_STVAL: u32 = 323;
pub const CSR_SIP: u32 = 324;
pub const CSR_SATP: u32 = 384;
pub const CSR_STIMECMP: u32 = 333;
pub const CSR_STIMECMPH: u32 = 349;
pub const CSR_VXSAT: u32 = 9;
pub const CSR_VXRM: u32 = 10;
pub const CSR_VXRM_MASK: u32 = 3;
pub const CSR_VXRM_SHIFT: u32 = 1;
pub const CSR_VXSAT_MASK: u32 = 1;
pub const CSR_SISELECT: u32 = 336;
pub const CSR_SIREG: u32 = 337;
pub const CSR_STOPEI: u32 = 348;
pub const CSR_STOPI: u32 = 3504;
pub const CSR_SIEH: u32 = 276;
pub const CSR_SIPH: u32 = 340;
pub const CSR_VSSTATUS: u32 = 512;
pub const CSR_VSIE: u32 = 516;
pub const CSR_VSTVEC: u32 = 517;
pub const CSR_VSSCRATCH: u32 = 576;
pub const CSR_VSEPC: u32 = 577;
pub const CSR_VSCAUSE: u32 = 578;
pub const CSR_VSTVAL: u32 = 579;
pub const CSR_VSIP: u32 = 580;
pub const CSR_VSATP: u32 = 640;
pub const CSR_VSTIMECMP: u32 = 589;
pub const CSR_VSTIMECMPH: u32 = 605;
pub const CSR_HSTATUS: u32 = 1536;
pub const CSR_HEDELEG: u32 = 1538;
pub const CSR_HIDELEG: u32 = 1539;
pub const CSR_HIE: u32 = 1540;
pub const CSR_HTIMEDELTA: u32 = 1541;
pub const CSR_HCOUNTEREN: u32 = 1542;
pub const CSR_HGEIE: u32 = 1543;
pub const CSR_HENVCFG: u32 = 1546;
pub const CSR_HTIMEDELTAH: u32 = 1557;
pub const CSR_HENVCFGH: u32 = 1562;
pub const CSR_HTVAL: u32 = 1603;
pub const CSR_HIP: u32 = 1604;
pub const CSR_HVIP: u32 = 1605;
pub const CSR_HTINST: u32 = 1610;
pub const CSR_HGATP: u32 = 1664;
pub const CSR_HGEIP: u32 = 3602;
pub const CSR_HVIEN: u32 = 1544;
pub const CSR_HVICTL: u32 = 1545;
pub const CSR_HVIPRIO1: u32 = 1606;
pub const CSR_HVIPRIO2: u32 = 1607;
pub const CSR_VSISELECT: u32 = 592;
pub const CSR_VSIREG: u32 = 593;
pub const CSR_VSTOPEI: u32 = 604;
pub const CSR_VSTOPI: u32 = 3760;
pub const CSR_HIDELEGH: u32 = 1555;
pub const CSR_HVIENH: u32 = 1560;
pub const CSR_HVIPH: u32 = 1621;
pub const CSR_HVIPRIO1H: u32 = 1622;
pub const CSR_HVIPRIO2H: u32 = 1623;
pub const CSR_VSIEH: u32 = 532;
pub const CSR_VSIPH: u32 = 596;
pub const CSR_HSTATEEN0: u32 = 1548;
pub const CSR_HSTATEEN0H: u32 = 1564;
pub const CSR_MSTATUS: u32 = 768;
pub const CSR_MISA: u32 = 769;
pub const CSR_MIDELEG: u32 = 771;
pub const CSR_MIE: u32 = 772;
pub const CSR_MTVEC: u32 = 773;
pub const CSR_MENVCFG: u32 = 778;
pub const CSR_MENVCFGH: u32 = 794;
pub const CSR_MSCRATCH: u32 = 832;
pub const CSR_MEPC: u32 = 833;
pub const CSR_MCAUSE: u32 = 834;
pub const CSR_MTVAL: u32 = 835;
pub const CSR_MIP: u32 = 836;
pub const CSR_PMPCFG0: u32 = 928;
pub const CSR_PMPADDR0: u32 = 944;
pub const CSR_MSECCFG: u32 = 1863;
pub const CSR_MSECCFGH: u32 = 1879;
pub const CSR_MVENDORID: u32 = 3857;
pub const CSR_MARCHID: u32 = 3858;
pub const CSR_MIMPID: u32 = 3859;
pub const CSR_MHARTID: u32 = 3860;
pub const CSR_MISELECT: u32 = 848;
pub const CSR_MIREG: u32 = 849;
pub const CSR_MTOPEI: u32 = 860;
pub const CSR_MTOPI: u32 = 4016;
pub const CSR_MVIEN: u32 = 776;
pub const CSR_MVIP: u32 = 777;
pub const CSR_MIDELEGH: u32 = 787;
pub const CSR_MIEH: u32 = 788;
pub const CSR_MVIENH: u32 = 792;
pub const CSR_MVIPH: u32 = 793;
pub const CSR_MIPH: u32 = 852;
pub const CSR_VSTART: u32 = 8;
pub const CSR_VCSR: u32 = 15;
pub const CSR_VL: u32 = 3104;
pub const CSR_VTYPE: u32 = 3105;
pub const CSR_VLENB: u32 = 3106;
pub const CSR_SEED: u32 = 21;
pub const CSR_STATUS: u32 = 256;
pub const CSR_IE: u32 = 260;
pub const CSR_TVEC: u32 = 261;
pub const CSR_ENVCFG: u32 = 266;
pub const CSR_SCRATCH: u32 = 320;
pub const CSR_EPC: u32 = 321;
pub const CSR_CAUSE: u32 = 322;
pub const CSR_TVAL: u32 = 323;
pub const CSR_IP: u32 = 324;
pub const CSR_IEH: u32 = 276;
pub const CSR_ISELECT: u32 = 336;
pub const CSR_IREG: u32 = 337;
pub const CSR_IPH: u32 = 340;
pub const CSR_TOPEI: u32 = 348;
pub const CSR_TOPI: u32 = 3504;
pub const RV_IRQ_SOFT: u32 = 1;
pub const RV_IRQ_TIMER: u32 = 5;
pub const RV_IRQ_EXT: u32 = 9;
pub const RV_IRQ_PMU: u32 = 13;
pub const PTRACE_SYSEMU: u32 = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: u32 = 32;
pub const REG_FMT: &[u8; 7] = b"%016lx\0";
pub const STACK_ALIGN: u32 = 16;
pub const RISCV_V_CTX_DEPTH_MASK: u32 = 16711680;
pub const RISCV_V_CTX_UNIT_DEPTH: u32 = 65536;
pub const RISCV_KERNEL_MODE_V: u32 = 1;
pub const RISCV_PREEMPT_V: u32 = 256;
pub const RISCV_PREEMPT_V_DIRTY: u32 = 2147483648;
pub const RISCV_PREEMPT_V_NEED_RESTORE: u32 = 1073741824;
pub const RISCV_PREEMPT_V_IN_SCHEDULE: u32 = 536870912;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const MAX_ERRNO: u32 = 4095;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 4;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const NR_CPUS: u32 = 64;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &[u8; 1] = b"\0";
pub const PER_CPU_ALIGNED_SECTION: &[u8; 1] = b"\0";
pub const PER_CPU_BASE_SECTION: &[u8; 14] = b".data..percpu\0";
pub const CPOPW: &[u8; 7] = b"cpopw \0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const PAGE_SHIFT: u32 = 12;
pub const PTE_FMT: &[u8; 7] = b"%016lx\0";
pub const MIN_MEMBLOCK_ADDR: u32 = 0;
pub const SZ_1: u32 = 1;
pub const SZ_2: u32 = 2;
pub const SZ_4: u32 = 4;
pub const SZ_8: u32 = 8;
pub const SZ_16: u32 = 16;
pub const SZ_32: u32 = 32;
pub const SZ_64: u32 = 64;
pub const SZ_128: u32 = 128;
pub const SZ_256: u32 = 256;
pub const SZ_512: u32 = 512;
pub const SZ_1K: u32 = 1024;
pub const SZ_2K: u32 = 2048;
pub const SZ_4K: u32 = 4096;
pub const SZ_8K: u32 = 8192;
pub const SZ_16K: u32 = 16384;
pub const SZ_24K: u32 = 24576;
pub const SZ_32K: u32 = 32768;
pub const SZ_64K: u32 = 65536;
pub const SZ_128K: u32 = 131072;
pub const SZ_192K: u32 = 196608;
pub const SZ_256K: u32 = 262144;
pub const SZ_384K: u32 = 393216;
pub const SZ_512K: u32 = 524288;
pub const SZ_1M: u32 = 1048576;
pub const SZ_2M: u32 = 2097152;
pub const SZ_3M: u32 = 3145728;
pub const SZ_4M: u32 = 4194304;
pub const SZ_6M: u32 = 6291456;
pub const SZ_8M: u32 = 8388608;
pub const SZ_12M: u32 = 12582912;
pub const SZ_16M: u32 = 16777216;
pub const SZ_18M: u32 = 18874368;
pub const SZ_24M: u32 = 25165824;
pub const SZ_32M: u32 = 33554432;
pub const SZ_64M: u32 = 67108864;
pub const SZ_128M: u32 = 134217728;
pub const SZ_256M: u32 = 268435456;
pub const SZ_512M: u32 = 536870912;
pub const SZ_1G: u32 = 1073741824;
pub const SZ_2G: u32 = 2147483648;
pub const KASAN_STACK_ORDER: u32 = 0;
pub const THREAD_SIZE_ORDER: u32 = 2;
pub const THREAD_SHIFT: u32 = 14;
pub const OVERFLOW_STACK_SIZE: u32 = 4096;
pub const TIF_NEED_RESCHED: u32 = 0;
pub const TIF_NEED_RESCHED_LAZY: u32 = 1;
pub const TIF_NOTIFY_RESUME: u32 = 2;
pub const TIF_SIGPENDING: u32 = 3;
pub const TIF_RESTORE_SIGMASK: u32 = 4;
pub const TIF_MEMDIE: u32 = 5;
pub const TIF_NOTIFY_SIGNAL: u32 = 9;
pub const TIF_UPROBE: u32 = 10;
pub const TIF_32BIT: u32 = 11;
pub const TIF_RISCV_V_DEFER_RESTORE: u32 = 12;
pub const _TIF_NEED_RESCHED: u32 = 1;
pub const _TIF_NEED_RESCHED_LAZY: u32 = 2;
pub const _TIF_NOTIFY_RESUME: u32 = 4;
pub const _TIF_SIGPENDING: u32 = 8;
pub const _TIF_NOTIFY_SIGNAL: u32 = 512;
pub const _TIF_UPROBE: u32 = 1024;
pub const _TIF_RISCV_V_DEFER_RESTORE: u32 = 4096;
pub const PREEMPT_ENABLED: u32 = 0;
pub const PREEMPT_DISABLE_OFFSET: u32 = 0;
pub const PREEMPT_LOCK_OFFSET: u32 = 0;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 512;
pub const STATIC_CALL_SITE_TAIL: u32 = 1;
pub const STATIC_CALL_SITE_INIT: u32 = 2;
pub const STATIC_CALL_SITE_FLAGS: u32 = 3;
pub const STACK_MAGIC: u32 = 3735928559;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const NODES_SHIFT: u32 = 0;
pub const MAX_NUMNODES: u32 = 1;
pub const NUMA_NO_NODE: i32 = -1;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const GRND_NONBLOCK: u32 = 1;
pub const GRND_RANDOM: u32 = 2;
pub const GRND_INSECURE: u32 = 4;
pub const first_online_node: u32 = 0;
pub const first_memory_node: u32 = 0;
pub const nr_node_ids: u32 = 1;
pub const nr_online_nodes: u32 = 1;
pub const NUMA_NO_MEMBLK: i32 = -1;
pub const INVALID_HARTID: i32 = -1;
pub const JUMP_LABEL_NOP_SIZE: u32 = 4;
pub const JUMP_TYPE_FALSE: u32 = 0;
pub const JUMP_TYPE_TRUE: u32 = 1;
pub const JUMP_TYPE_LINKED: u32 = 2;
pub const JUMP_TYPE_MASK: u32 = 3;
pub const force_read_lock_recursive: u32 = 0;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const LOCK_SECTION_END: &[u8; 12] = b".previous\n\t\0";
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const _Q_PENDING_LOOPS: u32 = 512;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const WQ_FLAG_EXCLUSIVE: u32 = 1;
pub const WQ_FLAG_WOKEN: u32 = 2;
pub const WQ_FLAG_CUSTOM: u32 = 4;
pub const WQ_FLAG_DONE: u32 = 8;
pub const WQ_FLAG_PRIORITY: u32 = 16;
pub const OSQ_UNLOCKED_VAL: u32 = 0;
pub const KCSAN_SEQLOCK_REGION_MAX: u32 = 1000;
pub const PB_migratetype_bits: u32 = 3;
pub const NR_PAGEFLAGS: u32 = 21;
pub const MAX_NR_ZONES: u32 = 3;
pub const NR_CPUS_BITS: u32 = 6;
pub const SPINLOCK_SIZE: u32 = 4;
pub const LRU_GEN_WIDTH: u32 = 0;
pub const __LRU_REFS_WIDTH: u32 = 0;
pub const ZONES_SHIFT: u32 = 2;
pub const ZONES_WIDTH: u32 = 2;
pub const MAX_PHYSMEM_BITS: u32 = 56;
pub const SECTION_SIZE_BITS: u32 = 27;
pub const SECTIONS_SHIFT: u32 = 29;
pub const SECTIONS_WIDTH: u32 = 0;
pub const NODES_WIDTH: u32 = 0;
pub const KASAN_TAG_WIDTH: u32 = 0;
pub const LAST_CPUPID_SHIFT: u32 = 0;
pub const LAST_CPUPID_WIDTH: u32 = 0;
pub const AT_SYSINFO_EHDR: u32 = 33;
pub const AT_L1I_CACHESIZE: u32 = 40;
pub const AT_L1I_CACHEGEOMETRY: u32 = 41;
pub const AT_L1D_CACHESIZE: u32 = 42;
pub const AT_L1D_CACHEGEOMETRY: u32 = 43;
pub const AT_L2_CACHESIZE: u32 = 44;
pub const AT_L2_CACHEGEOMETRY: u32 = 45;
pub const AT_L3_CACHESIZE: u32 = 46;
pub const AT_L3_CACHEGEOMETRY: u32 = 47;
pub const AT_VECTOR_SIZE_ARCH: u32 = 10;
pub const AT_MINSIGSTKSZ: u32 = 51;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_NOTELF: u32 = 10;
pub const AT_UID: u32 = 11;
pub const AT_EUID: u32 = 12;
pub const AT_GID: u32 = 13;
pub const AT_EGID: u32 = 14;
pub const AT_PLATFORM: u32 = 15;
pub const AT_HWCAP: u32 = 16;
pub const AT_CLKTCK: u32 = 17;
pub const AT_SECURE: u32 = 23;
pub const AT_BASE_PLATFORM: u32 = 24;
pub const AT_RANDOM: u32 = 25;
pub const AT_HWCAP2: u32 = 26;
pub const AT_RSEQ_FEATURE_SIZE: u32 = 27;
pub const AT_RSEQ_ALIGN: u32 = 28;
pub const AT_HWCAP3: u32 = 29;
pub const AT_HWCAP4: u32 = 30;
pub const AT_EXECFN: u32 = 31;
pub const AT_VECTOR_SIZE_BASE: u32 = 22;
pub const RCU_SEQ_CTR_SHIFT: u32 = 2;
pub const RCU_SEQ_STATE_MASK: u32 = 3;
pub const NUM_ACTIVE_RCU_POLL_OLDSTATE: u32 = 2;
pub const TRC_NEED_QS: u32 = 1;
pub const TRC_NEED_QS_CHECKED: u32 = 2;
pub const NUM_ACTIVE_RCU_POLL_FULL_OLDSTATE: u32 = 4;
pub const MAPLE_NODE_SLOTS: u32 = 31;
pub const MAPLE_RANGE64_SLOTS: u32 = 16;
pub const MAPLE_ARANGE64_SLOTS: u32 = 10;
pub const MAPLE_ALLOC_SLOTS: u32 = 30;
pub const MAPLE_NODE_MASK: u32 = 255;
pub const MT_FLAGS_ALLOC_RANGE: u32 = 1;
pub const MT_FLAGS_USE_RCU: u32 = 2;
pub const MT_FLAGS_HEIGHT_OFFSET: u32 = 2;
pub const MT_FLAGS_HEIGHT_MASK: u32 = 124;
pub const MT_FLAGS_LOCK_MASK: u32 = 768;
pub const MT_FLAGS_LOCK_IRQ: u32 = 256;
pub const MT_FLAGS_LOCK_BH: u32 = 512;
pub const MT_FLAGS_LOCK_EXTERN: u32 = 768;
pub const MT_FLAGS_ALLOC_WRAPPED: u32 = 2048;
pub const MAPLE_HEIGHT_MAX: u32 = 31;
pub const MAPLE_NODE_TYPE_MASK: u32 = 15;
pub const MAPLE_NODE_TYPE_SHIFT: u32 = 3;
pub const MAPLE_RESERVED_RANGE: u32 = 4096;
pub const RWSEM_UNLOCKED_VALUE: u32 = 0;
pub const RWSEM_WRITER_LOCKED: u32 = 1;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const PSEC_PER_SEC: u64 = 1000000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCK_AUX: u32 = 16;
pub const MAX_AUX_CLOCKS: u32 = 8;
pub const CLOCK_AUX_LAST: u32 = 23;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const PSEC_PER_NSEC: u32 = 1000;
pub const TIME_UPTIME_SEC_MAX: u32 = 946080000;
pub const NTP_API: u32 = 4;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const TIME_OK: u32 = 0;
pub const TIME_INS: u32 = 1;
pub const TIME_DEL: u32 = 2;
pub const TIME_OOP: u32 = 3;
pub const TIME_WAIT: u32 = 4;
pub const TIME_ERROR: u32 = 5;
pub const TIME_BAD: u32 = 5;
pub const ADJ_ADJTIME: u32 = 32768;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 1;
pub const ADJ_OFFSET_READONLY: u32 = 8192;
pub const SHIFT_PLL: u32 = 2;
pub const SHIFT_FLL: u32 = 2;
pub const MAXTC: u32 = 10;
pub const SHIFT_USEC: u32 = 16;
pub const PPM_SCALE_INV_SHIFT: u32 = 19;
pub const MAXPHASE: u32 = 500000000;
pub const MAXFREQ: u32 = 500000;
pub const MINSEC: u32 = 256;
pub const MAXSEC: u32 = 2048;
pub const NTP_PHASE_LIMIT: u32 = 16000000;
pub const NTP_SCALE_SHIFT: u32 = 32;
pub const NTP_INTERVAL_FREQ: u32 = 250;
pub const NTP_INTERVAL_LENGTH: u32 = 4000000;
pub const PIT_TICK_RATE: u32 = 1193182;
pub const TICK_NSEC: u32 = 4000000;
pub const HZ_TO_MSEC_SHR32: u32 = 29;
pub const MSEC_TO_HZ_SHR32: u32 = 33;
pub const HZ_TO_MSEC_NUM: u32 = 4;
pub const HZ_TO_MSEC_DEN: u32 = 1;
pub const MSEC_TO_HZ_NUM: u32 = 1;
pub const MSEC_TO_HZ_DEN: u32 = 4;
pub const HZ_TO_USEC_SHR32: u32 = 20;
pub const USEC_TO_HZ_SHR32: u32 = 43;
pub const HZ_TO_USEC_NUM: u32 = 4000;
pub const HZ_TO_USEC_DEN: u32 = 1;
pub const USEC_TO_HZ_NUM: u32 = 1;
pub const USEC_TO_HZ_DEN: u32 = 4000;
pub const HZ_TO_NSEC_NUM: u32 = 4000000;
pub const HZ_TO_NSEC_DEN: u32 = 1;
pub const NSEC_TO_HZ_NUM: u32 = 1;
pub const NSEC_TO_HZ_DEN: u32 = 4000000;
pub const SHIFT_HZ: u32 = 8;
pub const TICK_USEC: u32 = 4000;
pub const USER_TICK_USEC: u32 = 10000;
pub const SEC_JIFFIE_SC: u32 = 23;
pub const NSEC_JIFFIE_SC: u32 = 53;
pub const TIMESTAMP_SIZE: u32 = 30;
pub const LOW_RES_NSEC: u32 = 4000000;
pub const KTIME_LOW_RES: u32 = 4000000;
pub const TIMER_CPUMASK: u32 = 262143;
pub const TIMER_MIGRATING: u32 = 262144;
pub const TIMER_BASEMASK: u32 = 524287;
pub const TIMER_DEFERRABLE: u32 = 524288;
pub const TIMER_PINNED: u32 = 1048576;
pub const TIMER_IRQSAFE: u32 = 2097152;
pub const TIMER_INIT_FLAGS: u32 = 3670016;
pub const TIMER_ARRAYSHIFT: u32 = 22;
pub const TIMER_ARRAYMASK: u32 = 4290772992;
pub const TIMER_TRACE_FLAGMASK: u32 = 3932160;
pub const TIMER_NEXT_MAX_DELTA: u32 = 1073741823;
pub const UPROBE_HANDLER_REMOVE: u32 = 1;
pub const UPROBE_HANDLER_IGNORE: u32 = 2;
pub const MAX_URETPROBE_DEPTH: u32 = 64;
pub const UPROBE_NO_TRAMPOLINE_VADDR: i32 = -1;
pub const MAX_UINSN_BYTES: u32 = 8;
pub const UPROBE_SWBP_INSN_SIZE: u32 = 2;
pub const UPROBE_XOL_SLOT_BYTES: u32 = 8;
pub const CODETAG_SECTION_START_PREFIX: &[u8; 9] = b"__start_\0";
pub const CODETAG_SECTION_STOP_PREFIX: &[u8; 8] = b"__stop_\0";
pub const LINUX_MM_DEBUG_H: u32 = 1;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_CLEAR_SIGHAND: u64 = 4294967296;
pub const CLONE_INTO_CGROUP: u64 = 8589934592;
pub const CLONE_NEWTIME: u32 = 128;
pub const CLONE_ARGS_SIZE_VER0: u32 = 64;
pub const CLONE_ARGS_SIZE_VER1: u32 = 80;
pub const CLONE_ARGS_SIZE_VER2: u32 = 88;
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_EXT: u32 = 7;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const SCHED_FLAG_RESET_ON_FORK: u32 = 1;
pub const SCHED_FLAG_RECLAIM: u32 = 2;
pub const SCHED_FLAG_DL_OVERRUN: u32 = 4;
pub const SCHED_FLAG_KEEP_POLICY: u32 = 8;
pub const SCHED_FLAG_KEEP_PARAMS: u32 = 16;
pub const SCHED_FLAG_UTIL_CLAMP_MIN: u32 = 32;
pub const SCHED_FLAG_UTIL_CLAMP_MAX: u32 = 64;
pub const SCHED_FLAG_KEEP_ALL: u32 = 24;
pub const SCHED_FLAG_UTIL_CLAMP: u32 = 96;
pub const SCHED_FLAG_ALL: u32 = 127;
pub const KMSAN_RETVAL_SIZE: u32 = 800;
pub const KMSAN_PARAM_SIZE: u32 = 800;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_BOTH: i32 = -2;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIM64_INFINITY: i32 = -1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const _STK_LIM: u32 = 8388608;
pub const MLOCK_LIMIT: u32 = 8388608;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_NPROC: u32 = 6;
pub const RLIMIT_NOFILE: u32 = 7;
pub const RLIMIT_MEMLOCK: u32 = 8;
pub const RLIMIT_AS: u32 = 9;
pub const RLIMIT_LOCKS: u32 = 10;
pub const RLIMIT_SIGPENDING: u32 = 11;
pub const RLIMIT_MSGQUEUE: u32 = 12;
pub const RLIMIT_NICE: u32 = 13;
pub const RLIMIT_RTPRIO: u32 = 14;
pub const RLIMIT_RTTIME: u32 = 15;
pub const RLIM_NLIMITS: u32 = 16;
pub const RLIM_INFINITY: i32 = -1;
pub const MAX_NICE: u32 = 19;
pub const MIN_NICE: i32 = -20;
pub const NICE_WIDTH: u32 = 40;
pub const MAX_RT_PRIO: u32 = 100;
pub const MAX_DL_PRIO: u32 = 0;
pub const MAX_PRIO: u32 = 140;
pub const DEFAULT_PRIO: u32 = 120;
pub const _NSIG: u32 = 64;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const SIGRTMIN: u32 = 32;
pub const SIGRTMAX: u32 = 64;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const RISCV_V_MAGIC: u32 = 1397118039;
pub const END_MAGIC: u32 = 0;
pub const END_HDR_SIZE: u32 = 0;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const SEGV_CPERR: u32 = 10;
pub const NSIGSEGV: u32 = 10;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const TRAP_PERF_FLAG_ASYNC: u32 = 1;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const SIGQUEUE_PREALLOC: u32 = 1;
pub const SA_IMMUTABLE: u32 = 8388608;
pub const __ARCH_UAPI_SA_FLAGS: u32 = 0;
pub const UAPI_SA_FLAGS: u32 = 3623880711;
pub const CPUCLOCK_PERTHREAD_MASK: u32 = 4;
pub const CPUCLOCK_CLOCK_MASK: u32 = 3;
pub const CPUCLOCK_PROF: u32 = 0;
pub const CPUCLOCK_VIRT: u32 = 1;
pub const CPUCLOCK_SCHED: u32 = 2;
pub const CPUCLOCK_MAX: u32 = 3;
pub const CLOCKFD: u32 = 3;
pub const CLOCKFD_MASK: u32 = 7;
pub const MAX_DA_NAME_LEN: u32 = 32;
pub const MAX_DA_RETRY_RACING_EVENTS: u32 = 3;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const KM_MAX_IDX: u32 = 16;
pub const TASK_RUNNING: u32 = 0;
pub const TASK_INTERRUPTIBLE: u32 = 1;
pub const TASK_UNINTERRUPTIBLE: u32 = 2;
pub const __TASK_STOPPED: u32 = 4;
pub const __TASK_TRACED: u32 = 8;
pub const EXIT_DEAD: u32 = 16;
pub const EXIT_ZOMBIE: u32 = 32;
pub const EXIT_TRACE: u32 = 48;
pub const TASK_PARKED: u32 = 64;
pub const TASK_DEAD: u32 = 128;
pub const TASK_WAKEKILL: u32 = 256;
pub const TASK_WAKING: u32 = 512;
pub const TASK_NOLOAD: u32 = 1024;
pub const TASK_NEW: u32 = 2048;
pub const TASK_RTLOCK_WAIT: u32 = 4096;
pub const TASK_FREEZABLE: u32 = 8192;
pub const TASK_FROZEN: u32 = 32768;
pub const TASK_STATE_MAX: u32 = 65536;
pub const TASK_ANY: u32 = 65535;
pub const TASK_KILLABLE: u32 = 258;
pub const TASK_STOPPED: u32 = 260;
pub const TASK_TRACED: u32 = 8;
pub const TASK_IDLE: u32 = 1026;
pub const TASK_NORMAL: u32 = 3;
pub const TASK_REPORT: u32 = 127;
pub const SCHED_FIXEDPOINT_SHIFT: u32 = 10;
pub const SCHED_FIXEDPOINT_SCALE: u32 = 1024;
pub const SCHED_CAPACITY_SHIFT: u32 = 10;
pub const SCHED_CAPACITY_SCALE: u32 = 1024;
pub const UTIL_EST_WEIGHT_SHIFT: u32 = 2;
pub const UTIL_AVG_UNCHANGED: u32 = 2147483648;
pub const PERF_NR_CONTEXTS: u32 = 4;
pub const TASK_REPORT_IDLE: u32 = 128;
pub const TASK_REPORT_MAX: u32 = 256;
pub const PF_VCPU: u32 = 1;
pub const PF_IDLE: u32 = 2;
pub const PF_EXITING: u32 = 4;
pub const PF_POSTCOREDUMP: u32 = 8;
pub const PF_IO_WORKER: u32 = 16;
pub const PF_WQ_WORKER: u32 = 32;
pub const PF_FORKNOEXEC: u32 = 64;
pub const PF_MCE_PROCESS: u32 = 128;
pub const PF_SUPERPRIV: u32 = 256;
pub const PF_DUMPCORE: u32 = 512;
pub const PF_SIGNALED: u32 = 1024;
pub const PF_MEMALLOC: u32 = 2048;
pub const PF_NPROC_EXCEEDED: u32 = 4096;
pub const PF_USED_MATH: u32 = 8192;
pub const PF_USER_WORKER: u32 = 16384;
pub const PF_NOFREEZE: u32 = 32768;
pub const PF_KCOMPACTD: u32 = 65536;
pub const PF_KSWAPD: u32 = 131072;
pub const PF_MEMALLOC_NOFS: u32 = 262144;
pub const PF_MEMALLOC_NOIO: u32 = 524288;
pub const PF_LOCAL_THROTTLE: u32 = 1048576;
pub const PF_KTHREAD: u32 = 2097152;
pub const PF_RANDOMIZE: u32 = 4194304;
pub const PF__HOLE__00800000: u32 = 8388608;
pub const PF__HOLE__01000000: u32 = 16777216;
pub const PF__HOLE__02000000: u32 = 33554432;
pub const PF_NO_SETAFFINITY: u32 = 67108864;
pub const PF_MCE_EARLY: u32 = 134217728;
pub const PF_MEMALLOC_PIN: u32 = 268435456;
pub const PF_BLOCK_TS: u32 = 536870912;
pub const PF__HOLE__40000000: u32 = 1073741824;
pub const PF_SUSPEND_TASK: u32 = 2147483648;
pub const PFA_NO_NEW_PRIVS: u32 = 0;
pub const PFA_SPREAD_PAGE: u32 = 1;
pub const PFA_SPREAD_SLAB: u32 = 2;
pub const PFA_SPEC_SSB_DISABLE: u32 = 3;
pub const PFA_SPEC_SSB_FORCE_DISABLE: u32 = 4;
pub const PFA_SPEC_IB_DISABLE: u32 = 5;
pub const PFA_SPEC_IB_FORCE_DISABLE: u32 = 6;
pub const PFA_SPEC_SSB_NOEXEC: u32 = 7;
pub const MIGHT_RESCHED_RCU_SHIFT: u32 = 8;
pub const MIGHT_RESCHED_PREEMPT_MASK: u32 = 255;
pub const PREEMPT_LOCK_RESCHED_OFFSETS: u32 = 0;
pub const PERCPU_MODULE_RESERVE: u32 = 8192;
pub const PCPU_MIN_ALLOC_SHIFT: u32 = 2;
pub const PCPU_MIN_ALLOC_SIZE: u32 = 4;
pub const PERCPU_DYNAMIC_SIZE_SHIFT: u32 = 10;
pub const PERCPU_DYNAMIC_EARLY_SIZE: u32 = 20480;
pub const PERCPU_DYNAMIC_RESERVE: u32 = 28672;
pub const MM_CONTEXT_LOCK_PMLEN: u32 = 0;
pub const AT_VECTOR_SIZE: u32 = 66;
pub const ENCODED_PAGE_BITS: u32 = 3;
pub const ENCODED_PAGE_BIT_DELAY_RMAP: u32 = 1;
pub const ENCODED_PAGE_BIT_NR_PAGES_NEXT: u32 = 2;
pub const MM_ID_DUMMY: u32 = 0;
pub const MM_ID_MIN: u32 = 1;
pub const VMA_LOCK_OFFSET: u32 = 1073741824;
pub const VMA_REF_LIMIT: u32 = 1073741823;
pub const MM_MT_FLAGS: u32 = 771;
pub const MMF_DUMPABLE_BITS: u32 = 2;
pub const MMF_DUMPABLE_MASK: u32 = 3;
pub const MMF_DUMP_ANON_PRIVATE: u32 = 2;
pub const MMF_DUMP_ANON_SHARED: u32 = 3;
pub const MMF_DUMP_MAPPED_PRIVATE: u32 = 4;
pub const MMF_DUMP_MAPPED_SHARED: u32 = 5;
pub const MMF_DUMP_ELF_HEADERS: u32 = 6;
pub const MMF_DUMP_HUGETLB_PRIVATE: u32 = 7;
pub const MMF_DUMP_HUGETLB_SHARED: u32 = 8;
pub const MMF_DUMP_DAX_PRIVATE: u32 = 9;
pub const MMF_DUMP_DAX_SHARED: u32 = 10;
pub const MMF_DUMP_FILTER_SHIFT: u32 = 2;
pub const MMF_DUMP_FILTER_BITS: u32 = 9;
pub const MMF_DUMP_FILTER_MASK: u32 = 2044;
pub const MMF_DUMP_MASK_DEFAULT_ELF: u32 = 64;
pub const MMF_VM_MERGEABLE: u32 = 16;
pub const MMF_VM_HUGEPAGE: u32 = 17;
pub const MMF_HAS_UPROBES: u32 = 19;
pub const MMF_RECALC_UPROBES: u32 = 20;
pub const MMF_OOM_SKIP: u32 = 21;
pub const MMF_UNSTABLE: u32 = 22;
pub const MMF_HUGE_ZERO_PAGE: u32 = 23;
pub const MMF_DISABLE_THP: u32 = 24;
pub const MMF_DISABLE_THP_MASK: u32 = 16777216;
pub const MMF_OOM_REAP_QUEUED: u32 = 25;
pub const MMF_MULTIPROCESS: u32 = 26;
pub const MMF_HAS_PINNED: u32 = 27;
pub const MMF_HAS_MDWE: u32 = 28;
pub const MMF_HAS_MDWE_MASK: u32 = 268435456;
pub const MMF_HAS_MDWE_NO_INHERIT: u32 = 29;
pub const MMF_VM_MERGE_ANY: u32 = 30;
pub const MMF_VM_MERGE_ANY_MASK: u32 = 1073741824;
pub const MMF_TOPDOWN: u32 = 31;
pub const MMF_TOPDOWN_MASK: u32 = 2147483648;
pub const MMF_INIT_MASK: u32 = 3506440191;
pub const PAGEFLAGS_MASK: u32 = 2097151;
pub const PAGE_POISON_PATTERN: i32 = -1;
pub const FOLIO_PF_ANY: u32 = 0;
pub const FOLIO_PF_HEAD: u32 = 0;
pub const FOLIO_PF_NO_TAIL: u32 = 0;
pub const FOLIO_PF_NO_COMPOUND: u32 = 0;
pub const FOLIO_PF_SECOND: u32 = 1;
pub const FOLIO_HEAD_PAGE: u32 = 0;
pub const FOLIO_SECOND_PAGE: u32 = 1;
pub const __PG_HWPOISON: u32 = 0;
pub const FOLIO_MAPPING_ANON: u32 = 1;
pub const FOLIO_MAPPING_ANON_KSM: u32 = 2;
pub const FOLIO_MAPPING_KSM: u32 = 3;
pub const FOLIO_MAPPING_FLAGS: u32 = 3;
pub const MAX_PAGE_ORDER: u32 = 10;
pub const MAX_ORDER_NR_PAGES: u32 = 1024;
pub const NR_PAGE_ORDERS: u32 = 11;
pub const PAGE_BLOCK_MAX_ORDER: u32 = 10;
pub const PAGE_ALLOC_COSTLY_ORDER: u32 = 3;
pub const NR_VM_NUMA_EVENT_ITEMS: u32 = 0;
pub const LRU_BASE: u32 = 0;
pub const LRU_ACTIVE: u32 = 1;
pub const LRU_FILE: u32 = 2;
pub const WORKINGSET_ANON: u32 = 0;
pub const WORKINGSET_FILE: u32 = 1;
pub const ANON_AND_FILE: u32 = 2;
pub const MIN_NR_GENS: u32 = 2;
pub const MAX_NR_GENS: u32 = 4;
pub const MAX_NR_TIERS: u32 = 4;
pub const NR_PCP_THP: u32 = 0;
pub const ASYNC_AND_SYNC: u32 = 2;
pub const ZONEID_SHIFT: u32 = 2;
pub const ZONES_MASK: u32 = 3;
pub const NODES_MASK: u32 = 0;
pub const SECTIONS_MASK: u32 = 0;
pub const LAST_CPUPID_MASK: u32 = 0;
pub const KASAN_TAG_MASK: u32 = 0;
pub const ZONEID_MASK: u32 = 3;
pub const DEF_PRIORITY: u32 = 12;
pub const MAX_ZONES_PER_ZONELIST: u32 = 3;
pub const RCU_DONE_TAIL: u32 = 0;
pub const RCU_WAIT_TAIL: u32 = 1;
pub const RCU_NEXT_READY_TAIL: u32 = 2;
pub const RCU_NEXT_TAIL: u32 = 3;
pub const RCU_CBLIST_NSEGS: u32 = 4;
pub const SRCU_READ_FLAVOR_NORMAL: u32 = 1;
pub const SRCU_READ_FLAVOR_NMI: u32 = 2;
pub const SRCU_READ_FLAVOR_FAST: u32 = 8;
pub const SRCU_READ_FLAVOR_ALL: u32 = 11;
pub const SRCU_READ_FLAVOR_SLOWGP: u32 = 8;
pub const RCU_FANOUT: u32 = 64;
pub const RCU_FANOUT_LEAF: u32 = 16;
pub const RCU_FANOUT_1: u32 = 16;
pub const RCU_FANOUT_2: u32 = 1024;
pub const RCU_FANOUT_3: u32 = 65536;
pub const RCU_FANOUT_4: u32 = 4194304;
pub const RCU_NUM_LVLS: u32 = 2;
pub const NUM_RCU_LVL_0: u32 = 1;
pub const SRCU_SIZE_SMALL: u32 = 0;
pub const SRCU_SIZE_ALLOC: u32 = 1;
pub const SRCU_SIZE_WAIT_BARRIER: u32 = 2;
pub const SRCU_SIZE_WAIT_CALL: u32 = 3;
pub const SRCU_SIZE_WAIT_CBS1: u32 = 4;
pub const SRCU_SIZE_WAIT_CBS2: u32 = 5;
pub const SRCU_SIZE_WAIT_CBS3: u32 = 6;
pub const SRCU_SIZE_WAIT_CBS4: u32 = 7;
pub const SRCU_SIZE_BIG: u32 = 8;
pub const SRCU_STATE_IDLE: u32 = 0;
pub const SRCU_STATE_SCAN1: u32 = 1;
pub const SRCU_STATE_SCAN2: u32 = 2;
pub const SRCU_GP_SEQ_INITIAL_VAL: i32 = -400;
pub const SRCU_GP_SEQ_INITIAL_VAL_WITH_STATE: i32 = -401;
pub const SRCU_GET_STATE_COMPLETED: u32 = 1;
pub const NUM_ACTIVE_SRCU_POLL_OLDSTATE: u32 = 2;
pub const NOTIFY_DONE: u32 = 0;
pub const NOTIFY_OK: u32 = 1;
pub const NOTIFY_STOP_MASK: u32 = 32768;
pub const NOTIFY_BAD: u32 = 32770;
pub const NOTIFY_STOP: u32 = 32769;
pub const NETLINK_URELEASE: u32 = 1;
pub const KBD_KEYCODE: u32 = 1;
pub const KBD_UNBOUND_KEYCODE: u32 = 2;
pub const KBD_UNICODE: u32 = 3;
pub const KBD_KEYSYM: u32 = 4;
pub const KBD_POST_KEYSYM: u32 = 5;
pub const PA_SECTION_SHIFT: u32 = 27;
pub const PFN_SECTION_SHIFT: u32 = 15;
pub const NR_MEM_SECTIONS: u32 = 536870912;
pub const PAGES_PER_SECTION: u32 = 32768;
pub const PAGE_SECTION_MASK: i32 = -32768;
pub const SUBSECTION_SHIFT: u32 = 21;
pub const SUBSECTION_SIZE: u32 = 2097152;
pub const PFN_SUBSECTION_SHIFT: u32 = 9;
pub const PAGES_PER_SUBSECTION: u32 = 512;
pub const PAGE_SUBSECTION_MASK: i32 = -512;
pub const SUBSECTIONS_PER_SECTION: u32 = 64;
pub const LOCAL_DISTANCE: u32 = 10;
pub const REMOTE_DISTANCE: u32 = 20;
pub const DISTANCE_BITS: u32 = 8;
pub const RECLAIM_DISTANCE: u32 = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: u32 = 1;
pub const GFP_MOVABLE_SHIFT: u32 = 3;
pub const GFP_ZONES_SHIFT: u32 = 2;
pub const GOLDEN_RATIO_32: u32 = 1640531527;
pub const GOLDEN_RATIO_64: u64 = 7046029254386353131;
pub const KASAN_TAG_KERNEL: u32 = 255;
pub const KASAN_TAG_INVALID: u32 = 254;
pub const KASAN_TAG_MAX: u32 = 253;
pub const KASAN_TAG_MIN: u32 = 0;
pub const KASAN_VMALLOC_PAGE_RANGE: u32 = 1;
pub const KASAN_VMALLOC_TLB_FLUSH: u32 = 2;
pub const KMALLOC_SHIFT_HIGH: u32 = 13;
pub const KMALLOC_SHIFT_MAX: u32 = 22;
pub const KMALLOC_SHIFT_LOW: u32 = 3;
pub const KMALLOC_MAX_SIZE: u32 = 4194304;
pub const KMALLOC_MAX_CACHE_SIZE: u32 = 8192;
pub const KMALLOC_MAX_ORDER: u32 = 10;
pub const KMALLOC_MIN_SIZE: u32 = 8;
pub const RANDOM_KMALLOC_CACHES_NR: u32 = 0;
pub const PRINTK_INFO_SUBSYSTEM_LEN: u32 = 16;
pub const PRINTK_INFO_DEVICE_LEN: u32 = 48;
pub const SUID_DUMP_DISABLE: u32 = 0;
pub const SUID_DUMP_USER: u32 = 1;
pub const SUID_DUMP_ROOT: u32 = 2;
pub const BITS_PER_XA_VALUE: u32 = 63;
pub const XA_MAX_MARKS: u32 = 3;
pub const RADIX_TREE_ENTRY_MASK: u32 = 3;
pub const RADIX_TREE_INTERNAL_NODE: u32 = 2;
pub const RADIX_TREE_MAX_TAGS: u32 = 3;
pub const IDR_FREE: u32 = 0;
pub const IDA_CHUNK_SIZE: u32 = 128;
pub const DEFAULT_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_OVERFLOWGID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWGID: u32 = 65534;
pub const KERNFS_TYPE_MASK: u32 = 15;
pub const KERNFS_FLAG_MASK: i32 = -16;
pub const KERNFS_MAX_USER_XATTRS: u32 = 128;
pub const KERNFS_USER_XATTR_SIZE_LIMIT: u32 = 131072;
pub const STAT_HAVE_NSEC: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFBLK: u32 = 24576;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFIFO: u32 = 4096;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX_MNT_ID_UNIQUE: u32 = 16384;
pub const STATX_SUBVOL: u32 = 32768;
pub const STATX_WRITE_ATOMIC: u32 = 65536;
pub const STATX_DIO_READ_ALIGN: u32 = 131072;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const STATX_ATTR_WRITE_ATOMIC: u32 = 4194304;
pub const S_IRWXUGO: u32 = 511;
pub const S_IALLUGO: u32 = 4095;
pub const S_IRUGO: u32 = 292;
pub const S_IWUGO: u32 = 146;
pub const S_IXUGO: u32 = 73;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const KSTAT_ATTR_FS_IOC_FLAGS: u32 = 1050740;
pub const KSTAT_ATTR_VFS_FLAGS: u32 = 48;
pub const STATX_CHANGE_COOKIE: u32 = 1073741824;
pub const STATX_ATTR_CHANGE_MONOTONIC: i64 = -9223372036854775808;
pub const SYSFS_PREALLOC: u32 = 4096;
pub const SYSFS_GROUP_INVISIBLE: u32 = 8192;
pub const UEVENT_HELPER_PATH_LEN: u32 = 256;
pub const UEVENT_NUM_ENVP: u32 = 64;
pub const UEVENT_BUFFER_SIZE: u32 = 2048;
pub const SCHED_CPUFREQ_IOWAIT: u32 = 1;
pub const SDF_SHARED_CHILD: u32 = 1;
pub const SDF_SHARED_PARENT: u32 = 2;
pub const SDF_NEEDS_GROUPS: u32 = 4;
pub const PM_EVENT_INVALID: i32 = -1;
pub const PM_EVENT_ON: u32 = 0;
pub const PM_EVENT_FREEZE: u32 = 1;
pub const PM_EVENT_SUSPEND: u32 = 2;
pub const PM_EVENT_HIBERNATE: u32 = 4;
pub const PM_EVENT_QUIESCE: u32 = 8;
pub const PM_EVENT_RESUME: u32 = 16;
pub const PM_EVENT_THAW: u32 = 32;
pub const PM_EVENT_RESTORE: u32 = 64;
pub const PM_EVENT_RECOVER: u32 = 128;
pub const PM_EVENT_USER: u32 = 256;
pub const PM_EVENT_REMOTE: u32 = 512;
pub const PM_EVENT_AUTO: u32 = 1024;
pub const PM_EVENT_SLEEP: u32 = 6;
pub const PM_EVENT_USER_SUSPEND: u32 = 258;
pub const PM_EVENT_USER_RESUME: u32 = 272;
pub const PM_EVENT_REMOTE_RESUME: u32 = 528;
pub const PM_EVENT_AUTO_SUSPEND: u32 = 1026;
pub const PM_EVENT_AUTO_RESUME: u32 = 1040;
pub const PM_EVENT_PRETHAW: u32 = 8;
pub const BUILD_ID_SIZE_MAX: u32 = 20;
pub const CTL_MAXNAME: u32 = 10;
pub const UMH_NO_WAIT: u32 = 0;
pub const UMH_WAIT_EXEC: u32 = 1;
pub const UMH_WAIT_PROC: u32 = 2;
pub const UMH_KILLABLE: u32 = 4;
pub const UMH_FREEZABLE: u32 = 8;
pub const EM_NONE: u32 = 0;
pub const EM_M32: u32 = 1;
pub const EM_SPARC: u32 = 2;
pub const EM_386: u32 = 3;
pub const EM_68K: u32 = 4;
pub const EM_88K: u32 = 5;
pub const EM_486: u32 = 6;
pub const EM_860: u32 = 7;
pub const EM_MIPS: u32 = 8;
pub const EM_MIPS_RS3_LE: u32 = 10;
pub const EM_MIPS_RS4_BE: u32 = 10;
pub const EM_PARISC: u32 = 15;
pub const EM_SPARC32PLUS: u32 = 18;
pub const EM_PPC: u32 = 20;
pub const EM_PPC64: u32 = 21;
pub const EM_SPU: u32 = 23;
pub const EM_ARM: u32 = 40;
pub const EM_SH: u32 = 42;
pub const EM_SPARCV9: u32 = 43;
pub const EM_H8_300: u32 = 46;
pub const EM_IA_64: u32 = 50;
pub const EM_X86_64: u32 = 62;
pub const EM_S390: u32 = 22;
pub const EM_CRIS: u32 = 76;
pub const EM_M32R: u32 = 88;
pub const EM_MN10300: u32 = 89;
pub const EM_OPENRISC: u32 = 92;
pub const EM_ARCOMPACT: u32 = 93;
pub const EM_XTENSA: u32 = 94;
pub const EM_BLACKFIN: u32 = 106;
pub const EM_UNICORE: u32 = 110;
pub const EM_ALTERA_NIOS2: u32 = 113;
pub const EM_TI_C6000: u32 = 140;
pub const EM_HEXAGON: u32 = 164;
pub const EM_NDS32: u32 = 167;
pub const EM_AARCH64: u32 = 183;
pub const EM_TILEPRO: u32 = 188;
pub const EM_MICROBLAZE: u32 = 189;
pub const EM_TILEGX: u32 = 191;
pub const EM_ARCV2: u32 = 195;
pub const EM_RISCV: u32 = 243;
pub const EM_BPF: u32 = 247;
pub const EM_CSKY: u32 = 252;
pub const EM_LOONGARCH: u32 = 258;
pub const EM_FRV: u32 = 21569;
pub const EM_ALPHA: u32 = 36902;
pub const EM_CYGNUS_M32R: u32 = 36929;
pub const EM_S390_OLD: u32 = 41872;
pub const EM_CYGNUS_MN10300: u32 = 48879;
pub const PT_NULL: u32 = 0;
pub const PT_LOAD: u32 = 1;
pub const PT_DYNAMIC: u32 = 2;
pub const PT_INTERP: u32 = 3;
pub const PT_NOTE: u32 = 4;
pub const PT_SHLIB: u32 = 5;
pub const PT_PHDR: u32 = 6;
pub const PT_TLS: u32 = 7;
pub const PT_LOOS: u32 = 1610612736;
pub const PT_HIOS: u32 = 1879048191;
pub const PT_LOPROC: u32 = 1879048192;
pub const PT_HIPROC: u32 = 2147483647;
pub const PT_GNU_EH_FRAME: u32 = 1685382480;
pub const PT_GNU_STACK: u32 = 1685382481;
pub const PT_GNU_RELRO: u32 = 1685382482;
pub const PT_GNU_PROPERTY: u32 = 1685382483;
pub const PT_AARCH64_MEMTAG_MTE: u32 = 1879048194;
pub const PN_XNUM: u32 = 65535;
pub const ET_NONE: u32 = 0;
pub const ET_REL: u32 = 1;
pub const ET_EXEC: u32 = 2;
pub const ET_DYN: u32 = 3;
pub const ET_CORE: u32 = 4;
pub const ET_LOPROC: u32 = 65280;
pub const ET_HIPROC: u32 = 65535;
pub const DT_NULL: u32 = 0;
pub const DT_NEEDED: u32 = 1;
pub const DT_PLTRELSZ: u32 = 2;
pub const DT_PLTGOT: u32 = 3;
pub const DT_HASH: u32 = 4;
pub const DT_STRTAB: u32 = 5;
pub const DT_SYMTAB: u32 = 6;
pub const DT_RELA: u32 = 7;
pub const DT_RELASZ: u32 = 8;
pub const DT_RELAENT: u32 = 9;
pub const DT_STRSZ: u32 = 10;
pub const DT_SYMENT: u32 = 11;
pub const DT_INIT: u32 = 12;
pub const DT_FINI: u32 = 13;
pub const DT_SONAME: u32 = 14;
pub const DT_RPATH: u32 = 15;
pub const DT_SYMBOLIC: u32 = 16;
pub const DT_REL: u32 = 17;
pub const DT_RELSZ: u32 = 18;
pub const DT_RELENT: u32 = 19;
pub const DT_PLTREL: u32 = 20;
pub const DT_DEBUG: u32 = 21;
pub const DT_TEXTREL: u32 = 22;
pub const DT_JMPREL: u32 = 23;
pub const DT_ENCODING: u32 = 32;
pub const OLD_DT_LOOS: u32 = 1610612736;
pub const DT_LOOS: u32 = 1610612749;
pub const DT_HIOS: u32 = 1879044096;
pub const DT_VALRNGLO: u32 = 1879047424;
pub const DT_VALRNGHI: u32 = 1879047679;
pub const DT_ADDRRNGLO: u32 = 1879047680;
pub const DT_GNU_HASH: u32 = 1879047925;
pub const DT_ADDRRNGHI: u32 = 1879047935;
pub const DT_VERSYM: u32 = 1879048176;
pub const DT_RELACOUNT: u32 = 1879048185;
pub const DT_RELCOUNT: u32 = 1879048186;
pub const DT_FLAGS_1: u32 = 1879048187;
pub const DT_VERDEF: u32 = 1879048188;
pub const DT_VERDEFNUM: u32 = 1879048189;
pub const DT_VERNEED: u32 = 1879048190;
pub const DT_VERNEEDNUM: u32 = 1879048191;
pub const OLD_DT_HIOS: u32 = 1879048191;
pub const DT_LOPROC: u32 = 1879048192;
pub const DT_HIPROC: u32 = 2147483647;
pub const STB_LOCAL: u32 = 0;
pub const STB_GLOBAL: u32 = 1;
pub const STB_WEAK: u32 = 2;
pub const STN_UNDEF: u32 = 0;
pub const STT_NOTYPE: u32 = 0;
pub const STT_OBJECT: u32 = 1;
pub const STT_FUNC: u32 = 2;
pub const STT_SECTION: u32 = 3;
pub const STT_FILE: u32 = 4;
pub const STT_COMMON: u32 = 5;
pub const STT_TLS: u32 = 6;
pub const VER_FLG_BASE: u32 = 1;
pub const VER_FLG_WEAK: u32 = 2;
pub const EI_NIDENT: u32 = 16;
pub const PF_R: u32 = 4;
pub const PF_W: u32 = 2;
pub const PF_X: u32 = 1;
pub const SHT_NULL: u32 = 0;
pub const SHT_PROGBITS: u32 = 1;
pub const SHT_SYMTAB: u32 = 2;
pub const SHT_STRTAB: u32 = 3;
pub const SHT_RELA: u32 = 4;
pub const SHT_HASH: u32 = 5;
pub const SHT_DYNAMIC: u32 = 6;
pub const SHT_NOTE: u32 = 7;
pub const SHT_NOBITS: u32 = 8;
pub const SHT_REL: u32 = 9;
pub const SHT_SHLIB: u32 = 10;
pub const SHT_DYNSYM: u32 = 11;
pub const SHT_NUM: u32 = 12;
pub const SHT_LOPROC: u32 = 1879048192;
pub const SHT_HIPROC: u32 = 2147483647;
pub const SHT_LOUSER: u32 = 2147483648;
pub const SHT_HIUSER: u32 = 4294967295;
pub const SHF_WRITE: u32 = 1;
pub const SHF_ALLOC: u32 = 2;
pub const SHF_EXECINSTR: u32 = 4;
pub const SHF_MERGE: u32 = 16;
pub const SHF_STRINGS: u32 = 32;
pub const SHF_INFO_LINK: u32 = 64;
pub const SHF_LINK_ORDER: u32 = 128;
pub const SHF_OS_NONCONFORMING: u32 = 256;
pub const SHF_GROUP: u32 = 512;
pub const SHF_TLS: u32 = 1024;
pub const SHF_RELA_LIVEPATCH: u32 = 1048576;
pub const SHF_RO_AFTER_INIT: u32 = 2097152;
pub const SHF_ORDERED: u32 = 67108864;
pub const SHF_EXCLUDE: u32 = 134217728;
pub const SHF_MASKOS: u32 = 267386880;
pub const SHF_MASKPROC: u32 = 4026531840;
pub const SHN_UNDEF: u32 = 0;
pub const SHN_LORESERVE: u32 = 65280;
pub const SHN_LOPROC: u32 = 65280;
pub const SHN_HIPROC: u32 = 65311;
pub const SHN_LIVEPATCH: u32 = 65312;
pub const SHN_ABS: u32 = 65521;
pub const SHN_COMMON: u32 = 65522;
pub const SHN_HIRESERVE: u32 = 65535;
pub const EI_MAG0: u32 = 0;
pub const EI_MAG1: u32 = 1;
pub const EI_MAG2: u32 = 2;
pub const EI_MAG3: u32 = 3;
pub const EI_CLASS: u32 = 4;
pub const EI_DATA: u32 = 5;
pub const EI_VERSION: u32 = 6;
pub const EI_OSABI: u32 = 7;
pub const EI_PAD: u32 = 8;
pub const ELFMAG0: u32 = 127;
pub const ELFMAG1: u8 = 69u8;
pub const ELFMAG2: u8 = 76u8;
pub const ELFMAG3: u8 = 70u8;
pub const ELFMAG: &[u8; 5] = b"\x7FELF\0";
pub const SELFMAG: u32 = 4;
pub const ELFCLASSNONE: u32 = 0;
pub const ELFCLASS32: u32 = 1;
pub const ELFCLASS64: u32 = 2;
pub const ELFCLASSNUM: u32 = 3;
pub const ELFDATANONE: u32 = 0;
pub const ELFDATA2LSB: u32 = 1;
pub const ELFDATA2MSB: u32 = 2;
pub const EV_NONE: u32 = 0;
pub const EV_CURRENT: u32 = 1;
pub const EV_NUM: u32 = 2;
pub const ELFOSABI_NONE: u32 = 0;
pub const ELFOSABI_LINUX: u32 = 3;
pub const ELF_OSABI: u32 = 0;
pub const NN_GNU_PROPERTY_TYPE_0: &[u8; 4] = b"GNU\0";
pub const NT_GNU_PROPERTY_TYPE_0: u32 = 5;
pub const NN_PRSTATUS: &[u8; 5] = b"CORE\0";
pub const NT_PRSTATUS: u32 = 1;
pub const NN_PRFPREG: &[u8; 5] = b"CORE\0";
pub const NT_PRFPREG: u32 = 2;
pub const NN_PRPSINFO: &[u8; 5] = b"CORE\0";
pub const NT_PRPSINFO: u32 = 3;
pub const NN_TASKSTRUCT: &[u8; 5] = b"CORE\0";
pub const NT_TASKSTRUCT: u32 = 4;
pub const NN_AUXV: &[u8; 5] = b"CORE\0";
pub const NT_AUXV: u32 = 6;
pub const NN_SIGINFO: &[u8; 5] = b"CORE\0";
pub const NT_SIGINFO: u32 = 1397311305;
pub const NN_FILE: &[u8; 5] = b"CORE\0";
pub const NT_FILE: u32 = 1179208773;
pub const NN_PRXFPREG: &[u8; 6] = b"LINUX\0";
pub const NT_PRXFPREG: u32 = 1189489535;
pub const NN_PPC_VMX: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_VMX: u32 = 256;
pub const NN_PPC_SPE: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_SPE: u32 = 257;
pub const NN_PPC_VSX: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_VSX: u32 = 258;
pub const NN_PPC_TAR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TAR: u32 = 259;
pub const NN_PPC_PPR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_PPR: u32 = 260;
pub const NN_PPC_DSCR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_DSCR: u32 = 261;
pub const NN_PPC_EBB: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_EBB: u32 = 262;
pub const NN_PPC_PMU: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_PMU: u32 = 263;
pub const NN_PPC_TM_CGPR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CGPR: u32 = 264;
pub const NN_PPC_TM_CFPR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CFPR: u32 = 265;
pub const NN_PPC_TM_CVMX: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CVMX: u32 = 266;
pub const NN_PPC_TM_CVSX: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CVSX: u32 = 267;
pub const NN_PPC_TM_SPR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_SPR: u32 = 268;
pub const NN_PPC_TM_CTAR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CTAR: u32 = 269;
pub const NN_PPC_TM_CPPR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CPPR: u32 = 270;
pub const NN_PPC_TM_CDSCR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_TM_CDSCR: u32 = 271;
pub const NN_PPC_PKEY: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_PKEY: u32 = 272;
pub const NN_PPC_DEXCR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_DEXCR: u32 = 273;
pub const NN_PPC_HASHKEYR: &[u8; 6] = b"LINUX\0";
pub const NT_PPC_HASHKEYR: u32 = 274;
pub const NN_386_TLS: &[u8; 6] = b"LINUX\0";
pub const NT_386_TLS: u32 = 512;
pub const NN_386_IOPERM: &[u8; 6] = b"LINUX\0";
pub const NT_386_IOPERM: u32 = 513;
pub const NN_X86_XSTATE: &[u8; 6] = b"LINUX\0";
pub const NT_X86_XSTATE: u32 = 514;
pub const NN_X86_SHSTK: &[u8; 6] = b"LINUX\0";
pub const NT_X86_SHSTK: u32 = 516;
pub const NN_X86_XSAVE_LAYOUT: &[u8; 6] = b"LINUX\0";
pub const NT_X86_XSAVE_LAYOUT: u32 = 517;
pub const NN_S390_HIGH_GPRS: &[u8; 6] = b"LINUX\0";
pub const NT_S390_HIGH_GPRS: u32 = 768;
pub const NN_S390_TIMER: &[u8; 6] = b"LINUX\0";
pub const NT_S390_TIMER: u32 = 769;
pub const NN_S390_TODCMP: &[u8; 6] = b"LINUX\0";
pub const NT_S390_TODCMP: u32 = 770;
pub const NN_S390_TODPREG: &[u8; 6] = b"LINUX\0";
pub const NT_S390_TODPREG: u32 = 771;
pub const NN_S390_CTRS: &[u8; 6] = b"LINUX\0";
pub const NT_S390_CTRS: u32 = 772;
pub const NN_S390_PREFIX: &[u8; 6] = b"LINUX\0";
pub const NT_S390_PREFIX: u32 = 773;
pub const NN_S390_LAST_BREAK: &[u8; 6] = b"LINUX\0";
pub const NT_S390_LAST_BREAK: u32 = 774;
pub const NN_S390_SYSTEM_CALL: &[u8; 6] = b"LINUX\0";
pub const NT_S390_SYSTEM_CALL: u32 = 775;
pub const NN_S390_TDB: &[u8; 6] = b"LINUX\0";
pub const NT_S390_TDB: u32 = 776;
pub const NN_S390_VXRS_LOW: &[u8; 6] = b"LINUX\0";
pub const NT_S390_VXRS_LOW: u32 = 777;
pub const NN_S390_VXRS_HIGH: &[u8; 6] = b"LINUX\0";
pub const NT_S390_VXRS_HIGH: u32 = 778;
pub const NN_S390_GS_CB: &[u8; 6] = b"LINUX\0";
pub const NT_S390_GS_CB: u32 = 779;
pub const NN_S390_GS_BC: &[u8; 6] = b"LINUX\0";
pub const NT_S390_GS_BC: u32 = 780;
pub const NN_S390_RI_CB: &[u8; 6] = b"LINUX\0";
pub const NT_S390_RI_CB: u32 = 781;
pub const NN_S390_PV_CPU_DATA: &[u8; 6] = b"LINUX\0";
pub const NT_S390_PV_CPU_DATA: u32 = 782;
pub const NN_ARM_VFP: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_VFP: u32 = 1024;
pub const NN_ARM_TLS: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_TLS: u32 = 1025;
pub const NN_ARM_HW_BREAK: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_HW_BREAK: u32 = 1026;
pub const NN_ARM_HW_WATCH: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_HW_WATCH: u32 = 1027;
pub const NN_ARM_SYSTEM_CALL: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_SYSTEM_CALL: u32 = 1028;
pub const NN_ARM_SVE: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_SVE: u32 = 1029;
pub const NN_ARM_PAC_MASK: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_PAC_MASK: u32 = 1030;
pub const NN_ARM_PACA_KEYS: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_PACA_KEYS: u32 = 1031;
pub const NN_ARM_PACG_KEYS: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_PACG_KEYS: u32 = 1032;
pub const NN_ARM_TAGGED_ADDR_CTRL: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_TAGGED_ADDR_CTRL: u32 = 1033;
pub const NN_ARM_PAC_ENABLED_KEYS: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_PAC_ENABLED_KEYS: u32 = 1034;
pub const NN_ARM_SSVE: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_SSVE: u32 = 1035;
pub const NN_ARM_ZA: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_ZA: u32 = 1036;
pub const NN_ARM_ZT: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_ZT: u32 = 1037;
pub const NN_ARM_FPMR: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_FPMR: u32 = 1038;
pub const NN_ARM_POE: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_POE: u32 = 1039;
pub const NN_ARM_GCS: &[u8; 6] = b"LINUX\0";
pub const NT_ARM_GCS: u32 = 1040;
pub const NN_ARC_V2: &[u8; 6] = b"LINUX\0";
pub const NT_ARC_V2: u32 = 1536;
pub const NN_VMCOREDD: &[u8; 6] = b"LINUX\0";
pub const NT_VMCOREDD: u32 = 1792;
pub const NN_MIPS_DSP: &[u8; 6] = b"LINUX\0";
pub const NT_MIPS_DSP: u32 = 2048;
pub const NN_MIPS_FP_MODE: &[u8; 6] = b"LINUX\0";
pub const NT_MIPS_FP_MODE: u32 = 2049;
pub const NN_MIPS_MSA: &[u8; 6] = b"LINUX\0";
pub const NT_MIPS_MSA: u32 = 2050;
pub const NN_RISCV_CSR: &[u8; 6] = b"LINUX\0";
pub const NT_RISCV_CSR: u32 = 2304;
pub const NN_RISCV_VECTOR: &[u8; 6] = b"LINUX\0";
pub const NT_RISCV_VECTOR: u32 = 2305;
pub const NN_RISCV_TAGGED_ADDR_CTRL: &[u8; 6] = b"LINUX\0";
pub const NT_RISCV_TAGGED_ADDR_CTRL: u32 = 2306;
pub const NN_LOONGARCH_CPUCFG: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_CPUCFG: u32 = 2560;
pub const NN_LOONGARCH_CSR: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_CSR: u32 = 2561;
pub const NN_LOONGARCH_LSX: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_LSX: u32 = 2562;
pub const NN_LOONGARCH_LASX: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_LASX: u32 = 2563;
pub const NN_LOONGARCH_LBT: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_LBT: u32 = 2564;
pub const NN_LOONGARCH_HW_BREAK: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_HW_BREAK: u32 = 2565;
pub const NN_LOONGARCH_HW_WATCH: &[u8; 6] = b"LINUX\0";
pub const NT_LOONGARCH_HW_WATCH: u32 = 2566;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_AND: u32 = 3221225472;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_BTI: u32 = 1;
pub const IPC_CREAT: u32 = 512;
pub const IPC_EXCL: u32 = 1024;
pub const IPC_NOWAIT: u32 = 2048;
pub const IPC_DIPC: u32 = 4096;
pub const IPC_OWN: u32 = 8192;
pub const IPC_RMID: u32 = 0;
pub const IPC_SET: u32 = 1;
pub const IPC_STAT: u32 = 2;
pub const IPC_INFO: u32 = 3;
pub const IPC_OLD: u32 = 0;
pub const IPC_64: u32 = 256;
pub const SEMOP: u32 = 1;
pub const SEMGET: u32 = 2;
pub const SEMCTL: u32 = 3;
pub const SEMTIMEDOP: u32 = 4;
pub const MSGSND: u32 = 11;
pub const MSGRCV: u32 = 12;
pub const MSGGET: u32 = 13;
pub const MSGCTL: u32 = 14;
pub const SHMAT: u32 = 21;
pub const SHMDT: u32 = 22;
pub const SHMGET: u32 = 23;
pub const SHMCTL: u32 = 24;
pub const DIPC: u32 = 25;
pub const SEM_UNDO: u32 = 4096;
pub const GETPID: u32 = 11;
pub const GETVAL: u32 = 12;
pub const GETALL: u32 = 13;
pub const GETNCNT: u32 = 14;
pub const GETZCNT: u32 = 15;
pub const SETVAL: u32 = 16;
pub const SETALL: u32 = 17;
pub const SEM_STAT: u32 = 18;
pub const SEM_INFO: u32 = 19;
pub const SEM_STAT_ANY: u32 = 20;
pub const SEMMNI: u32 = 32000;
pub const SEMMSL: u32 = 32000;
pub const SEMMNS: u32 = 1024000000;
pub const SEMOPM: u32 = 500;
pub const SEMVMX: u32 = 32767;
pub const SEMAEM: u32 = 32767;
pub const SEMUME: u32 = 500;
pub const SEMMNU: u32 = 1024000000;
pub const SEMMAP: u32 = 1024000000;
pub const SEMUSZ: u32 = 20;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_DEVMEM_LINEAR: u32 = 78;
pub const SCM_DEVMEM_LINEAR: u32 = 78;
pub const SO_DEVMEM_DMABUF: u32 = 79;
pub const SCM_DEVMEM_DMABUF: u32 = 79;
pub const SO_DEVMEM_DONTNEED: u32 = 80;
pub const SCM_TS_OPT_ID: u32 = 81;
pub const SO_RCVPRIORITY: u32 = 82;
pub const SO_PASSRIGHTS: u32 = 83;
pub const SO_INQ: u32 = 84;
pub const SCM_INQ: u32 = 84;
pub const SOCK_IOC_TYPE: u32 = 137;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCETHTOOL: u32 = 35142;
pub const SIOCGMIIPHY: u32 = 35143;
pub const SIOCGMIIREG: u32 = 35144;
pub const SIOCSMIIREG: u32 = 35145;
pub const SIOCWANDEV: u32 = 35146;
pub const SIOCOUTQNSD: u32 = 35147;
pub const SIOCGSKNS: u32 = 35148;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCGIFVLAN: u32 = 35202;
pub const SIOCSIFVLAN: u32 = 35203;
pub const SIOCBONDENSLAVE: u32 = 35216;
pub const SIOCBONDRELEASE: u32 = 35217;
pub const SIOCBONDSETHWADDR: u32 = 35218;
pub const SIOCBONDSLAVEINFOQUERY: u32 = 35219;
pub const SIOCBONDINFOQUERY: u32 = 35220;
pub const SIOCBONDCHANGEACTIVE: u32 = 35221;
pub const SIOCBRADDBR: u32 = 35232;
pub const SIOCBRDELBR: u32 = 35233;
pub const SIOCBRADDIF: u32 = 35234;
pub const SIOCBRDELIF: u32 = 35235;
pub const SIOCSHWTSTAMP: u32 = 35248;
pub const SIOCGHWTSTAMP: u32 = 35249;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const UIO_FASTIOV: u32 = 8;
pub const UIO_MAXIOV: u32 = 1024;
pub const ITER_SOURCE: u32 = 1;
pub const ITER_DEST: u32 = 0;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const SOCK_SNDBUF_LOCK: u32 = 1;
pub const SOCK_RCVBUF_LOCK: u32 = 2;
pub const SOCK_BUF_LOCK_MASK: u32 = 3;
pub const SOCK_TXREHASH_DEFAULT: u32 = 255;
pub const SOCK_TXREHASH_DISABLED: u32 = 0;
pub const SOCK_TXREHASH_ENABLED: u32 = 1;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_CREDENTIALS: u32 = 2;
pub const SCM_SECURITY: u32 = 3;
pub const SCM_PIDFD: u32 = 4;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_LOCAL: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const SOMAXCONN: u32 = 4096;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_TRYHARD: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const MSG_PROBE: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_DONTWAIT: u32 = 64;
pub const MSG_EOR: u32 = 128;
pub const MSG_WAITALL: u32 = 256;
pub const MSG_FIN: u32 = 512;
pub const MSG_SYN: u32 = 1024;
pub const MSG_CONFIRM: u32 = 2048;
pub const MSG_RST: u32 = 4096;
pub const MSG_ERRQUEUE: u32 = 8192;
pub const MSG_NOSIGNAL: u32 = 16384;
pub const MSG_MORE: u32 = 32768;
pub const MSG_WAITFORONE: u32 = 65536;
pub const MSG_SENDPAGE_NOPOLICY: u32 = 65536;
pub const MSG_BATCH: u32 = 262144;
pub const MSG_EOF: u32 = 512;
pub const MSG_NO_SHARED_FRAGS: u32 = 524288;
pub const MSG_SENDPAGE_DECRYPTED: u32 = 1048576;
pub const MSG_SOCK_DEVMEM: u32 = 33554432;
pub const MSG_ZEROCOPY: u32 = 67108864;
pub const MSG_SPLICE_PAGES: u32 = 134217728;
pub const MSG_FASTOPEN: u32 = 536870912;
pub const MSG_CMSG_CLOEXEC: u32 = 1073741824;
pub const MSG_CMSG_COMPAT: u32 = 2147483648;
pub const MSG_INTERNAL_SENDMSG_FLAGS: u32 = 135331840;
pub const SOL_IP: u32 = 0;
pub const SOL_TCP: u32 = 6;
pub const SOL_UDP: u32 = 17;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const SOL_SCTP: u32 = 132;
pub const SOL_UDPLITE: u32 = 136;
pub const SOL_RAW: u32 = 255;
pub const SOL_IPX: u32 = 256;
pub const SOL_AX25: u32 = 257;
pub const SOL_ATALK: u32 = 258;
pub const SOL_NETROM: u32 = 259;
pub const SOL_ROSE: u32 = 260;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOL_VSOCK: u32 = 287;
pub const IPX_TYPE: u32 = 1;
pub const __UAPI_DEF_IF_IFCONF: u32 = 1;
pub const __UAPI_DEF_IF_IFMAP: u32 = 1;
pub const __UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __UAPI_DEF_IN_ADDR: u32 = 1;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 1;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP_MREQ: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 1;
pub const __UAPI_DEF_IN_CLASS: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 1;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 1;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 1;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 1;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 1;
pub const __UAPI_DEF_XATTR: u32 = 1;
pub const IFNAMSIZ: u32 = 16;
pub const IFALIASZ: u32 = 256;
pub const ALTIFNAMSIZ: u32 = 128;
pub const GENERIC_HDLC_VERSION: u32 = 4;
pub const CLOCK_DEFAULT: u32 = 0;
pub const CLOCK_EXT: u32 = 1;
pub const CLOCK_INT: u32 = 2;
pub const CLOCK_TXINT: u32 = 3;
pub const CLOCK_TXFROMRX: u32 = 4;
pub const ENCODING_DEFAULT: u32 = 0;
pub const ENCODING_NRZ: u32 = 1;
pub const ENCODING_NRZI: u32 = 2;
pub const ENCODING_FM_MARK: u32 = 3;
pub const ENCODING_FM_SPACE: u32 = 4;
pub const ENCODING_MANCHESTER: u32 = 5;
pub const PARITY_DEFAULT: u32 = 0;
pub const PARITY_NONE: u32 = 1;
pub const PARITY_CRC16_PR0: u32 = 2;
pub const PARITY_CRC16_PR1: u32 = 3;
pub const PARITY_CRC16_PR0_CCITT: u32 = 4;
pub const PARITY_CRC16_PR1_CCITT: u32 = 5;
pub const PARITY_CRC32_PR0_CCITT: u32 = 6;
pub const PARITY_CRC32_PR1_CCITT: u32 = 7;
pub const LMI_DEFAULT: u32 = 0;
pub const LMI_NONE: u32 = 1;
pub const LMI_ANSI: u32 = 2;
pub const LMI_CCITT: u32 = 3;
pub const LMI_CISCO: u32 = 4;
pub const IF_GET_IFACE: u32 = 1;
pub const IF_GET_PROTO: u32 = 2;
pub const IF_IFACE_V35: u32 = 4096;
pub const IF_IFACE_V24: u32 = 4097;
pub const IF_IFACE_X21: u32 = 4098;
pub const IF_IFACE_T1: u32 = 4099;
pub const IF_IFACE_E1: u32 = 4100;
pub const IF_IFACE_SYNC_SERIAL: u32 = 4101;
pub const IF_IFACE_X21D: u32 = 4102;
pub const IF_PROTO_HDLC: u32 = 8192;
pub const IF_PROTO_PPP: u32 = 8193;
pub const IF_PROTO_CISCO: u32 = 8194;
pub const IF_PROTO_FR: u32 = 8195;
pub const IF_PROTO_FR_ADD_PVC: u32 = 8196;
pub const IF_PROTO_FR_DEL_PVC: u32 = 8197;
pub const IF_PROTO_X25: u32 = 8198;
pub const IF_PROTO_HDLC_ETH: u32 = 8199;
pub const IF_PROTO_FR_ADD_ETH_PVC: u32 = 8200;
pub const IF_PROTO_FR_DEL_ETH_PVC: u32 = 8201;
pub const IF_PROTO_FR_PVC: u32 = 8202;
pub const IF_PROTO_FR_ETH_PVC: u32 = 8203;
pub const IF_PROTO_RAW: u32 = 8204;
pub const IFHWADDRLEN: u32 = 6;
pub const LINUX_VFS_DEBUG_H: u32 = 1;
pub const MINORBITS: u32 = 20;
pub const MINORMASK: u32 = 1048575;
pub const LIST_BL_LOCKMASK: u32 = 1;
pub const DNAME_INLINE_WORDS: u32 = 5;
pub const SHRINKER_UNIT_BITS: u32 = 64;
pub const SHRINK_STOP: i32 = -1;
pub const SHRINK_EMPTY: i32 = -2;
pub const DEFAULT_SEEKS: u32 = 2;
pub const RESERVED_PIDS: u32 = 300;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub const _KERNEL_CAPABILITY_VERSION: u32 = 537396514;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 16384;
pub const O_LARGEFILE: u32 = 32768;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4259840;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_GETLK64: u32 = 12;
pub const F_SETLK64: u32 = 13;
pub const F_SETLKW64: u32 = 14;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const RESOLVE_NO_XDEV: u32 = 1;
pub const RESOLVE_NO_MAGICLINKS: u32 = 2;
pub const RESOLVE_NO_SYMLINKS: u32 = 4;
pub const RESOLVE_BENEATH: u32 = 8;
pub const RESOLVE_IN_ROOT: u32 = 16;
pub const RESOLVE_CACHED: u32 = 32;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_DUPFD_QUERY: u32 = 1027;
pub const F_CREATED_QUERY: u32 = 1028;
pub const F_CANCELLK: u32 = 1029;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const F_SEAL_EXEC: u32 = 32;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const AT_FDCWD: i32 = -100;
pub const PIDFD_SELF_THREAD: i32 = -10000;
pub const PIDFD_SELF_THREAD_GROUP: i32 = -10001;
pub const FD_PIDFS_ROOT: i32 = -10002;
pub const FD_INVALID: i32 = -10009;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_RENAME_NOREPLACE: u32 = 1;
pub const AT_RENAME_EXCHANGE: u32 = 2;
pub const AT_RENAME_WHITEOUT: u32 = 4;
pub const AT_EACCESS: u32 = 512;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_HANDLE_FID: u32 = 512;
pub const AT_HANDLE_MNT_ID_UNIQUE: u32 = 1;
pub const AT_HANDLE_CONNECTABLE: u32 = 2;
pub const AT_EXECVE_CHECK: u32 = 65536;
pub const VALID_OPEN_FLAGS: u32 = 8388547;
pub const VALID_RESOLVE_FLAGS: u32 = 63;
pub const OPEN_HOW_SIZE_VER0: u32 = 24;
pub const OPEN_HOW_SIZE_LATEST: u32 = 24;
pub const SIGEMT_MASK: u32 = 0;
pub const JOBCTL_STOP_SIGMASK: u32 = 65535;
pub const JOBCTL_STOP_DEQUEUED_BIT: u32 = 16;
pub const JOBCTL_STOP_PENDING_BIT: u32 = 17;
pub const JOBCTL_STOP_CONSUME_BIT: u32 = 18;
pub const JOBCTL_TRAP_STOP_BIT: u32 = 19;
pub const JOBCTL_TRAP_NOTIFY_BIT: u32 = 20;
pub const JOBCTL_TRAPPING_BIT: u32 = 21;
pub const JOBCTL_LISTENING_BIT: u32 = 22;
pub const JOBCTL_TRAP_FREEZE_BIT: u32 = 23;
pub const JOBCTL_PTRACE_FROZEN_BIT: u32 = 24;
pub const JOBCTL_STOPPED_BIT: u32 = 26;
pub const JOBCTL_TRACED_BIT: u32 = 27;
pub const JOBCTL_STOP_DEQUEUED: u32 = 65536;
pub const JOBCTL_STOP_PENDING: u32 = 131072;
pub const JOBCTL_STOP_CONSUME: u32 = 262144;
pub const JOBCTL_TRAP_STOP: u32 = 524288;
pub const JOBCTL_TRAP_NOTIFY: u32 = 1048576;
pub const JOBCTL_TRAPPING: u32 = 2097152;
pub const JOBCTL_LISTENING: u32 = 4194304;
pub const JOBCTL_TRAP_FREEZE: u32 = 8388608;
pub const JOBCTL_PTRACE_FROZEN: u32 = 16777216;
pub const JOBCTL_STOPPED: u32 = 67108864;
pub const JOBCTL_TRACED: u32 = 134217728;
pub const JOBCTL_TRAP_MASK: u32 = 1572864;
pub const JOBCTL_PENDING_MASK: u32 = 1703936;
pub const EX_TYPE_NONE: u32 = 0;
pub const EX_TYPE_FIXUP: u32 = 1;
pub const EX_TYPE_BPF: u32 = 2;
pub const EX_TYPE_UACCESS_ERR_ZERO: u32 = 3;
pub const EX_TYPE_LOAD_UNALIGNED_ZEROPAD: u32 = 4;
pub const EX_DATA_REG_ERR_SHIFT: u32 = 0;
pub const EX_DATA_REG_ZERO_SHIFT: u32 = 5;
pub const EX_DATA_REG_DATA_SHIFT: u32 = 0;
pub const EX_DATA_REG_ADDR_SHIFT: u32 = 5;
pub const _PAGE_ACCESSED_OFFSET: u32 = 6;
pub const _PAGE_PRESENT: u32 = 1;
pub const _PAGE_READ: u32 = 2;
pub const _PAGE_WRITE: u32 = 4;
pub const _PAGE_EXEC: u32 = 8;
pub const _PAGE_USER: u32 = 16;
pub const _PAGE_GLOBAL: u32 = 32;
pub const _PAGE_ACCESSED: u32 = 64;
pub const _PAGE_DIRTY: u32 = 128;
pub const _PAGE_SOFT: u32 = 768;
pub const _PAGE_SPECIAL: u32 = 256;
pub const _PAGE_TABLE: u32 = 1;
pub const _PAGE_PROT_NONE: u32 = 32;
pub const _PAGE_SWP_EXCLUSIVE: u32 = 64;
pub const _PAGE_PFN_SHIFT: u32 = 10;
pub const _PAGE_LEAF: u32 = 14;
pub const BPF_JIT_REGION_SIZE: u32 = 134217728;
pub const VA_BITS_SV32: u32 = 32;
pub const VA_BITS_SV39: u32 = 39;
pub const VA_BITS_SV48: u32 = 48;
pub const VA_BITS_SV57: u32 = 57;
pub const PCI_IO_SIZE: u32 = 16777216;
pub const RISCV_ALTERNATIVES_BOOT: u32 = 0;
pub const RISCV_ALTERNATIVES_MODULE: u32 = 1;
pub const RISCV_ALTERNATIVES_EARLY_BOOT: u32 = 2;
pub const ANDES_VENDOR_ID: u32 = 798;
pub const MICROCHIP_VENDOR_ID: u32 = 41;
pub const SIFIVE_VENDOR_ID: u32 = 1161;
pub const THEAD_VENDOR_ID: u32 = 1463;
pub const ERRATA_ANDES_NO_IOCP: u32 = 0;
pub const ERRATA_ANDES_NUMBER: u32 = 1;
pub const ERRATA_SIFIVE_CIP_453: u32 = 0;
pub const ERRATA_SIFIVE_CIP_1200: u32 = 1;
pub const ERRATA_SIFIVE_NUMBER: u32 = 2;
pub const ERRATA_THEAD_MAE: u32 = 0;
pub const ERRATA_THEAD_PMU: u32 = 1;
pub const ERRATA_THEAD_GHOSTWRITE: u32 = 2;
pub const ERRATA_THEAD_NUMBER: u32 = 3;
pub const ALT_SVPBMT_SHIFT: u32 = 61;
pub const ALT_THEAD_MAE_SHIFT: u32 = 59;
pub const THEAD_C9XX_RV_IRQ_PMU: u32 = 17;
pub const THEAD_C9XX_CSR_SCOUNTEROF: u32 = 1477;
pub const COMPAT_UTS_MACHINE: &[u8; 8] = b"riscv\0\0\0";
pub const COMPAT_USER_HZ: u32 = 100;
pub const COMPAT_RLIM_INFINITY: u32 = 4294967295;
pub const COMPAT_OFF_T_MAX: u32 = 2147483647;
pub const _COMPAT_NSIG: u32 = 64;
pub const _COMPAT_NSIG_BPW: u32 = 32;
pub const PGDIR_SHIFT_L3: u32 = 30;
pub const PGDIR_SHIFT_L4: u32 = 39;
pub const PGDIR_SHIFT_L5: u32 = 48;
pub const P4D_SHIFT_L3: u32 = 30;
pub const P4D_SHIFT_L4: u32 = 39;
pub const P4D_SHIFT_L5: u32 = 39;
pub const PUD_SHIFT: u32 = 30;
pub const PMD_SHIFT: u32 = 21;
pub const _PAGE_NAPOT_SHIFT: u32 = 63;
pub const NAPOT_CONT_ORDER_BASE: u32 = 4;
pub const _PAGE_NOCACHE_SVPBMT: u64 = 2305843009213693952;
pub const _PAGE_IO_SVPBMT: u64 = 4611686018427387904;
pub const _PAGE_MTMASK_SVPBMT: u64 = 6917529027641081856;
pub const _PAGE_PMA_THEAD: u64 = 8070450532247928832;
pub const _PAGE_NOCACHE_THEAD: u64 = 3458764513820540928;
pub const _PAGE_IO_THEAD: i64 = -8070450532247928832;
pub const _PAGE_MTMASK_THEAD: i64 = -576460752303423488;
pub const MMAP_MIN_VA_BITS_64: u32 = 39;
pub const _PAGE_BASE: u32 = 81;
pub const _PAGE_KERNEL: u32 = 231;
pub const PFN_PTE_SHIFT: u32 = 10;
pub const __SWP_TYPE_SHIFT: u32 = 7;
pub const __SWP_TYPE_BITS: u32 = 5;
pub const __SWP_TYPE_MASK: u32 = 31;
pub const __SWP_OFFSET_SHIFT: u32 = 12;
pub const __LSW: u32 = 0;
pub const __MSW: u32 = 1;
pub const CLONE_LEGACY_FLAGS: u32 = 4294967295;
pub const ASSOC_ARRAY_KEY_CHUNK_SIZE: u32 = 64;
pub const KEY_POS_VIEW: u32 = 16777216;
pub const KEY_POS_READ: u32 = 33554432;
pub const KEY_POS_WRITE: u32 = 67108864;
pub const KEY_POS_SEARCH: u32 = 134217728;
pub const KEY_POS_LINK: u32 = 268435456;
pub const KEY_POS_SETATTR: u32 = 536870912;
pub const KEY_POS_ALL: u32 = 1056964608;
pub const KEY_USR_VIEW: u32 = 65536;
pub const KEY_USR_READ: u32 = 131072;
pub const KEY_USR_WRITE: u32 = 262144;
pub const KEY_USR_SEARCH: u32 = 524288;
pub const KEY_USR_LINK: u32 = 1048576;
pub const KEY_USR_SETATTR: u32 = 2097152;
pub const KEY_USR_ALL: u32 = 4128768;
pub const KEY_GRP_VIEW: u32 = 256;
pub const KEY_GRP_READ: u32 = 512;
pub const KEY_GRP_WRITE: u32 = 1024;
pub const KEY_GRP_SEARCH: u32 = 2048;
pub const KEY_GRP_LINK: u32 = 4096;
pub const KEY_GRP_SETATTR: u32 = 8192;
pub const KEY_GRP_ALL: u32 = 16128;
pub const KEY_OTH_VIEW: u32 = 1;
pub const KEY_OTH_READ: u32 = 2;
pub const KEY_OTH_WRITE: u32 = 4;
pub const KEY_OTH_SEARCH: u32 = 8;
pub const KEY_OTH_LINK: u32 = 16;
pub const KEY_OTH_SETATTR: u32 = 32;
pub const KEY_OTH_ALL: u32 = 63;
pub const KEY_PERM_UNDEF: u32 = 4294967295;
pub const KEY_FLAG_DEAD: u32 = 0;
pub const KEY_FLAG_REVOKED: u32 = 1;
pub const KEY_FLAG_IN_QUOTA: u32 = 2;
pub const KEY_FLAG_USER_CONSTRUCT: u32 = 3;
pub const KEY_FLAG_ROOT_CAN_CLEAR: u32 = 4;
pub const KEY_FLAG_INVALIDATED: u32 = 5;
pub const KEY_FLAG_BUILTIN: u32 = 6;
pub const KEY_FLAG_ROOT_CAN_INVAL: u32 = 7;
pub const KEY_FLAG_KEEP: u32 = 8;
pub const KEY_FLAG_UID_KEYRING: u32 = 9;
pub const KEY_FLAG_USER_ALIVE: u32 = 10;
pub const KEY_ALLOC_IN_QUOTA: u32 = 0;
pub const KEY_ALLOC_QUOTA_OVERRUN: u32 = 1;
pub const KEY_ALLOC_NOT_IN_QUOTA: u32 = 2;
pub const KEY_ALLOC_BUILT_IN: u32 = 4;
pub const KEY_ALLOC_BYPASS_RESTRICTION: u32 = 8;
pub const KEY_ALLOC_UID_KEYRING: u32 = 16;
pub const KEY_ALLOC_SET_KEEP: u32 = 32;
pub const HIGH_RES_NSEC: u32 = 1;
pub const KTIME_HIGH_RES: u32 = 1;
pub const MONOTONIC_RES_NSEC: u32 = 1;
pub const KTIME_MONOTONIC_RES: u32 = 1;
pub const HRTIMER_STATE_INACTIVE: u32 = 0;
pub const HRTIMER_STATE_ENQUEUED: u32 = 1;
pub const ALARMTIMER_STATE_INACTIVE: u32 = 0;
pub const ALARMTIMER_STATE_ENQUEUED: u32 = 1;
pub const RCUREF_ONEREF: u32 = 0;
pub const RCUREF_MAXREF: u32 = 2147483647;
pub const RCUREF_SATURATED: u32 = 2684354560;
pub const RCUREF_RELEASED: u32 = 3221225472;
pub const RCUREF_DEAD: u32 = 3758096384;
pub const RCUREF_NOREF: u32 = 4294967295;
pub const SIGNAL_STOP_STOPPED: u32 = 1;
pub const SIGNAL_STOP_CONTINUED: u32 = 2;
pub const SIGNAL_GROUP_EXIT: u32 = 4;
pub const SIGNAL_CLD_STOPPED: u32 = 16;
pub const SIGNAL_CLD_CONTINUED: u32 = 32;
pub const SIGNAL_CLD_MASK: u32 = 48;
pub const SIGNAL_UNKILLABLE: u32 = 64;
pub const SIGNAL_STOP_MASK: u32 = 51;
pub const UUID_SIZE: u32 = 16;
pub const UUID_STRING_LEN: u32 = 36;
pub const RR_TIMESLICE: u32 = 25;
pub const IOPRIO_CLASS_SHIFT: u32 = 13;
pub const IOPRIO_NR_CLASSES: u32 = 8;
pub const IOPRIO_CLASS_MASK: u32 = 7;
pub const IOPRIO_PRIO_MASK: u32 = 8191;
pub const IOPRIO_LEVEL_NR_BITS: u32 = 3;
pub const IOPRIO_NR_LEVELS: u32 = 8;
pub const IOPRIO_LEVEL_MASK: u32 = 7;
pub const IOPRIO_BE_NR: u32 = 8;
pub const IOPRIO_NORM: u32 = 4;
pub const IOPRIO_BE_NORM: u32 = 4;
pub const IOPRIO_HINT_SHIFT: u32 = 3;
pub const IOPRIO_HINT_NR_BITS: u32 = 10;
pub const IOPRIO_NR_HINTS: u32 = 1024;
pub const IOPRIO_HINT_MASK: u32 = 1023;
pub const S_DT_SHIFT: u32 = 12;
pub const S_DT_MASK: u32 = 15;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DT_MAX: u32 = 16;
pub const FT_UNKNOWN: u32 = 0;
pub const FT_REG_FILE: u32 = 1;
pub const FT_DIR: u32 = 2;
pub const FT_CHRDEV: u32 = 3;
pub const FT_BLKDEV: u32 = 4;
pub const FT_FIFO: u32 = 5;
pub const FT_SOCK: u32 = 6;
pub const FT_SYMLINK: u32 = 7;
pub const FT_MAX: u32 = 8;
pub const FILE_REF_ONEREF: u32 = 0;
pub const FILE_REF_MAXREF: u64 = 9223372036854775807;
pub const FILE_REF_SATURATED: i64 = -6917529027641081856;
pub const FILE_REF_RELEASED: i64 = -4611686018427387904;
pub const FILE_REF_DEAD: i64 = -2305843009213693952;
pub const FILE_REF_NOREF: i32 = -1;
pub const UNICODE_MAJ_SHIFT: u32 = 16;
pub const UNICODE_MIN_SHIFT: u32 = 8;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const IO_INTEGRITY_CHK_GUARD: u32 = 1;
pub const IO_INTEGRITY_CHK_REFTAG: u32 = 2;
pub const IO_INTEGRITY_CHK_APPTAG: u32 = 4;
pub const IO_INTEGRITY_VALID_FLAGS: u32 = 7;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const SEEK_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const LBMD_PI_CAP_INTEGRITY: u32 = 1;
pub const LBMD_PI_CAP_REFTAG: u32 = 2;
pub const LBMD_PI_CSUM_NONE: u32 = 0;
pub const LBMD_PI_CSUM_IP: u32 = 1;
pub const LBMD_PI_CSUM_CRC16_T10DIF: u32 = 2;
pub const LBMD_PI_CSUM_CRC64_NVME: u32 = 4;
pub const LBMD_SIZE_VER0: u32 = 16;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FILE_ATTR_SIZE_VER0: u32 = 24;
pub const FILE_ATTR_SIZE_LATEST: u32 = 24;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const PROCFS_IOCTL_MAGIC: u8 = 102u8;
pub const PAGE_IS_WPALLOWED: u32 = 1;
pub const PAGE_IS_WRITTEN: u32 = 2;
pub const PAGE_IS_FILE: u32 = 4;
pub const PAGE_IS_PRESENT: u32 = 8;
pub const PAGE_IS_SWAPPED: u32 = 16;
pub const PAGE_IS_PFNZERO: u32 = 32;
pub const PAGE_IS_HUGE: u32 = 64;
pub const PAGE_IS_SOFT_DIRTY: u32 = 128;
pub const PAGE_IS_GUARD: u32 = 256;
pub const PM_SCAN_WP_MATCHING: u32 = 1;
pub const PM_SCAN_CHECK_WPASYNC: u32 = 2;
pub const MAY_EXEC: u32 = 1;
pub const MAY_WRITE: u32 = 2;
pub const MAY_READ: u32 = 4;
pub const MAY_APPEND: u32 = 8;
pub const MAY_ACCESS: u32 = 16;
pub const MAY_OPEN: u32 = 32;
pub const MAY_CHDIR: u32 = 64;
pub const MAY_NOT_BLOCK: u32 = 128;
pub const ATTR_MODE: u32 = 1;
pub const ATTR_UID: u32 = 2;
pub const ATTR_GID: u32 = 4;
pub const ATTR_SIZE: u32 = 8;
pub const ATTR_ATIME: u32 = 16;
pub const ATTR_MTIME: u32 = 32;
pub const ATTR_CTIME: u32 = 64;
pub const ATTR_ATIME_SET: u32 = 128;
pub const ATTR_MTIME_SET: u32 = 256;
pub const ATTR_FORCE: u32 = 512;
pub const ATTR_KILL_SUID: u32 = 2048;
pub const ATTR_KILL_SGID: u32 = 4096;
pub const ATTR_FILE: u32 = 8192;
pub const ATTR_KILL_PRIV: u32 = 16384;
pub const ATTR_OPEN: u32 = 32768;
pub const ATTR_TIMES_SET: u32 = 65536;
pub const ATTR_TOUCH: u32 = 131072;
pub const ATTR_DELEG: u32 = 262144;
pub const WHITEOUT_MODE: u32 = 0;
pub const WHITEOUT_DEV: u32 = 0;
pub const XQM_USRQUOTA: u32 = 0;
pub const XQM_GRPQUOTA: u32 = 1;
pub const XQM_PRJQUOTA: u32 = 2;
pub const XQM_MAXQUOTAS: u32 = 3;
pub const FS_DQUOT_VERSION: u32 = 1;
pub const FS_DQ_ISOFT: u32 = 1;
pub const FS_DQ_IHARD: u32 = 2;
pub const FS_DQ_BSOFT: u32 = 4;
pub const FS_DQ_BHARD: u32 = 8;
pub const FS_DQ_RTBSOFT: u32 = 16;
pub const FS_DQ_RTBHARD: u32 = 32;
pub const FS_DQ_LIMIT_MASK: u32 = 63;
pub const FS_DQ_BTIMER: u32 = 64;
pub const FS_DQ_ITIMER: u32 = 128;
pub const FS_DQ_RTBTIMER: u32 = 256;
pub const FS_DQ_TIMER_MASK: u32 = 448;
pub const FS_DQ_BWARNS: u32 = 512;
pub const FS_DQ_IWARNS: u32 = 1024;
pub const FS_DQ_RTBWARNS: u32 = 2048;
pub const FS_DQ_WARNS_MASK: u32 = 3584;
pub const FS_DQ_BCOUNT: u32 = 4096;
pub const FS_DQ_ICOUNT: u32 = 8192;
pub const FS_DQ_RTBCOUNT: u32 = 16384;
pub const FS_DQ_ACCT_MASK: u32 = 28672;
pub const FS_DQ_BIGTIME: u32 = 32768;
pub const FS_QUOTA_UDQ_ACCT: u32 = 1;
pub const FS_QUOTA_UDQ_ENFD: u32 = 2;
pub const FS_QUOTA_GDQ_ACCT: u32 = 4;
pub const FS_QUOTA_GDQ_ENFD: u32 = 8;
pub const FS_QUOTA_PDQ_ACCT: u32 = 16;
pub const FS_QUOTA_PDQ_ENFD: u32 = 32;
pub const FS_USER_QUOTA: u32 = 1;
pub const FS_PROJ_QUOTA: u32 = 2;
pub const FS_GROUP_QUOTA: u32 = 4;
pub const FS_QSTAT_VERSION: u32 = 1;
pub const FS_QSTATV_VERSION1: u32 = 1;
pub const V1_INIT_ALLOC: u32 = 1;
pub const V1_INIT_REWRITE: u32 = 1;
pub const V1_DEL_ALLOC: u32 = 0;
pub const V1_DEL_REWRITE: u32 = 2;
pub const QTREE_INIT_ALLOC: u32 = 4;
pub const QTREE_INIT_REWRITE: u32 = 2;
pub const QTREE_DEL_ALLOC: u32 = 0;
pub const QTREE_DEL_REWRITE: u32 = 6;
pub const V2_INIT_ALLOC: u32 = 4;
pub const V2_INIT_REWRITE: u32 = 2;
pub const V2_DEL_ALLOC: u32 = 0;
pub const V2_DEL_REWRITE: u32 = 6;
pub const OVERFLOW_PROJID: u32 = 65534;
pub const __DQUOT_VERSION__: &[u8; 12] = b"dquot_6.6.0\0";
pub const MAXQUOTAS: u32 = 3;
pub const USRQUOTA: u32 = 0;
pub const GRPQUOTA: u32 = 1;
pub const PRJQUOTA: u32 = 2;
pub const SUBCMDMASK: u32 = 255;
pub const SUBCMDSHIFT: u32 = 8;
pub const Q_SYNC: u32 = 8388609;
pub const Q_QUOTAON: u32 = 8388610;
pub const Q_QUOTAOFF: u32 = 8388611;
pub const Q_GETFMT: u32 = 8388612;
pub const Q_GETINFO: u32 = 8388613;
pub const Q_SETINFO: u32 = 8388614;
pub const Q_GETQUOTA: u32 = 8388615;
pub const Q_SETQUOTA: u32 = 8388616;
pub const Q_GETNEXTQUOTA: u32 = 8388617;
pub const QFMT_VFS_OLD: u32 = 1;
pub const QFMT_VFS_V0: u32 = 2;
pub const QFMT_OCFS2: u32 = 3;
pub const QFMT_VFS_V1: u32 = 4;
pub const QFMT_SHMEM: u32 = 5;
pub const QIF_DQBLKSIZE_BITS: u32 = 10;
pub const QIF_DQBLKSIZE: u32 = 1024;
pub const IIF_BGRACE: u32 = 1;
pub const IIF_IGRACE: u32 = 2;
pub const IIF_FLAGS: u32 = 4;
pub const IIF_ALL: u32 = 7;
pub const QUOTA_NL_NOWARN: u32 = 0;
pub const QUOTA_NL_IHARDWARN: u32 = 1;
pub const QUOTA_NL_ISOFTLONGWARN: u32 = 2;
pub const QUOTA_NL_ISOFTWARN: u32 = 3;
pub const QUOTA_NL_BHARDWARN: u32 = 4;
pub const QUOTA_NL_BSOFTLONGWARN: u32 = 5;
pub const QUOTA_NL_BSOFTWARN: u32 = 6;
pub const QUOTA_NL_IHARDBELOW: u32 = 7;
pub const QUOTA_NL_ISOFTBELOW: u32 = 8;
pub const QUOTA_NL_BHARDBELOW: u32 = 9;
pub const QUOTA_NL_BSOFTBELOW: u32 = 10;
pub const QTYPE_MASK_USR: u32 = 1;
pub const QTYPE_MASK_GRP: u32 = 2;
pub const QTYPE_MASK_PRJ: u32 = 4;
pub const DQ_MOD_B: u32 = 0;
pub const DQ_BLKS_B: u32 = 1;
pub const DQ_INODES_B: u32 = 2;
pub const DQ_FAKE_B: u32 = 3;
pub const DQ_READ_B: u32 = 4;
pub const DQ_ACTIVE_B: u32 = 5;
pub const DQ_RELEASING_B: u32 = 6;
pub const DQ_LASTSET_B: u32 = 7;
pub const QC_INO_SOFT: u32 = 1;
pub const QC_INO_HARD: u32 = 2;
pub const QC_SPC_SOFT: u32 = 4;
pub const QC_SPC_HARD: u32 = 8;
pub const QC_RT_SPC_SOFT: u32 = 16;
pub const QC_RT_SPC_HARD: u32 = 32;
pub const QC_LIMIT_MASK: u32 = 63;
pub const QC_SPC_TIMER: u32 = 64;
pub const QC_INO_TIMER: u32 = 128;
pub const QC_RT_SPC_TIMER: u32 = 256;
pub const QC_TIMER_MASK: u32 = 448;
pub const QC_SPC_WARNS: u32 = 512;
pub const QC_INO_WARNS: u32 = 1024;
pub const QC_RT_SPC_WARNS: u32 = 2048;
pub const QC_WARNS_MASK: u32 = 3584;
pub const QC_SPACE: u32 = 4096;
pub const QC_INO_COUNT: u32 = 8192;
pub const QC_RT_SPACE: u32 = 16384;
pub const QC_ACCT_MASK: u32 = 28672;
pub const QC_FLAGS: u32 = 32768;
pub const QCI_SYSFILE: u32 = 1;
pub const QCI_ROOT_SQUASH: u32 = 2;
pub const QCI_ACCT_ENABLED: u32 = 4;
pub const QCI_LIMITS_ENFORCED: u32 = 8;
pub const FILESYSTEM_MAX_STACK_DEPTH: u32 = 2;
pub const IOCB_EVENTFD: u32 = 65536;
pub const IOCB_DIRECT: u32 = 131072;
pub const IOCB_WRITE: u32 = 262144;
pub const IOCB_WAITQ: u32 = 524288;
pub const IOCB_NOIO: u32 = 1048576;
pub const IOCB_ALLOC_CACHE: u32 = 2097152;
pub const IOCB_DIO_CALLER_COMP: u32 = 4194304;
pub const IOCB_AIO_RW: u32 = 8388608;
pub const IOCB_HAS_METADATA: u32 = 16777216;
pub const IOP_FASTPERM: u32 = 1;
pub const IOP_LOOKUP: u32 = 2;
pub const IOP_NOFOLLOW: u32 = 4;
pub const IOP_XATTR: u32 = 8;
pub const IOP_DEFAULT_READLINK: u32 = 16;
pub const IOP_MGTIME: u32 = 32;
pub const IOP_CACHED_LINK: u32 = 64;
pub const MAX_NON_LFS: u32 = 2147483647;
pub const FASYNC_MAGIC: u32 = 17921;
pub const SB_ENC_STRICT_MODE_FL: u32 = 1;
pub const SB_ENC_NO_COMPAT_FALLBACK_FL: u32 = 2;
pub const MNT_FORCE: u32 = 1;
pub const MNT_DETACH: u32 = 2;
pub const MNT_EXPIRE: u32 = 4;
pub const UMOUNT_NOFOLLOW: u32 = 8;
pub const UMOUNT_UNUSED: u32 = 2147483648;
pub const SB_I_CGROUPWB: u32 = 1;
pub const SB_I_NOEXEC: u32 = 2;
pub const SB_I_NODEV: u32 = 4;
pub const SB_I_STABLE_WRITES: u32 = 8;
pub const SB_I_USERNS_VISIBLE: u32 = 16;
pub const SB_I_IMA_UNVERIFIABLE_SIGNATURE: u32 = 32;
pub const SB_I_UNTRUSTED_MOUNTER: u32 = 64;
pub const SB_I_EVM_HMAC_UNSUPPORTED: u32 = 128;
pub const SB_I_SKIP_SYNC: u32 = 256;
pub const SB_I_PERSB_BDI: u32 = 512;
pub const SB_I_TS_EXPIRY_WARNED: u32 = 1024;
pub const SB_I_RETIRED: u32 = 2048;
pub const SB_I_NOUMASK: u32 = 4096;
pub const SB_I_NOIDMAP: u32 = 8192;
pub const SB_I_ALLOW_HSM: u32 = 16384;
pub const FILLDIR_FLAG_NOINTR: u32 = 4096;
pub const NOMMU_MAP_COPY: u32 = 1;
pub const NOMMU_MAP_DIRECT: u32 = 8;
pub const REMAP_FILE_DEDUP: u32 = 1;
pub const REMAP_FILE_CAN_SHORTEN: u32 = 2;
pub const REMAP_FILE_ADVISORY: u32 = 2;
pub const COPY_FILE_SPLICE: u32 = 1;
pub const S_SYNC: u32 = 1;
pub const S_NOATIME: u32 = 2;
pub const S_APPEND: u32 = 4;
pub const S_IMMUTABLE: u32 = 8;
pub const S_DEAD: u32 = 16;
pub const S_NOQUOTA: u32 = 32;
pub const S_DIRSYNC: u32 = 64;
pub const S_NOCMTIME: u32 = 128;
pub const S_SWAPFILE: u32 = 256;
pub const S_PRIVATE: u32 = 512;
pub const S_IMA: u32 = 1024;
pub const S_AUTOMOUNT: u32 = 2048;
pub const S_NOSEC: u32 = 4096;
pub const S_DAX: u32 = 0;
pub const S_ENCRYPTED: u32 = 16384;
pub const S_CASEFOLD: u32 = 32768;
pub const S_VERITY: u32 = 65536;
pub const S_KERNEL_FILE: u32 = 131072;
pub const S_ANON_INODE: u32 = 524288;
pub const __I_NEW: u32 = 0;
pub const I_NEW: u32 = 1;
pub const __I_SYNC: u32 = 1;
pub const I_SYNC: u32 = 2;
pub const __I_LRU_ISOLATING: u32 = 2;
pub const I_LRU_ISOLATING: u32 = 4;
pub const I_DIRTY_SYNC: u32 = 8;
pub const I_DIRTY_DATASYNC: u32 = 16;
pub const I_DIRTY_PAGES: u32 = 32;
pub const I_WILL_FREE: u32 = 64;
pub const I_FREEING: u32 = 128;
pub const I_CLEAR: u32 = 256;
pub const I_REFERENCED: u32 = 512;
pub const I_LINKABLE: u32 = 1024;
pub const I_DIRTY_TIME: u32 = 2048;
pub const I_WB_SWITCH: u32 = 4096;
pub const I_OVL_INUSE: u32 = 8192;
pub const I_CREATING: u32 = 16384;
pub const I_DONTCACHE: u32 = 32768;
pub const I_SYNC_QUEUED: u32 = 65536;
pub const I_PINNING_NETFS_WB: u32 = 131072;
pub const I_DIRTY_INODE: u32 = 24;
pub const I_DIRTY: u32 = 56;
pub const I_DIRTY_ALL: u32 = 2104;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_DISALLOW_NOTIFY_PERM: u32 = 16;
pub const FS_ALLOW_IDMAP: u32 = 32;
pub const FS_MGTIME: u32 = 64;
pub const FS_LBS: u32 = 128;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const CHRDEV_MAJOR_MAX: u32 = 512;
pub const CHRDEV_MAJOR_DYN_END: u32 = 234;
pub const CHRDEV_MAJOR_DYN_EXT_START: u32 = 511;
pub const CHRDEV_MAJOR_DYN_EXT_END: u32 = 384;
pub const IOCB_FLAG_RESFD: u32 = 1;
pub const IOCB_FLAG_IOPRIO: u32 = 2;
pub const __NR_io_setup: u32 = 0;
pub const __NR_io_destroy: u32 = 1;
pub const __NR_io_submit: u32 = 2;
pub const __NR_io_cancel: u32 = 3;
pub const __NR_io_getevents: u32 = 4;
pub const __NR_setxattr: u32 = 5;
pub const __NR_lsetxattr: u32 = 6;
pub const __NR_fsetxattr: u32 = 7;
pub const __NR_getxattr: u32 = 8;
pub const __NR_lgetxattr: u32 = 9;
pub const __NR_fgetxattr: u32 = 10;
pub const __NR_listxattr: u32 = 11;
pub const __NR_llistxattr: u32 = 12;
pub const __NR_flistxattr: u32 = 13;
pub const __NR_removexattr: u32 = 14;
pub const __NR_lremovexattr: u32 = 15;
pub const __NR_fremovexattr: u32 = 16;
pub const __NR_getcwd: u32 = 17;
pub const __NR_lookup_dcookie: u32 = 18;
pub const __NR_eventfd2: u32 = 19;
pub const __NR_epoll_create1: u32 = 20;
pub const __NR_epoll_ctl: u32 = 21;
pub const __NR_epoll_pwait: u32 = 22;
pub const __NR_dup: u32 = 23;
pub const __NR_dup3: u32 = 24;
pub const __NR_fcntl: u32 = 25;
pub const __NR_inotify_init1: u32 = 26;
pub const __NR_inotify_add_watch: u32 = 27;
pub const __NR_inotify_rm_watch: u32 = 28;
pub const __NR_ioctl: u32 = 29;
pub const __NR_ioprio_set: u32 = 30;
pub const __NR_ioprio_get: u32 = 31;
pub const __NR_flock: u32 = 32;
pub const __NR_mknodat: u32 = 33;
pub const __NR_mkdirat: u32 = 34;
pub const __NR_unlinkat: u32 = 35;
pub const __NR_symlinkat: u32 = 36;
pub const __NR_linkat: u32 = 37;
pub const __NR_umount2: u32 = 39;
pub const __NR_mount: u32 = 40;
pub const __NR_pivot_root: u32 = 41;
pub const __NR_nfsservctl: u32 = 42;
pub const __NR_statfs: u32 = 43;
pub const __NR_fstatfs: u32 = 44;
pub const __NR_truncate: u32 = 45;
pub const __NR_ftruncate: u32 = 46;
pub const __NR_fallocate: u32 = 47;
pub const __NR_faccessat: u32 = 48;
pub const __NR_chdir: u32 = 49;
pub const __NR_fchdir: u32 = 50;
pub const __NR_chroot: u32 = 51;
pub const __NR_fchmod: u32 = 52;
pub const __NR_fchmodat: u32 = 53;
pub const __NR_fchownat: u32 = 54;
pub const __NR_fchown: u32 = 55;
pub const __NR_openat: u32 = 56;
pub const __NR_close: u32 = 57;
pub const __NR_vhangup: u32 = 58;
pub const __NR_pipe2: u32 = 59;
pub const __NR_quotactl: u32 = 60;
pub const __NR_getdents64: u32 = 61;
pub const __NR_lseek: u32 = 62;
pub const __NR_read: u32 = 63;
pub const __NR_write: u32 = 64;
pub const __NR_readv: u32 = 65;
pub const __NR_writev: u32 = 66;
pub const __NR_pread64: u32 = 67;
pub const __NR_pwrite64: u32 = 68;
pub const __NR_preadv: u32 = 69;
pub const __NR_pwritev: u32 = 70;
pub const __NR_sendfile: u32 = 71;
pub const __NR_pselect6: u32 = 72;
pub const __NR_ppoll: u32 = 73;
pub const __NR_signalfd4: u32 = 74;
pub const __NR_vmsplice: u32 = 75;
pub const __NR_splice: u32 = 76;
pub const __NR_tee: u32 = 77;
pub const __NR_readlinkat: u32 = 78;
pub const __NR_newfstatat: u32 = 79;
pub const __NR_fstat: u32 = 80;
pub const __NR_sync: u32 = 81;
pub const __NR_fsync: u32 = 82;
pub const __NR_fdatasync: u32 = 83;
pub const __NR_sync_file_range: u32 = 84;
pub const __NR_timerfd_create: u32 = 85;
pub const __NR_timerfd_settime: u32 = 86;
pub const __NR_timerfd_gettime: u32 = 87;
pub const __NR_utimensat: u32 = 88;
pub const __NR_acct: u32 = 89;
pub const __NR_capget: u32 = 90;
pub const __NR_capset: u32 = 91;
pub const __NR_personality: u32 = 92;
pub const __NR_exit: u32 = 93;
pub const __NR_exit_group: u32 = 94;
pub const __NR_waitid: u32 = 95;
pub const __NR_set_tid_address: u32 = 96;
pub const __NR_unshare: u32 = 97;
pub const __NR_futex: u32 = 98;
pub const __NR_set_robust_list: u32 = 99;
pub const __NR_get_robust_list: u32 = 100;
pub const __NR_nanosleep: u32 = 101;
pub const __NR_getitimer: u32 = 102;
pub const __NR_setitimer: u32 = 103;
pub const __NR_kexec_load: u32 = 104;
pub const __NR_init_module: u32 = 105;
pub const __NR_delete_module: u32 = 106;
pub const __NR_timer_create: u32 = 107;
pub const __NR_timer_gettime: u32 = 108;
pub const __NR_timer_getoverrun: u32 = 109;
pub const __NR_timer_settime: u32 = 110;
pub const __NR_timer_delete: u32 = 111;
pub const __NR_clock_settime: u32 = 112;
pub const __NR_clock_gettime: u32 = 113;
pub const __NR_clock_getres: u32 = 114;
pub const __NR_clock_nanosleep: u32 = 115;
pub const __NR_syslog: u32 = 116;
pub const __NR_ptrace: u32 = 117;
pub const __NR_sched_setparam: u32 = 118;
pub const __NR_sched_setscheduler: u32 = 119;
pub const __NR_sched_getscheduler: u32 = 120;
pub const __NR_sched_getparam: u32 = 121;
pub const __NR_sched_setaffinity: u32 = 122;
pub const __NR_sched_getaffinity: u32 = 123;
pub const __NR_sched_yield: u32 = 124;
pub const __NR_sched_get_priority_max: u32 = 125;
pub const __NR_sched_get_priority_min: u32 = 126;
pub const __NR_sched_rr_get_interval: u32 = 127;
pub const __NR_restart_syscall: u32 = 128;
pub const __NR_kill: u32 = 129;
pub const __NR_tkill: u32 = 130;
pub const __NR_tgkill: u32 = 131;
pub const __NR_sigaltstack: u32 = 132;
pub const __NR_rt_sigsuspend: u32 = 133;
pub const __NR_rt_sigaction: u32 = 134;
pub const __NR_rt_sigprocmask: u32 = 135;
pub const __NR_rt_sigpending: u32 = 136;
pub const __NR_rt_sigtimedwait: u32 = 137;
pub const __NR_rt_sigqueueinfo: u32 = 138;
pub const __NR_rt_sigreturn: u32 = 139;
pub const __NR_setpriority: u32 = 140;
pub const __NR_getpriority: u32 = 141;
pub const __NR_reboot: u32 = 142;
pub const __NR_setregid: u32 = 143;
pub const __NR_setgid: u32 = 144;
pub const __NR_setreuid: u32 = 145;
pub const __NR_setuid: u32 = 146;
pub const __NR_setresuid: u32 = 147;
pub const __NR_getresuid: u32 = 148;
pub const __NR_setresgid: u32 = 149;
pub const __NR_getresgid: u32 = 150;
pub const __NR_setfsuid: u32 = 151;
pub const __NR_setfsgid: u32 = 152;
pub const __NR_times: u32 = 153;
pub const __NR_setpgid: u32 = 154;
pub const __NR_getpgid: u32 = 155;
pub const __NR_getsid: u32 = 156;
pub const __NR_setsid: u32 = 157;
pub const __NR_getgroups: u32 = 158;
pub const __NR_setgroups: u32 = 159;
pub const __NR_uname: u32 = 160;
pub const __NR_sethostname: u32 = 161;
pub const __NR_setdomainname: u32 = 162;
pub const __NR_getrlimit: u32 = 163;
pub const __NR_setrlimit: u32 = 164;
pub const __NR_getrusage: u32 = 165;
pub const __NR_umask: u32 = 166;
pub const __NR_prctl: u32 = 167;
pub const __NR_getcpu: u32 = 168;
pub const __NR_gettimeofday: u32 = 169;
pub const __NR_settimeofday: u32 = 170;
pub const __NR_adjtimex: u32 = 171;
pub const __NR_getpid: u32 = 172;
pub const __NR_getppid: u32 = 173;
pub const __NR_getuid: u32 = 174;
pub const __NR_geteuid: u32 = 175;
pub const __NR_getgid: u32 = 176;
pub const __NR_getegid: u32 = 177;
pub const __NR_gettid: u32 = 178;
pub const __NR_sysinfo: u32 = 179;
pub const __NR_mq_open: u32 = 180;
pub const __NR_mq_unlink: u32 = 181;
pub const __NR_mq_timedsend: u32 = 182;
pub const __NR_mq_timedreceive: u32 = 183;
pub const __NR_mq_notify: u32 = 184;
pub const __NR_mq_getsetattr: u32 = 185;
pub const __NR_msgget: u32 = 186;
pub const __NR_msgctl: u32 = 187;
pub const __NR_msgrcv: u32 = 188;
pub const __NR_msgsnd: u32 = 189;
pub const __NR_semget: u32 = 190;
pub const __NR_semctl: u32 = 191;
pub const __NR_semtimedop: u32 = 192;
pub const __NR_semop: u32 = 193;
pub const __NR_shmget: u32 = 194;
pub const __NR_shmctl: u32 = 195;
pub const __NR_shmat: u32 = 196;
pub const __NR_shmdt: u32 = 197;
pub const __NR_socket: u32 = 198;
pub const __NR_socketpair: u32 = 199;
pub const __NR_bind: u32 = 200;
pub const __NR_listen: u32 = 201;
pub const __NR_accept: u32 = 202;
pub const __NR_connect: u32 = 203;
pub const __NR_getsockname: u32 = 204;
pub const __NR_getpeername: u32 = 205;
pub const __NR_sendto: u32 = 206;
pub const __NR_recvfrom: u32 = 207;
pub const __NR_setsockopt: u32 = 208;
pub const __NR_getsockopt: u32 = 209;
pub const __NR_shutdown: u32 = 210;
pub const __NR_sendmsg: u32 = 211;
pub const __NR_recvmsg: u32 = 212;
pub const __NR_readahead: u32 = 213;
pub const __NR_brk: u32 = 214;
pub const __NR_munmap: u32 = 215;
pub const __NR_mremap: u32 = 216;
pub const __NR_add_key: u32 = 217;
pub const __NR_request_key: u32 = 218;
pub const __NR_keyctl: u32 = 219;
pub const __NR_clone: u32 = 220;
pub const __NR_execve: u32 = 221;
pub const __NR_mmap: u32 = 222;
pub const __NR_fadvise64: u32 = 223;
pub const __NR_swapon: u32 = 224;
pub const __NR_swapoff: u32 = 225;
pub const __NR_mprotect: u32 = 226;
pub const __NR_msync: u32 = 227;
pub const __NR_mlock: u32 = 228;
pub const __NR_munlock: u32 = 229;
pub const __NR_mlockall: u32 = 230;
pub const __NR_munlockall: u32 = 231;
pub const __NR_mincore: u32 = 232;
pub const __NR_madvise: u32 = 233;
pub const __NR_remap_file_pages: u32 = 234;
pub const __NR_mbind: u32 = 235;
pub const __NR_get_mempolicy: u32 = 236;
pub const __NR_set_mempolicy: u32 = 237;
pub const __NR_migrate_pages: u32 = 238;
pub const __NR_move_pages: u32 = 239;
pub const __NR_rt_tgsigqueueinfo: u32 = 240;
pub const __NR_perf_event_open: u32 = 241;
pub const __NR_accept4: u32 = 242;
pub const __NR_recvmmsg: u32 = 243;
pub const __NR_riscv_hwprobe: u32 = 258;
pub const __NR_riscv_flush_icache: u32 = 259;
pub const __NR_wait4: u32 = 260;
pub const __NR_prlimit64: u32 = 261;
pub const __NR_fanotify_init: u32 = 262;
pub const __NR_fanotify_mark: u32 = 263;
pub const __NR_name_to_handle_at: u32 = 264;
pub const __NR_open_by_handle_at: u32 = 265;
pub const __NR_clock_adjtime: u32 = 266;
pub const __NR_syncfs: u32 = 267;
pub const __NR_setns: u32 = 268;
pub const __NR_sendmmsg: u32 = 269;
pub const __NR_process_vm_readv: u32 = 270;
pub const __NR_process_vm_writev: u32 = 271;
pub const __NR_kcmp: u32 = 272;
pub const __NR_finit_module: u32 = 273;
pub const __NR_sched_setattr: u32 = 274;
pub const __NR_sched_getattr: u32 = 275;
pub const __NR_renameat2: u32 = 276;
pub const __NR_seccomp: u32 = 277;
pub const __NR_getrandom: u32 = 278;
pub const __NR_memfd_create: u32 = 279;
pub const __NR_bpf: u32 = 280;
pub const __NR_execveat: u32 = 281;
pub const __NR_userfaultfd: u32 = 282;
pub const __NR_membarrier: u32 = 283;
pub const __NR_mlock2: u32 = 284;
pub const __NR_copy_file_range: u32 = 285;
pub const __NR_preadv2: u32 = 286;
pub const __NR_pwritev2: u32 = 287;
pub const __NR_pkey_mprotect: u32 = 288;
pub const __NR_pkey_alloc: u32 = 289;
pub const __NR_pkey_free: u32 = 290;
pub const __NR_statx: u32 = 291;
pub const __NR_io_pgetevents: u32 = 292;
pub const __NR_rseq: u32 = 293;
pub const __NR_kexec_file_load: u32 = 294;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_cachestat: u32 = 451;
pub const __NR_fchmodat2: u32 = 452;
pub const __NR_map_shadow_stack: u32 = 453;
pub const __NR_futex_wake: u32 = 454;
pub const __NR_futex_wait: u32 = 455;
pub const __NR_futex_requeue: u32 = 456;
pub const __NR_statmount: u32 = 457;
pub const __NR_listmount: u32 = 458;
pub const __NR_lsm_get_self_attr: u32 = 459;
pub const __NR_lsm_set_self_attr: u32 = 460;
pub const __NR_lsm_list_modules: u32 = 461;
pub const __NR_mseal: u32 = 462;
pub const __NR_setxattrat: u32 = 463;
pub const __NR_getxattrat: u32 = 464;
pub const __NR_listxattrat: u32 = 465;
pub const __NR_removexattrat: u32 = 466;
pub const __NR_open_tree_attr: u32 = 467;
pub const __NR_file_getattr: u32 = 468;
pub const __NR_file_setattr: u32 = 469;
pub const __NR_syscalls: u32 = 470;
pub const NR_syscalls: u32 = 470;
pub const COMPAT_USE_64BIT_TIME: u32 = 0;
pub const COMPAT_MINSIGSTKSZ: u32 = 2048;
pub const _COMPAT_NSIG_WORDS: u32 = 2;
pub const R_RISCV_NONE: u32 = 0;
pub const R_RISCV_32: u32 = 1;
pub const R_RISCV_64: u32 = 2;
pub const R_RISCV_RELATIVE: u32 = 3;
pub const R_RISCV_COPY: u32 = 4;
pub const R_RISCV_JUMP_SLOT: u32 = 5;
pub const R_RISCV_TLS_DTPMOD32: u32 = 6;
pub const R_RISCV_TLS_DTPMOD64: u32 = 7;
pub const R_RISCV_TLS_DTPREL32: u32 = 8;
pub const R_RISCV_TLS_DTPREL64: u32 = 9;
pub const R_RISCV_TLS_TPREL32: u32 = 10;
pub const R_RISCV_TLS_TPREL64: u32 = 11;
pub const R_RISCV_IRELATIVE: u32 = 58;
pub const R_RISCV_BRANCH: u32 = 16;
pub const R_RISCV_JAL: u32 = 17;
pub const R_RISCV_CALL: u32 = 18;
pub const R_RISCV_CALL_PLT: u32 = 19;
pub const R_RISCV_GOT_HI20: u32 = 20;
pub const R_RISCV_TLS_GOT_HI20: u32 = 21;
pub const R_RISCV_TLS_GD_HI20: u32 = 22;
pub const R_RISCV_PCREL_HI20: u32 = 23;
pub const R_RISCV_PCREL_LO12_I: u32 = 24;
pub const R_RISCV_PCREL_LO12_S: u32 = 25;
pub const R_RISCV_HI20: u32 = 26;
pub const R_RISCV_LO12_I: u32 = 27;
pub const R_RISCV_LO12_S: u32 = 28;
pub const R_RISCV_TPREL_HI20: u32 = 29;
pub const R_RISCV_TPREL_LO12_I: u32 = 30;
pub const R_RISCV_TPREL_LO12_S: u32 = 31;
pub const R_RISCV_TPREL_ADD: u32 = 32;
pub const R_RISCV_ADD8: u32 = 33;
pub const R_RISCV_ADD16: u32 = 34;
pub const R_RISCV_ADD32: u32 = 35;
pub const R_RISCV_ADD64: u32 = 36;
pub const R_RISCV_SUB8: u32 = 37;
pub const R_RISCV_SUB16: u32 = 38;
pub const R_RISCV_SUB32: u32 = 39;
pub const R_RISCV_SUB64: u32 = 40;
pub const R_RISCV_GNU_VTINHERIT: u32 = 41;
pub const R_RISCV_GNU_VTENTRY: u32 = 42;
pub const R_RISCV_ALIGN: u32 = 43;
pub const R_RISCV_RVC_BRANCH: u32 = 44;
pub const R_RISCV_RVC_JUMP: u32 = 45;
pub const R_RISCV_GPREL_I: u32 = 47;
pub const R_RISCV_GPREL_S: u32 = 48;
pub const R_RISCV_TPREL_I: u32 = 49;
pub const R_RISCV_TPREL_S: u32 = 50;
pub const R_RISCV_RELAX: u32 = 51;
pub const R_RISCV_SUB6: u32 = 52;
pub const R_RISCV_SET6: u32 = 53;
pub const R_RISCV_SET8: u32 = 54;
pub const R_RISCV_SET16: u32 = 55;
pub const R_RISCV_SET32: u32 = 56;
pub const R_RISCV_32_PCREL: u32 = 57;
pub const R_RISCV_PLT32: u32 = 59;
pub const R_RISCV_SET_ULEB128: u32 = 60;
pub const R_RISCV_SUB_ULEB128: u32 = 61;
pub const ELF_ARCH: u32 = 243;
pub const ELF_CLASS: u32 = 2;
pub const ELF_DATA: u32 = 1;
pub const ELF_FDPIC_CORE_EFLAGS: u32 = 0;
pub const ELF32_GNU_PROPERTY_ALIGN: u32 = 4;
pub const ELF64_GNU_PROPERTY_ALIGN: u32 = 8;
pub const ELF_GNU_PROPERTY_ALIGN: u32 = 8;
pub const CLS_BITS: u32 = 6;
pub const _DPRINTK_CLASS_DFLT: u32 = 63;
pub const _DPRINTK_FLAGS_NONE: u32 = 0;
pub const _DPRINTK_FLAGS_PRINT: u32 = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: u32 = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: u32 = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: u32 = 8;
pub const _DPRINTK_FLAGS_INCL_TID: u32 = 16;
pub const _DPRINTK_FLAGS_INCL_SOURCENAME: u32 = 32;
pub const _DPRINTK_FLAGS_INCL_ANY: u32 = 62;
pub const _DPRINTK_FLAGS_DEFAULT: u32 = 0;
pub const PCI_ANY_ID: i32 = -1;
pub const IEEE1394_MATCH_VENDOR_ID: u32 = 1;
pub const IEEE1394_MATCH_MODEL_ID: u32 = 2;
pub const IEEE1394_MATCH_SPECIFIER_ID: u32 = 4;
pub const IEEE1394_MATCH_VERSION: u32 = 8;
pub const USB_DEVICE_ID_MATCH_VENDOR: u32 = 1;
pub const USB_DEVICE_ID_MATCH_PRODUCT: u32 = 2;
pub const USB_DEVICE_ID_MATCH_DEV_LO: u32 = 4;
pub const USB_DEVICE_ID_MATCH_DEV_HI: u32 = 8;
pub const USB_DEVICE_ID_MATCH_DEV_CLASS: u32 = 16;
pub const USB_DEVICE_ID_MATCH_DEV_SUBCLASS: u32 = 32;
pub const USB_DEVICE_ID_MATCH_DEV_PROTOCOL: u32 = 64;
pub const USB_DEVICE_ID_MATCH_INT_CLASS: u32 = 128;
pub const USB_DEVICE_ID_MATCH_INT_SUBCLASS: u32 = 256;
pub const USB_DEVICE_ID_MATCH_INT_PROTOCOL: u32 = 512;
pub const USB_DEVICE_ID_MATCH_INT_NUMBER: u32 = 1024;
pub const HID_ANY_ID: i32 = -1;
pub const HID_BUS_ANY: u32 = 65535;
pub const HID_GROUP_ANY: u32 = 0;
pub const CCW_DEVICE_ID_MATCH_CU_TYPE: u32 = 1;
pub const CCW_DEVICE_ID_MATCH_CU_MODEL: u32 = 2;
pub const CCW_DEVICE_ID_MATCH_DEVICE_TYPE: u32 = 4;
pub const CCW_DEVICE_ID_MATCH_DEVICE_MODEL: u32 = 8;
pub const AP_DEVICE_ID_MATCH_CARD_TYPE: u32 = 1;
pub const AP_DEVICE_ID_MATCH_QUEUE_TYPE: u32 = 2;
pub const ACPI_ID_LEN: u32 = 16;
pub const PNP_ID_LEN: u32 = 8;
pub const PNP_MAX_DEVICES: u32 = 8;
pub const SERIO_ANY: u32 = 255;
pub const PCMCIA_DEV_ID_MATCH_MANF_ID: u32 = 1;
pub const PCMCIA_DEV_ID_MATCH_CARD_ID: u32 = 2;
pub const PCMCIA_DEV_ID_MATCH_FUNC_ID: u32 = 4;
pub const PCMCIA_DEV_ID_MATCH_FUNCTION: u32 = 8;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID1: u32 = 16;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID2: u32 = 32;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID3: u32 = 64;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID4: u32 = 128;
pub const PCMCIA_DEV_ID_MATCH_DEVICE_NO: u32 = 256;
pub const PCMCIA_DEV_ID_MATCH_FAKE_CIS: u32 = 512;
pub const PCMCIA_DEV_ID_MATCH_ANONYMOUS: u32 = 1024;
pub const INPUT_DEVICE_ID_EV_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_KEY_MIN_INTERESTING: u32 = 113;
pub const INPUT_DEVICE_ID_KEY_MAX: u32 = 767;
pub const INPUT_DEVICE_ID_REL_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_ABS_MAX: u32 = 63;
pub const INPUT_DEVICE_ID_MSC_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_LED_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_SND_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_FF_MAX: u32 = 127;
pub const INPUT_DEVICE_ID_SW_MAX: u32 = 17;
pub const INPUT_DEVICE_ID_PROP_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_MATCH_BUS: u32 = 1;
pub const INPUT_DEVICE_ID_MATCH_VENDOR: u32 = 2;
pub const INPUT_DEVICE_ID_MATCH_PRODUCT: u32 = 4;
pub const INPUT_DEVICE_ID_MATCH_VERSION: u32 = 8;
pub const INPUT_DEVICE_ID_MATCH_EVBIT: u32 = 16;
pub const INPUT_DEVICE_ID_MATCH_KEYBIT: u32 = 32;
pub const INPUT_DEVICE_ID_MATCH_RELBIT: u32 = 64;
pub const INPUT_DEVICE_ID_MATCH_ABSBIT: u32 = 128;
pub const INPUT_DEVICE_ID_MATCH_MSCIT: u32 = 256;
pub const INPUT_DEVICE_ID_MATCH_LEDBIT: u32 = 512;
pub const INPUT_DEVICE_ID_MATCH_SNDBIT: u32 = 1024;
pub const INPUT_DEVICE_ID_MATCH_FFBIT: u32 = 2048;
pub const INPUT_DEVICE_ID_MATCH_SWBIT: u32 = 4096;
pub const INPUT_DEVICE_ID_MATCH_PROPBIT: u32 = 8192;
pub const EISA_SIG_LEN: u32 = 8;
pub const EISA_DEVICE_MODALIAS_FMT: &[u8; 9] = b"eisa:s%s\0";
pub const PA_HWTYPE_ANY_ID: u32 = 255;
pub const PA_HVERSION_REV_ANY_ID: u32 = 255;
pub const PA_HVERSION_ANY_ID: u32 = 65535;
pub const PA_SVERSION_ANY_ID: u32 = 4294967295;
pub const SDIO_ANY_ID: i32 = -1;
pub const SSB_ANY_VENDOR: u32 = 65535;
pub const SSB_ANY_ID: u32 = 65535;
pub const SSB_ANY_REV: u32 = 255;
pub const BCMA_ANY_MANUF: u32 = 65535;
pub const BCMA_ANY_ID: u32 = 65535;
pub const BCMA_ANY_REV: u32 = 255;
pub const BCMA_ANY_CLASS: u32 = 255;
pub const VIRTIO_DEV_ANY_ID: u32 = 4294967295;
pub const RPMSG_NAME_SIZE: u32 = 32;
pub const RPMSG_DEVICE_MODALIAS_FMT: &[u8; 9] = b"rpmsg:%s\0";
pub const I2C_NAME_SIZE: u32 = 20;
pub const I2C_MODULE_PREFIX: &[u8; 5] = b"i2c:\0";
pub const PCI_EPF_NAME_SIZE: u32 = 20;
pub const PCI_EPF_MODULE_PREFIX: &[u8; 9] = b"pci_epf:\0";
pub const I3C_MATCH_DCR: u32 = 1;
pub const I3C_MATCH_MANUF: u32 = 2;
pub const I3C_MATCH_PART: u32 = 4;
pub const I3C_MATCH_EXTRA_INFO: u32 = 8;
pub const SPI_NAME_SIZE: u32 = 32;
pub const SPI_MODULE_PREFIX: &[u8; 5] = b"spi:\0";
pub const SLIMBUS_NAME_SIZE: u32 = 32;
pub const SLIMBUS_MODULE_PREFIX: &[u8; 6] = b"slim:\0";
pub const APR_NAME_SIZE: u32 = 32;
pub const APR_MODULE_PREFIX: &[u8; 5] = b"apr:\0";
pub const SPMI_NAME_SIZE: u32 = 32;
pub const SPMI_MODULE_PREFIX: &[u8; 6] = b"spmi:\0";
pub const PLATFORM_NAME_SIZE: u32 = 24;
pub const PLATFORM_MODULE_PREFIX: &[u8; 10] = b"platform:\0";
pub const MDIO_NAME_SIZE: u32 = 32;
pub const MDIO_MODULE_PREFIX: &[u8; 6] = b"mdio:\0";
pub const MDIO_ID_FMT: &[u8; 65] =
    b"%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u\0";
pub const ZORRO_WILDCARD: u32 = 4294967295;
pub const ZORRO_DEVICE_MODALIAS_FMT: &[u8; 12] = b"zorro:i%08X\0";
pub const ISAPNP_ANY_ID: u32 = 65535;
pub const X86_VENDOR_ANY: u32 = 65535;
pub const X86_FAMILY_ANY: u32 = 0;
pub const X86_MODEL_ANY: u32 = 0;
pub const X86_STEPPING_ANY: u32 = 0;
pub const X86_STEP_MIN: u32 = 0;
pub const X86_STEP_MAX: u32 = 15;
pub const X86_FEATURE_ANY: u32 = 0;
pub const X86_CPU_TYPE_ANY: u32 = 0;
pub const IPACK_ANY_FORMAT: u32 = 255;
pub const IPACK_ANY_ID: i32 = -1;
pub const MEI_CL_MODULE_PREFIX: &[u8; 5] = b"mei:\0";
pub const MEI_CL_NAME_SIZE: u32 = 32;
pub const MEI_CL_VERSION_ANY: u32 = 255;
pub const RIO_ANY_ID: u32 = 65535;
pub const TBSVC_MATCH_PROTOCOL_KEY: u32 = 1;
pub const TBSVC_MATCH_PROTOCOL_ID: u32 = 2;
pub const TBSVC_MATCH_PROTOCOL_VERSION: u32 = 4;
pub const TBSVC_MATCH_PROTOCOL_REVISION: u32 = 8;
pub const TYPEC_ANY_MODE: u32 = 7;
pub const WMI_MODULE_PREFIX: &[u8; 5] = b"wmi:\0";
pub const MHI_DEVICE_MODALIAS_FMT: &[u8; 7] = b"mhi:%s\0";
pub const MHI_NAME_SIZE: u32 = 32;
pub const MHI_EP_DEVICE_MODALIAS_FMT: &[u8; 10] = b"mhi_ep:%s\0";
pub const AUXILIARY_NAME_SIZE: u32 = 32;
pub const AUXILIARY_MODULE_PREFIX: &[u8; 11] = b"auxiliary:\0";
pub const SSAM_MATCH_TARGET: u32 = 1;
pub const SSAM_MATCH_INSTANCE: u32 = 2;
pub const SSAM_MATCH_FUNCTION: u32 = 4;
pub const ISHTP_MODULE_PREFIX: &[u8; 7] = b"ishtp:\0";
pub const CDX_ANY_ID: u32 = 65535;
pub const SWNODE_GRAPH_PORT_NAME_FMT: &[u8; 8] = b"port@%u\0";
pub const SWNODE_GRAPH_ENDPOINT_NAME_FMT: &[u8; 12] = b"endpoint@%u\0";
pub const NR_FWNODE_REFERENCE_ARGS: u32 = 16;
pub const NODE_ADDING_FIRST_MEMORY: u32 = 1;
pub const NODE_ADDED_FIRST_MEMORY: u32 = 2;
pub const NODE_CANCEL_ADDING_FIRST_MEMORY: u32 = 4;
pub const NODE_REMOVING_LAST_MEMORY: u32 = 8;
pub const NODE_REMOVED_LAST_MEMORY: u32 = 16;
pub const NODE_CANCEL_REMOVING_LAST_MEMORY: u32 = 32;
pub const ACPI_BINARY_SEMAPHORE: u32 = 0;
pub const ACPI_OSL_MUTEX: u32 = 1;
pub const DEBUGGER_SINGLE_THREADED: u32 = 0;
pub const DEBUGGER_MULTI_THREADED: u32 = 1;
pub const ACPI_SRC_OS_LF_ONLY: u32 = 0;
pub const COMPILER_VA_MACRO: u32 = 1;
pub const ACPI_REDUCED_HARDWARE: u32 = 1;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _D: u32 = 4;
pub const _C: u32 = 8;
pub const _P: u32 = 16;
pub const _S: u32 = 32;
pub const _X: u32 = 64;
pub const _SP: u32 = 128;
pub const ACPI_MACHINE_WIDTH: u32 = 64;
pub const ACPI_MSG_ERROR: &[u8; 15] = b"\x013ACPI Error: \0";
pub const ACPI_MSG_EXCEPTION: &[u8; 19] = b"\x013ACPI Exception: \0";
pub const ACPI_MSG_WARNING: &[u8; 17] = b"\x014ACPI Warning: \0";
pub const ACPI_MSG_INFO: &[u8; 9] = b"\x016ACPI: \0";
pub const ACPI_MSG_BIOS_ERROR: &[u8; 26] = b"\x013ACPI BIOS Error (bug): \0";
pub const ACPI_MSG_BIOS_WARNING: &[u8; 28] = b"\x014ACPI BIOS Warning (bug): \0";
pub const ACPI_MUTEX_TYPE: u32 = 0;
pub const DEBUGGER_THREADING: u32 = 1;
pub const METHOD_NAME__ADR: &[u8; 5] = b"_ADR\0";
pub const METHOD_NAME__AEI: &[u8; 5] = b"_AEI\0";
pub const METHOD_NAME__BBN: &[u8; 5] = b"_BBN\0";
pub const METHOD_NAME__CBA: &[u8; 5] = b"_CBA\0";
pub const METHOD_NAME__CID: &[u8; 5] = b"_CID\0";
pub const METHOD_NAME__CLS: &[u8; 5] = b"_CLS\0";
pub const METHOD_NAME__CRS: &[u8; 5] = b"_CRS\0";
pub const METHOD_NAME__DDN: &[u8; 5] = b"_DDN\0";
pub const METHOD_NAME__DIS: &[u8; 5] = b"_DIS\0";
pub const METHOD_NAME__DMA: &[u8; 5] = b"_DMA\0";
pub const METHOD_NAME__EVT: &[u8; 5] = b"_EVT\0";
pub const METHOD_NAME__HID: &[u8; 5] = b"_HID\0";
pub const METHOD_NAME__INI: &[u8; 5] = b"_INI\0";
pub const METHOD_NAME__PLD: &[u8; 5] = b"_PLD\0";
pub const METHOD_NAME__DSD: &[u8; 5] = b"_DSD\0";
pub const METHOD_NAME__PRS: &[u8; 5] = b"_PRS\0";
pub const METHOD_NAME__PRT: &[u8; 5] = b"_PRT\0";
pub const METHOD_NAME__PRW: &[u8; 5] = b"_PRW\0";
pub const METHOD_NAME__PS0: &[u8; 5] = b"_PS0\0";
pub const METHOD_NAME__PS1: &[u8; 5] = b"_PS1\0";
pub const METHOD_NAME__PS2: &[u8; 5] = b"_PS2\0";
pub const METHOD_NAME__PS3: &[u8; 5] = b"_PS3\0";
pub const METHOD_NAME__REG: &[u8; 5] = b"_REG\0";
pub const METHOD_NAME__SB_: &[u8; 5] = b"_SB_\0";
pub const METHOD_NAME__SEG: &[u8; 5] = b"_SEG\0";
pub const METHOD_NAME__SRS: &[u8; 5] = b"_SRS\0";
pub const METHOD_NAME__STA: &[u8; 5] = b"_STA\0";
pub const METHOD_NAME__SUB: &[u8; 5] = b"_SUB\0";
pub const METHOD_NAME__UID: &[u8; 5] = b"_UID\0";
pub const METHOD_PATHNAME__PTS: &[u8; 6] = b"\\_PTS\0";
pub const METHOD_PATHNAME__SST: &[u8; 10] = b"\\_SI._SST\0";
pub const METHOD_PATHNAME__WAK: &[u8; 6] = b"\\_WAK\0";
pub const ACPI_ROOT_PATHNAME: &[u8; 5] = b"\\___\0";
pub const ACPI_NAMESPACE_ROOT: &[u8; 15] = b"Namespace Root\0";
pub const ACPI_NS_ROOT_PATH: &[u8; 2] = b"\\\0";
pub const ACPI_ASCII_MAX: u32 = 127;
pub const ACPI_MAX_GPE_BLOCKS: u32 = 2;
pub const ACPI_GPE_REGISTER_WIDTH: u32 = 8;
pub const ACPI_PM1_REGISTER_WIDTH: u32 = 16;
pub const ACPI_PM2_REGISTER_WIDTH: u32 = 8;
pub const ACPI_PM_TIMER_WIDTH: u32 = 32;
pub const ACPI_RESET_REGISTER_WIDTH: u32 = 8;
pub const ACPI_NAMESEG_SIZE: u32 = 4;
pub const ACPI_PATH_SEGMENT_LENGTH: u32 = 5;
pub const ACPI_PATH_SEPARATOR: u8 = 46u8;
pub const ACPI_OEM_ID_SIZE: u32 = 6;
pub const ACPI_OEM_TABLE_ID_SIZE: u32 = 8;
pub const PCI_ROOT_HID_STRING: &[u8; 8] = b"PNP0A03\0";
pub const PCI_EXPRESS_ROOT_HID_STRING: &[u8; 8] = b"PNP0A08\0";
pub const ACPI_PM_TIMER_FREQUENCY: u32 = 3579545;
pub const ACPI_MSEC_PER_SEC: u32 = 1000;
pub const ACPI_USEC_PER_MSEC: u32 = 1000;
pub const ACPI_USEC_PER_SEC: u32 = 1000000;
pub const ACPI_100NSEC_PER_USEC: u32 = 10;
pub const ACPI_100NSEC_PER_MSEC: u32 = 10000;
pub const ACPI_100NSEC_PER_SEC: u32 = 10000000;
pub const ACPI_NSEC_PER_USEC: u32 = 1000;
pub const ACPI_NSEC_PER_MSEC: u32 = 1000000;
pub const ACPI_NSEC_PER_SEC: u32 = 1000000000;
pub const ACPI_OWNER_ID_MAX: u32 = 4095;
pub const ACPI_INTEGER_BIT_SIZE: u32 = 64;
pub const ACPI_MAX_DECIMAL_DIGITS: u32 = 20;
pub const ACPI_MAX64_DECIMAL_DIGITS: u32 = 20;
pub const ACPI_MAX32_DECIMAL_DIGITS: u32 = 10;
pub const ACPI_MAX16_DECIMAL_DIGITS: u32 = 5;
pub const ACPI_MAX8_DECIMAL_DIGITS: u32 = 3;
pub const ACPI_WAIT_FOREVER: u32 = 65535;
pub const ACPI_DO_NOT_WAIT: u32 = 0;
pub const ACPI_ACCESS_BIT_SHIFT: u32 = 2;
pub const ACPI_ACCESS_BYTE_SHIFT: i32 = -1;
pub const ACPI_ACCESS_BIT_MAX: u32 = 29;
pub const ACPI_ACCESS_BYTE_MAX: u32 = 32;
pub const ACPI_ACCESS_BIT_DEFAULT: u32 = 6;
pub const ACPI_ACCESS_BYTE_DEFAULT: u32 = 9;
pub const ACPI_FULL_INITIALIZATION: u32 = 0;
pub const ACPI_NO_FACS_INIT: u32 = 1;
pub const ACPI_NO_ACPI_ENABLE: u32 = 2;
pub const ACPI_NO_HARDWARE_INIT: u32 = 4;
pub const ACPI_NO_EVENT_INIT: u32 = 8;
pub const ACPI_NO_HANDLER_INIT: u32 = 16;
pub const ACPI_NO_OBJECT_INIT: u32 = 32;
pub const ACPI_NO_DEVICE_INIT: u32 = 64;
pub const ACPI_NO_ADDRESS_SPACE_INIT: u32 = 128;
pub const ACPI_SUBSYSTEM_INITIALIZE: u32 = 1;
pub const ACPI_INITIALIZED_OK: u32 = 2;
pub const ACPI_S_STATE_COUNT: u32 = 6;
pub const ACPI_D_STATE_COUNT: u32 = 5;
pub const ACPI_C_STATE_COUNT: u32 = 4;
pub const ACPI_SLEEP_TYPE_MAX: u32 = 7;
pub const ACPI_SLEEP_TYPE_INVALID: u32 = 255;
pub const ACPI_GENERIC_NOTIFY_MAX: u32 = 15;
pub const ACPI_SPECIFIC_NOTIFY_MAX: u32 = 132;
pub const ACPI_TYPE_ANY: u32 = 0;
pub const ACPI_TYPE_INTEGER: u32 = 1;
pub const ACPI_TYPE_STRING: u32 = 2;
pub const ACPI_TYPE_BUFFER: u32 = 3;
pub const ACPI_TYPE_PACKAGE: u32 = 4;
pub const ACPI_TYPE_FIELD_UNIT: u32 = 5;
pub const ACPI_TYPE_DEVICE: u32 = 6;
pub const ACPI_TYPE_EVENT: u32 = 7;
pub const ACPI_TYPE_METHOD: u32 = 8;
pub const ACPI_TYPE_MUTEX: u32 = 9;
pub const ACPI_TYPE_REGION: u32 = 10;
pub const ACPI_TYPE_POWER: u32 = 11;
pub const ACPI_TYPE_PROCESSOR: u32 = 12;
pub const ACPI_TYPE_THERMAL: u32 = 13;
pub const ACPI_TYPE_BUFFER_FIELD: u32 = 14;
pub const ACPI_TYPE_DDB_HANDLE: u32 = 15;
pub const ACPI_TYPE_DEBUG_OBJECT: u32 = 16;
pub const ACPI_TYPE_EXTERNAL_MAX: u32 = 16;
pub const ACPI_NUM_TYPES: u32 = 17;
pub const ACPI_TYPE_LOCAL_REGION_FIELD: u32 = 17;
pub const ACPI_TYPE_LOCAL_BANK_FIELD: u32 = 18;
pub const ACPI_TYPE_LOCAL_INDEX_FIELD: u32 = 19;
pub const ACPI_TYPE_LOCAL_REFERENCE: u32 = 20;
pub const ACPI_TYPE_LOCAL_ALIAS: u32 = 21;
pub const ACPI_TYPE_LOCAL_METHOD_ALIAS: u32 = 22;
pub const ACPI_TYPE_LOCAL_NOTIFY: u32 = 23;
pub const ACPI_TYPE_LOCAL_ADDRESS_HANDLER: u32 = 24;
pub const ACPI_TYPE_LOCAL_RESOURCE: u32 = 25;
pub const ACPI_TYPE_LOCAL_RESOURCE_FIELD: u32 = 26;
pub const ACPI_TYPE_LOCAL_SCOPE: u32 = 27;
pub const ACPI_TYPE_NS_NODE_MAX: u32 = 27;
pub const ACPI_TOTAL_TYPES: u32 = 28;
pub const ACPI_TYPE_LOCAL_EXTRA: u32 = 28;
pub const ACPI_TYPE_LOCAL_DATA: u32 = 29;
pub const ACPI_TYPE_LOCAL_MAX: u32 = 29;
pub const ACPI_TYPE_INVALID: u32 = 30;
pub const ACPI_TYPE_NOT_FOUND: u32 = 255;
pub const ACPI_NUM_NS_TYPES: u32 = 31;
pub const ACPI_READ: u32 = 0;
pub const ACPI_WRITE: u32 = 1;
pub const ACPI_IO_MASK: u32 = 1;
pub const ACPI_EVENT_PMTIMER: u32 = 0;
pub const ACPI_EVENT_GLOBAL: u32 = 1;
pub const ACPI_EVENT_POWER_BUTTON: u32 = 2;
pub const ACPI_EVENT_SLEEP_BUTTON: u32 = 3;
pub const ACPI_EVENT_RTC: u32 = 4;
pub const ACPI_EVENT_MAX: u32 = 4;
pub const ACPI_NUM_FIXED_EVENTS: u32 = 5;
pub const ACPI_GPE_ENABLE: u32 = 0;
pub const ACPI_GPE_DISABLE: u32 = 1;
pub const ACPI_GPE_CONDITIONAL_ENABLE: u32 = 2;
pub const ACPI_NOT_ISR: u32 = 1;
pub const ACPI_ISR: u32 = 0;
pub const ACPI_SYSTEM_NOTIFY: u32 = 1;
pub const ACPI_DEVICE_NOTIFY: u32 = 2;
pub const ACPI_ALL_NOTIFY: u32 = 3;
pub const ACPI_MAX_NOTIFY_HANDLER_TYPE: u32 = 3;
pub const ACPI_NUM_NOTIFY_TYPES: u32 = 2;
pub const ACPI_MAX_SYS_NOTIFY: u32 = 127;
pub const ACPI_MAX_DEVICE_SPECIFIC_NOTIFY: u32 = 191;
pub const ACPI_SYSTEM_HANDLER_LIST: u32 = 0;
pub const ACPI_DEVICE_HANDLER_LIST: u32 = 1;
pub const ACPI_NUM_PREDEFINED_REGIONS: u32 = 12;
pub const ACPI_REG_DISCONNECT: u32 = 0;
pub const ACPI_REG_CONNECT: u32 = 1;
pub const ACPI_BITREG_TIMER_STATUS: u32 = 0;
pub const ACPI_BITREG_BUS_MASTER_STATUS: u32 = 1;
pub const ACPI_BITREG_GLOBAL_LOCK_STATUS: u32 = 2;
pub const ACPI_BITREG_POWER_BUTTON_STATUS: u32 = 3;
pub const ACPI_BITREG_SLEEP_BUTTON_STATUS: u32 = 4;
pub const ACPI_BITREG_RT_CLOCK_STATUS: u32 = 5;
pub const ACPI_BITREG_WAKE_STATUS: u32 = 6;
pub const ACPI_BITREG_PCIEXP_WAKE_STATUS: u32 = 7;
pub const ACPI_BITREG_TIMER_ENABLE: u32 = 8;
pub const ACPI_BITREG_GLOBAL_LOCK_ENABLE: u32 = 9;
pub const ACPI_BITREG_POWER_BUTTON_ENABLE: u32 = 10;
pub const ACPI_BITREG_SLEEP_BUTTON_ENABLE: u32 = 11;
pub const ACPI_BITREG_RT_CLOCK_ENABLE: u32 = 12;
pub const ACPI_BITREG_PCIEXP_WAKE_DISABLE: u32 = 13;
pub const ACPI_BITREG_SCI_ENABLE: u32 = 14;
pub const ACPI_BITREG_BUS_MASTER_RLD: u32 = 15;
pub const ACPI_BITREG_GLOBAL_LOCK_RELEASE: u32 = 16;
pub const ACPI_BITREG_SLEEP_TYPE: u32 = 17;
pub const ACPI_BITREG_SLEEP_ENABLE: u32 = 18;
pub const ACPI_BITREG_ARB_DISABLE: u32 = 19;
pub const ACPI_BITREG_MAX: u32 = 19;
pub const ACPI_NUM_BITREG: u32 = 20;
pub const ACPI_CLEAR_STATUS: u32 = 1;
pub const ACPI_ENABLE_EVENT: u32 = 1;
pub const ACPI_DISABLE_EVENT: u32 = 0;
pub const ACPI_NO_BUFFER: u32 = 0;
pub const ACPI_FULL_PATHNAME: u32 = 0;
pub const ACPI_SINGLE_NAME: u32 = 1;
pub const ACPI_FULL_PATHNAME_NO_TRAILING: u32 = 2;
pub const ACPI_NAME_TYPE_MAX: u32 = 2;
pub const ACPI_SYS_MODE_UNKNOWN: u32 = 0;
pub const ACPI_SYS_MODE_ACPI: u32 = 1;
pub const ACPI_SYS_MODE_LEGACY: u32 = 2;
pub const ACPI_SYS_MODES_MASK: u32 = 3;
pub const ACPI_EVENT_TYPE_GPE: u32 = 0;
pub const ACPI_EVENT_TYPE_FIXED: u32 = 1;
pub const ACPI_INIT_DEVICE_INI: u32 = 1;
pub const ACPI_TABLE_EVENT_LOAD: u32 = 0;
pub const ACPI_TABLE_EVENT_UNLOAD: u32 = 1;
pub const ACPI_TABLE_EVENT_INSTALL: u32 = 2;
pub const ACPI_TABLE_EVENT_UNINSTALL: u32 = 3;
pub const ACPI_NUM_TABLE_EVENTS: u32 = 4;
pub const ACPI_REGION_ACTIVATE: u32 = 0;
pub const ACPI_REGION_DEACTIVATE: u32 = 1;
pub const ACPI_INTERRUPT_NOT_HANDLED: u32 = 0;
pub const ACPI_INTERRUPT_HANDLED: u32 = 1;
pub const ACPI_REENABLE_GPE: u32 = 128;
pub const ACPI_EISAID_STRING_SIZE: u32 = 8;
pub const ACPI_UUID_LENGTH: u32 = 16;
pub const ACPI_PCICLS_STRING_SIZE: u32 = 7;
pub const ACPI_PCI_ROOT_BRIDGE: u32 = 1;
pub const ACPI_VALID_ADR: u32 = 2;
pub const ACPI_VALID_HID: u32 = 4;
pub const ACPI_VALID_UID: u32 = 8;
pub const ACPI_VALID_CID: u32 = 32;
pub const ACPI_VALID_CLS: u32 = 64;
pub const ACPI_VALID_SXDS: u32 = 256;
pub const ACPI_VALID_SXWS: u32 = 512;
pub const ACPI_STA_DEVICE_PRESENT: u32 = 1;
pub const ACPI_STA_DEVICE_ENABLED: u32 = 2;
pub const ACPI_STA_DEVICE_UI: u32 = 4;
pub const ACPI_STA_DEVICE_FUNCTIONING: u32 = 8;
pub const ACPI_STA_DEVICE_OK: u32 = 8;
pub const ACPI_STA_BATTERY_PRESENT: u32 = 16;
pub const ACPI_VENDOR_STRINGS: u32 = 1;
pub const ACPI_FEATURE_STRINGS: u32 = 2;
pub const ACPI_ENABLE_INTERFACES: u32 = 0;
pub const ACPI_DISABLE_INTERFACES: u32 = 4;
pub const ACPI_DISABLE_ALL_VENDOR_STRINGS: u32 = 5;
pub const ACPI_DISABLE_ALL_FEATURE_STRINGS: u32 = 6;
pub const ACPI_DISABLE_ALL_STRINGS: u32 = 7;
pub const ACPI_ENABLE_ALL_VENDOR_STRINGS: u32 = 1;
pub const ACPI_ENABLE_ALL_FEATURE_STRINGS: u32 = 2;
pub const ACPI_ENABLE_ALL_STRINGS: u32 = 3;
pub const ACPI_OSI_WIN_2000: u32 = 1;
pub const ACPI_OSI_WIN_XP: u32 = 2;
pub const ACPI_OSI_WIN_XP_SP1: u32 = 3;
pub const ACPI_OSI_WINSRV_2003: u32 = 4;
pub const ACPI_OSI_WIN_XP_SP2: u32 = 5;
pub const ACPI_OSI_WINSRV_2003_SP1: u32 = 6;
pub const ACPI_OSI_WIN_VISTA: u32 = 7;
pub const ACPI_OSI_WINSRV_2008: u32 = 8;
pub const ACPI_OSI_WIN_VISTA_SP1: u32 = 9;
pub const ACPI_OSI_WIN_VISTA_SP2: u32 = 10;
pub const ACPI_OSI_WIN_7: u32 = 11;
pub const ACPI_OSI_WIN_8: u32 = 12;
pub const ACPI_OSI_WIN_8_1: u32 = 13;
pub const ACPI_OSI_WIN_10: u32 = 14;
pub const ACPI_OSI_WIN_10_RS1: u32 = 15;
pub const ACPI_OSI_WIN_10_RS2: u32 = 16;
pub const ACPI_OSI_WIN_10_RS3: u32 = 17;
pub const ACPI_OSI_WIN_10_RS4: u32 = 18;
pub const ACPI_OSI_WIN_10_RS5: u32 = 19;
pub const ACPI_OSI_WIN_10_19H1: u32 = 20;
pub const ACPI_OSI_WIN_10_20H1: u32 = 21;
pub const ACPI_OSI_WIN_11: u32 = 22;
pub const ACPI_OSI_WIN_11_22H2: u32 = 23;
pub const ACPI_OPT_END: i32 = -1;
pub const AE_CODE_ENVIRONMENTAL: u32 = 0;
pub const AE_CODE_PROGRAMMER: u32 = 4096;
pub const AE_CODE_ACPI_TABLES: u32 = 8192;
pub const AE_CODE_AML: u32 = 12288;
pub const AE_CODE_CONTROL: u32 = 16384;
pub const AE_CODE_MAX: u32 = 16384;
pub const AE_CODE_MASK: u32 = 61440;
pub const AE_CODE_ENV_MAX: u32 = 35;
pub const AE_CODE_PGM_MAX: u32 = 9;
pub const AE_CODE_TBL_MAX: u32 = 5;
pub const AE_CODE_AML_MAX: u32 = 37;
pub const AE_CODE_CTRL_MAX: u32 = 12;
pub const ACPI_SIG_DSDT: &[u8; 5] = b"DSDT\0";
pub const ACPI_SIG_FADT: &[u8; 5] = b"FACP\0";
pub const ACPI_SIG_FACS: &[u8; 5] = b"FACS\0";
pub const ACPI_SIG_OSDT: &[u8; 5] = b"OSDT\0";
pub const ACPI_SIG_PSDT: &[u8; 5] = b"PSDT\0";
pub const ACPI_SIG_RSDP: &[u8; 9] = b"RSD PTR \0";
pub const ACPI_SIG_RSDT: &[u8; 5] = b"RSDT\0";
pub const ACPI_SIG_XSDT: &[u8; 5] = b"XSDT\0";
pub const ACPI_SIG_SSDT: &[u8; 5] = b"SSDT\0";
pub const ACPI_RSDP_NAME: &[u8; 5] = b"RSDP\0";
pub const ACPI_OEM_NAME: &[u8; 4] = b"OEM\0";
pub const ACPI_GLOCK_PENDING: u32 = 1;
pub const ACPI_GLOCK_OWNED: u32 = 2;
pub const ACPI_FACS_S4_BIOS_PRESENT: u32 = 1;
pub const ACPI_FACS_64BIT_WAKE: u32 = 2;
pub const ACPI_FACS_64BIT_ENVIRONMENT: u32 = 1;
pub const ACPI_FADT_LEGACY_DEVICES: u32 = 1;
pub const ACPI_FADT_8042: u32 = 2;
pub const ACPI_FADT_NO_VGA: u32 = 4;
pub const ACPI_FADT_NO_MSI: u32 = 8;
pub const ACPI_FADT_NO_ASPM: u32 = 16;
pub const ACPI_FADT_NO_CMOS_RTC: u32 = 32;
pub const FADT2_REVISION_ID: u32 = 3;
pub const ACPI_FADT_PSCI_COMPLIANT: u32 = 1;
pub const ACPI_FADT_PSCI_USE_HVC: u32 = 2;
pub const ACPI_FADT_WBINVD: u32 = 1;
pub const ACPI_FADT_WBINVD_FLUSH: u32 = 2;
pub const ACPI_FADT_C1_SUPPORTED: u32 = 4;
pub const ACPI_FADT_C2_MP_SUPPORTED: u32 = 8;
pub const ACPI_FADT_POWER_BUTTON: u32 = 16;
pub const ACPI_FADT_SLEEP_BUTTON: u32 = 32;
pub const ACPI_FADT_FIXED_RTC: u32 = 64;
pub const ACPI_FADT_S4_RTC_WAKE: u32 = 128;
pub const ACPI_FADT_32BIT_TIMER: u32 = 256;
pub const ACPI_FADT_DOCKING_SUPPORTED: u32 = 512;
pub const ACPI_FADT_RESET_REGISTER: u32 = 1024;
pub const ACPI_FADT_SEALED_CASE: u32 = 2048;
pub const ACPI_FADT_HEADLESS: u32 = 4096;
pub const ACPI_FADT_SLEEP_TYPE: u32 = 8192;
pub const ACPI_FADT_PCI_EXPRESS_WAKE: u32 = 16384;
pub const ACPI_FADT_PLATFORM_CLOCK: u32 = 32768;
pub const ACPI_FADT_S4_RTC_VALID: u32 = 65536;
pub const ACPI_FADT_REMOTE_POWER_ON: u32 = 131072;
pub const ACPI_FADT_APIC_CLUSTER: u32 = 262144;
pub const ACPI_FADT_APIC_PHYSICAL: u32 = 524288;
pub const ACPI_FADT_HW_REDUCED: u32 = 1048576;
pub const ACPI_FADT_LOW_POWER_S0: u32 = 2097152;
pub const ACPI_X_WAKE_STATUS: u32 = 128;
pub const ACPI_X_SLEEP_TYPE_MASK: u32 = 28;
pub const ACPI_X_SLEEP_TYPE_POSITION: u32 = 2;
pub const ACPI_X_SLEEP_ENABLE: u32 = 32;
pub const ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL: u32 = 0;
pub const ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL: u32 = 1;
pub const ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL: u32 = 2;
pub const ACPI_TABLE_ORIGIN_MASK: u32 = 3;
pub const ACPI_TABLE_IS_VERIFIED: u32 = 4;
pub const ACPI_TABLE_IS_LOADED: u32 = 8;
pub const ACPI_SIG_AEST: &[u8; 5] = b"AEST\0";
pub const ACPI_SIG_ASF: &[u8; 5] = b"ASF!\0";
pub const ACPI_SIG_ASPT: &[u8; 5] = b"ASPT\0";
pub const ACPI_SIG_BERT: &[u8; 5] = b"BERT\0";
pub const ACPI_SIG_BGRT: &[u8; 5] = b"BGRT\0";
pub const ACPI_SIG_BOOT: &[u8; 5] = b"BOOT\0";
pub const ACPI_SIG_CEDT: &[u8; 5] = b"CEDT\0";
pub const ACPI_SIG_CPEP: &[u8; 5] = b"CPEP\0";
pub const ACPI_SIG_CSRT: &[u8; 5] = b"CSRT\0";
pub const ACPI_SIG_DBG2: &[u8; 5] = b"DBG2\0";
pub const ACPI_SIG_DBGP: &[u8; 5] = b"DBGP\0";
pub const ACPI_SIG_DMAR: &[u8; 5] = b"DMAR\0";
pub const ACPI_SIG_DRTM: &[u8; 5] = b"DRTM\0";
pub const ACPI_SIG_ECDT: &[u8; 5] = b"ECDT\0";
pub const ACPI_SIG_EINJ: &[u8; 5] = b"EINJ\0";
pub const ACPI_SIG_ERST: &[u8; 5] = b"ERST\0";
pub const ACPI_SIG_FPDT: &[u8; 5] = b"FPDT\0";
pub const ACPI_SIG_GTDT: &[u8; 5] = b"GTDT\0";
pub const ACPI_SIG_HEST: &[u8; 5] = b"HEST\0";
pub const ACPI_SIG_HMAT: &[u8; 5] = b"HMAT\0";
pub const ACPI_SIG_HPET: &[u8; 5] = b"HPET\0";
pub const ACPI_SIG_IBFT: &[u8; 5] = b"IBFT\0";
pub const ACPI_SIG_MSCT: &[u8; 5] = b"MSCT\0";
pub const ACPI_SIG_S3PT: &[u8; 5] = b"S3PT\0";
pub const ACPI_SIG_PCCS: &[u8; 4] = b"PCC\0";
pub const ACPI_SIG_NBFT: &[u8; 5] = b"NBFT\0";
pub const ACPI_SIG_MATR: &[u8; 5] = b"MATR\0";
pub const ACPI_SIG_MSDM: &[u8; 5] = b"MSDM\0";
pub const ASPT_REVISION_ID: u32 = 1;
pub const ACPI_ASF_SMBUS_PROTOCOLS: u32 = 1;
pub const ACPI_BERT_UNCORRECTABLE: u32 = 1;
pub const ACPI_BERT_CORRECTABLE: u32 = 2;
pub const ACPI_BERT_MULTIPLE_UNCORRECTABLE: u32 = 4;
pub const ACPI_BERT_MULTIPLE_CORRECTABLE: u32 = 8;
pub const ACPI_BERT_ERROR_ENTRY_COUNT: u32 = 4080;
pub const ACPI_BGRT_DISPLAYED: u32 = 1;
pub const ACPI_BGRT_ORIENTATION_OFFSET: u32 = 6;
pub const ACPI_CDAT_DSMAS_NON_VOLATILE: u32 = 4;
pub const ACPI_CDAT_DSMAS_SHAREABLE: u32 = 8;
pub const ACPI_CDAT_DSMAS_READ_ONLY: u32 = 64;
pub const ACPI_CDAT_DSIS_MEM_ATTACHED: u32 = 1;
pub const ACPI_CDAT_SSLBIS_US_PORT: u32 = 256;
pub const ACPI_CDAT_SSLBIS_ANY_PORT: u32 = 65535;
pub const ACPI_CEDT_CHBS_VERSION_CXL11: u32 = 0;
pub const ACPI_CEDT_CHBS_VERSION_CXL20: u32 = 1;
pub const ACPI_CEDT_CHBS_LENGTH_CXL11: u32 = 8192;
pub const ACPI_CEDT_CHBS_LENGTH_CXL20: u32 = 65536;
pub const ACPI_CEDT_CFMWS_ARITHMETIC_MODULO: u32 = 0;
pub const ACPI_CEDT_CFMWS_ARITHMETIC_XOR: u32 = 1;
pub const ACPI_CEDT_CFMWS_RESTRICT_TYPE2: u32 = 1;
pub const ACPI_CEDT_CFMWS_RESTRICT_TYPE3: u32 = 2;
pub const ACPI_CEDT_CFMWS_RESTRICT_VOLATILE: u32 = 4;
pub const ACPI_CEDT_CFMWS_RESTRICT_PMEM: u32 = 8;
pub const ACPI_CEDT_CFMWS_RESTRICT_FIXED: u32 = 16;
pub const ACPI_CEDT_RDPAS_BUS_MASK: u32 = 65280;
pub const ACPI_CEDT_RDPAS_DEVICE_MASK: u32 = 248;
pub const ACPI_CEDT_RDPAS_FUNCTION_MASK: u32 = 7;
pub const ACPI_CEDT_RDPAS_PROTOCOL_IO: u32 = 0;
pub const ACPI_CEDT_RDPAS_PROTOCOL_CACHEMEM: u32 = 1;
pub const ACPI_CSRT_TYPE_INTERRUPT: u32 = 1;
pub const ACPI_CSRT_TYPE_TIMER: u32 = 2;
pub const ACPI_CSRT_TYPE_DMA: u32 = 3;
pub const ACPI_CSRT_XRUPT_LINE: u32 = 0;
pub const ACPI_CSRT_XRUPT_CONTROLLER: u32 = 1;
pub const ACPI_CSRT_TIMER: u32 = 0;
pub const ACPI_CSRT_DMA_CHANNEL: u32 = 0;
pub const ACPI_CSRT_DMA_CONTROLLER: u32 = 1;
pub const ACPI_DBG2_SERIAL_PORT: u32 = 32768;
pub const ACPI_DBG2_1394_PORT: u32 = 32769;
pub const ACPI_DBG2_USB_PORT: u32 = 32770;
pub const ACPI_DBG2_NET_PORT: u32 = 32771;
pub const ACPI_DBG2_16550_COMPATIBLE: u32 = 0;
pub const ACPI_DBG2_16550_SUBSET: u32 = 1;
pub const ACPI_DBG2_MAX311XE_SPI: u32 = 2;
pub const ACPI_DBG2_ARM_PL011: u32 = 3;
pub const ACPI_DBG2_MSM8X60: u32 = 4;
pub const ACPI_DBG2_16550_NVIDIA: u32 = 5;
pub const ACPI_DBG2_TI_OMAP: u32 = 6;
pub const ACPI_DBG2_APM88XXXX: u32 = 8;
pub const ACPI_DBG2_MSM8974: u32 = 9;
pub const ACPI_DBG2_SAM5250: u32 = 10;
pub const ACPI_DBG2_INTEL_USIF: u32 = 11;
pub const ACPI_DBG2_IMX6: u32 = 12;
pub const ACPI_DBG2_ARM_SBSA_32BIT: u32 = 13;
pub const ACPI_DBG2_ARM_SBSA_GENERIC: u32 = 14;
pub const ACPI_DBG2_ARM_DCC: u32 = 15;
pub const ACPI_DBG2_BCM2835: u32 = 16;
pub const ACPI_DBG2_SDM845_1_8432MHZ: u32 = 17;
pub const ACPI_DBG2_16550_WITH_GAS: u32 = 18;
pub const ACPI_DBG2_SDM845_7_372MHZ: u32 = 19;
pub const ACPI_DBG2_INTEL_LPSS: u32 = 20;
pub const ACPI_DBG2_RISCV_SBI_CON: u32 = 21;
pub const ACPI_DBG2_1394_STANDARD: u32 = 0;
pub const ACPI_DBG2_USB_XHCI: u32 = 0;
pub const ACPI_DBG2_USB_EHCI: u32 = 1;
pub const ACPI_DMAR_INTR_REMAP: u32 = 1;
pub const ACPI_DMAR_X2APIC_OPT_OUT: u32 = 2;
pub const ACPI_DMAR_X2APIC_MODE: u32 = 4;
pub const ACPI_DMAR_INCLUDE_ALL: u32 = 1;
pub const ACPI_DMAR_ALLOW_ALL: u32 = 1;
pub const ACPI_DMAR_ALL_PORTS: u32 = 1;
pub const ACPI_DRTM_ACCESS_ALLOWED: u32 = 1;
pub const ACPI_DRTM_ENABLE_GAP_CODE: u32 = 2;
pub const ACPI_DRTM_INCOMPLETE_MEASUREMENTS: u32 = 4;
pub const ACPI_DRTM_AUTHORITY_ORDER: u32 = 8;
pub const ACPI_EINJ_PRESERVE: u32 = 1;
pub const ACPI_EINJ_PROCESSOR_CORRECTABLE: u32 = 1;
pub const ACPI_EINJ_PROCESSOR_UNCORRECTABLE: u32 = 2;
pub const ACPI_EINJ_PROCESSOR_FATAL: u32 = 4;
pub const ACPI_EINJ_MEMORY_CORRECTABLE: u32 = 8;
pub const ACPI_EINJ_MEMORY_UNCORRECTABLE: u32 = 16;
pub const ACPI_EINJ_MEMORY_FATAL: u32 = 32;
pub const ACPI_EINJ_PCIX_CORRECTABLE: u32 = 64;
pub const ACPI_EINJ_PCIX_UNCORRECTABLE: u32 = 128;
pub const ACPI_EINJ_PCIX_FATAL: u32 = 256;
pub const ACPI_EINJ_PLATFORM_CORRECTABLE: u32 = 512;
pub const ACPI_EINJ_PLATFORM_UNCORRECTABLE: u32 = 1024;
pub const ACPI_EINJ_PLATFORM_FATAL: u32 = 2048;
pub const ACPI_EINJ_CXL_CACHE_CORRECTABLE: u32 = 4096;
pub const ACPI_EINJ_CXL_CACHE_UNCORRECTABLE: u32 = 8192;
pub const ACPI_EINJ_CXL_CACHE_FATAL: u32 = 16384;
pub const ACPI_EINJ_CXL_MEM_CORRECTABLE: u32 = 32768;
pub const ACPI_EINJ_CXL_MEM_UNCORRECTABLE: u32 = 65536;
pub const ACPI_EINJ_CXL_MEM_FATAL: u32 = 131072;
pub const ACPI_EINJ_VENDOR_DEFINED: u32 = 2147483648;
pub const ACPI_ERST_PRESERVE: u32 = 1;
pub const ACPI_GTDT_INTERRUPT_MODE: u32 = 1;
pub const ACPI_GTDT_INTERRUPT_POLARITY: u32 = 2;
pub const ACPI_GTDT_ALWAYS_ON: u32 = 4;
pub const ACPI_GTDT_GT_IRQ_MODE: u32 = 1;
pub const ACPI_GTDT_GT_IRQ_POLARITY: u32 = 2;
pub const ACPI_GTDT_GT_IS_SECURE_TIMER: u32 = 1;
pub const ACPI_GTDT_GT_ALWAYS_ON: u32 = 2;
pub const ACPI_GTDT_WATCHDOG_IRQ_MODE: u32 = 1;
pub const ACPI_GTDT_WATCHDOG_IRQ_POLARITY: u32 = 2;
pub const ACPI_GTDT_WATCHDOG_SECURE: u32 = 4;
pub const ACPI_HEST_FIRMWARE_FIRST: u32 = 1;
pub const ACPI_HEST_GLOBAL: u32 = 2;
pub const ACPI_HEST_GHES_ASSIST: u32 = 4;
pub const ACPI_HEST_TYPE: u32 = 1;
pub const ACPI_HEST_POLL_INTERVAL: u32 = 2;
pub const ACPI_HEST_POLL_THRESHOLD_VALUE: u32 = 4;
pub const ACPI_HEST_POLL_THRESHOLD_WINDOW: u32 = 8;
pub const ACPI_HEST_ERR_THRESHOLD_VALUE: u32 = 16;
pub const ACPI_HEST_ERR_THRESHOLD_WINDOW: u32 = 32;
pub const ACPI_HEST_UNCORRECTABLE: u32 = 1;
pub const ACPI_HEST_CORRECTABLE: u32 = 2;
pub const ACPI_HEST_MULTIPLE_UNCORRECTABLE: u32 = 4;
pub const ACPI_HEST_MULTIPLE_CORRECTABLE: u32 = 8;
pub const ACPI_HEST_ERROR_ENTRY_COUNT: u32 = 4080;
pub const ACPI_HEST_GEN_ERROR_RECOVERABLE: u32 = 0;
pub const ACPI_HEST_GEN_ERROR_FATAL: u32 = 1;
pub const ACPI_HEST_GEN_ERROR_CORRECTED: u32 = 2;
pub const ACPI_HEST_GEN_ERROR_NONE: u32 = 3;
pub const ACPI_HEST_GEN_VALID_FRU_ID: u32 = 1;
pub const ACPI_HEST_GEN_VALID_FRU_STRING: u32 = 2;
pub const ACPI_HEST_GEN_VALID_TIMESTAMP: u32 = 4;
pub const ACPI_HMAT_PROCESSOR_PD_VALID: u32 = 1;
pub const ACPI_HMAT_MEMORY_PD_VALID: u32 = 2;
pub const ACPI_HMAT_RESERVATION_HINT: u32 = 4;
pub const ACPI_HMAT_MEMORY_HIERARCHY: u32 = 15;
pub const ACPI_HMAT_MEMORY: u32 = 0;
pub const ACPI_HMAT_LAST_LEVEL_CACHE: u32 = 1;
pub const ACPI_HMAT_1ST_LEVEL_CACHE: u32 = 2;
pub const ACPI_HMAT_2ND_LEVEL_CACHE: u32 = 3;
pub const ACPI_HMAT_3RD_LEVEL_CACHE: u32 = 4;
pub const ACPI_HMAT_MINIMUM_XFER_SIZE: u32 = 16;
pub const ACPI_HMAT_NON_SEQUENTIAL_XFERS: u32 = 32;
pub const ACPI_HMAT_ACCESS_LATENCY: u32 = 0;
pub const ACPI_HMAT_READ_LATENCY: u32 = 1;
pub const ACPI_HMAT_WRITE_LATENCY: u32 = 2;
pub const ACPI_HMAT_ACCESS_BANDWIDTH: u32 = 3;
pub const ACPI_HMAT_READ_BANDWIDTH: u32 = 4;
pub const ACPI_HMAT_WRITE_BANDWIDTH: u32 = 5;
pub const ACPI_HMAT_TOTAL_CACHE_LEVEL: u32 = 15;
pub const ACPI_HMAT_CACHE_LEVEL: u32 = 240;
pub const ACPI_HMAT_CACHE_ASSOCIATIVITY: u32 = 3840;
pub const ACPI_HMAT_WRITE_POLICY: u32 = 61440;
pub const ACPI_HMAT_CACHE_LINE_SIZE: u32 = 4294901760;
pub const ACPI_HMAT_CACHE_MODE_UNKNOWN: u32 = 0;
pub const ACPI_HMAT_CACHE_MODE_EXTENDED_LINEAR: u32 = 1;
pub const ACPI_HMAT_CA_NONE: u32 = 0;
pub const ACPI_HMAT_CA_DIRECT_MAPPED: u32 = 1;
pub const ACPI_HMAT_CA_COMPLEX_CACHE_INDEXING: u32 = 2;
pub const ACPI_HMAT_CP_NONE: u32 = 0;
pub const ACPI_HMAT_CP_WB: u32 = 1;
pub const ACPI_HMAT_CP_WT: u32 = 2;
pub const ACPI_HPET_PAGE_PROTECT_MASK: u32 = 3;
pub const ACPI_SIG_AGDI: &[u8; 5] = b"AGDI\0";
pub const ACPI_SIG_APMT: &[u8; 5] = b"APMT\0";
pub const ACPI_SIG_BDAT: &[u8; 5] = b"BDAT\0";
pub const ACPI_SIG_CCEL: &[u8; 5] = b"CCEL\0";
pub const ACPI_SIG_CDAT: &[u8; 5] = b"CDAT\0";
pub const ACPI_SIG_ERDT: &[u8; 5] = b"ERDT\0";
pub const ACPI_SIG_IORT: &[u8; 5] = b"IORT\0";
pub const ACPI_SIG_IVRS: &[u8; 5] = b"IVRS\0";
pub const ACPI_SIG_LPIT: &[u8; 5] = b"LPIT\0";
pub const ACPI_SIG_MADT: &[u8; 5] = b"APIC\0";
pub const ACPI_SIG_MCFG: &[u8; 5] = b"MCFG\0";
pub const ACPI_SIG_MCHI: &[u8; 5] = b"MCHI\0";
pub const ACPI_SIG_MPAM: &[u8; 5] = b"MPAM\0";
pub const ACPI_SIG_MPST: &[u8; 5] = b"MPST\0";
pub const ACPI_SIG_MRRM: &[u8; 5] = b"MRRM\0";
pub const ACPI_SIG_NFIT: &[u8; 5] = b"NFIT\0";
pub const ACPI_SIG_NHLT: &[u8; 5] = b"NHLT\0";
pub const ACPI_SIG_PCCT: &[u8; 5] = b"PCCT\0";
pub const ACPI_SIG_PDTT: &[u8; 5] = b"PDTT\0";
pub const ACPI_SIG_PHAT: &[u8; 5] = b"PHAT\0";
pub const ACPI_SIG_PMTT: &[u8; 5] = b"PMTT\0";
pub const ACPI_SIG_PPTT: &[u8; 5] = b"PPTT\0";
pub const ACPI_SIG_PRMT: &[u8; 5] = b"PRMT\0";
pub const ACPI_SIG_RASF: &[u8; 5] = b"RASF\0";
pub const ACPI_SIG_RAS2: &[u8; 5] = b"RAS2\0";
pub const ACPI_SIG_RGRT: &[u8; 5] = b"RGRT\0";
pub const ACPI_SIG_RHCT: &[u8; 5] = b"RHCT\0";
pub const ACPI_SIG_RIMT: &[u8; 5] = b"RIMT\0";
pub const ACPI_SIG_SBST: &[u8; 5] = b"SBST\0";
pub const ACPI_SIG_SDEI: &[u8; 5] = b"SDEI\0";
pub const ACPI_SIG_SDEV: &[u8; 5] = b"SDEV\0";
pub const ACPI_SIG_SVKL: &[u8; 5] = b"SVKL\0";
pub const ACPI_SIG_TDEL: &[u8; 5] = b"TDEL\0";
pub const ACPI_AEST_PROCESSOR_ERROR_NODE: u32 = 0;
pub const ACPI_AEST_MEMORY_ERROR_NODE: u32 = 1;
pub const ACPI_AEST_SMMU_ERROR_NODE: u32 = 2;
pub const ACPI_AEST_VENDOR_ERROR_NODE: u32 = 3;
pub const ACPI_AEST_GIC_ERROR_NODE: u32 = 4;
pub const ACPI_AEST_PCIE_ERROR_NODE: u32 = 5;
pub const ACPI_AEST_PROXY_ERROR_NODE: u32 = 6;
pub const ACPI_AEST_NODE_TYPE_RESERVED: u32 = 7;
pub const ACPI_AEST_CACHE_RESOURCE: u32 = 0;
pub const ACPI_AEST_TLB_RESOURCE: u32 = 1;
pub const ACPI_AEST_GENERIC_RESOURCE: u32 = 2;
pub const ACPI_AEST_RESOURCE_RESERVED: u32 = 3;
pub const ACPI_AEST_CACHE_DATA: u32 = 0;
pub const ACPI_AEST_CACHE_INSTRUCTION: u32 = 1;
pub const ACPI_AEST_CACHE_UNIFIED: u32 = 2;
pub const ACPI_AEST_CACHE_RESERVED: u32 = 3;
pub const ACPI_AEST_GIC_CPU: u32 = 0;
pub const ACPI_AEST_GIC_DISTRIBUTOR: u32 = 1;
pub const ACPI_AEST_GIC_REDISTRIBUTOR: u32 = 2;
pub const ACPI_AEST_GIC_ITS: u32 = 3;
pub const ACPI_AEST_GIC_RESERVED: u32 = 4;
pub const ACPI_AEST_NODE_GROUP_FORMAT_4K: u32 = 0;
pub const ACPI_AEST_NODE_GROUP_FORMAT_16K: u32 = 1;
pub const ACPI_AEST_NODE_GROUP_FORMAT_64K: u32 = 2;
pub const ACPI_AEST_NODE_SYSTEM_REGISTER: u32 = 0;
pub const ACPI_AEST_NODE_MEMORY_MAPPED: u32 = 1;
pub const ACPI_AEST_NODE_SINGLE_RECORD_MEMORY_MAPPED: u32 = 2;
pub const ACPI_AEST_XFACE_RESERVED: u32 = 3;
pub const ACPI_AEST_NODE_FAULT_HANDLING: u32 = 0;
pub const ACPI_AEST_NODE_ERROR_RECOVERY: u32 = 1;
pub const ACPI_AEST_XRUPT_RESERVED: u32 = 2;
pub const ACPI_AGDI_SIGNALING_MODE: u32 = 1;
pub const ACPI_APMT_NODE_ID_LENGTH: u32 = 4;
pub const ACPI_APMT_FLAGS_DUAL_PAGE: u32 = 1;
pub const ACPI_APMT_FLAGS_AFFINITY: u32 = 2;
pub const ACPI_APMT_FLAGS_ATOMIC: u32 = 4;
pub const ACPI_APMT_FLAGS_DUAL_PAGE_NSUPP: u32 = 0;
pub const ACPI_APMT_FLAGS_DUAL_PAGE_SUPP: u32 = 1;
pub const ACPI_APMT_FLAGS_AFFINITY_PROC: u32 = 0;
pub const ACPI_APMT_FLAGS_AFFINITY_PROC_CONTAINER: u32 = 2;
pub const ACPI_APMT_FLAGS_ATOMIC_NSUPP: u32 = 0;
pub const ACPI_APMT_FLAGS_ATOMIC_SUPP: u32 = 4;
pub const ACPI_APMT_OVFLW_IRQ_FLAGS_MODE: u32 = 1;
pub const ACPI_APMT_OVFLW_IRQ_FLAGS_TYPE: u32 = 2;
pub const ACPI_APMT_OVFLW_IRQ_FLAGS_MODE_LEVEL: u32 = 0;
pub const ACPI_APMT_OVFLW_IRQ_FLAGS_MODE_EDGE: u32 = 1;
pub const ACPI_APMT_OVFLW_IRQ_FLAGS_TYPE_WIRED: u32 = 0;
pub const ACPI_IORT_ID_SINGLE_MAPPING: u32 = 1;
pub const ACPI_IORT_NODE_COHERENT: u32 = 1;
pub const ACPI_IORT_NODE_NOT_COHERENT: u32 = 0;
pub const ACPI_IORT_HT_TRANSIENT: u32 = 1;
pub const ACPI_IORT_HT_WRITE: u32 = 2;
pub const ACPI_IORT_HT_READ: u32 = 4;
pub const ACPI_IORT_HT_OVERRIDE: u32 = 8;
pub const ACPI_IORT_MF_COHERENCY: u32 = 1;
pub const ACPI_IORT_MF_ATTRIBUTES: u32 = 2;
pub const ACPI_IORT_MF_CANWBS: u32 = 4;
pub const ACPI_IORT_NC_STALL_SUPPORTED: u32 = 1;
pub const ACPI_IORT_NC_PASID_BITS: u32 = 62;
pub const ACPI_IORT_ATS_SUPPORTED: u32 = 1;
pub const ACPI_IORT_PRI_SUPPORTED: u32 = 2;
pub const ACPI_IORT_PASID_FWD_SUPPORTED: u32 = 4;
pub const ACPI_IORT_PASID_MAX_WIDTH: u32 = 31;
pub const ACPI_IORT_SMMU_V1: u32 = 0;
pub const ACPI_IORT_SMMU_V2: u32 = 1;
pub const ACPI_IORT_SMMU_CORELINK_MMU400: u32 = 2;
pub const ACPI_IORT_SMMU_CORELINK_MMU500: u32 = 3;
pub const ACPI_IORT_SMMU_CORELINK_MMU401: u32 = 4;
pub const ACPI_IORT_SMMU_CAVIUM_THUNDERX: u32 = 5;
pub const ACPI_IORT_SMMU_DVM_SUPPORTED: u32 = 1;
pub const ACPI_IORT_SMMU_COHERENT_WALK: u32 = 2;
pub const ACPI_IORT_SMMU_V3_GENERIC: u32 = 0;
pub const ACPI_IORT_SMMU_V3_HISILICON_HI161X: u32 = 1;
pub const ACPI_IORT_SMMU_V3_CAVIUM_CN99XX: u32 = 2;
pub const ACPI_IORT_SMMU_V3_COHACC_OVERRIDE: u32 = 1;
pub const ACPI_IORT_SMMU_V3_HTTU_OVERRIDE: u32 = 6;
pub const ACPI_IORT_SMMU_V3_PXM_VALID: u32 = 8;
pub const ACPI_IORT_SMMU_V3_DEVICEID_VALID: u32 = 16;
pub const ACPI_IORT_RMR_REMAP_PERMITTED: u32 = 1;
pub const ACPI_IORT_RMR_ACCESS_PRIVILEGE: u32 = 2;
pub const ACPI_IORT_RMR_ATTR_DEVICE_NGNRNE: u32 = 0;
pub const ACPI_IORT_RMR_ATTR_DEVICE_NGNRE: u32 = 1;
pub const ACPI_IORT_RMR_ATTR_DEVICE_NGRE: u32 = 2;
pub const ACPI_IORT_RMR_ATTR_DEVICE_GRE: u32 = 3;
pub const ACPI_IORT_RMR_ATTR_NORMAL_NC: u32 = 4;
pub const ACPI_IORT_RMR_ATTR_NORMAL_IWB_OWB: u32 = 5;
pub const ACPI_IVRS_PHYSICAL_SIZE: u32 = 32512;
pub const ACPI_IVRS_VIRTUAL_SIZE: u32 = 4161536;
pub const ACPI_IVRS_ATS_RESERVED: u32 = 4194304;
pub const ACPI_IVHD_TT_ENABLE: u32 = 1;
pub const ACPI_IVHD_PASS_PW: u32 = 2;
pub const ACPI_IVHD_RES_PASS_PW: u32 = 4;
pub const ACPI_IVHD_ISOC: u32 = 8;
pub const ACPI_IVHD_IOTLB: u32 = 16;
pub const ACPI_IVMD_UNITY: u32 = 1;
pub const ACPI_IVMD_READ: u32 = 2;
pub const ACPI_IVMD_WRITE: u32 = 4;
pub const ACPI_IVMD_EXCLUSION_RANGE: u32 = 8;
pub const ACPI_IVHD_MSI_NUMBER_MASK: u32 = 31;
pub const ACPI_IVHD_UNIT_ID_MASK: u32 = 7936;
pub const ACPI_IVHD_ENTRY_LENGTH: u32 = 192;
pub const ACPI_IVHD_INIT_PASS: u32 = 1;
pub const ACPI_IVHD_EINT_PASS: u32 = 2;
pub const ACPI_IVHD_NMI_PASS: u32 = 4;
pub const ACPI_IVHD_SYSTEM_MGMT: u32 = 48;
pub const ACPI_IVHD_LINT0_PASS: u32 = 64;
pub const ACPI_IVHD_LINT1_PASS: u32 = 128;
pub const ACPI_IVHD_ATS_DISABLED: u32 = 2147483648;
pub const ACPI_IVHD_IOAPIC: u32 = 1;
pub const ACPI_IVHD_HPET: u32 = 2;
pub const ACPI_IVRS_UID_NOT_PRESENT: u32 = 0;
pub const ACPI_IVRS_UID_IS_INTEGER: u32 = 1;
pub const ACPI_IVRS_UID_IS_STRING: u32 = 2;
pub const ACPI_LPIT_STATE_DISABLED: u32 = 1;
pub const ACPI_LPIT_NO_COUNTER: u32 = 2;
pub const ACPI_MADT_PCAT_COMPAT: u32 = 1;
pub const ACPI_MADT_DUAL_PIC: u32 = 1;
pub const ACPI_MADT_MULTIPLE_APIC: u32 = 0;
pub const ACPI_MADT_CPEI_OVERRIDE: u32 = 1;
pub const ACPI_MADT_PERFORMANCE_IRQ_MODE: u32 = 2;
pub const ACPI_MADT_VGIC_IRQ_MODE: u32 = 4;
pub const ACPI_MADT_GICC_ONLINE_CAPABLE: u32 = 8;
pub const ACPI_MADT_GICC_NON_COHERENT: u32 = 16;
pub const ACPI_MADT_OVERRIDE_SPI_VALUES: u32 = 1;
pub const ACPI_MADT_GICR_NON_COHERENT: u32 = 1;
pub const ACPI_MADT_ITS_NON_COHERENT: u32 = 1;
pub const ACPI_MADT_MP_WAKEUP_SIZE_V0: u32 = 16;
pub const ACPI_MADT_MP_WAKEUP_SIZE_V1: u32 = 24;
pub const ACPI_MULTIPROC_WAKEUP_MB_OS_SIZE: u32 = 2032;
pub const ACPI_MULTIPROC_WAKEUP_MB_FIRMWARE_SIZE: u32 = 2048;
pub const ACPI_MP_WAKE_COMMAND_WAKEUP: u32 = 1;
pub const ACPI_MP_WAKE_COMMAND_TEST: u32 = 2;
pub const ACPI_MADT_ENABLED: u32 = 1;
pub const ACPI_MADT_ONLINE_CAPABLE: u32 = 2;
pub const ACPI_MADT_POLARITY_MASK: u32 = 3;
pub const ACPI_MADT_TRIGGER_MASK: u32 = 12;
pub const ACPI_MADT_POLARITY_CONFORMS: u32 = 0;
pub const ACPI_MADT_POLARITY_ACTIVE_HIGH: u32 = 1;
pub const ACPI_MADT_POLARITY_RESERVED: u32 = 2;
pub const ACPI_MADT_POLARITY_ACTIVE_LOW: u32 = 3;
pub const ACPI_MADT_TRIGGER_CONFORMS: u32 = 0;
pub const ACPI_MADT_TRIGGER_EDGE: u32 = 4;
pub const ACPI_MADT_TRIGGER_RESERVED: u32 = 8;
pub const ACPI_MADT_TRIGGER_LEVEL: u32 = 12;
pub const ACPI_MPST_ENABLED: u32 = 1;
pub const ACPI_MPST_POWER_MANAGED: u32 = 2;
pub const ACPI_MPST_HOT_PLUG_CAPABLE: u32 = 4;
pub const ACPI_MPST_PRESERVE: u32 = 1;
pub const ACPI_MPST_AUTOENTRY: u32 = 2;
pub const ACPI_MPST_AUTOEXIT: u32 = 4;
pub const ACPI_MRRM_FLAGS_REGION_ASSIGNMENT_OS: u32 = 1;
pub const ACPI_MRRM_VALID_REGION_ID_FLAGS_LOCAL: u32 = 1;
pub const ACPI_MRRM_VALID_REGION_ID_FLAGS_REMOTE: u32 = 2;
pub const ACPI_NFIT_ADD_ONLINE_ONLY: u32 = 1;
pub const ACPI_NFIT_PROXIMITY_VALID: u32 = 2;
pub const ACPI_NFIT_LOCATION_COOKIE_VALID: u32 = 4;
pub const ACPI_NFIT_MEM_SAVE_FAILED: u32 = 1;
pub const ACPI_NFIT_MEM_RESTORE_FAILED: u32 = 2;
pub const ACPI_NFIT_MEM_FLUSH_FAILED: u32 = 4;
pub const ACPI_NFIT_MEM_NOT_ARMED: u32 = 8;
pub const ACPI_NFIT_MEM_HEALTH_OBSERVED: u32 = 16;
pub const ACPI_NFIT_MEM_HEALTH_ENABLED: u32 = 32;
pub const ACPI_NFIT_MEM_MAP_FAILED: u32 = 64;
pub const ACPI_NFIT_CONTROL_BUFFERED: u32 = 1;
pub const ACPI_NFIT_CONTROL_MFG_INFO_VALID: u32 = 1;
pub const ACPI_NFIT_CAPABILITY_CACHE_FLUSH: u32 = 1;
pub const ACPI_NFIT_CAPABILITY_MEM_FLUSH: u32 = 2;
pub const ACPI_NFIT_CAPABILITY_MEM_MIRRORING: u32 = 4;
pub const ACPI_NFIT_DIMM_NUMBER_MASK: u32 = 15;
pub const ACPI_NFIT_CHANNEL_NUMBER_MASK: u32 = 240;
pub const ACPI_NFIT_MEMORY_ID_MASK: u32 = 3840;
pub const ACPI_NFIT_SOCKET_ID_MASK: u32 = 61440;
pub const ACPI_NFIT_NODE_ID_MASK: u32 = 268369920;
pub const ACPI_NFIT_DIMM_NUMBER_OFFSET: u32 = 0;
pub const ACPI_NFIT_CHANNEL_NUMBER_OFFSET: u32 = 4;
pub const ACPI_NFIT_MEMORY_ID_OFFSET: u32 = 8;
pub const ACPI_NFIT_SOCKET_ID_OFFSET: u32 = 12;
pub const ACPI_NFIT_NODE_ID_OFFSET: u32 = 16;
pub const ACPI_NHLT_LINKTYPE_HDA: u32 = 0;
pub const ACPI_NHLT_LINKTYPE_DSP: u32 = 1;
pub const ACPI_NHLT_LINKTYPE_PDM: u32 = 2;
pub const ACPI_NHLT_LINKTYPE_SSP: u32 = 3;
pub const ACPI_NHLT_LINKTYPE_SLIMBUS: u32 = 4;
pub const ACPI_NHLT_LINKTYPE_SDW: u32 = 5;
pub const ACPI_NHLT_LINKTYPE_UAOL: u32 = 6;
pub const ACPI_NHLT_DEVICEID_DMIC: u32 = 44576;
pub const ACPI_NHLT_DEVICEID_BT: u32 = 44592;
pub const ACPI_NHLT_DEVICEID_I2S: u32 = 44596;
pub const ACPI_NHLT_DEVICETYPE_PDM: u32 = 0;
pub const ACPI_NHLT_DEVICETYPE_PDM_SKL: u32 = 1;
pub const ACPI_NHLT_DEVICETYPE_BT: u32 = 0;
pub const ACPI_NHLT_DEVICETYPE_FM: u32 = 1;
pub const ACPI_NHLT_DEVICETYPE_MODEM: u32 = 2;
pub const ACPI_NHLT_DEVICETYPE_CODEC: u32 = 4;
pub const ACPI_NHLT_DIR_RENDER: u32 = 0;
pub const ACPI_NHLT_DIR_CAPTURE: u32 = 1;
pub const ACPI_NHLT_CONFIGTYPE_GENERIC: u32 = 0;
pub const ACPI_NHLT_CONFIGTYPE_MICARRAY: u32 = 1;
pub const ACPI_NHLT_ARRAYTYPE_LINEAR2_SMALL: u32 = 10;
pub const ACPI_NHLT_ARRAYTYPE_LINEAR2_BIG: u32 = 11;
pub const ACPI_NHLT_ARRAYTYPE_LINEAR4_GEO1: u32 = 12;
pub const ACPI_NHLT_ARRAYTYPE_PLANAR4_LSHAPED: u32 = 13;
pub const ACPI_NHLT_ARRAYTYPE_LINEAR4_GEO2: u32 = 14;
pub const ACPI_NHLT_ARRAYTYPE_VENDOR: u32 = 15;
pub const ACPI_NHLT_MICTYPE_OMNIDIRECTIONAL: u32 = 0;
pub const ACPI_NHLT_MICTYPE_SUBCARDIOID: u32 = 1;
pub const ACPI_NHLT_MICTYPE_CARDIOID: u32 = 2;
pub const ACPI_NHLT_MICTYPE_SUPERCARDIOID: u32 = 3;
pub const ACPI_NHLT_MICTYPE_HYPERCARDIOID: u32 = 4;
pub const ACPI_NHLT_MICTYPE_8SHAPED: u32 = 5;
pub const ACPI_NHLT_MICTYPE_RESERVED: u32 = 6;
pub const ACPI_NHLT_MICTYPE_VENDORDEFINED: u32 = 7;
pub const ACPI_NHLT_MICLOCATION_TOP: u32 = 0;
pub const ACPI_NHLT_MICLOCATION_BOTTOM: u32 = 1;
pub const ACPI_NHLT_MICLOCATION_LEFT: u32 = 2;
pub const ACPI_NHLT_MICLOCATION_RIGHT: u32 = 3;
pub const ACPI_NHLT_MICLOCATION_FRONT: u32 = 4;
pub const ACPI_NHLT_MICLOCATION_REAR: u32 = 5;
pub const ACPI_PCCT_DOORBELL: u32 = 1;
pub const ACPI_PCCT_INTERRUPT_POLARITY: u32 = 1;
pub const ACPI_PCCT_INTERRUPT_MODE: u32 = 2;
pub const ACPI_PDTT_RUNTIME_TRIGGER: u32 = 1;
pub const ACPI_PDTT_WAIT_COMPLETION: u32 = 2;
pub const ACPI_PDTT_TRIGGER_ORDER: u32 = 4;
pub const ACPI_PHAT_TYPE_FW_VERSION_DATA: u32 = 0;
pub const ACPI_PHAT_TYPE_FW_HEALTH_DATA: u32 = 1;
pub const ACPI_PHAT_TYPE_RESERVED: u32 = 2;
pub const ACPI_PHAT_ERRORS_FOUND: u32 = 0;
pub const ACPI_PHAT_NO_ERRORS: u32 = 1;
pub const ACPI_PHAT_UNKNOWN_ERRORS: u32 = 2;
pub const ACPI_PHAT_ADVISORY: u32 = 3;
pub const ACPI_PMTT_TYPE_SOCKET: u32 = 0;
pub const ACPI_PMTT_TYPE_CONTROLLER: u32 = 1;
pub const ACPI_PMTT_TYPE_DIMM: u32 = 2;
pub const ACPI_PMTT_TYPE_RESERVED: u32 = 3;
pub const ACPI_PMTT_TYPE_VENDOR: u32 = 255;
pub const ACPI_PMTT_TOP_LEVEL: u32 = 1;
pub const ACPI_PMTT_PHYSICAL: u32 = 2;
pub const ACPI_PMTT_MEMORY_TYPE: u32 = 12;
pub const ACPI_PPTT_PHYSICAL_PACKAGE: u32 = 1;
pub const ACPI_PPTT_ACPI_PROCESSOR_ID_VALID: u32 = 2;
pub const ACPI_PPTT_ACPI_PROCESSOR_IS_THREAD: u32 = 4;
pub const ACPI_PPTT_ACPI_LEAF_NODE: u32 = 8;
pub const ACPI_PPTT_ACPI_IDENTICAL: u32 = 16;
pub const ACPI_PPTT_SIZE_PROPERTY_VALID: u32 = 1;
pub const ACPI_PPTT_NUMBER_OF_SETS_VALID: u32 = 2;
pub const ACPI_PPTT_ASSOCIATIVITY_VALID: u32 = 4;
pub const ACPI_PPTT_ALLOCATION_TYPE_VALID: u32 = 8;
pub const ACPI_PPTT_CACHE_TYPE_VALID: u32 = 16;
pub const ACPI_PPTT_WRITE_POLICY_VALID: u32 = 32;
pub const ACPI_PPTT_LINE_SIZE_VALID: u32 = 64;
pub const ACPI_PPTT_CACHE_ID_VALID: u32 = 128;
pub const ACPI_PPTT_MASK_ALLOCATION_TYPE: u32 = 3;
pub const ACPI_PPTT_MASK_CACHE_TYPE: u32 = 12;
pub const ACPI_PPTT_MASK_WRITE_POLICY: u32 = 16;
pub const ACPI_PPTT_CACHE_READ_ALLOCATE: u32 = 0;
pub const ACPI_PPTT_CACHE_WRITE_ALLOCATE: u32 = 1;
pub const ACPI_PPTT_CACHE_RW_ALLOCATE: u32 = 2;
pub const ACPI_PPTT_CACHE_RW_ALLOCATE_ALT: u32 = 3;
pub const ACPI_PPTT_CACHE_TYPE_DATA: u32 = 0;
pub const ACPI_PPTT_CACHE_TYPE_INSTR: u32 = 4;
pub const ACPI_PPTT_CACHE_TYPE_UNIFIED: u32 = 8;
pub const ACPI_PPTT_CACHE_TYPE_UNIFIED_ALT: u32 = 12;
pub const ACPI_PPTT_CACHE_POLICY_WB: u32 = 0;
pub const ACPI_PPTT_CACHE_POLICY_WT: u32 = 16;
pub const ACPI_RASF_SCRUBBER_RUNNING: u32 = 1;
pub const ACPI_RASF_SPEED: u32 = 14;
pub const ACPI_RASF_SPEED_SLOW: u32 = 0;
pub const ACPI_RASF_SPEED_MEDIUM: u32 = 8;
pub const ACPI_RASF_SPEED_FAST: u32 = 14;
pub const ACPI_RASF_GENERATE_SCI: u32 = 32768;
pub const ACPI_RASF_COMMAND_COMPLETE: u32 = 1;
pub const ACPI_RASF_SCI_DOORBELL: u32 = 2;
pub const ACPI_RASF_ERROR: u32 = 4;
pub const ACPI_RASF_STATUS: u32 = 248;
pub const ACPI_RAS2_SCRUBBER_RUNNING: u32 = 1;
pub const ACPI_RAS2_GENERATE_SCI: u32 = 32768;
pub const ACPI_RAS2_COMMAND_COMPLETE: u32 = 1;
pub const ACPI_RAS2_SCI_DOORBELL: u32 = 2;
pub const ACPI_RAS2_ERROR: u32 = 4;
pub const ACPI_RAS2_STATUS: u32 = 248;
pub const ACPI_RHCT_TIMER_CANNOT_WAKEUP_CPU: u32 = 1;
pub const ACPI_RIMT_IOMMU_FLAGS_PCIE: u32 = 1;
pub const ACPI_RIMT_IOMMU_FLAGS_PXM_VALID: u32 = 2;
pub const ACPI_RIMT_GSI_LEVEL_TRIGGERRED: u32 = 1;
pub const ACPI_RIMT_GSI_ACTIVE_HIGH: u32 = 2;
pub const ACPI_RIMT_PCIE_ATS_SUPPORTED: u32 = 1;
pub const ACPI_RIMT_PCIE_PRI_SUPPORTED: u32 = 2;
pub const ACPI_SDEV_HANDOFF_TO_UNSECURE_OS: u32 = 1;
pub const ACPI_SDEV_SECURE_COMPONENTS_PRESENT: u32 = 2;
pub const ACPI_SIG_SLIC: &[u8; 5] = b"SLIC\0";
pub const ACPI_SIG_SLIT: &[u8; 5] = b"SLIT\0";
pub const ACPI_SIG_SPCR: &[u8; 5] = b"SPCR\0";
pub const ACPI_SIG_SPMI: &[u8; 5] = b"SPMI\0";
pub const ACPI_SIG_SRAT: &[u8; 5] = b"SRAT\0";
pub const ACPI_SIG_STAO: &[u8; 5] = b"STAO\0";
pub const ACPI_SIG_TCPA: &[u8; 5] = b"TCPA\0";
pub const ACPI_SIG_TPM2: &[u8; 5] = b"TPM2\0";
pub const ACPI_SIG_UEFI: &[u8; 5] = b"UEFI\0";
pub const ACPI_SIG_VIOT: &[u8; 5] = b"VIOT\0";
pub const ACPI_SIG_WAET: &[u8; 5] = b"WAET\0";
pub const ACPI_SIG_WDAT: &[u8; 5] = b"WDAT\0";
pub const ACPI_SIG_WDDT: &[u8; 5] = b"WDDT\0";
pub const ACPI_SIG_WDRT: &[u8; 5] = b"WDRT\0";
pub const ACPI_SIG_WPBT: &[u8; 5] = b"WPBT\0";
pub const ACPI_SIG_WSMT: &[u8; 5] = b"WSMT\0";
pub const ACPI_SIG_XENV: &[u8; 5] = b"XENV\0";
pub const ACPI_SIG_XXXX: &[u8; 5] = b"XXXX\0";
pub const ACPI_SPCR_DO_NOT_DISABLE: u32 = 1;
pub const ACPI_SRAT_CPU_USE_AFFINITY: u32 = 1;
pub const ACPI_SRAT_MEM_ENABLED: u32 = 1;
pub const ACPI_SRAT_MEM_HOT_PLUGGABLE: u32 = 2;
pub const ACPI_SRAT_MEM_NON_VOLATILE: u32 = 4;
pub const ACPI_SRAT_CPU_ENABLED: u32 = 1;
pub const ACPI_SRAT_GICC_ENABLED: u32 = 1;
pub const ACPI_SRAT_DEVICE_HANDLE_SIZE: u32 = 16;
pub const ACPI_SRAT_GENERIC_AFFINITY_ENABLED: u32 = 1;
pub const ACPI_SRAT_ARCHITECTURAL_TRANSACTIONS: u32 = 2;
pub const ACPI_SRAT_RINTC_ENABLED: u32 = 1;
pub const ACPI_TCPA_CLIENT_TABLE: u32 = 0;
pub const ACPI_TCPA_SERVER_TABLE: u32 = 1;
pub const ACPI_TCPA_PCI_DEVICE: u32 = 1;
pub const ACPI_TCPA_BUS_PNP: u32 = 2;
pub const ACPI_TCPA_ADDRESS_VALID: u32 = 4;
pub const ACPI_TCPA_INTERRUPT_MODE: u32 = 1;
pub const ACPI_TCPA_INTERRUPT_POLARITY: u32 = 2;
pub const ACPI_TCPA_SCI_VIA_GPE: u32 = 4;
pub const ACPI_TCPA_GLOBAL_INTERRUPT: u32 = 8;
pub const ACPI_TPM23_ACPI_START_METHOD: u32 = 2;
pub const ACPI_TPM2_NOT_ALLOWED: u32 = 0;
pub const ACPI_TPM2_RESERVED1: u32 = 1;
pub const ACPI_TPM2_START_METHOD: u32 = 2;
pub const ACPI_TPM2_RESERVED3: u32 = 3;
pub const ACPI_TPM2_RESERVED4: u32 = 4;
pub const ACPI_TPM2_RESERVED5: u32 = 5;
pub const ACPI_TPM2_MEMORY_MAPPED: u32 = 6;
pub const ACPI_TPM2_COMMAND_BUFFER: u32 = 7;
pub const ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD: u32 = 8;
pub const ACPI_TPM2_RESERVED9: u32 = 9;
pub const ACPI_TPM2_RESERVED10: u32 = 10;
pub const ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC: u32 = 11;
pub const ACPI_TPM2_RESERVED: u32 = 12;
pub const ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON: u32 = 13;
pub const ACPI_TPM2_CRB_WITH_ARM_FFA: u32 = 15;
pub const ACPI_TPM2_INTERRUPT_SUPPORT: u32 = 1;
pub const ACPI_TPM2_IDLE_SUPPORT: u32 = 1;
pub const ACPI_WAET_RTC_NO_ACK: u32 = 1;
pub const ACPI_WAET_TIMER_ONE_READ: u32 = 2;
pub const ACPI_WDAT_ENABLED: u32 = 1;
pub const ACPI_WDAT_STOPPED: u32 = 128;
pub const ACPI_WDDT_AVAILABLE: u32 = 1;
pub const ACPI_WDDT_ACTIVE: u32 = 2;
pub const ACPI_WDDT_TCO_OS_OWNED: u32 = 4;
pub const ACPI_WDDT_USER_RESET: u32 = 2048;
pub const ACPI_WDDT_WDT_RESET: u32 = 4096;
pub const ACPI_WDDT_POWER_FAIL: u32 = 8192;
pub const ACPI_WDDT_UNKNOWN_RESET: u32 = 16384;
pub const ACPI_WDDT_AUTO_RESET: u32 = 1;
pub const ACPI_WDDT_ALERT_SUPPORT: u32 = 2;
pub const ACPI_WSMT_FIXED_COMM_BUFFERS: u32 = 1;
pub const ACPI_WSMT_COMM_BUFFER_NESTED_PTR_PROTECTION: u32 = 2;
pub const ACPI_WSMT_SYSTEM_RESOURCE_PROTECTION: u32 = 4;
pub const ACPI_FADT_CONFORMANCE: &[u8; 26] = b"ACPI 6.1 (FADT version 6)\0";
pub const ACPI_DMA_WIDTH8: u32 = 0;
pub const ACPI_DMA_WIDTH16: u32 = 1;
pub const ACPI_DMA_WIDTH32: u32 = 2;
pub const ACPI_DMA_WIDTH64: u32 = 3;
pub const ACPI_DMA_WIDTH128: u32 = 4;
pub const ACPI_DMA_WIDTH256: u32 = 5;
pub const ACPI_RESOURCE_GPIO_TYPE_INT: u32 = 0;
pub const ACPI_RESOURCE_GPIO_TYPE_IO: u32 = 1;
pub const ACPI_PIN_CONFIG_DEFAULT: u32 = 0;
pub const ACPI_PIN_CONFIG_PULLUP: u32 = 1;
pub const ACPI_PIN_CONFIG_PULLDOWN: u32 = 2;
pub const ACPI_PIN_CONFIG_NOPULL: u32 = 3;
pub const ACPI_IO_RESTRICT_NONE: u32 = 0;
pub const ACPI_IO_RESTRICT_INPUT: u32 = 1;
pub const ACPI_IO_RESTRICT_OUTPUT: u32 = 2;
pub const ACPI_IO_RESTRICT_NONE_PRESERVE: u32 = 3;
pub const ACPI_RESOURCE_SERIAL_TYPE_I2C: u32 = 1;
pub const ACPI_RESOURCE_SERIAL_TYPE_SPI: u32 = 2;
pub const ACPI_RESOURCE_SERIAL_TYPE_UART: u32 = 3;
pub const ACPI_RESOURCE_SERIAL_TYPE_CSI2: u32 = 4;
pub const ACPI_CONTROLLER_INITIATED: u32 = 0;
pub const ACPI_DEVICE_INITIATED: u32 = 1;
pub const ACPI_I2C_7BIT_MODE: u32 = 0;
pub const ACPI_I2C_10BIT_MODE: u32 = 1;
pub const ACPI_SPI_4WIRE_MODE: u32 = 0;
pub const ACPI_SPI_3WIRE_MODE: u32 = 1;
pub const ACPI_SPI_ACTIVE_LOW: u32 = 0;
pub const ACPI_SPI_ACTIVE_HIGH: u32 = 1;
pub const ACPI_SPI_FIRST_PHASE: u32 = 0;
pub const ACPI_SPI_SECOND_PHASE: u32 = 1;
pub const ACPI_SPI_START_LOW: u32 = 0;
pub const ACPI_SPI_START_HIGH: u32 = 1;
pub const ACPI_UART_LITTLE_ENDIAN: u32 = 0;
pub const ACPI_UART_BIG_ENDIAN: u32 = 1;
pub const ACPI_UART_5_DATA_BITS: u32 = 0;
pub const ACPI_UART_6_DATA_BITS: u32 = 1;
pub const ACPI_UART_7_DATA_BITS: u32 = 2;
pub const ACPI_UART_8_DATA_BITS: u32 = 3;
pub const ACPI_UART_9_DATA_BITS: u32 = 4;
pub const ACPI_UART_NO_STOP_BITS: u32 = 0;
pub const ACPI_UART_1_STOP_BIT: u32 = 1;
pub const ACPI_UART_1P5_STOP_BITS: u32 = 2;
pub const ACPI_UART_2_STOP_BITS: u32 = 3;
pub const ACPI_UART_FLOW_CONTROL_NONE: u32 = 0;
pub const ACPI_UART_FLOW_CONTROL_HW: u32 = 1;
pub const ACPI_UART_FLOW_CONTROL_XON_XOFF: u32 = 2;
pub const ACPI_UART_PARITY_NONE: u32 = 0;
pub const ACPI_UART_PARITY_EVEN: u32 = 1;
pub const ACPI_UART_PARITY_ODD: u32 = 2;
pub const ACPI_UART_PARITY_MARK: u32 = 3;
pub const ACPI_UART_PARITY_SPACE: u32 = 4;
pub const ACPI_UART_CARRIER_DETECT: u32 = 4;
pub const ACPI_UART_RING_INDICATOR: u32 = 8;
pub const ACPI_UART_DATA_SET_READY: u32 = 16;
pub const ACPI_UART_DATA_TERMINAL_READY: u32 = 32;
pub const ACPI_UART_CLEAR_TO_SEND: u32 = 64;
pub const ACPI_UART_REQUEST_TO_SEND: u32 = 128;
pub const ACPI_PIN_CONFIG_BIAS_PULL_UP: u32 = 1;
pub const ACPI_PIN_CONFIG_BIAS_PULL_DOWN: u32 = 2;
pub const ACPI_PIN_CONFIG_BIAS_DEFAULT: u32 = 3;
pub const ACPI_PIN_CONFIG_BIAS_DISABLE: u32 = 4;
pub const ACPI_PIN_CONFIG_BIAS_HIGH_IMPEDANCE: u32 = 5;
pub const ACPI_PIN_CONFIG_BIAS_BUS_HOLD: u32 = 6;
pub const ACPI_PIN_CONFIG_DRIVE_OPEN_DRAIN: u32 = 7;
pub const ACPI_PIN_CONFIG_DRIVE_OPEN_SOURCE: u32 = 8;
pub const ACPI_PIN_CONFIG_DRIVE_PUSH_PULL: u32 = 9;
pub const ACPI_PIN_CONFIG_DRIVE_STRENGTH: u32 = 10;
pub const ACPI_PIN_CONFIG_SLEW_RATE: u32 = 11;
pub const ACPI_PIN_CONFIG_INPUT_DEBOUNCE: u32 = 12;
pub const ACPI_PIN_CONFIG_INPUT_SCHMITT_TRIGGER: u32 = 13;
pub const ACPI_RESOURCE_TYPE_IRQ: u32 = 0;
pub const ACPI_RESOURCE_TYPE_DMA: u32 = 1;
pub const ACPI_RESOURCE_TYPE_START_DEPENDENT: u32 = 2;
pub const ACPI_RESOURCE_TYPE_END_DEPENDENT: u32 = 3;
pub const ACPI_RESOURCE_TYPE_IO: u32 = 4;
pub const ACPI_RESOURCE_TYPE_FIXED_IO: u32 = 5;
pub const ACPI_RESOURCE_TYPE_VENDOR: u32 = 6;
pub const ACPI_RESOURCE_TYPE_END_TAG: u32 = 7;
pub const ACPI_RESOURCE_TYPE_MEMORY24: u32 = 8;
pub const ACPI_RESOURCE_TYPE_MEMORY32: u32 = 9;
pub const ACPI_RESOURCE_TYPE_FIXED_MEMORY32: u32 = 10;
pub const ACPI_RESOURCE_TYPE_ADDRESS16: u32 = 11;
pub const ACPI_RESOURCE_TYPE_ADDRESS32: u32 = 12;
pub const ACPI_RESOURCE_TYPE_ADDRESS64: u32 = 13;
pub const ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64: u32 = 14;
pub const ACPI_RESOURCE_TYPE_EXTENDED_IRQ: u32 = 15;
pub const ACPI_RESOURCE_TYPE_GENERIC_REGISTER: u32 = 16;
pub const ACPI_RESOURCE_TYPE_GPIO: u32 = 17;
pub const ACPI_RESOURCE_TYPE_FIXED_DMA: u32 = 18;
pub const ACPI_RESOURCE_TYPE_SERIAL_BUS: u32 = 19;
pub const ACPI_RESOURCE_TYPE_PIN_FUNCTION: u32 = 20;
pub const ACPI_RESOURCE_TYPE_PIN_CONFIG: u32 = 21;
pub const ACPI_RESOURCE_TYPE_PIN_GROUP: u32 = 22;
pub const ACPI_RESOURCE_TYPE_PIN_GROUP_FUNCTION: u32 = 23;
pub const ACPI_RESOURCE_TYPE_PIN_GROUP_CONFIG: u32 = 24;
pub const ACPI_RESOURCE_TYPE_CLOCK_INPUT: u32 = 25;
pub const ACPI_RESOURCE_TYPE_MAX: u32 = 25;
pub const ACPI_RS_SIZE_NO_DATA: u32 = 8;
pub const ACPI_UTILITIES: u32 = 1;
pub const ACPI_HARDWARE: u32 = 2;
pub const ACPI_EVENTS: u32 = 4;
pub const ACPI_TABLES: u32 = 8;
pub const ACPI_NAMESPACE: u32 = 16;
pub const ACPI_PARSER: u32 = 32;
pub const ACPI_DISPATCHER: u32 = 64;
pub const ACPI_EXECUTER: u32 = 128;
pub const ACPI_RESOURCES: u32 = 256;
pub const ACPI_CA_DEBUGGER: u32 = 512;
pub const ACPI_OS_SERVICES: u32 = 1024;
pub const ACPI_CA_DISASSEMBLER: u32 = 2048;
pub const ACPI_COMPILER: u32 = 4096;
pub const ACPI_TOOLS: u32 = 8192;
pub const ACPI_EXAMPLE: u32 = 16384;
pub const ACPI_DRIVER: u32 = 32768;
pub const DT_COMPILER: u32 = 65536;
pub const ASL_PREPROCESSOR: u32 = 131072;
pub const ACPI_ALL_COMPONENTS: u32 = 131071;
pub const ACPI_COMPONENT_DEFAULT: u32 = 131071;
pub const ACPI_ALL_DRIVERS: u32 = 4294901760;
pub const ACPI_LV_INIT: u32 = 1;
pub const ACPI_LV_DEBUG_OBJECT: u32 = 2;
pub const ACPI_LV_INFO: u32 = 4;
pub const ACPI_LV_REPAIR: u32 = 8;
pub const ACPI_LV_TRACE_POINT: u32 = 16;
pub const ACPI_LV_ALL_EXCEPTIONS: u32 = 31;
pub const ACPI_LV_INIT_NAMES: u32 = 32;
pub const ACPI_LV_PARSE: u32 = 64;
pub const ACPI_LV_LOAD: u32 = 128;
pub const ACPI_LV_DISPATCH: u32 = 256;
pub const ACPI_LV_EXEC: u32 = 512;
pub const ACPI_LV_NAMES: u32 = 1024;
pub const ACPI_LV_OPREGION: u32 = 2048;
pub const ACPI_LV_BFIELD: u32 = 4096;
pub const ACPI_LV_TABLES: u32 = 8192;
pub const ACPI_LV_VALUES: u32 = 16384;
pub const ACPI_LV_OBJECTS: u32 = 32768;
pub const ACPI_LV_RESOURCES: u32 = 65536;
pub const ACPI_LV_USER_REQUESTS: u32 = 131072;
pub const ACPI_LV_PACKAGE: u32 = 262144;
pub const ACPI_LV_EVALUATION: u32 = 524288;
pub const ACPI_LV_VERBOSITY1: u32 = 1048415;
pub const ACPI_LV_ALLOCATIONS: u32 = 1048576;
pub const ACPI_LV_FUNCTIONS: u32 = 2097152;
pub const ACPI_LV_OPTIMIZATIONS: u32 = 4194304;
pub const ACPI_LV_PARSE_TREES: u32 = 8388608;
pub const ACPI_LV_VERBOSITY2: u32 = 16777055;
pub const ACPI_LV_ALL: u32 = 16777055;
pub const ACPI_LV_MUTEX: u32 = 16777216;
pub const ACPI_LV_THREADS: u32 = 33554432;
pub const ACPI_LV_IO: u32 = 67108864;
pub const ACPI_LV_INTERRUPTS: u32 = 134217728;
pub const ACPI_LV_VERBOSITY3: u32 = 268435295;
pub const ACPI_LV_AML_DISASSEMBLE: u32 = 268435456;
pub const ACPI_LV_VERBOSE_INFO: u32 = 536870912;
pub const ACPI_LV_FULL_TABLES: u32 = 1073741824;
pub const ACPI_LV_EVENTS: u32 = 2147483648;
pub const ACPI_LV_VERBOSE: u32 = 4026531840;
pub const ACPI_NORMAL_DEFAULT: u32 = 11;
pub const ACPI_DEBUG_ALL: u32 = 285212511;
pub const ACPI_TRACE_LEVEL_ALL: u32 = 16777055;
pub const ACPI_TRACE_LAYER_ALL: u32 = 511;
pub const ACPI_TRACE_LEVEL_DEFAULT: u32 = 16;
pub const ACPI_TRACE_LAYER_DEFAULT: u32 = 128;
pub const ACPI_MUTEX_SEM: u32 = 1;
pub const ACPI_SIGNAL_FATAL: u32 = 0;
pub const ACPI_SIGNAL_BREAKPOINT: u32 = 1;
pub const REQUEST_FILE_ONLY: u32 = 0;
pub const REQUEST_DIR_ONLY: u32 = 1;
pub const ACPI_CA_VERSION: u32 = 539296772;
pub const ACPI_OS_NAME: &[u8; 21] = b"Microsoft Windows NT\0";
pub const ACPI_MAX_STATE_CACHE_DEPTH: u32 = 96;
pub const ACPI_MAX_PARSE_CACHE_DEPTH: u32 = 96;
pub const ACPI_MAX_EXTPARSE_CACHE_DEPTH: u32 = 96;
pub const ACPI_MAX_OBJECT_CACHE_DEPTH: u32 = 96;
pub const ACPI_MAX_NAMESPACE_CACHE_DEPTH: u32 = 96;
pub const ACPI_MAX_COMMENT_CACHE_DEPTH: u32 = 96;
pub const ACPI_CA_SUPPORT_LEVEL: u32 = 5;
pub const ACPI_MAX_SEMAPHORE_COUNT: u32 = 256;
pub const ACPI_MAX_REFERENCE_COUNT: u32 = 16384;
pub const ACPI_DEFAULT_PAGE_SIZE: u32 = 4096;
pub const ACPI_NUM_OWNERID_MASKS: u32 = 128;
pub const ACPI_ROOT_TABLE_SIZE_INCREMENT: u32 = 4;
pub const ACPI_MAX_SLEEP: u32 = 2000;
pub const ACPI_ADDRESS_RANGE_MAX: u32 = 2;
pub const ACPI_MAX_LOOP_TIMEOUT: u32 = 30;
pub const ACPI_METHOD_NUM_LOCALS: u32 = 8;
pub const ACPI_METHOD_MAX_LOCAL: u32 = 7;
pub const ACPI_METHOD_NUM_ARGS: u32 = 7;
pub const ACPI_METHOD_MAX_ARG: u32 = 6;
pub const ACPI_OBJ_NUM_OPERANDS: u32 = 8;
pub const ACPI_OBJ_MAX_OPERAND: u32 = 7;
pub const ACPI_RESULTS_FRAME_OBJ_NUM: u32 = 8;
pub const ACPI_RESULTS_OBJ_NUM_MAX: u32 = 255;
pub const ACPI_EBDA_PTR_LOCATION: u32 = 1038;
pub const ACPI_EBDA_PTR_LENGTH: u32 = 2;
pub const ACPI_EBDA_WINDOW_SIZE: u32 = 1024;
pub const ACPI_HI_RSDP_WINDOW_BASE: u32 = 917504;
pub const ACPI_HI_RSDP_WINDOW_SIZE: u32 = 131072;
pub const ACPI_RSDP_SCAN_STEP: u32 = 16;
pub const ACPI_USER_REGION_BEGIN: u32 = 128;
pub const ACPI_MAX_ADDRESS_SPACE: u32 = 255;
pub const ACPI_NUM_DEFAULT_SPACES: u32 = 4;
pub const ACPI_MAX_MATCH_OPCODE: u32 = 5;
pub const ACPI_RSDP_CHECKSUM_LENGTH: u32 = 20;
pub const ACPI_RSDP_XCHECKSUM_LENGTH: u32 = 36;
pub const ACPI_SERIAL_HEADER_SIZE: u32 = 2;
pub const ACPI_SMBUS_DATA_SIZE: u32 = 32;
pub const ACPI_SMBUS_BUFFER_SIZE: u32 = 34;
pub const ACPI_IPMI_DATA_SIZE: u32 = 64;
pub const ACPI_IPMI_BUFFER_SIZE: u32 = 66;
pub const ACPI_MAX_GSBUS_DATA_SIZE: u32 = 255;
pub const ACPI_MAX_GSBUS_BUFFER_SIZE: u32 = 257;
pub const ACPI_PRM_INPUT_BUFFER_SIZE: u32 = 26;
pub const ACPI_FFH_INPUT_BUFFER_SIZE: u32 = 256;
pub const ACPI_NUM_sx_d_METHODS: u32 = 4;
pub const ACPI_NUM_sx_w_METHODS: u32 = 5;
pub const UUID_BUFFER_LENGTH: u32 = 16;
pub const UUID_STRING_LENGTH: u32 = 36;
pub const UUID_HYPHEN1_OFFSET: u32 = 8;
pub const UUID_HYPHEN2_OFFSET: u32 = 13;
pub const UUID_HYPHEN3_OFFSET: u32 = 18;
pub const UUID_HYPHEN4_OFFSET: u32 = 23;
pub const ACPI_DEBUGGER_MAX_ARGS: u32 = 11;
pub const ACPI_DB_LINE_BUFFER_SIZE: u32 = 512;
pub const ACPI_DEBUGGER_COMMAND_PROMPT: u8 = 45u8;
pub const ACPI_DEBUGGER_EXECUTE_PROMPT: u8 = 37u8;
pub const ACPI_PLD_REV1_BUFFER_SIZE: u32 = 16;
pub const ACPI_PLD_REV2_BUFFER_SIZE: u32 = 20;
pub const ACPI_PLD_BUFFER_SIZE: u32 = 20;
pub const ACPI_PLD_PANEL_TOP: u32 = 0;
pub const ACPI_PLD_PANEL_BOTTOM: u32 = 1;
pub const ACPI_PLD_PANEL_LEFT: u32 = 2;
pub const ACPI_PLD_PANEL_RIGHT: u32 = 3;
pub const ACPI_PLD_PANEL_FRONT: u32 = 4;
pub const ACPI_PLD_PANEL_BACK: u32 = 5;
pub const ACPI_PLD_PANEL_UNKNOWN: u32 = 6;
pub const ACPI_BUS_FILE_ROOT: &[u8; 5] = b"acpi\0";
pub const ACPI_DRIVER_ALL_NOTIFY_EVENTS: u32 = 1;
pub const MAX_ACPI_DEVICE_NAME_LEN: u32 = 40;
pub const MAX_ACPI_CLASS_NAME_LEN: u32 = 20;
pub const ACPI_DEVICE_SWNODE_ROOT: u32 = 0;
pub const ACPI_DEVICE_CSI2_DATA_LANES: u32 = 8;
pub const ACPI_DEVICE_SWNODE_PORT_NAME_LENGTH: u32 = 8;
pub const ACPI_MAX_STRING: u32 = 80;
pub const ACPI_POWER_HID: &[u8; 9] = b"LNXPOWER\0";
pub const ACPI_PROCESSOR_OBJECT_HID: &[u8; 7] = b"LNXCPU\0";
pub const ACPI_SYSTEM_HID: &[u8; 9] = b"LNXSYSTM\0";
pub const ACPI_THERMAL_HID: &[u8; 9] = b"LNXTHERM\0";
pub const ACPI_BUTTON_HID_POWERF: &[u8; 9] = b"LNXPWRBN\0";
pub const ACPI_BUTTON_HID_SLEEPF: &[u8; 9] = b"LNXSLPBN\0";
pub const ACPI_VIDEO_HID: &[u8; 9] = b"LNXVIDEO\0";
pub const ACPI_BAY_HID: &[u8; 9] = b"LNXIOBAY\0";
pub const ACPI_DOCK_HID: &[u8; 8] = b"LNXDOCK\0";
pub const ACPI_ECDT_HID: &[u8; 6] = b"LNXEC\0";
pub const ACPI_SMBUS_MS_HID: &[u8; 8] = b"SMB0001\0";
pub const ACPI_SMBUS_IBM_HID: &[u8; 9] = b"SMBUSIBM\0";
pub const ACPI_FIXED_HARDWARE_EVENT: u32 = 256;
pub const PMD_ORDER: u32 = 9;
pub const PUD_ORDER: u32 = 18;
pub const USER_PGTABLES_CEILING: u32 = 0;
pub const FIRST_USER_ADDRESS: u32 = 0;
pub const ARCH_PAGE_TABLE_SYNC_MASK: u32 = 0;
pub const __PGTBL_PGD_MODIFIED: u32 = 0;
pub const __PGTBL_P4D_MODIFIED: u32 = 1;
pub const __PGTBL_PUD_MODIFIED: u32 = 2;
pub const __PGTBL_PMD_MODIFIED: u32 = 3;
pub const __PGTBL_PTE_MODIFIED: u32 = 4;
pub const IO_SPACE_LIMIT: u32 = 16777215;
pub const PIO_INDIRECT_SIZE: u32 = 0;
pub const MMIO_UPPER_LIMIT: u32 = 16777215;
pub const PHYS_CPUID_INVALID: i32 = -1;
pub const acpi_strict: u32 = 1;
pub const ACPI_SPACE_MEM: u32 = 0;
pub const ACPI_VIDEO_OUTPUT_SWITCHING: u32 = 1;
pub const ACPI_VIDEO_DEVICE_POSTING: u32 = 2;
pub const ACPI_VIDEO_ROM_AVAILABLE: u32 = 4;
pub const ACPI_VIDEO_BACKLIGHT: u32 = 8;
pub const ACPI_VIDEO_BACKLIGHT_FORCE_VENDOR: u32 = 16;
pub const ACPI_VIDEO_BACKLIGHT_FORCE_VIDEO: u32 = 32;
pub const ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VENDOR: u32 = 64;
pub const ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VIDEO: u32 = 128;
pub const ACPI_VIDEO_BACKLIGHT_DMI_VENDOR: u32 = 256;
pub const ACPI_VIDEO_BACKLIGHT_DMI_VIDEO: u32 = 512;
pub const ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR: u32 = 1024;
pub const ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO: u32 = 2048;
pub const PXM_INVAL: i32 = -1;
pub const OSC_PCI_CAPABILITY_DWORDS: u32 = 3;
pub const OSC_CXL_CAPABILITY_DWORDS: u32 = 5;
pub const OSC_QUERY_DWORD: u32 = 0;
pub const OSC_SUPPORT_DWORD: u32 = 1;
pub const OSC_CONTROL_DWORD: u32 = 2;
pub const OSC_EXT_SUPPORT_DWORD: u32 = 3;
pub const OSC_EXT_CONTROL_DWORD: u32 = 4;
pub const OSC_QUERY_ENABLE: u32 = 1;
pub const OSC_REQUEST_ERROR: u32 = 2;
pub const OSC_INVALID_UUID_ERROR: u32 = 4;
pub const OSC_INVALID_REVISION_ERROR: u32 = 8;
pub const OSC_CAPABILITIES_MASK_ERROR: u32 = 16;
pub const OSC_SB_PAD_SUPPORT: u32 = 1;
pub const OSC_SB_PPC_OST_SUPPORT: u32 = 2;
pub const OSC_SB_PR3_SUPPORT: u32 = 4;
pub const OSC_SB_HOTPLUG_OST_SUPPORT: u32 = 8;
pub const OSC_SB_APEI_SUPPORT: u32 = 16;
pub const OSC_SB_CPC_SUPPORT: u32 = 32;
pub const OSC_SB_CPCV2_SUPPORT: u32 = 64;
pub const OSC_SB_PCLPI_SUPPORT: u32 = 128;
pub const OSC_SB_OSLPI_SUPPORT: u32 = 256;
pub const OSC_SB_FAST_THERMAL_SAMPLING_SUPPORT: u32 = 512;
pub const OSC_SB_OVER_16_PSTATES_SUPPORT: u32 = 1024;
pub const OSC_SB_GED_SUPPORT: u32 = 2048;
pub const OSC_SB_CPC_DIVERSE_HIGH_SUPPORT: u32 = 4096;
pub const OSC_SB_IRQ_RESOURCE_SOURCE_SUPPORT: u32 = 8192;
pub const OSC_SB_CPC_FLEXIBLE_ADR_SPACE: u32 = 16384;
pub const OSC_SB_GENERIC_INITIATOR_SUPPORT: u32 = 131072;
pub const OSC_SB_NATIVE_USB4_SUPPORT: u32 = 262144;
pub const OSC_SB_BATTERY_CHARGE_LIMITING_SUPPORT: u32 = 524288;
pub const OSC_SB_PRM_SUPPORT: u32 = 2097152;
pub const OSC_SB_FFH_OPR_SUPPORT: u32 = 4194304;
pub const OSC_USB_USB3_TUNNELING: u32 = 1;
pub const OSC_USB_DP_TUNNELING: u32 = 2;
pub const OSC_USB_PCIE_TUNNELING: u32 = 4;
pub const OSC_USB_XDOMAIN: u32 = 8;
pub const OSC_PCI_EXT_CONFIG_SUPPORT: u32 = 1;
pub const OSC_PCI_ASPM_SUPPORT: u32 = 2;
pub const OSC_PCI_CLOCK_PM_SUPPORT: u32 = 4;
pub const OSC_PCI_SEGMENT_GROUPS_SUPPORT: u32 = 8;
pub const OSC_PCI_MSI_SUPPORT: u32 = 16;
pub const OSC_PCI_EDR_SUPPORT: u32 = 128;
pub const OSC_PCI_HPX_TYPE_3_SUPPORT: u32 = 256;
pub const OSC_PCI_EXPRESS_NATIVE_HP_CONTROL: u32 = 1;
pub const OSC_PCI_SHPC_NATIVE_HP_CONTROL: u32 = 2;
pub const OSC_PCI_EXPRESS_PME_CONTROL: u32 = 4;
pub const OSC_PCI_EXPRESS_AER_CONTROL: u32 = 8;
pub const OSC_PCI_EXPRESS_CAPABILITY_CONTROL: u32 = 16;
pub const OSC_PCI_EXPRESS_LTR_CONTROL: u32 = 32;
pub const OSC_PCI_EXPRESS_DPC_CONTROL: u32 = 128;
pub const OSC_CXL_1_1_PORT_REG_ACCESS_SUPPORT: u32 = 1;
pub const OSC_CXL_2_0_PORT_DEV_REG_ACCESS_SUPPORT: u32 = 2;
pub const OSC_CXL_PROTOCOL_ERR_REPORTING_SUPPORT: u32 = 4;
pub const OSC_CXL_NATIVE_HP_SUPPORT: u32 = 8;
pub const OSC_CXL_ERROR_REPORTING_CONTROL: u32 = 1;
pub const ACPI_GSB_ACCESS_ATTRIB_QUICK: u32 = 2;
pub const ACPI_GSB_ACCESS_ATTRIB_SEND_RCV: u32 = 4;
pub const ACPI_GSB_ACCESS_ATTRIB_BYTE: u32 = 6;
pub const ACPI_GSB_ACCESS_ATTRIB_WORD: u32 = 8;
pub const ACPI_GSB_ACCESS_ATTRIB_BLOCK: u32 = 10;
pub const ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE: u32 = 11;
pub const ACPI_GSB_ACCESS_ATTRIB_WORD_CALL: u32 = 12;
pub const ACPI_GSB_ACCESS_ATTRIB_BLOCK_CALL: u32 = 13;
pub const ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES: u32 = 14;
pub const ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS: u32 = 15;
pub const ACPI_OST_EC_OSPM_SHUTDOWN: u32 = 256;
pub const ACPI_OST_EC_OSPM_EJECT: u32 = 259;
pub const ACPI_OST_EC_OSPM_INSERTION: u32 = 512;
pub const ACPI_OST_SC_SUCCESS: u32 = 0;
pub const ACPI_OST_SC_NON_SPECIFIC_FAILURE: u32 = 1;
pub const ACPI_OST_SC_UNRECOGNIZED_NOTIFY: u32 = 2;
pub const ACPI_OST_SC_OS_SHUTDOWN_DENIED: u32 = 128;
pub const ACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS: u32 = 129;
pub const ACPI_OST_SC_OS_SHUTDOWN_COMPLETED: u32 = 130;
pub const ACPI_OST_SC_OS_SHUTDOWN_NOT_SUPPORTED: u32 = 131;
pub const ACPI_OST_SC_EJECT_NOT_SUPPORTED: u32 = 128;
pub const ACPI_OST_SC_DEVICE_IN_USE: u32 = 129;
pub const ACPI_OST_SC_DEVICE_BUSY: u32 = 130;
pub const ACPI_OST_SC_EJECT_DEPENDENCY_BUSY: u32 = 131;
pub const ACPI_OST_SC_EJECT_IN_PROGRESS: u32 = 132;
pub const ACPI_OST_SC_INSERT_IN_PROGRESS: u32 = 128;
pub const ACPI_OST_SC_DRIVER_LOAD_FAILURE: u32 = 129;
pub const ACPI_OST_SC_INSERT_NOT_SUPPORTED: u32 = 130;
pub const ACPI_TABLE_ID_LEN: u32 = 5;
pub const STACK_DEPOT_EXTRA_BITS: u32 = 5;
pub const DEPOT_POOL_ORDER: u32 = 2;
pub const DEPOT_POOL_SIZE: u32 = 16384;
pub const DEPOT_STACK_ALIGN: u32 = 4;
pub const DEPOT_OFFSET_BITS: u32 = 10;
pub const STACK_DEPOT_FLAGS_NUM: u32 = 2;
pub const DRM_NAME: &[u8; 4] = b"drm\0";
pub const DRM_MIN_ORDER: u32 = 5;
pub const DRM_MAX_ORDER: u32 = 22;
pub const DRM_RAM_PERCENT: u32 = 10;
pub const _DRM_LOCK_HELD: u32 = 2147483648;
pub const _DRM_LOCK_CONT: u32 = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: u32 = 1;
pub const _DRM_PRE_MODESET: u32 = 1;
pub const _DRM_POST_MODESET: u32 = 2;
pub const DRM_CAP_DUMB_BUFFER: u32 = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: u32 = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: u32 = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: u32 = 4;
pub const DRM_CAP_PRIME: u32 = 5;
pub const DRM_PRIME_CAP_IMPORT: u32 = 1;
pub const DRM_PRIME_CAP_EXPORT: u32 = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: u32 = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: u32 = 7;
pub const DRM_CAP_CURSOR_WIDTH: u32 = 8;
pub const DRM_CAP_CURSOR_HEIGHT: u32 = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: u32 = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: u32 = 17;
pub const DRM_CAP_CRTC_IN_VBLANK_EVENT: u32 = 18;
pub const DRM_CAP_SYNCOBJ: u32 = 19;
pub const DRM_CAP_SYNCOBJ_TIMELINE: u32 = 20;
pub const DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP: u32 = 21;
pub const DRM_CLIENT_CAP_STEREO_3D: u32 = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: u32 = 2;
pub const DRM_CLIENT_CAP_ATOMIC: u32 = 3;
pub const DRM_CLIENT_CAP_ASPECT_RATIO: u32 = 4;
pub const DRM_CLIENT_CAP_WRITEBACK_CONNECTORS: u32 = 5;
pub const DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT: u32 = 6;
pub const DRM_RDWR: u32 = 2;
pub const DRM_CLOEXEC: u32 = 524288;
pub const DRM_SYNCOBJ_CREATE_SIGNALED: u32 = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_TIMELINE: u32 = 2;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_TIMELINE: u32 = 2;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL: u32 = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT: u32 = 2;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE: u32 = 4;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_DEADLINE: u32 = 8;
pub const DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED: u32 = 1;
pub const DRM_CRTC_SEQUENCE_RELATIVE: u32 = 1;
pub const DRM_CRTC_SEQUENCE_NEXT_ON_MISS: u32 = 2;
pub const DRM_CLIENT_NAME_MAX_LEN: u32 = 64;
pub const DRM_CONNECTOR_NAME_LEN: u32 = 32;
pub const DRM_DISPLAY_MODE_LEN: u32 = 32;
pub const DRM_PROP_NAME_LEN: u32 = 32;
pub const DRM_MODE_TYPE_BUILTIN: u32 = 1;
pub const DRM_MODE_TYPE_CLOCK_C: u32 = 3;
pub const DRM_MODE_TYPE_CRTC_C: u32 = 5;
pub const DRM_MODE_TYPE_PREFERRED: u32 = 8;
pub const DRM_MODE_TYPE_DEFAULT: u32 = 16;
pub const DRM_MODE_TYPE_USERDEF: u32 = 32;
pub const DRM_MODE_TYPE_DRIVER: u32 = 64;
pub const DRM_MODE_TYPE_ALL: u32 = 104;
pub const DRM_MODE_FLAG_PHSYNC: u32 = 1;
pub const DRM_MODE_FLAG_NHSYNC: u32 = 2;
pub const DRM_MODE_FLAG_PVSYNC: u32 = 4;
pub const DRM_MODE_FLAG_NVSYNC: u32 = 8;
pub const DRM_MODE_FLAG_INTERLACE: u32 = 16;
pub const DRM_MODE_FLAG_DBLSCAN: u32 = 32;
pub const DRM_MODE_FLAG_CSYNC: u32 = 64;
pub const DRM_MODE_FLAG_PCSYNC: u32 = 128;
pub const DRM_MODE_FLAG_NCSYNC: u32 = 256;
pub const DRM_MODE_FLAG_HSKEW: u32 = 512;
pub const DRM_MODE_FLAG_BCAST: u32 = 1024;
pub const DRM_MODE_FLAG_PIXMUX: u32 = 2048;
pub const DRM_MODE_FLAG_DBLCLK: u32 = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: u32 = 8192;
pub const DRM_MODE_FLAG_3D_MASK: u32 = 507904;
pub const DRM_MODE_FLAG_3D_NONE: u32 = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: u32 = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: u32 = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: u32 = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: u32 = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: u32 = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: u32 = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: u32 = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: u32 = 131072;
pub const DRM_MODE_PICTURE_ASPECT_NONE: u32 = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: u32 = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: u32 = 2;
pub const DRM_MODE_PICTURE_ASPECT_64_27: u32 = 3;
pub const DRM_MODE_PICTURE_ASPECT_256_135: u32 = 4;
pub const DRM_MODE_CONTENT_TYPE_NO_DATA: u32 = 0;
pub const DRM_MODE_CONTENT_TYPE_GRAPHICS: u32 = 1;
pub const DRM_MODE_CONTENT_TYPE_PHOTO: u32 = 2;
pub const DRM_MODE_CONTENT_TYPE_CINEMA: u32 = 3;
pub const DRM_MODE_CONTENT_TYPE_GAME: u32 = 4;
pub const DRM_MODE_FLAG_PIC_AR_MASK: u32 = 7864320;
pub const DRM_MODE_FLAG_PIC_AR_NONE: u32 = 0;
pub const DRM_MODE_FLAG_PIC_AR_4_3: u32 = 524288;
pub const DRM_MODE_FLAG_PIC_AR_16_9: u32 = 1048576;
pub const DRM_MODE_FLAG_PIC_AR_64_27: u32 = 1572864;
pub const DRM_MODE_FLAG_PIC_AR_256_135: u32 = 2097152;
pub const DRM_MODE_FLAG_ALL: u32 = 521215;
pub const DRM_MODE_DPMS_ON: u32 = 0;
pub const DRM_MODE_DPMS_STANDBY: u32 = 1;
pub const DRM_MODE_DPMS_SUSPEND: u32 = 2;
pub const DRM_MODE_DPMS_OFF: u32 = 3;
pub const DRM_MODE_SCALE_NONE: u32 = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: u32 = 1;
pub const DRM_MODE_SCALE_CENTER: u32 = 2;
pub const DRM_MODE_SCALE_ASPECT: u32 = 3;
pub const DRM_MODE_DITHERING_OFF: u32 = 0;
pub const DRM_MODE_DITHERING_ON: u32 = 1;
pub const DRM_MODE_DITHERING_AUTO: u32 = 2;
pub const DRM_MODE_DIRTY_OFF: u32 = 0;
pub const DRM_MODE_DIRTY_ON: u32 = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: u32 = 2;
pub const DRM_MODE_LINK_STATUS_GOOD: u32 = 0;
pub const DRM_MODE_LINK_STATUS_BAD: u32 = 1;
pub const DRM_MODE_ROTATE_0: u32 = 1;
pub const DRM_MODE_ROTATE_90: u32 = 2;
pub const DRM_MODE_ROTATE_180: u32 = 4;
pub const DRM_MODE_ROTATE_270: u32 = 8;
pub const DRM_MODE_ROTATE_MASK: u32 = 15;
pub const DRM_MODE_REFLECT_X: u32 = 16;
pub const DRM_MODE_REFLECT_Y: u32 = 32;
pub const DRM_MODE_REFLECT_MASK: u32 = 48;
pub const DRM_MODE_CONTENT_PROTECTION_UNDESIRED: u32 = 0;
pub const DRM_MODE_CONTENT_PROTECTION_DESIRED: u32 = 1;
pub const DRM_MODE_CONTENT_PROTECTION_ENABLED: u32 = 2;
pub const DRM_MODE_PRESENT_TOP_FIELD: u32 = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: u32 = 2;
pub const DRM_MODE_ENCODER_NONE: u32 = 0;
pub const DRM_MODE_ENCODER_DAC: u32 = 1;
pub const DRM_MODE_ENCODER_TMDS: u32 = 2;
pub const DRM_MODE_ENCODER_LVDS: u32 = 3;
pub const DRM_MODE_ENCODER_TVDAC: u32 = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: u32 = 5;
pub const DRM_MODE_ENCODER_DSI: u32 = 6;
pub const DRM_MODE_ENCODER_DPMST: u32 = 7;
pub const DRM_MODE_ENCODER_DPI: u32 = 8;
pub const DRM_MODE_CONNECTOR_Unknown: u32 = 0;
pub const DRM_MODE_CONNECTOR_VGA: u32 = 1;
pub const DRM_MODE_CONNECTOR_DVII: u32 = 2;
pub const DRM_MODE_CONNECTOR_DVID: u32 = 3;
pub const DRM_MODE_CONNECTOR_DVIA: u32 = 4;
pub const DRM_MODE_CONNECTOR_Composite: u32 = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: u32 = 6;
pub const DRM_MODE_CONNECTOR_LVDS: u32 = 7;
pub const DRM_MODE_CONNECTOR_Component: u32 = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: u32 = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: u32 = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: u32 = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: u32 = 12;
pub const DRM_MODE_CONNECTOR_TV: u32 = 13;
pub const DRM_MODE_CONNECTOR_eDP: u32 = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: u32 = 15;
pub const DRM_MODE_CONNECTOR_DSI: u32 = 16;
pub const DRM_MODE_CONNECTOR_DPI: u32 = 17;
pub const DRM_MODE_CONNECTOR_WRITEBACK: u32 = 18;
pub const DRM_MODE_CONNECTOR_SPI: u32 = 19;
pub const DRM_MODE_CONNECTOR_USB: u32 = 20;
pub const DRM_MODE_PROP_PENDING: u32 = 1;
pub const DRM_MODE_PROP_RANGE: u32 = 2;
pub const DRM_MODE_PROP_IMMUTABLE: u32 = 4;
pub const DRM_MODE_PROP_ENUM: u32 = 8;
pub const DRM_MODE_PROP_BLOB: u32 = 16;
pub const DRM_MODE_PROP_BITMASK: u32 = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: u32 = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: u32 = 65472;
pub const DRM_MODE_PROP_ATOMIC: u32 = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: u32 = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: u32 = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: u32 = 3772834016;
pub const DRM_MODE_OBJECT_MODE: u32 = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: u32 = 2964369584;
pub const DRM_MODE_OBJECT_FB: u32 = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: u32 = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: u32 = 4008636142;
pub const DRM_MODE_OBJECT_ANY: u32 = 0;
pub const DRM_MODE_FB_INTERLACED: u32 = 1;
pub const DRM_MODE_FB_MODIFIERS: u32 = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: u32 = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: u32 = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: u32 = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: u32 = 256;
pub const DRM_MODE_CURSOR_BO: u32 = 1;
pub const DRM_MODE_CURSOR_MOVE: u32 = 2;
pub const DRM_MODE_CURSOR_FLAGS: u32 = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: u32 = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: u32 = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: u32 = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: u32 = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: u32 = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: u32 = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: u32 = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: u32 = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: u32 = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: u32 = 1795;
pub const FORMAT_BLOB_CURRENT: u32 = 1;
pub const DRM_IOCTL_BASE: u8 = 100u8;
pub const DRM_COMMAND_BASE: u32 = 64;
pub const DRM_COMMAND_END: u32 = 160;
pub const DRM_EVENT_VBLANK: u32 = 1;
pub const DRM_EVENT_FLIP_COMPLETE: u32 = 2;
pub const DRM_EVENT_CRTC_SEQUENCE: u32 = 3;
pub const PGMAP_ALTMAP_VALID: u32 = 1;
pub const DIRECT_MAP_PHYSMEM_END: u64 = 72057594037927935;
pub const MAPCOUNT_ELF_CORE_MARGIN: u32 = 5;
pub const VM_NONE: u32 = 0;
pub const VM_READ: u32 = 1;
pub const VM_WRITE: u32 = 2;
pub const VM_EXEC: u32 = 4;
pub const VM_SHARED: u32 = 8;
pub const VM_MAYREAD: u32 = 16;
pub const VM_MAYWRITE: u32 = 32;
pub const VM_MAYEXEC: u32 = 64;
pub const VM_MAYSHARE: u32 = 128;
pub const VM_GROWSDOWN: u32 = 256;
pub const VM_UFFD_MISSING: u32 = 512;
pub const VM_PFNMAP: u32 = 1024;
pub const VM_UFFD_WP: u32 = 4096;
pub const VM_LOCKED: u32 = 8192;
pub const VM_IO: u32 = 16384;
pub const VM_SEQ_READ: u32 = 32768;
pub const VM_RAND_READ: u32 = 65536;
pub const VM_DONTCOPY: u32 = 131072;
pub const VM_DONTEXPAND: u32 = 262144;
pub const VM_LOCKONFAULT: u32 = 524288;
pub const VM_ACCOUNT: u32 = 1048576;
pub const VM_NORESERVE: u32 = 2097152;
pub const VM_HUGETLB: u32 = 4194304;
pub const VM_SYNC: u32 = 8388608;
pub const VM_ARCH_1: u32 = 16777216;
pub const VM_WIPEONFORK: u32 = 33554432;
pub const VM_DONTDUMP: u32 = 67108864;
pub const VM_SOFTDIRTY: u32 = 0;
pub const VM_MIXEDMAP: u32 = 268435456;
pub const VM_HUGEPAGE: u32 = 536870912;
pub const VM_NOHUGEPAGE: u32 = 1073741824;
pub const VM_MERGEABLE: u32 = 2147483648;
pub const VM_SHADOW_STACK: u32 = 0;
pub const VM_MTE: u32 = 0;
pub const VM_MTE_ALLOWED: u32 = 0;
pub const VM_GROWSUP: u32 = 0;
pub const VM_UFFD_MINOR: u32 = 0;
pub const VM_ALLOW_ANY_UNCACHED_BIT: u32 = 39;
pub const VM_DROPPABLE_BIT: u32 = 40;
pub const VM_SEALED_BIT: u32 = 42;
pub const VM_DATA_FLAGS_NON_EXEC: u32 = 115;
pub const VM_DATA_FLAGS_EXEC: u32 = 119;
pub const VM_STARTGAP_FLAGS: u32 = 256;
pub const VM_STACK: u32 = 256;
pub const VM_STACK_EARLY: u32 = 0;
pub const VM_ACCESS_FLAGS: u32 = 7;
pub const VM_SPECIAL: u32 = 268715008;
pub const VM_NO_KHUGEPAGED: u32 = 272909312;
pub const VM_INIT_DEF_MASK: u32 = 1073741824;
pub const VM_LOCKED_MASK: u32 = 532480;
pub const VM_ARCH_CLEAR: u32 = 0;
pub const TVA_SMAPS: u32 = 1;
pub const TVA_IN_PF: u32 = 2;
pub const TVA_ENFORCE_SYSFS: u32 = 4;
pub const HPAGE_PMD_SHIFT: u32 = 21;
pub const HPAGE_PUD_SHIFT: u32 = 30;
pub const HPAGE_PMD_ORDER: u32 = 9;
pub const HPAGE_PMD_NR: u32 = 512;
pub const HPAGE_PMD_SIZE: u32 = 2097152;
pub const HPAGE_PUD_ORDER: u32 = 18;
pub const HPAGE_PUD_NR: u32 = 262144;
pub const HPAGE_PUD_SIZE: u32 = 1073741824;
pub const transparent_hugepage_flags: u32 = 0;
pub const GUP_PIN_COUNTING_BIAS: u32 = 1024;
pub const MAX_FOLIO_NR_PAGES: u32 = 262144;
pub const MM_CP_TRY_CHANGE_WRITABLE: u32 = 1;
pub const MM_CP_PROT_NUMA: u32 = 2;
pub const MM_CP_UFFD_WP: u32 = 4;
pub const MM_CP_UFFD_WP_RESOLVE: u32 = 8;
pub const MM_CP_UFFD_WP_ALL: u32 = 12;
pub const VM_UNMAPPED_AREA_TOPDOWN: u32 = 1;
pub const VMEMMAP_RESERVE_NR: u32 = 2;
pub const VM_SEALED_SYSMAP: u32 = 0;
pub const PAGE_SNAPSHOT_FAITHFUL: u32 = 1;
pub const PAGE_SNAPSHOT_PG_BUDDY: u32 = 2;
pub const PAGE_SNAPSHOT_PG_IDLE: u32 = 4;
pub const SG_CHAIN: u32 = 1;
pub const SG_END: u32 = 2;
pub const SG_PAGE_LINK_MASK: u32 = 3;
pub const SG_CHUNK_SIZE: u32 = 128;
pub const SG_MAX_SEGMENTS: u32 = 2048;
pub const SG_MITER_ATOMIC: u32 = 1;
pub const SG_MITER_TO_SG: u32 = 2;
pub const SG_MITER_FROM_SG: u32 = 4;
pub const SG_MITER_LOCAL: u32 = 8;
pub const FDPUT_FPUT: u32 = 1;
pub const FDPUT_POS_UNLOCK: u32 = 2;
pub const DMA_ATTR_WEAK_ORDERING: u32 = 2;
pub const DMA_ATTR_WRITE_COMBINE: u32 = 4;
pub const DMA_ATTR_NO_KERNEL_MAPPING: u32 = 16;
pub const DMA_ATTR_SKIP_CPU_SYNC: u32 = 32;
pub const DMA_ATTR_FORCE_CONTIGUOUS: u32 = 64;
pub const DMA_ATTR_ALLOC_SINGLE_PAGES: u32 = 128;
pub const DMA_ATTR_NO_WARN: u32 = 256;
pub const DMA_ATTR_PRIVILEGED: u32 = 512;
pub const DMA_IOVA_USE_SWIOTLB: i64 = -9223372036854775808;
pub const DRM_MM_NODE_ALLOCATED_BIT: u32 = 0;
pub const DRM_MM_NODE_SCANNED_BIT: u32 = 1;
pub const DRM_FILE_PAGE_OFFSET_START: u32 = 1048576;
pub const DRM_FILE_PAGE_OFFSET_SIZE: u32 = 268435200;
pub const DRM_MAJOR: u32 = 226;
pub const KUNIT_PARAM_DESC_SIZE: u32 = 128;
pub const KUNIT_STATUS_COMMENT_SIZE: u32 = 256;
pub const KUNIT_INDENT_LEN: u32 = 4;
pub const KUNIT_SUBTEST_INDENT: &[u8; 5] = b"    \0";
pub const KUNIT_SUBSUBTEST_INDENT: &[u8; 9] = b"        \0";
pub const ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE: u32 = 1;
pub const SYS_RISCV_FLUSH_ICACHE_LOCAL: u32 = 1;
pub const SYS_RISCV_FLUSH_ICACHE_ALL: u32 = 1;
pub const IRQF_TRIGGER_NONE: u32 = 0;
pub const IRQF_TRIGGER_RISING: u32 = 1;
pub const IRQF_TRIGGER_FALLING: u32 = 2;
pub const IRQF_TRIGGER_HIGH: u32 = 4;
pub const IRQF_TRIGGER_LOW: u32 = 8;
pub const IRQF_TRIGGER_MASK: u32 = 15;
pub const IRQF_TRIGGER_PROBE: u32 = 16;
pub const IRQF_SHARED: u32 = 128;
pub const IRQF_PROBE_SHARED: u32 = 256;
pub const __IRQF_TIMER: u32 = 512;
pub const IRQF_PERCPU: u32 = 1024;
pub const IRQF_NOBALANCING: u32 = 2048;
pub const IRQF_IRQPOLL: u32 = 4096;
pub const IRQF_ONESHOT: u32 = 8192;
pub const IRQF_NO_SUSPEND: u32 = 16384;
pub const IRQF_FORCE_RESUME: u32 = 32768;
pub const IRQF_NO_THREAD: u32 = 65536;
pub const IRQF_EARLY_RESUME: u32 = 131072;
pub const IRQF_COND_SUSPEND: u32 = 262144;
pub const IRQF_NO_AUTOEN: u32 = 524288;
pub const IRQF_NO_DEBUG: u32 = 1048576;
pub const IRQF_COND_ONESHOT: u32 = 2097152;
pub const IRQF_TIMER: u32 = 82432;
pub const IRQ_NOTCONNECTED: u32 = 2147483648;
pub const IRQ_AFFINITY_MAX_SETS: u32 = 4;
pub const NR_IRQS: u32 = 64;
pub const INVALID_CONTEXT: i32 = -1;
pub const NR_IRQS_LEGACY: u32 = 0;
pub const ARCH_IRQ_INIT_FLAGS: u32 = 0;
pub const IRQ_DEFAULT_INIT_FLAGS: u32 = 0;
pub const INVALID_HWIRQ: i32 = -1;
pub const SECTOR_SHIFT: u32 = 9;
pub const SECTOR_SIZE: u32 = 512;
pub const PAGE_SECTORS_SHIFT: u32 = 3;
pub const PAGE_SECTORS: u32 = 8;
pub const SECTOR_MASK: u32 = 7;
pub const BD_PARTNO: u32 = 255;
pub const BD_READ_ONLY: u32 = 256;
pub const BD_WRITE_HOLDER: u32 = 512;
pub const BD_HAS_SUBMIT_BIO: u32 = 1024;
pub const BD_RO_WARNED: u32 = 2048;
pub const BLK_STS_OK: u32 = 0;
pub const BLK_QC_T_NONE: i32 = -1;
pub const BIO_MAX_SECTORS: i32 = -1;
pub const REQ_OP_BITS: u32 = 8;
pub const REQ_FLAG_BITS: u32 = 24;
pub const BIO_MAX_VECS: u32 = 256;
pub const BIO_MAX_INLINE_VECS: u32 = 1024;
pub const BIO_POOL_SIZE: u32 = 2;
pub const SBQ_WAIT_QUEUES: u32 = 8;
pub const SBQ_WAKE_BATCH: u32 = 8;
pub const BLKCG_MAX_POLS: u32 = 6;
pub const DISK_MAX_PARTS: u32 = 256;
pub const DISK_NAME_LEN: u32 = 32;
pub const PARTITION_META_INFO_VOLNAMELTH: u32 = 64;
pub const PARTITION_META_INFO_UUIDLTH: u32 = 37;
pub const GD_NEED_PART_SCAN: u32 = 0;
pub const GD_READ_ONLY: u32 = 1;
pub const GD_DEAD: u32 = 2;
pub const GD_NATIVE_CAPACITY: u32 = 3;
pub const GD_ADDED: u32 = 4;
pub const GD_SUPPRESS_PART_SCAN: u32 = 5;
pub const GD_OWNS_QUEUE: u32 = 6;
pub const BLK_DEFAULT_SG_TIMEOUT: u32 = 15000;
pub const BLK_MIN_SG_TIMEOUT: u32 = 1750;
pub const BLK_POLL_ONESHOT: u32 = 1;
pub const BLKDEV_ZERO_NOUNMAP: u32 = 1;
pub const BLKDEV_ZERO_NOFALLBACK: u32 = 2;
pub const BLKDEV_ZERO_KILLABLE: u32 = 4;
pub const BDEVNAME_SIZE: u32 = 32;
pub const BDEVT_SIZE: u32 = 10;
pub const BLKDEV_MAJOR_MAX: u32 = 512;
pub const PREFETCH_STRIDE: u32 = 256;
pub const BLKDEV_MIN_RQ: u32 = 4;
pub const BLKDEV_DEFAULT_RQ: u32 = 128;
pub const BLK_MQ_MAX_DEPTH: u32 = 10240;
pub const BLK_MQ_NO_HCTX_IDX: i32 = -1;
pub const CONFIGFS_ITEM_NAME_LEN: u32 = 20;
pub const cpu_smt_num_threads: u32 = 1;
pub const CPU_ONLINE: u32 = 2;
pub const CPU_UP_PREPARE: u32 = 3;
pub const CPU_DEAD: u32 = 7;
pub const CPU_DEAD_FROZEN: u32 = 8;
pub const CPU_POST_DEAD: u32 = 9;
pub const CPU_BROKEN: u32 = 11;
pub const MAX_PHANDLE_ARGS: u32 = 16;
pub const OF_DYNAMIC: u32 = 1;
pub const OF_DETACHED: u32 = 2;
pub const OF_POPULATED: u32 = 3;
pub const OF_POPULATED_BUS: u32 = 4;
pub const OF_OVERLAY: u32 = 5;
pub const OF_OVERLAY_FREE_CSET: u32 = 6;
pub const OF_RECONFIG_ATTACH_NODE: u32 = 1;
pub const OF_RECONFIG_DETACH_NODE: u32 = 2;
pub const OF_RECONFIG_ADD_PROPERTY: u32 = 3;
pub const OF_RECONFIG_REMOVE_PROPERTY: u32 = 4;
pub const OF_RECONFIG_UPDATE_PROPERTY: u32 = 5;
pub const PM_QOS_DEFAULT_VALUE: i32 = -1;
pub const PM_QOS_CPU_LATENCY_DEFAULT_VALUE: u32 = 2000000000;
pub const PM_QOS_LATENCY_TOLERANCE_DEFAULT_VALUE: u32 = 0;
pub const PM_QOS_MIN_FREQUENCY_DEFAULT_VALUE: u32 = 0;
pub const PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT: i32 = -1;
pub const PM_QOS_FLAG_NO_POWER_OFF: u32 = 1;
pub const FREQ_QOS_MIN_DEFAULT_VALUE: u32 = 0;
pub const CPUFREQ_ETERNAL: i32 = -1;
pub const CPUFREQ_NAME_LEN: u32 = 16;
pub const CPUFREQ_NAME_PLEN: u32 = 17;
pub const CPUFREQ_SHARED_TYPE_NONE: u32 = 0;
pub const CPUFREQ_SHARED_TYPE_HW: u32 = 1;
pub const CPUFREQ_SHARED_TYPE_ALL: u32 = 2;
pub const CPUFREQ_SHARED_TYPE_ANY: u32 = 3;
pub const CPUFREQ_RELATION_L: u32 = 0;
pub const CPUFREQ_RELATION_H: u32 = 1;
pub const CPUFREQ_RELATION_C: u32 = 2;
pub const CPUFREQ_TRANSITION_NOTIFIER: u32 = 0;
pub const CPUFREQ_POLICY_NOTIFIER: u32 = 1;
pub const CPUFREQ_PRECHANGE: u32 = 0;
pub const CPUFREQ_POSTCHANGE: u32 = 1;
pub const CPUFREQ_CREATE_POLICY: u32 = 0;
pub const CPUFREQ_REMOVE_POLICY: u32 = 1;
pub const CPUFREQ_POLICY_UNKNOWN: u32 = 0;
pub const CPUFREQ_POLICY_POWERSAVE: u32 = 1;
pub const CPUFREQ_POLICY_PERFORMANCE: u32 = 2;
pub const CPUFREQ_ENTRY_INVALID: i32 = -1;
pub const CPUFREQ_TABLE_END: i32 = -2;
pub const CPUFREQ_BOOST_FREQ: u32 = 1;
pub const CPUFREQ_INEFFICIENT_FREQ: u32 = 2;
pub const IPV6_FL_A_GET: u32 = 0;
pub const IPV6_FL_A_PUT: u32 = 1;
pub const IPV6_FL_A_RENEW: u32 = 2;
pub const IPV6_FL_F_CREATE: u32 = 1;
pub const IPV6_FL_F_EXCL: u32 = 2;
pub const IPV6_FL_F_REFLECT: u32 = 4;
pub const IPV6_FL_F_REMOTE: u32 = 8;
pub const IPV6_FL_S_NONE: u32 = 0;
pub const IPV6_FL_S_EXCL: u32 = 1;
pub const IPV6_FL_S_PROCESS: u32 = 2;
pub const IPV6_FL_S_USER: u32 = 3;
pub const IPV6_FL_S_ANY: u32 = 255;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const IPV6_PRIORITY_FILLER: u32 = 256;
pub const IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const IPV6_PRIORITY_BULK: u32 = 1024;
pub const IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const IPV6_PRIORITY_8: u32 = 2048;
pub const IPV6_PRIORITY_9: u32 = 2304;
pub const IPV6_PRIORITY_10: u32 = 2560;
pub const IPV6_PRIORITY_11: u32 = 2816;
pub const IPV6_PRIORITY_12: u32 = 3072;
pub const IPV6_PRIORITY_13: u32 = 3328;
pub const IPV6_PRIORITY_14: u32 = 3584;
pub const IPV6_PRIORITY_15: u32 = 3840;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_MH: u32 = 135;
pub const IPV6_TLV_PAD1: u32 = 0;
pub const IPV6_TLV_PADN: u32 = 1;
pub const IPV6_TLV_ROUTERALERT: u32 = 5;
pub const IPV6_TLV_CALIPSO: u32 = 7;
pub const IPV6_TLV_IOAM: u32 = 49;
pub const IPV6_TLV_JUMBO: u32 = 194;
pub const IPV6_TLV_HAO: u32 = 201;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_FLOWINFO: u32 = 11;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_FLOWLABEL_MGR: u32 = 32;
pub const IPV6_FLOWINFO_SEND: u32 = 33;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const SIPHASH_CONST_0: u64 = 8317987319222330741;
pub const SIPHASH_CONST_1: u64 = 7237128888997146477;
pub const SIPHASH_CONST_2: u64 = 7816392313619706465;
pub const SIPHASH_CONST_3: u64 = 8387220255154660723;
pub const HSIPHASH_CONST_0: u32 = 0;
pub const HSIPHASH_CONST_1: u32 = 0;
pub const HSIPHASH_CONST_2: u32 = 1819895653;
pub const HSIPHASH_CONST_3: u32 = 1952801890;
pub const ETH_ALEN: u32 = 6;
pub const ETH_TLEN: u32 = 2;
pub const ETH_HLEN: u32 = 14;
pub const ETH_ZLEN: u32 = 60;
pub const ETH_DATA_LEN: u32 = 1500;
pub const ETH_FRAME_LEN: u32 = 1514;
pub const ETH_FCS_LEN: u32 = 4;
pub const ETH_MIN_MTU: u32 = 68;
pub const ETH_MAX_MTU: u32 = 65535;
pub const ETH_P_LOOP: u32 = 96;
pub const ETH_P_PUP: u32 = 512;
pub const ETH_P_PUPAT: u32 = 513;
pub const ETH_P_TSN: u32 = 8944;
pub const ETH_P_ERSPAN2: u32 = 8939;
pub const ETH_P_IP: u32 = 2048;
pub const ETH_P_X25: u32 = 2053;
pub const ETH_P_ARP: u32 = 2054;
pub const ETH_P_BPQ: u32 = 2303;
pub const ETH_P_IEEEPUP: u32 = 2560;
pub const ETH_P_IEEEPUPAT: u32 = 2561;
pub const ETH_P_BATMAN: u32 = 17157;
pub const ETH_P_DEC: u32 = 24576;
pub const ETH_P_DNA_DL: u32 = 24577;
pub const ETH_P_DNA_RC: u32 = 24578;
pub const ETH_P_DNA_RT: u32 = 24579;
pub const ETH_P_LAT: u32 = 24580;
pub const ETH_P_DIAG: u32 = 24581;
pub const ETH_P_CUST: u32 = 24582;
pub const ETH_P_SCA: u32 = 24583;
pub const ETH_P_TEB: u32 = 25944;
pub const ETH_P_RARP: u32 = 32821;
pub const ETH_P_ATALK: u32 = 32923;
pub const ETH_P_AARP: u32 = 33011;
pub const ETH_P_8021Q: u32 = 33024;
pub const ETH_P_ERSPAN: u32 = 35006;
pub const ETH_P_IPX: u32 = 33079;
pub const ETH_P_IPV6: u32 = 34525;
pub const ETH_P_PAUSE: u32 = 34824;
pub const ETH_P_SLOW: u32 = 34825;
pub const ETH_P_WCCP: u32 = 34878;
pub const ETH_P_MPLS_UC: u32 = 34887;
pub const ETH_P_MPLS_MC: u32 = 34888;
pub const ETH_P_ATMMPOA: u32 = 34892;
pub const ETH_P_PPP_DISC: u32 = 34915;
pub const ETH_P_PPP_SES: u32 = 34916;
pub const ETH_P_LINK_CTL: u32 = 34924;
pub const ETH_P_ATMFATE: u32 = 34948;
pub const ETH_P_PAE: u32 = 34958;
pub const ETH_P_PROFINET: u32 = 34962;
pub const ETH_P_REALTEK: u32 = 34969;
pub const ETH_P_AOE: u32 = 34978;
pub const ETH_P_ETHERCAT: u32 = 34980;
pub const ETH_P_8021AD: u32 = 34984;
pub const ETH_P_802_EX1: u32 = 34997;
pub const ETH_P_PREAUTH: u32 = 35015;
pub const ETH_P_TIPC: u32 = 35018;
pub const ETH_P_LLDP: u32 = 35020;
pub const ETH_P_MRP: u32 = 35043;
pub const ETH_P_MACSEC: u32 = 35045;
pub const ETH_P_8021AH: u32 = 35047;
pub const ETH_P_MVRP: u32 = 35061;
pub const ETH_P_1588: u32 = 35063;
pub const ETH_P_NCSI: u32 = 35064;
pub const ETH_P_PRP: u32 = 35067;
pub const ETH_P_CFM: u32 = 35074;
pub const ETH_P_FCOE: u32 = 35078;
pub const ETH_P_IBOE: u32 = 35093;
pub const ETH_P_TDLS: u32 = 35085;
pub const ETH_P_FIP: u32 = 35092;
pub const ETH_P_80221: u32 = 35095;
pub const ETH_P_HSR: u32 = 35119;
pub const ETH_P_NSH: u32 = 35151;
pub const ETH_P_LOOPBACK: u32 = 36864;
pub const ETH_P_QINQ1: u32 = 37120;
pub const ETH_P_QINQ2: u32 = 37376;
pub const ETH_P_QINQ3: u32 = 37632;
pub const ETH_P_EDSA: u32 = 56026;
pub const ETH_P_DSA_8021Q: u32 = 56027;
pub const ETH_P_DSA_A5PSW: u32 = 57345;
pub const ETH_P_IFE: u32 = 60734;
pub const ETH_P_AF_IUCV: u32 = 64507;
pub const ETH_P_802_3_MIN: u32 = 1536;
pub const ETH_P_802_3: u32 = 1;
pub const ETH_P_AX25: u32 = 2;
pub const ETH_P_ALL: u32 = 3;
pub const ETH_P_802_2: u32 = 4;
pub const ETH_P_SNAP: u32 = 5;
pub const ETH_P_DDCMP: u32 = 6;
pub const ETH_P_WAN_PPP: u32 = 7;
pub const ETH_P_PPP_MP: u32 = 8;
pub const ETH_P_LOCALTALK: u32 = 9;
pub const ETH_P_CAN: u32 = 12;
pub const ETH_P_CANFD: u32 = 13;
pub const ETH_P_CANXL: u32 = 14;
pub const ETH_P_PPPTALK: u32 = 16;
pub const ETH_P_TR_802_2: u32 = 17;
pub const ETH_P_MOBITEX: u32 = 21;
pub const ETH_P_CONTROL: u32 = 22;
pub const ETH_P_IRDA: u32 = 23;
pub const ETH_P_ECONET: u32 = 24;
pub const ETH_P_HDLC: u32 = 25;
pub const ETH_P_ARCNET: u32 = 26;
pub const ETH_P_DSA: u32 = 27;
pub const ETH_P_TRAILER: u32 = 28;
pub const ETH_P_PHONET: u32 = 245;
pub const ETH_P_IEEE802154: u32 = 246;
pub const ETH_P_CAIF: u32 = 247;
pub const ETH_P_XDSA: u32 = 248;
pub const ETH_P_MAP: u32 = 249;
pub const ETH_P_MCTP: u32 = 250;
pub const __UAPI_DEF_ETHHDR: u32 = 1;
pub const TC_PRIO_BESTEFFORT: u32 = 0;
pub const TC_PRIO_FILLER: u32 = 1;
pub const TC_PRIO_BULK: u32 = 2;
pub const TC_PRIO_INTERACTIVE_BULK: u32 = 4;
pub const TC_PRIO_INTERACTIVE: u32 = 6;
pub const TC_PRIO_CONTROL: u32 = 7;
pub const TC_PRIO_MAX: u32 = 15;
pub const TC_H_MAJ_MASK: u32 = 4294901760;
pub const TC_H_MIN_MASK: u32 = 65535;
pub const TC_H_UNSPEC: u32 = 0;
pub const TC_H_ROOT: u32 = 4294967295;
pub const TC_H_INGRESS: u32 = 4294967281;
pub const TC_H_CLSACT: u32 = 4294967281;
pub const TC_H_MIN_PRIORITY: u32 = 65504;
pub const TC_H_MIN_INGRESS: u32 = 65522;
pub const TC_H_MIN_EGRESS: u32 = 65523;
pub const TC_LINKLAYER_MASK: u32 = 15;
pub const TC_RTAB_SIZE: u32 = 1024;
pub const SKBPRIO_MAX_PRIORITY: u32 = 64;
pub const TCQ_PRIO_BANDS: u32 = 16;
pub const TCQ_MIN_PRIO_BANDS: u32 = 2;
pub const TCQ_PLUG_BUFFER: u32 = 0;
pub const TCQ_PLUG_RELEASE_ONE: u32 = 1;
pub const TCQ_PLUG_RELEASE_INDEFINITE: u32 = 2;
pub const TCQ_PLUG_LIMIT: u32 = 3;
pub const TC_RED_ECN: u32 = 1;
pub const TC_RED_HARDDROP: u32 = 2;
pub const TC_RED_ADAPTATIVE: u32 = 4;
pub const TC_RED_NODROP: u32 = 8;
pub const TC_RED_HISTORIC_FLAGS: u32 = 7;
pub const MAX_DPs: u32 = 16;
pub const TC_HTB_NUMPRIO: u32 = 8;
pub const TC_HTB_MAXDEPTH: u32 = 8;
pub const TC_HTB_PROTOVER: u32 = 3;
pub const NETEM_DIST_SCALE: u32 = 8192;
pub const NETEM_DIST_MAX: u32 = 16384;
pub const TC_QOPT_BITMASK: u32 = 15;
pub const TC_QOPT_MAX_QUEUE: u32 = 16;
pub const TC_MQPRIO_F_MODE: u32 = 1;
pub const TC_MQPRIO_F_SHAPER: u32 = 2;
pub const TC_MQPRIO_F_MIN_RATE: u32 = 4;
pub const TC_MQPRIO_F_MAX_RATE: u32 = 8;
pub const SFB_MAX_PROB: u32 = 65535;
pub const FQ_CODEL_QUANTUM_MAX: u32 = 1048576;
pub const FQ_BANDS: u32 = 3;
pub const FQ_MIN_WEIGHT: u32 = 16384;
pub const TC_CAKE_MAX_TINS: u32 = 8;
pub const TCQ_ETS_MAX_BANDS: u32 = 16;
pub const TC_COOKIE_MAX_SIZE: u32 = 16;
pub const TCA_ACT_FLAGS_NO_PERCPU_STATS: u32 = 1;
pub const TCA_ACT_FLAGS_SKIP_HW: u32 = 2;
pub const TCA_ACT_FLAGS_SKIP_SW: u32 = 4;
pub const TCA_ACT_HW_STATS_IMMEDIATE: u32 = 1;
pub const TCA_ACT_HW_STATS_DELAYED: u32 = 2;
pub const TCA_ACT_MAX_PRIO: u32 = 32;
pub const TCA_ACT_BIND: u32 = 1;
pub const TCA_ACT_NOBIND: u32 = 0;
pub const TCA_ACT_UNBIND: u32 = 1;
pub const TCA_ACT_NOUNBIND: u32 = 0;
pub const TCA_ACT_REPLACE: u32 = 1;
pub const TCA_ACT_NOREPLACE: u32 = 0;
pub const TC_ACT_UNSPEC: i32 = -1;
pub const TC_ACT_OK: u32 = 0;
pub const TC_ACT_RECLASSIFY: u32 = 1;
pub const TC_ACT_SHOT: u32 = 2;
pub const TC_ACT_PIPE: u32 = 3;
pub const TC_ACT_STOLEN: u32 = 4;
pub const TC_ACT_QUEUED: u32 = 5;
pub const TC_ACT_REPEAT: u32 = 6;
pub const TC_ACT_REDIRECT: u32 = 7;
pub const TC_ACT_TRAP: u32 = 8;
pub const TC_ACT_VALUE_MAX: u32 = 8;
pub const __TC_ACT_EXT_SHIFT: u32 = 28;
pub const TC_ACT_EXT_VAL_MASK: u32 = 268435455;
pub const TCA_ACT_GACT: u32 = 5;
pub const TCA_ACT_IPT: u32 = 6;
pub const TCA_ACT_PEDIT: u32 = 7;
pub const TCA_ACT_MIRRED: u32 = 8;
pub const TCA_ACT_NAT: u32 = 9;
pub const TCA_ACT_XT: u32 = 10;
pub const TCA_ACT_SKBEDIT: u32 = 11;
pub const TCA_ACT_VLAN: u32 = 12;
pub const TCA_ACT_BPF: u32 = 13;
pub const TCA_ACT_CONNMARK: u32 = 14;
pub const TCA_ACT_SKBMOD: u32 = 15;
pub const TCA_ACT_CSUM: u32 = 16;
pub const TCA_ACT_TUNNEL_KEY: u32 = 17;
pub const TCA_ACT_SIMP: u32 = 22;
pub const TCA_ACT_IFE: u32 = 25;
pub const TCA_ACT_SAMPLE: u32 = 26;
pub const TC_POLICE_UNSPEC: i32 = -1;
pub const TC_POLICE_OK: u32 = 0;
pub const TC_POLICE_RECLASSIFY: u32 = 1;
pub const TC_POLICE_SHOT: u32 = 2;
pub const TC_POLICE_PIPE: u32 = 3;
pub const TCA_CLS_FLAGS_SKIP_HW: u32 = 1;
pub const TCA_CLS_FLAGS_SKIP_SW: u32 = 2;
pub const TCA_CLS_FLAGS_IN_HW: u32 = 4;
pub const TCA_CLS_FLAGS_NOT_IN_HW: u32 = 8;
pub const TCA_CLS_FLAGS_VERBOSE: u32 = 16;
pub const TC_U32_UNSPEC: u32 = 0;
pub const TC_U32_ROOT: u32 = 4293918720;
pub const TC_U32_TERMINAL: u32 = 1;
pub const TC_U32_OFFSET: u32 = 2;
pub const TC_U32_VAROFFSET: u32 = 4;
pub const TC_U32_EAT: u32 = 8;
pub const TC_U32_MAXDEPTH: u32 = 8;
pub const TCA_BPF_FLAG_ACT_DIRECT: u32 = 1;
pub const TCA_FLOWER_MASK_FLAGS_RANGE: u32 = 1;
pub const TCF_EM_REL_END: u32 = 0;
pub const TCF_EM_REL_AND: u32 = 1;
pub const TCF_EM_REL_OR: u32 = 2;
pub const TCF_EM_INVERT: u32 = 4;
pub const TCF_EM_SIMPLE: u32 = 8;
pub const TCF_EM_REL_MASK: u32 = 3;
pub const TCF_EM_CONTAINER: u32 = 0;
pub const TCF_EM_CMP: u32 = 1;
pub const TCF_EM_NBYTE: u32 = 2;
pub const TCF_EM_U32: u32 = 3;
pub const TCF_EM_META: u32 = 4;
pub const TCF_EM_TEXT: u32 = 5;
pub const TCF_EM_VLAN: u32 = 6;
pub const TCF_EM_CANID: u32 = 7;
pub const TCF_EM_IPSET: u32 = 8;
pub const TCF_EM_IPT: u32 = 9;
pub const TCF_EM_MAX: u32 = 9;
pub const FLOW_DIS_MPLS_MAX: u32 = 7;
pub const FLOW_DIS_TUN_OPTS_MAX: u32 = 255;
pub const FLOW_DIS_CFM_MDL_MAX: u32 = 7;
pub const FLOW_KEYS_DIGEST_LEN: u32 = 16;
pub const PACKET_HOST: u32 = 0;
pub const PACKET_BROADCAST: u32 = 1;
pub const PACKET_MULTICAST: u32 = 2;
pub const PACKET_OTHERHOST: u32 = 3;
pub const PACKET_OUTGOING: u32 = 4;
pub const PACKET_LOOPBACK: u32 = 5;
pub const PACKET_USER: u32 = 6;
pub const PACKET_KERNEL: u32 = 7;
pub const PACKET_FASTROUTE: u32 = 6;
pub const PACKET_ADD_MEMBERSHIP: u32 = 1;
pub const PACKET_DROP_MEMBERSHIP: u32 = 2;
pub const PACKET_RECV_OUTPUT: u32 = 3;
pub const PACKET_RX_RING: u32 = 5;
pub const PACKET_STATISTICS: u32 = 6;
pub const PACKET_COPY_THRESH: u32 = 7;
pub const PACKET_AUXDATA: u32 = 8;
pub const PACKET_ORIGDEV: u32 = 9;
pub const PACKET_VERSION: u32 = 10;
pub const PACKET_HDRLEN: u32 = 11;
pub const PACKET_RESERVE: u32 = 12;
pub const PACKET_TX_RING: u32 = 13;
pub const PACKET_LOSS: u32 = 14;
pub const PACKET_VNET_HDR: u32 = 15;
pub const PACKET_TX_TIMESTAMP: u32 = 16;
pub const PACKET_TIMESTAMP: u32 = 17;
pub const PACKET_FANOUT: u32 = 18;
pub const PACKET_TX_HAS_OFF: u32 = 19;
pub const PACKET_QDISC_BYPASS: u32 = 20;
pub const PACKET_ROLLOVER_STATS: u32 = 21;
pub const PACKET_FANOUT_DATA: u32 = 22;
pub const PACKET_IGNORE_OUTGOING: u32 = 23;
pub const PACKET_VNET_HDR_SZ: u32 = 24;
pub const PACKET_FANOUT_HASH: u32 = 0;
pub const PACKET_FANOUT_LB: u32 = 1;
pub const PACKET_FANOUT_CPU: u32 = 2;
pub const PACKET_FANOUT_ROLLOVER: u32 = 3;
pub const PACKET_FANOUT_RND: u32 = 4;
pub const PACKET_FANOUT_QM: u32 = 5;
pub const PACKET_FANOUT_CBPF: u32 = 6;
pub const PACKET_FANOUT_EBPF: u32 = 7;
pub const PACKET_FANOUT_FLAG_ROLLOVER: u32 = 4096;
pub const PACKET_FANOUT_FLAG_UNIQUEID: u32 = 8192;
pub const PACKET_FANOUT_FLAG_IGNORE_OUTGOING: u32 = 16384;
pub const PACKET_FANOUT_FLAG_DEFRAG: u32 = 32768;
pub const TP_STATUS_KERNEL: u32 = 0;
pub const TP_STATUS_USER: u32 = 1;
pub const TP_STATUS_COPY: u32 = 2;
pub const TP_STATUS_LOSING: u32 = 4;
pub const TP_STATUS_CSUMNOTREADY: u32 = 8;
pub const TP_STATUS_VLAN_VALID: u32 = 16;
pub const TP_STATUS_BLK_TMO: u32 = 32;
pub const TP_STATUS_VLAN_TPID_VALID: u32 = 64;
pub const TP_STATUS_CSUM_VALID: u32 = 128;
pub const TP_STATUS_GSO_TCP: u32 = 256;
pub const TP_STATUS_AVAILABLE: u32 = 0;
pub const TP_STATUS_SEND_REQUEST: u32 = 1;
pub const TP_STATUS_SENDING: u32 = 2;
pub const TP_STATUS_WRONG_FORMAT: u32 = 4;
pub const TP_STATUS_TS_SOFTWARE: u32 = 536870912;
pub const TP_STATUS_TS_SYS_HARDWARE: u32 = 1073741824;
pub const TP_STATUS_TS_RAW_HARDWARE: u32 = 2147483648;
pub const TP_FT_REQ_FILL_RXHASH: u32 = 1;
pub const TPACKET_ALIGNMENT: u32 = 16;
pub const PACKET_MR_MULTICAST: u32 = 0;
pub const PACKET_MR_PROMISC: u32 = 1;
pub const PACKET_MR_ALLMULTI: u32 = 2;
pub const PACKET_MR_UNICAST: u32 = 3;
pub const LOOPBACK_IFINDEX: u32 = 1;
pub const FLOWI_FLAG_ANYSRC: u32 = 1;
pub const FLOWI_FLAG_KNOWN_NH: u32 = 2;
pub const FLOWI_FLAG_L3MDEV_OIF: u32 = 4;
pub const FLOWI_FLAG_ANY_SPORT: u32 = 8;
pub const NF_CT_STATE_INVALID_BIT: u32 = 1;
pub const NF_CT_STATE_UNTRACKED_BIT: u32 = 64;
pub const NF_CT_EXPECT_PERMANENT: u32 = 1;
pub const NF_CT_EXPECT_INACTIVE: u32 = 2;
pub const NF_CT_EXPECT_USERSPACE: u32 = 4;
pub const NFCT_INFOMASK: u32 = 7;
pub const NFCT_PTRMASK: i32 = -8;
pub const SKB_DROP_REASON_SUBSYS_SHIFT: u32 = 16;
pub const NET_IOV: u32 = 1;
pub const CHECKSUM_NONE: u32 = 0;
pub const CHECKSUM_UNNECESSARY: u32 = 1;
pub const CHECKSUM_COMPLETE: u32 = 2;
pub const CHECKSUM_PARTIAL: u32 = 3;
pub const SKB_MAX_CSUM_LEVEL: u32 = 3;
pub const MAX_SKB_FRAGS: u32 = 17;
pub const GSO_BY_FRAGS: u32 = 65535;
pub const SKB_DATAREF_SHIFT: u32 = 16;
pub const SKB_DATAREF_MASK: u32 = 65535;
pub const NET_SKBUFF_DATA_USES_OFFSET: u32 = 1;
pub const CLONED_MASK: u32 = 1;
pub const PKT_TYPE_MAX: u32 = 7;
pub const SKB_TSTAMP_TYPE_MASK: u32 = 3;
pub const TC_AT_INGRESS_MASK: u32 = 4;
pub const SKB_ALLOC_FCLONE: u32 = 1;
pub const SKB_ALLOC_RX: u32 = 2;
pub const SKB_ALLOC_NAPI: u32 = 4;
pub const SKB_DST_NOREF: u32 = 1;
pub const SKB_DST_PTRMASK: i32 = -2;
pub const ENCAP_TYPE_ETHER: u32 = 0;
pub const ENCAP_TYPE_IPPROTO: u32 = 1;
pub const NET_IP_ALIGN: u32 = 2;
pub const CHECKSUM_BREAK: u32 = 76;
pub const MAC_ADDR_STR_LEN: u32 = 17;
pub const NPROTO: u32 = 46;
pub const SYS_SOCKET: u32 = 1;
pub const SYS_BIND: u32 = 2;
pub const SYS_CONNECT: u32 = 3;
pub const SYS_LISTEN: u32 = 4;
pub const SYS_ACCEPT: u32 = 5;
pub const SYS_GETSOCKNAME: u32 = 6;
pub const SYS_GETPEERNAME: u32 = 7;
pub const SYS_SOCKETPAIR: u32 = 8;
pub const SYS_SEND: u32 = 9;
pub const SYS_RECV: u32 = 10;
pub const SYS_SENDTO: u32 = 11;
pub const SYS_RECVFROM: u32 = 12;
pub const SYS_SHUTDOWN: u32 = 13;
pub const SYS_SETSOCKOPT: u32 = 14;
pub const SYS_GETSOCKOPT: u32 = 15;
pub const SYS_SENDMSG: u32 = 16;
pub const SYS_RECVMSG: u32 = 17;
pub const SYS_ACCEPT4: u32 = 18;
pub const SYS_RECVMMSG: u32 = 19;
pub const SYS_SENDMMSG: u32 = 20;
pub const __SO_ACCEPTCON: u32 = 65536;
pub const SOCK_TYPE_MASK: u32 = 15;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 2048;
pub const SOCK_COREDUMP: u32 = 256;
pub const _LINUX_BPF_H: u32 = 1;
pub const BPF_LD: u32 = 0;
pub const BPF_LDX: u32 = 1;
pub const BPF_ST: u32 = 2;
pub const BPF_STX: u32 = 3;
pub const BPF_ALU: u32 = 4;
pub const BPF_JMP: u32 = 5;
pub const BPF_RET: u32 = 6;
pub const BPF_MISC: u32 = 7;
pub const BPF_W: u32 = 0;
pub const BPF_H: u32 = 8;
pub const BPF_B: u32 = 16;
pub const BPF_IMM: u32 = 0;
pub const BPF_ABS: u32 = 32;
pub const BPF_IND: u32 = 64;
pub const BPF_MEM: u32 = 96;
pub const BPF_LEN: u32 = 128;
pub const BPF_MSH: u32 = 160;
pub const BPF_ADD: u32 = 0;
pub const BPF_SUB: u32 = 16;
pub const BPF_MUL: u32 = 32;
pub const BPF_DIV: u32 = 48;
pub const BPF_OR: u32 = 64;
pub const BPF_AND: u32 = 80;
pub const BPF_LSH: u32 = 96;
pub const BPF_RSH: u32 = 112;
pub const BPF_NEG: u32 = 128;
pub const BPF_MOD: u32 = 144;
pub const BPF_XOR: u32 = 160;
pub const BPF_JA: u32 = 0;
pub const BPF_JEQ: u32 = 16;
pub const BPF_JGT: u32 = 32;
pub const BPF_JGE: u32 = 48;
pub const BPF_JSET: u32 = 64;
pub const BPF_K: u32 = 0;
pub const BPF_X: u32 = 8;
pub const BPF_MAXINSNS: u32 = 4096;
pub const BPF_JMP32: u32 = 6;
pub const BPF_ALU64: u32 = 7;
pub const BPF_DW: u32 = 24;
pub const BPF_MEMSX: u32 = 128;
pub const BPF_ATOMIC: u32 = 192;
pub const BPF_XADD: u32 = 192;
pub const BPF_MOV: u32 = 176;
pub const BPF_ARSH: u32 = 192;
pub const BPF_END: u32 = 208;
pub const BPF_TO_LE: u32 = 0;
pub const BPF_TO_BE: u32 = 8;
pub const BPF_FROM_LE: u32 = 0;
pub const BPF_FROM_BE: u32 = 8;
pub const BPF_JNE: u32 = 80;
pub const BPF_JLT: u32 = 160;
pub const BPF_JLE: u32 = 176;
pub const BPF_JSGT: u32 = 96;
pub const BPF_JSGE: u32 = 112;
pub const BPF_JSLT: u32 = 192;
pub const BPF_JSLE: u32 = 208;
pub const BPF_JCOND: u32 = 224;
pub const BPF_CALL: u32 = 128;
pub const BPF_EXIT: u32 = 144;
pub const BPF_FETCH: u32 = 1;
pub const BPF_XCHG: u32 = 225;
pub const BPF_CMPXCHG: u32 = 241;
pub const BPF_LOAD_ACQ: u32 = 256;
pub const BPF_STORE_REL: u32 = 272;
pub const BPF_F_ALLOW_OVERRIDE: u32 = 1;
pub const BPF_F_ALLOW_MULTI: u32 = 2;
pub const BPF_F_REPLACE: u32 = 4;
pub const BPF_F_BEFORE: u32 = 8;
pub const BPF_F_AFTER: u32 = 16;
pub const BPF_F_ID: u32 = 32;
pub const BPF_F_PREORDER: u32 = 64;
pub const BPF_F_STRICT_ALIGNMENT: u32 = 1;
pub const BPF_F_ANY_ALIGNMENT: u32 = 2;
pub const BPF_F_TEST_RND_HI32: u32 = 4;
pub const BPF_F_TEST_STATE_FREQ: u32 = 8;
pub const BPF_F_SLEEPABLE: u32 = 16;
pub const BPF_F_XDP_HAS_FRAGS: u32 = 32;
pub const BPF_F_XDP_DEV_BOUND_ONLY: u32 = 64;
pub const BPF_F_TEST_REG_INVARIANTS: u32 = 128;
pub const BPF_F_NETFILTER_IP_DEFRAG: u32 = 1;
pub const BPF_PSEUDO_MAP_FD: u32 = 1;
pub const BPF_PSEUDO_MAP_IDX: u32 = 5;
pub const BPF_PSEUDO_MAP_VALUE: u32 = 2;
pub const BPF_PSEUDO_MAP_IDX_VALUE: u32 = 6;
pub const BPF_PSEUDO_BTF_ID: u32 = 3;
pub const BPF_PSEUDO_FUNC: u32 = 4;
pub const BPF_PSEUDO_CALL: u32 = 1;
pub const BPF_PSEUDO_KFUNC_CALL: u32 = 2;
pub const BPF_F_QUERY_EFFECTIVE: u32 = 1;
pub const BPF_F_TEST_RUN_ON_CPU: u32 = 1;
pub const BPF_F_TEST_XDP_LIVE_FRAMES: u32 = 2;
pub const BPF_F_TEST_SKB_CHECKSUM_COMPLETE: u32 = 4;
pub const BPF_BUILD_ID_SIZE: u32 = 20;
pub const BPF_OBJ_NAME_LEN: u32 = 16;
pub const XDP_PACKET_HEADROOM: u32 = 256;
pub const BPF_TAG_SIZE: u32 = 8;
pub const BPF_MAJOR_VERSION: u32 = 1;
pub const BPF_MINOR_VERSION: u32 = 1;
pub const BPF_A: u32 = 16;
pub const BPF_TAX: u32 = 0;
pub const BPF_TXA: u32 = 128;
pub const BPF_MEMWORDS: u32 = 16;
pub const SKF_AD_OFF: i32 = -4096;
pub const SKF_AD_PROTOCOL: u32 = 0;
pub const SKF_AD_PKTTYPE: u32 = 4;
pub const SKF_AD_IFINDEX: u32 = 8;
pub const SKF_AD_NLATTR: u32 = 12;
pub const SKF_AD_NLATTR_NEST: u32 = 16;
pub const SKF_AD_MARK: u32 = 20;
pub const SKF_AD_QUEUE: u32 = 24;
pub const SKF_AD_HATYPE: u32 = 28;
pub const SKF_AD_RXHASH: u32 = 32;
pub const SKF_AD_CPU: u32 = 36;
pub const SKF_AD_ALU_XOR_X: u32 = 40;
pub const SKF_AD_VLAN_TAG: u32 = 44;
pub const SKF_AD_VLAN_TAG_PRESENT: u32 = 48;
pub const SKF_AD_PAY_OFFSET: u32 = 52;
pub const SKF_AD_RANDOM: u32 = 56;
pub const SKF_AD_VLAN_TPID: u32 = 60;
pub const SKF_AD_MAX: u32 = 64;
pub const SKF_NET_OFF: i32 = -1048576;
pub const SKF_LL_OFF: i32 = -2097152;
pub const BPF_NET_OFF: i32 = -1048576;
pub const BPF_LL_OFF: i32 = -2097152;
pub const KSYM_NAME_LEN: u32 = 512;
pub const _LINUX_BTF_H: u32 = 1;
pub const BTF_SET8_KFUNCS: u32 = 1;
pub const BTF_MAGIC: u32 = 60319;
pub const BTF_VERSION: u32 = 1;
pub const BTF_MAX_TYPE: u32 = 1048575;
pub const BTF_MAX_NAME_OFFSET: u32 = 16777215;
pub const BTF_MAX_VLEN: u32 = 65535;
pub const BTF_INT_SIGNED: u32 = 1;
pub const BTF_INT_CHAR: u32 = 2;
pub const BTF_INT_BOOL: u32 = 4;
pub const KF_ACQUIRE: u32 = 1;
pub const KF_RELEASE: u32 = 2;
pub const KF_RET_NULL: u32 = 4;
pub const KF_TRUSTED_ARGS: u32 = 16;
pub const KF_SLEEPABLE: u32 = 32;
pub const KF_DESTRUCTIVE: u32 = 64;
pub const KF_RCU: u32 = 128;
pub const KF_ITER_NEW: u32 = 256;
pub const KF_ITER_NEXT: u32 = 512;
pub const KF_ITER_DESTROY: u32 = 1024;
pub const KF_RCU_PROTECTED: u32 = 2048;
pub const KF_FASTCALL: u32 = 4096;
pub const KF_ARENA_RET: u32 = 8192;
pub const KF_ARENA_ARG1: u32 = 16384;
pub const KF_ARENA_ARG2: u32 = 32768;
pub const BTF_SHOW_UNSAFE: u32 = 16;
pub const static_call_initialized: u32 = 0;
pub const TASKSTATS_VERSION: u32 = 16;
pub const TS_COMM_LEN: u32 = 32;
pub const TASKSTATS_GENL_NAME: &[u8; 10] = b"TASKSTATS\0";
pub const TASKSTATS_GENL_VERSION: u32 = 1;
pub const SEQ_SKIP: u32 = 1;
pub const UID_GID_MAP_MAX_BASE_EXTENTS: u32 = 5;
pub const UID_GID_MAP_MAX_EXTENTS: u32 = 340;
pub const USERNS_SETGROUPS_ALLOWED: u32 = 1;
pub const USERNS_INIT_FLAGS: u32 = 1;
pub const CGROUP_LSM_NUM: u32 = 0;
pub const NR_PSI_RESOURCES: u32 = 0;
pub const MAX_CGROUP_TYPE_NAMELEN: u32 = 32;
pub const MAX_CGROUP_ROOT_NAMELEN: u32 = 64;
pub const MAX_CFTYPE_NAME: u32 = 64;
pub const CGROUP_WEIGHT_MIN: u32 = 1;
pub const CGROUP_WEIGHT_DFL: u32 = 100;
pub const CGROUP_WEIGHT_MAX: u32 = 10000;
pub const EFD_SEMAPHORE: u32 = 1;
pub const EFD_CLOEXEC: u32 = 524288;
pub const EFD_NONBLOCK: u32 = 2048;
pub const EFD_SHARED_FCNTL_FLAGS: u32 = 526336;
pub const EFD_FLAGS_SET: u32 = 526337;
pub const FPROP_FRAC_SHIFT: u32 = 10;
pub const FPROP_FRAC_BASE: u32 = 1024;
pub const PAGEVEC_SIZE: u32 = 31;
pub const DIRTY_SCOPE: u32 = 8;
pub const BDP_ASYNC: u32 = 1;
pub const MEM_CGROUP_ID_SHIFT: u32 = 16;
pub const MEMCG_CGWB_FRN_CNT: u32 = 4;
pub const MEMCG_CHARGE_BATCH: u32 = 64;
pub const cfi_bpf_hash: u32 = 0;
pub const cfi_bpf_subprog_hash: u32 = 0;
pub const RES_DEF_TIMEOUT: u32 = 250000000;
pub const RES_NR_HELD: u32 = 31;
pub const BPF_BASE_TYPE_BITS: u32 = 8;
pub const BPF_BASE_TYPE_LIMIT: u32 = 256;
pub const MAX_BPF_FUNC_ARGS: u32 = 12;
pub const MAX_BPF_FUNC_REG_ARGS: u32 = 5;
pub const BPF_DISPATCHER_MAX: u32 = 48;
pub const BPF_STRUCT_OPS_MAX_NR_MEMBERS: u32 = 64;
pub const BPF_COMPLEXITY_LIMIT_INSNS: u32 = 1000000;
pub const MAX_TAIL_CALL_CNT: u32 = 33;
pub const BPF_MAX_USER_RINGBUF_SAMPLES: u32 = 131072;
pub const BPF_RET_BIND_NO_CAP_NET_BIND_SERVICE: u32 = 1;
pub const BPF_RET_SET_CN: u32 = 1;
pub const BPF_ITER_FUNC_PREFIX: &[u8; 10] = b"bpf_iter_\0";
pub const BPF_ITER_CTX_ARG_MAX: u32 = 2;
pub const MAX_BPRINTF_VARARGS: u32 = 12;
pub const MAX_BPRINTF_BUF: u32 = 1024;
pub const MAX_BPRINTF_BIN_ARGS: u32 = 512;
pub const LSM_ID_UNDEF: u32 = 0;
pub const LSM_ID_CAPABILITY: u32 = 100;
pub const LSM_ID_SELINUX: u32 = 101;
pub const LSM_ID_SMACK: u32 = 102;
pub const LSM_ID_TOMOYO: u32 = 103;
pub const LSM_ID_APPARMOR: u32 = 104;
pub const LSM_ID_YAMA: u32 = 105;
pub const LSM_ID_LOADPIN: u32 = 106;
pub const LSM_ID_SAFESETID: u32 = 107;
pub const LSM_ID_LOCKDOWN: u32 = 108;
pub const LSM_ID_BPF: u32 = 109;
pub const LSM_ID_LANDLOCK: u32 = 110;
pub const LSM_ID_IMA: u32 = 111;
pub const LSM_ID_EVM: u32 = 112;
pub const LSM_ID_IPE: u32 = 113;
pub const LSM_ATTR_UNDEF: u32 = 0;
pub const LSM_ATTR_CURRENT: u32 = 100;
pub const LSM_ATTR_EXEC: u32 = 101;
pub const LSM_ATTR_FSCREATE: u32 = 102;
pub const LSM_ATTR_KEYCREATE: u32 = 103;
pub const LSM_ATTR_PREV: u32 = 104;
pub const LSM_ATTR_SOCKCREATE: u32 = 105;
pub const LSM_FLAG_SINGLE: u32 = 1;
pub const CAP_OPT_NONE: u32 = 0;
pub const SECURITY_LSM_NATIVE_LABELS: u32 = 1;
pub const LSM_SETID_ID: u32 = 1;
pub const LSM_SETID_RE: u32 = 2;
pub const LSM_SETID_RES: u32 = 4;
pub const LSM_SETID_FS: u32 = 8;
pub const LSM_PRLIMIT_READ: u32 = 1;
pub const LSM_PRLIMIT_WRITE: u32 = 2;
pub const LSM_UNSAFE_SHARE: u32 = 1;
pub const LSM_UNSAFE_PTRACE: u32 = 2;
pub const LSM_UNSAFE_NO_NEW_PRIVS: u32 = 4;
pub const SCM_MAX_FD: u32 = 253;
pub const NETLINK_ROUTE: u32 = 0;
pub const NETLINK_UNUSED: u32 = 1;
pub const NETLINK_USERSOCK: u32 = 2;
pub const NETLINK_FIREWALL: u32 = 3;
pub const NETLINK_SOCK_DIAG: u32 = 4;
pub const NETLINK_NFLOG: u32 = 5;
pub const NETLINK_XFRM: u32 = 6;
pub const NETLINK_SELINUX: u32 = 7;
pub const NETLINK_ISCSI: u32 = 8;
pub const NETLINK_AUDIT: u32 = 9;
pub const NETLINK_FIB_LOOKUP: u32 = 10;
pub const NETLINK_CONNECTOR: u32 = 11;
pub const NETLINK_NETFILTER: u32 = 12;
pub const NETLINK_IP6_FW: u32 = 13;
pub const NETLINK_DNRTMSG: u32 = 14;
pub const NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const NETLINK_GENERIC: u32 = 16;
pub const NETLINK_SCSITRANSPORT: u32 = 18;
pub const NETLINK_ECRYPTFS: u32 = 19;
pub const NETLINK_RDMA: u32 = 20;
pub const NETLINK_CRYPTO: u32 = 21;
pub const NETLINK_SMC: u32 = 22;
pub const NETLINK_INET_DIAG: u32 = 4;
pub const MAX_LINKS: u32 = 32;
pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLM_F_NONREC: u32 = 256;
pub const NLM_F_BULK: u32 = 512;
pub const NLM_F_CAPPED: u32 = 256;
pub const NLM_F_ACK_TLVS: u32 = 512;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NLMSG_NOOP: u32 = 1;
pub const NLMSG_ERROR: u32 = 2;
pub const NLMSG_DONE: u32 = 3;
pub const NLMSG_OVERRUN: u32 = 4;
pub const NLMSG_MIN_TYPE: u32 = 16;
pub const NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const NETLINK_PKTINFO: u32 = 3;
pub const NETLINK_BROADCAST_ERROR: u32 = 4;
pub const NETLINK_NO_ENOBUFS: u32 = 5;
pub const NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const NETLINK_CAP_ACK: u32 = 10;
pub const NETLINK_EXT_ACK: u32 = 11;
pub const NETLINK_GET_STRICT_CHK: u32 = 12;
pub const NET_MAJOR: u32 = 36;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub const NETLINK_CTX_SIZE: u32 = 48;
pub const NL_CFG_F_NONROOT_RECV: u32 = 1;
pub const NL_CFG_F_NONROOT_SEND: u32 = 2;
pub const NETLINK_MAX_COOKIE_LEN: u32 = 8;
pub const NETLINK_MAX_FMTMSG_LEN: u32 = 80;
pub const ETH_MDIO_SUPPORTS_C22: u32 = 1;
pub const ETH_MDIO_SUPPORTS_C45: u32 = 2;
pub const ETHTOOL_FWVERS_LEN: u32 = 32;
pub const ETHTOOL_BUSINFO_LEN: u32 = 32;
pub const ETHTOOL_EROMVERS_LEN: u32 = 32;
pub const SOPASS_MAX: u32 = 6;
pub const PFC_STORM_PREVENTION_AUTO: u32 = 65535;
pub const PFC_STORM_PREVENTION_DISABLE: u32 = 0;
pub const DOWNSHIFT_DEV_DEFAULT_COUNT: u32 = 255;
pub const DOWNSHIFT_DEV_DISABLE: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_ON: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_OFF: u32 = 255;
pub const ETHTOOL_PHY_EDPD_DFLT_TX_MSECS: u32 = 65535;
pub const ETHTOOL_PHY_EDPD_NO_TX: u32 = 65534;
pub const ETHTOOL_PHY_EDPD_DISABLE: u32 = 0;
pub const ETH_GSTRING_LEN: u32 = 32;
pub const ETH_RX_NFC_IP4: u32 = 1;
pub const ETHTOOL_RX_FLOW_SPEC_RING: u32 = 4294967295;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF: u64 = 1095216660480;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF: u32 = 32;
pub const ETH_RXFH_CONTEXT_ALLOC: u32 = 4294967295;
pub const ETH_RXFH_INDIR_NO_CHANGE: u32 = 4294967295;
pub const ETHTOOL_RXNTUPLE_ACTION_DROP: i32 = -1;
pub const ETHTOOL_RXNTUPLE_ACTION_CLEAR: i32 = -2;
pub const ETHTOOL_FLASH_MAX_FILENAME: u32 = 128;
pub const ETH_FW_DUMP_DISABLE: u32 = 0;
pub const MAX_NUM_QUEUE: u32 = 4096;
pub const ETHTOOL_GSET: u32 = 1;
pub const ETHTOOL_SSET: u32 = 2;
pub const ETHTOOL_GDRVINFO: u32 = 3;
pub const ETHTOOL_GREGS: u32 = 4;
pub const ETHTOOL_GWOL: u32 = 5;
pub const ETHTOOL_SWOL: u32 = 6;
pub const ETHTOOL_GMSGLVL: u32 = 7;
pub const ETHTOOL_SMSGLVL: u32 = 8;
pub const ETHTOOL_NWAY_RST: u32 = 9;
pub const ETHTOOL_GLINK: u32 = 10;
pub const ETHTOOL_GEEPROM: u32 = 11;
pub const ETHTOOL_SEEPROM: u32 = 12;
pub const ETHTOOL_GCOALESCE: u32 = 14;
pub const ETHTOOL_SCOALESCE: u32 = 15;
pub const ETHTOOL_GRINGPARAM: u32 = 16;
pub const ETHTOOL_SRINGPARAM: u32 = 17;
pub const ETHTOOL_GPAUSEPARAM: u32 = 18;
pub const ETHTOOL_SPAUSEPARAM: u32 = 19;
pub const ETHTOOL_GRXCSUM: u32 = 20;
pub const ETHTOOL_SRXCSUM: u32 = 21;
pub const ETHTOOL_GTXCSUM: u32 = 22;
pub const ETHTOOL_STXCSUM: u32 = 23;
pub const ETHTOOL_GSG: u32 = 24;
pub const ETHTOOL_SSG: u32 = 25;
pub const ETHTOOL_TEST: u32 = 26;
pub const ETHTOOL_GSTRINGS: u32 = 27;
pub const ETHTOOL_PHYS_ID: u32 = 28;
pub const ETHTOOL_GSTATS: u32 = 29;
pub const ETHTOOL_GTSO: u32 = 30;
pub const ETHTOOL_STSO: u32 = 31;
pub const ETHTOOL_GPERMADDR: u32 = 32;
pub const ETHTOOL_GUFO: u32 = 33;
pub const ETHTOOL_SUFO: u32 = 34;
pub const ETHTOOL_GGSO: u32 = 35;
pub const ETHTOOL_SGSO: u32 = 36;
pub const ETHTOOL_GFLAGS: u32 = 37;
pub const ETHTOOL_SFLAGS: u32 = 38;
pub const ETHTOOL_GPFLAGS: u32 = 39;
pub const ETHTOOL_SPFLAGS: u32 = 40;
pub const ETHTOOL_GRXFH: u32 = 41;
pub const ETHTOOL_SRXFH: u32 = 42;
pub const ETHTOOL_GGRO: u32 = 43;
pub const ETHTOOL_SGRO: u32 = 44;
pub const ETHTOOL_GRXRINGS: u32 = 45;
pub const ETHTOOL_GRXCLSRLCNT: u32 = 46;
pub const ETHTOOL_GRXCLSRULE: u32 = 47;
pub const ETHTOOL_GRXCLSRLALL: u32 = 48;
pub const ETHTOOL_SRXCLSRLDEL: u32 = 49;
pub const ETHTOOL_SRXCLSRLINS: u32 = 50;
pub const ETHTOOL_FLASHDEV: u32 = 51;
pub const ETHTOOL_RESET: u32 = 52;
pub const ETHTOOL_SRXNTUPLE: u32 = 53;
pub const ETHTOOL_GRXNTUPLE: u32 = 54;
pub const ETHTOOL_GSSET_INFO: u32 = 55;
pub const ETHTOOL_GRXFHINDIR: u32 = 56;
pub const ETHTOOL_SRXFHINDIR: u32 = 57;
pub const ETHTOOL_GFEATURES: u32 = 58;
pub const ETHTOOL_SFEATURES: u32 = 59;
pub const ETHTOOL_GCHANNELS: u32 = 60;
pub const ETHTOOL_SCHANNELS: u32 = 61;
pub const ETHTOOL_SET_DUMP: u32 = 62;
pub const ETHTOOL_GET_DUMP_FLAG: u32 = 63;
pub const ETHTOOL_GET_DUMP_DATA: u32 = 64;
pub const ETHTOOL_GET_TS_INFO: u32 = 65;
pub const ETHTOOL_GMODULEINFO: u32 = 66;
pub const ETHTOOL_GMODULEEEPROM: u32 = 67;
pub const ETHTOOL_GEEE: u32 = 68;
pub const ETHTOOL_SEEE: u32 = 69;
pub const ETHTOOL_GRSSH: u32 = 70;
pub const ETHTOOL_SRSSH: u32 = 71;
pub const ETHTOOL_GTUNABLE: u32 = 72;
pub const ETHTOOL_STUNABLE: u32 = 73;
pub const ETHTOOL_GPHYSTATS: u32 = 74;
pub const ETHTOOL_PERQUEUE: u32 = 75;
pub const ETHTOOL_GLINKSETTINGS: u32 = 76;
pub const ETHTOOL_SLINKSETTINGS: u32 = 77;
pub const ETHTOOL_PHY_GTUNABLE: u32 = 78;
pub const ETHTOOL_PHY_STUNABLE: u32 = 79;
pub const ETHTOOL_GFECPARAM: u32 = 80;
pub const ETHTOOL_SFECPARAM: u32 = 81;
pub const SPARC_ETH_GSET: u32 = 1;
pub const SPARC_ETH_SSET: u32 = 2;
pub const SPEED_10: u32 = 10;
pub const SPEED_100: u32 = 100;
pub const SPEED_1000: u32 = 1000;
pub const SPEED_2500: u32 = 2500;
pub const SPEED_5000: u32 = 5000;
pub const SPEED_10000: u32 = 10000;
pub const SPEED_14000: u32 = 14000;
pub const SPEED_20000: u32 = 20000;
pub const SPEED_25000: u32 = 25000;
pub const SPEED_40000: u32 = 40000;
pub const SPEED_50000: u32 = 50000;
pub const SPEED_56000: u32 = 56000;
pub const SPEED_100000: u32 = 100000;
pub const SPEED_200000: u32 = 200000;
pub const SPEED_400000: u32 = 400000;
pub const SPEED_800000: u32 = 800000;
pub const SPEED_UNKNOWN: i32 = -1;
pub const DUPLEX_HALF: u32 = 0;
pub const DUPLEX_FULL: u32 = 1;
pub const DUPLEX_UNKNOWN: u32 = 255;
pub const MASTER_SLAVE_CFG_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_CFG_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_CFG_MASTER_PREFERRED: u32 = 2;
pub const MASTER_SLAVE_CFG_SLAVE_PREFERRED: u32 = 3;
pub const MASTER_SLAVE_CFG_MASTER_FORCE: u32 = 4;
pub const MASTER_SLAVE_CFG_SLAVE_FORCE: u32 = 5;
pub const MASTER_SLAVE_STATE_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_STATE_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_STATE_MASTER: u32 = 2;
pub const MASTER_SLAVE_STATE_SLAVE: u32 = 3;
pub const MASTER_SLAVE_STATE_ERR: u32 = 4;
pub const RATE_MATCH_NONE: u32 = 0;
pub const RATE_MATCH_PAUSE: u32 = 1;
pub const RATE_MATCH_CRS: u32 = 2;
pub const RATE_MATCH_OPEN_LOOP: u32 = 3;
pub const PORT_TP: u32 = 0;
pub const PORT_AUI: u32 = 1;
pub const PORT_MII: u32 = 2;
pub const PORT_FIBRE: u32 = 3;
pub const PORT_BNC: u32 = 4;
pub const PORT_DA: u32 = 5;
pub const PORT_NONE: u32 = 239;
pub const PORT_OTHER: u32 = 255;
pub const XCVR_INTERNAL: u32 = 0;
pub const XCVR_EXTERNAL: u32 = 1;
pub const XCVR_DUMMY1: u32 = 2;
pub const XCVR_DUMMY2: u32 = 3;
pub const XCVR_DUMMY3: u32 = 4;
pub const AUTONEG_DISABLE: u32 = 0;
pub const AUTONEG_ENABLE: u32 = 1;
pub const ETH_TP_MDI_INVALID: u32 = 0;
pub const ETH_TP_MDI: u32 = 1;
pub const ETH_TP_MDI_X: u32 = 2;
pub const ETH_TP_MDI_AUTO: u32 = 3;
pub const WAKE_PHY: u32 = 1;
pub const WAKE_UCAST: u32 = 2;
pub const WAKE_MCAST: u32 = 4;
pub const WAKE_BCAST: u32 = 8;
pub const WAKE_ARP: u32 = 16;
pub const WAKE_MAGIC: u32 = 32;
pub const WAKE_MAGICSECURE: u32 = 64;
pub const WAKE_FILTER: u32 = 128;
pub const WOL_MODE_COUNT: u32 = 8;
pub const RXH_XFRM_SYM_XOR: u32 = 1;
pub const RXH_XFRM_SYM_OR_XOR: u32 = 2;
pub const RXH_XFRM_NO_CHANGE: u32 = 255;
pub const FLOW_EXT: u32 = 2147483648;
pub const FLOW_MAC_EXT: u32 = 1073741824;
pub const FLOW_RSS: u32 = 536870912;
pub const RXH_L2DA: u32 = 2;
pub const RXH_VLAN: u32 = 4;
pub const RXH_L3_PROTO: u32 = 8;
pub const RXH_IP_SRC: u32 = 16;
pub const RXH_IP_DST: u32 = 32;
pub const RXH_L4_B_0_1: u32 = 64;
pub const RXH_L4_B_2_3: u32 = 128;
pub const RXH_GTP_TEID: u32 = 256;
pub const RXH_DISCARD: u32 = 2147483648;
pub const RX_CLS_FLOW_DISC: i32 = -1;
pub const RX_CLS_FLOW_WAKE: i32 = -2;
pub const RX_CLS_LOC_SPECIAL: u32 = 2147483648;
pub const RX_CLS_LOC_ANY: u32 = 4294967295;
pub const RX_CLS_LOC_FIRST: u32 = 4294967294;
pub const RX_CLS_LOC_LAST: u32 = 4294967293;
pub const ETH_MODULE_SFF_8079: u32 = 1;
pub const ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8472: u32 = 2;
pub const ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const ETH_MODULE_SFF_8636: u32 = 3;
pub const ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8436: u32 = 4;
pub const ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const ETH_RESET_SHARED_SHIFT: u32 = 16;
pub const ETHTOOL_GENL_NAME: &[u8; 8] = b"ethtool\0";
pub const ETHTOOL_GENL_VERSION: u32 = 1;
pub const ETHTOOL_MCGRP_MONITOR_NAME: &[u8; 8] = b"monitor\0";
pub const ETHTOOL_MM_MAX_VERIFY_TIME_MS: u32 = 128;
pub const ETHTOOL_MM_MAX_VERIFY_RETRIES: u32 = 3;
pub const ETH_RSS_HASH_UNKNOWN: u32 = 0;
pub const ETH_RSS_HASH_NO_CHANGE: u32 = 0;
pub const ETHTOOL_STAT_NOT_SET: i32 = -1;
pub const ETHTOOL_MAX_LANES: u32 = 8;
pub const ETHTOOL_RMON_HIST_MAX: u32 = 11;
pub const ETH_MODULE_EEPROM_PAGE_LEN: u32 = 128;
pub const ETH_MODULE_MAX_I2C_ADDRESS: u32 = 127;
pub const FW_ACTION_NOUEVENT: u32 = 0;
pub const FW_ACTION_UEVENT: u32 = 1;
pub const MII_BMCR: u32 = 0;
pub const MII_BMSR: u32 = 1;
pub const MII_PHYSID1: u32 = 2;
pub const MII_PHYSID2: u32 = 3;
pub const MII_ADVERTISE: u32 = 4;
pub const MII_LPA: u32 = 5;
pub const MII_EXPANSION: u32 = 6;
pub const MII_CTRL1000: u32 = 9;
pub const MII_STAT1000: u32 = 10;
pub const MII_MMD_CTRL: u32 = 13;
pub const MII_MMD_DATA: u32 = 14;
pub const MII_ESTATUS: u32 = 15;
pub const MII_DCOUNTER: u32 = 18;
pub const MII_FCSCOUNTER: u32 = 19;
pub const MII_NWAYTEST: u32 = 20;
pub const MII_RERRCOUNTER: u32 = 21;
pub const MII_SREVISION: u32 = 22;
pub const MII_RESV1: u32 = 23;
pub const MII_LBRERROR: u32 = 24;
pub const MII_PHYADDR: u32 = 25;
pub const MII_RESV2: u32 = 26;
pub const MII_TPISTATUS: u32 = 27;
pub const MII_NCONFIG: u32 = 28;
pub const BMCR_RESV: u32 = 63;
pub const BMCR_SPEED1000: u32 = 64;
pub const BMCR_CTST: u32 = 128;
pub const BMCR_FULLDPLX: u32 = 256;
pub const BMCR_ANRESTART: u32 = 512;
pub const BMCR_ISOLATE: u32 = 1024;
pub const BMCR_PDOWN: u32 = 2048;
pub const BMCR_ANENABLE: u32 = 4096;
pub const BMCR_SPEED100: u32 = 8192;
pub const BMCR_LOOPBACK: u32 = 16384;
pub const BMCR_RESET: u32 = 32768;
pub const BMCR_SPEED10: u32 = 0;
pub const BMSR_ERCAP: u32 = 1;
pub const BMSR_JCD: u32 = 2;
pub const BMSR_LSTATUS: u32 = 4;
pub const BMSR_ANEGCAPABLE: u32 = 8;
pub const BMSR_RFAULT: u32 = 16;
pub const BMSR_ANEGCOMPLETE: u32 = 32;
pub const BMSR_RESV: u32 = 192;
pub const BMSR_ESTATEN: u32 = 256;
pub const BMSR_100HALF2: u32 = 512;
pub const BMSR_100FULL2: u32 = 1024;
pub const BMSR_10HALF: u32 = 2048;
pub const BMSR_10FULL: u32 = 4096;
pub const BMSR_100HALF: u32 = 8192;
pub const BMSR_100FULL: u32 = 16384;
pub const BMSR_100BASE4: u32 = 32768;
pub const ADVERTISE_SLCT: u32 = 31;
pub const ADVERTISE_CSMA: u32 = 1;
pub const ADVERTISE_10HALF: u32 = 32;
pub const ADVERTISE_1000XFULL: u32 = 32;
pub const ADVERTISE_10FULL: u32 = 64;
pub const ADVERTISE_1000XHALF: u32 = 64;
pub const ADVERTISE_100HALF: u32 = 128;
pub const ADVERTISE_1000XPAUSE: u32 = 128;
pub const ADVERTISE_100FULL: u32 = 256;
pub const ADVERTISE_1000XPSE_ASYM: u32 = 256;
pub const ADVERTISE_100BASE4: u32 = 512;
pub const ADVERTISE_PAUSE_CAP: u32 = 1024;
pub const ADVERTISE_PAUSE_ASYM: u32 = 2048;
pub const ADVERTISE_RESV: u32 = 4096;
pub const ADVERTISE_RFAULT: u32 = 8192;
pub const ADVERTISE_LPACK: u32 = 16384;
pub const ADVERTISE_NPAGE: u32 = 32768;
pub const ADVERTISE_FULL: u32 = 321;
pub const ADVERTISE_ALL: u32 = 480;
pub const LPA_SLCT: u32 = 31;
pub const LPA_10HALF: u32 = 32;
pub const LPA_1000XFULL: u32 = 32;
pub const LPA_10FULL: u32 = 64;
pub const LPA_1000XHALF: u32 = 64;
pub const LPA_100HALF: u32 = 128;
pub const LPA_1000XPAUSE: u32 = 128;
pub const LPA_100FULL: u32 = 256;
pub const LPA_1000XPAUSE_ASYM: u32 = 256;
pub const LPA_100BASE4: u32 = 512;
pub const LPA_PAUSE_CAP: u32 = 1024;
pub const LPA_PAUSE_ASYM: u32 = 2048;
pub const LPA_RESV: u32 = 4096;
pub const LPA_RFAULT: u32 = 8192;
pub const LPA_LPACK: u32 = 16384;
pub const LPA_NPAGE: u32 = 32768;
pub const LPA_DUPLEX: u32 = 320;
pub const LPA_100: u32 = 896;
pub const EXPANSION_NWAY: u32 = 1;
pub const EXPANSION_LCWP: u32 = 2;
pub const EXPANSION_ENABLENPAGE: u32 = 4;
pub const EXPANSION_NPCAPABLE: u32 = 8;
pub const EXPANSION_MFAULTS: u32 = 16;
pub const EXPANSION_RESV: u32 = 65504;
pub const ESTATUS_1000_XFULL: u32 = 32768;
pub const ESTATUS_1000_XHALF: u32 = 16384;
pub const ESTATUS_1000_TFULL: u32 = 8192;
pub const ESTATUS_1000_THALF: u32 = 4096;
pub const NWAYTEST_RESV1: u32 = 255;
pub const NWAYTEST_LOOPBACK: u32 = 256;
pub const NWAYTEST_RESV2: u32 = 65024;
pub const ADVERTISE_SGMII: u32 = 1;
pub const LPA_SGMII: u32 = 1;
pub const LPA_SGMII_SPD_MASK: u32 = 3072;
pub const LPA_SGMII_FULL_DUPLEX: u32 = 4096;
pub const LPA_SGMII_DPX_SPD_MASK: u32 = 7168;
pub const LPA_SGMII_10: u32 = 0;
pub const LPA_SGMII_10HALF: u32 = 0;
pub const LPA_SGMII_10FULL: u32 = 4096;
pub const LPA_SGMII_100: u32 = 1024;
pub const LPA_SGMII_100HALF: u32 = 1024;
pub const LPA_SGMII_100FULL: u32 = 5120;
pub const LPA_SGMII_1000: u32 = 2048;
pub const LPA_SGMII_1000HALF: u32 = 2048;
pub const LPA_SGMII_1000FULL: u32 = 6144;
pub const LPA_SGMII_LINK: u32 = 32768;
pub const ADVERTISE_1000FULL: u32 = 512;
pub const ADVERTISE_1000HALF: u32 = 256;
pub const CTL1000_PREFER_MASTER: u32 = 1024;
pub const CTL1000_AS_MASTER: u32 = 2048;
pub const CTL1000_ENABLE_MASTER: u32 = 4096;
pub const LPA_1000MSFAIL: u32 = 32768;
pub const LPA_1000MSRES: u32 = 16384;
pub const LPA_1000LOCALRXOK: u32 = 8192;
pub const LPA_1000REMRXOK: u32 = 4096;
pub const LPA_1000FULL: u32 = 2048;
pub const LPA_1000HALF: u32 = 1024;
pub const FLOW_CTRL_TX: u32 = 1;
pub const FLOW_CTRL_RX: u32 = 2;
pub const MII_MMD_CTRL_DEVAD_MASK: u32 = 31;
pub const MII_MMD_CTRL_ADDR: u32 = 0;
pub const MII_MMD_CTRL_NOINCR: u32 = 16384;
pub const MII_MMD_CTRL_INCR_RDWT: u32 = 32768;
pub const MII_MMD_CTRL_INCR_ON_WT: u32 = 49152;
pub const MDIO_MMD_PMAPMD: u32 = 1;
pub const MDIO_MMD_WIS: u32 = 2;
pub const MDIO_MMD_PCS: u32 = 3;
pub const MDIO_MMD_PHYXS: u32 = 4;
pub const MDIO_MMD_DTEXS: u32 = 5;
pub const MDIO_MMD_TC: u32 = 6;
pub const MDIO_MMD_AN: u32 = 7;
pub const MDIO_MMD_POWER_UNIT: u32 = 13;
pub const MDIO_MMD_C22EXT: u32 = 29;
pub const MDIO_MMD_VEND1: u32 = 30;
pub const MDIO_MMD_VEND2: u32 = 31;
pub const MDIO_CTRL1: u32 = 0;
pub const MDIO_STAT1: u32 = 1;
pub const MDIO_DEVID1: u32 = 2;
pub const MDIO_DEVID2: u32 = 3;
pub const MDIO_SPEED: u32 = 4;
pub const MDIO_DEVS1: u32 = 5;
pub const MDIO_DEVS2: u32 = 6;
pub const MDIO_CTRL2: u32 = 7;
pub const MDIO_STAT2: u32 = 8;
pub const MDIO_PMA_TXDIS: u32 = 9;
pub const MDIO_PMA_RXDET: u32 = 10;
pub const MDIO_PMA_EXTABLE: u32 = 11;
pub const MDIO_PKGID1: u32 = 14;
pub const MDIO_PKGID2: u32 = 15;
pub const MDIO_AN_ADVERTISE: u32 = 16;
pub const MDIO_AN_LPA: u32 = 19;
pub const MDIO_PCS_EEE_ABLE: u32 = 20;
pub const MDIO_PCS_EEE_ABLE2: u32 = 21;
pub const MDIO_PMA_NG_EXTABLE: u32 = 21;
pub const MDIO_PCS_EEE_WK_ERR: u32 = 22;
pub const MDIO_PHYXS_LNSTAT: u32 = 24;
pub const MDIO_AN_EEE_ADV: u32 = 60;
pub const MDIO_AN_EEE_LPABLE: u32 = 61;
pub const MDIO_AN_EEE_ADV2: u32 = 62;
pub const MDIO_AN_EEE_LPABLE2: u32 = 63;
pub const MDIO_AN_CTRL2: u32 = 64;
pub const MDIO_PMA_10GBT_SWAPPOL: u32 = 130;
pub const MDIO_PMA_10GBT_TXPWR: u32 = 131;
pub const MDIO_PMA_10GBT_SNR: u32 = 133;
pub const MDIO_PMA_10GBR_FSRT_CSR: u32 = 147;
pub const MDIO_PMA_10GBR_FECABLE: u32 = 170;
pub const MDIO_PCS_10GBX_STAT1: u32 = 24;
pub const MDIO_PCS_10GBRT_STAT1: u32 = 32;
pub const MDIO_PCS_10GBRT_STAT2: u32 = 33;
pub const MDIO_AN_10GBT_CTRL: u32 = 32;
pub const MDIO_AN_10GBT_STAT: u32 = 33;
pub const MDIO_B10L_PMA_CTRL: u32 = 2294;
pub const MDIO_PMA_10T1L_STAT: u32 = 2295;
pub const MDIO_PCS_10T1L_CTRL: u32 = 2278;
pub const MDIO_PMA_PMD_BT1: u32 = 18;
pub const MDIO_AN_T1_CTRL: u32 = 512;
pub const MDIO_AN_T1_STAT: u32 = 513;
pub const MDIO_AN_T1_ADV_L: u32 = 514;
pub const MDIO_AN_T1_ADV_M: u32 = 515;
pub const MDIO_AN_T1_ADV_H: u32 = 516;
pub const MDIO_AN_T1_LP_L: u32 = 517;
pub const MDIO_AN_T1_LP_M: u32 = 518;
pub const MDIO_AN_T1_LP_H: u32 = 519;
pub const MDIO_AN_10BT1_AN_CTRL: u32 = 526;
pub const MDIO_AN_10BT1_AN_STAT: u32 = 527;
pub const MDIO_PMA_PMD_BT1_CTRL: u32 = 2100;
pub const MDIO_PCS_1000BT1_CTRL: u32 = 2304;
pub const MDIO_PCS_1000BT1_STAT: u32 = 2305;
pub const MDIO_PMA_LASI_RXCTRL: u32 = 36864;
pub const MDIO_PMA_LASI_TXCTRL: u32 = 36865;
pub const MDIO_PMA_LASI_CTRL: u32 = 36866;
pub const MDIO_PMA_LASI_RXSTAT: u32 = 36867;
pub const MDIO_PMA_LASI_TXSTAT: u32 = 36868;
pub const MDIO_PMA_LASI_STAT: u32 = 36869;
pub const MDIO_CTRL1_SPEEDSELEXT: u32 = 8256;
pub const MDIO_CTRL1_SPEEDSEL: u32 = 8316;
pub const MDIO_CTRL1_FULLDPLX: u32 = 256;
pub const MDIO_CTRL1_LPOWER: u32 = 2048;
pub const MDIO_CTRL1_RESET: u32 = 32768;
pub const MDIO_PMA_CTRL1_LOOPBACK: u32 = 1;
pub const MDIO_PMA_CTRL1_SPEED1000: u32 = 64;
pub const MDIO_PMA_CTRL1_SPEED100: u32 = 8192;
pub const MDIO_PCS_CTRL1_LOOPBACK: u32 = 16384;
pub const MDIO_PHYXS_CTRL1_LOOPBACK: u32 = 16384;
pub const MDIO_AN_CTRL1_RESTART: u32 = 512;
pub const MDIO_AN_CTRL1_ENABLE: u32 = 4096;
pub const MDIO_AN_CTRL1_XNP: u32 = 8192;
pub const MDIO_PCS_CTRL1_CLKSTOP_EN: u32 = 1024;
pub const MDIO_CTRL1_SPEED10G: u32 = 8256;
pub const MDIO_CTRL1_SPEED10P2B: u32 = 8260;
pub const MDIO_CTRL1_SPEED2_5G: u32 = 8280;
pub const MDIO_CTRL1_SPEED5G: u32 = 8284;
pub const MDIO_STAT1_LPOWERABLE: u32 = 2;
pub const MDIO_STAT1_LSTATUS: u32 = 4;
pub const MDIO_STAT1_FAULT: u32 = 128;
pub const MDIO_PCS_STAT1_CLKSTOP_CAP: u32 = 64;
pub const MDIO_AN_STAT1_LPABLE: u32 = 1;
pub const MDIO_AN_STAT1_ABLE: u32 = 8;
pub const MDIO_AN_STAT1_RFAULT: u32 = 16;
pub const MDIO_AN_STAT1_COMPLETE: u32 = 32;
pub const MDIO_AN_STAT1_PAGE: u32 = 64;
pub const MDIO_AN_STAT1_XNP: u32 = 128;
pub const MDIO_SPEED_10G: u32 = 1;
pub const MDIO_PMA_SPEED_2B: u32 = 2;
pub const MDIO_PMA_SPEED_10P: u32 = 4;
pub const MDIO_PMA_SPEED_1000: u32 = 16;
pub const MDIO_PMA_SPEED_100: u32 = 32;
pub const MDIO_PMA_SPEED_10: u32 = 64;
pub const MDIO_PMA_SPEED_2_5G: u32 = 8192;
pub const MDIO_PMA_SPEED_5G: u32 = 16384;
pub const MDIO_PCS_SPEED_10P2B: u32 = 2;
pub const MDIO_PCS_SPEED_2_5G: u32 = 64;
pub const MDIO_PCS_SPEED_5G: u32 = 128;
pub const MDIO_PMA_CTRL2_TYPE: u32 = 15;
pub const MDIO_PMA_CTRL2_10GBCX4: u32 = 0;
pub const MDIO_PMA_CTRL2_10GBEW: u32 = 1;
pub const MDIO_PMA_CTRL2_10GBLW: u32 = 2;
pub const MDIO_PMA_CTRL2_10GBSW: u32 = 3;
pub const MDIO_PMA_CTRL2_10GBLX4: u32 = 4;
pub const MDIO_PMA_CTRL2_10GBER: u32 = 5;
pub const MDIO_PMA_CTRL2_10GBLR: u32 = 6;
pub const MDIO_PMA_CTRL2_10GBSR: u32 = 7;
pub const MDIO_PMA_CTRL2_10GBLRM: u32 = 8;
pub const MDIO_PMA_CTRL2_10GBT: u32 = 9;
pub const MDIO_PMA_CTRL2_10GBKX4: u32 = 10;
pub const MDIO_PMA_CTRL2_10GBKR: u32 = 11;
pub const MDIO_PMA_CTRL2_1000BT: u32 = 12;
pub const MDIO_PMA_CTRL2_1000BKX: u32 = 13;
pub const MDIO_PMA_CTRL2_100BTX: u32 = 14;
pub const MDIO_PMA_CTRL2_10BT: u32 = 15;
pub const MDIO_PMA_CTRL2_2_5GBT: u32 = 48;
pub const MDIO_PMA_CTRL2_5GBT: u32 = 49;
pub const MDIO_PMA_CTRL2_BASET1: u32 = 61;
pub const MDIO_PCS_CTRL2_TYPE: u32 = 3;
pub const MDIO_PCS_CTRL2_10GBR: u32 = 0;
pub const MDIO_PCS_CTRL2_10GBX: u32 = 1;
pub const MDIO_PCS_CTRL2_10GBW: u32 = 2;
pub const MDIO_PCS_CTRL2_10GBT: u32 = 3;
pub const MDIO_STAT2_RXFAULT: u32 = 1024;
pub const MDIO_STAT2_TXFAULT: u32 = 2048;
pub const MDIO_STAT2_DEVPRST: u32 = 49152;
pub const MDIO_STAT2_DEVPRST_VAL: u32 = 32768;
pub const MDIO_PMA_STAT2_LBABLE: u32 = 1;
pub const MDIO_PMA_STAT2_10GBEW: u32 = 2;
pub const MDIO_PMA_STAT2_10GBLW: u32 = 4;
pub const MDIO_PMA_STAT2_10GBSW: u32 = 8;
pub const MDIO_PMA_STAT2_10GBLX4: u32 = 16;
pub const MDIO_PMA_STAT2_10GBER: u32 = 32;
pub const MDIO_PMA_STAT2_10GBLR: u32 = 64;
pub const MDIO_PMA_STAT2_10GBSR: u32 = 128;
pub const MDIO_PMD_STAT2_TXDISAB: u32 = 256;
pub const MDIO_PMA_STAT2_EXTABLE: u32 = 512;
pub const MDIO_PMA_STAT2_RXFLTABLE: u32 = 4096;
pub const MDIO_PMA_STAT2_TXFLTABLE: u32 = 8192;
pub const MDIO_PCS_STAT2_10GBR: u32 = 1;
pub const MDIO_PCS_STAT2_10GBX: u32 = 2;
pub const MDIO_PCS_STAT2_10GBW: u32 = 4;
pub const MDIO_PCS_STAT2_RXFLTABLE: u32 = 4096;
pub const MDIO_PCS_STAT2_TXFLTABLE: u32 = 8192;
pub const MDIO_PMD_TXDIS_GLOBAL: u32 = 1;
pub const MDIO_PMD_TXDIS_0: u32 = 2;
pub const MDIO_PMD_TXDIS_1: u32 = 4;
pub const MDIO_PMD_TXDIS_2: u32 = 8;
pub const MDIO_PMD_TXDIS_3: u32 = 16;
pub const MDIO_PMD_RXDET_GLOBAL: u32 = 1;
pub const MDIO_PMD_RXDET_0: u32 = 2;
pub const MDIO_PMD_RXDET_1: u32 = 4;
pub const MDIO_PMD_RXDET_2: u32 = 8;
pub const MDIO_PMD_RXDET_3: u32 = 16;
pub const MDIO_PMA_EXTABLE_10GCX4: u32 = 1;
pub const MDIO_PMA_EXTABLE_10GBLRM: u32 = 2;
pub const MDIO_PMA_EXTABLE_10GBT: u32 = 4;
pub const MDIO_PMA_EXTABLE_10GBKX4: u32 = 8;
pub const MDIO_PMA_EXTABLE_10GBKR: u32 = 16;
pub const MDIO_PMA_EXTABLE_1000BT: u32 = 32;
pub const MDIO_PMA_EXTABLE_1000BKX: u32 = 64;
pub const MDIO_PMA_EXTABLE_100BTX: u32 = 128;
pub const MDIO_PMA_EXTABLE_10BT: u32 = 256;
pub const MDIO_PMA_EXTABLE_BT1: u32 = 2048;
pub const MDIO_PMA_EXTABLE_NBT: u32 = 16384;
pub const MDIO_PHYXS_LNSTAT_SYNC0: u32 = 1;
pub const MDIO_PHYXS_LNSTAT_SYNC1: u32 = 2;
pub const MDIO_PHYXS_LNSTAT_SYNC2: u32 = 4;
pub const MDIO_PHYXS_LNSTAT_SYNC3: u32 = 8;
pub const MDIO_PHYXS_LNSTAT_ALIGN: u32 = 4096;
pub const MDIO_PMA_10GBT_SWAPPOL_ABNX: u32 = 1;
pub const MDIO_PMA_10GBT_SWAPPOL_CDNX: u32 = 2;
pub const MDIO_PMA_10GBT_SWAPPOL_AREV: u32 = 256;
pub const MDIO_PMA_10GBT_SWAPPOL_BREV: u32 = 512;
pub const MDIO_PMA_10GBT_SWAPPOL_CREV: u32 = 1024;
pub const MDIO_PMA_10GBT_SWAPPOL_DREV: u32 = 2048;
pub const MDIO_PMA_10GBT_TXPWR_SHORT: u32 = 1;
pub const MDIO_PMA_10GBT_SNR_BIAS: u32 = 32768;
pub const MDIO_PMA_10GBT_SNR_MAX: u32 = 127;
pub const MDIO_PMA_10GBR_FECABLE_ABLE: u32 = 1;
pub const MDIO_PMA_10GBR_FECABLE_ERRABLE: u32 = 2;
pub const MDIO_PMA_10GBR_FSRT_ENABLE: u32 = 1;
pub const MDIO_PCS_10GBRT_STAT1_BLKLK: u32 = 1;
pub const MDIO_PCS_10GBRT_STAT2_ERR: u32 = 255;
pub const MDIO_PCS_10GBRT_STAT2_BER: u32 = 16128;
pub const MDIO_AN_10GBT_CTRL_ADVFSRT2_5G: u32 = 32;
pub const MDIO_AN_10GBT_CTRL_ADV2_5G: u32 = 128;
pub const MDIO_AN_10GBT_CTRL_ADV5G: u32 = 256;
pub const MDIO_AN_10GBT_CTRL_ADV10G: u32 = 4096;
pub const MDIO_AN_10GBT_STAT_LP2_5G: u32 = 32;
pub const MDIO_AN_10GBT_STAT_LP5G: u32 = 64;
pub const MDIO_AN_10GBT_STAT_LPTRR: u32 = 512;
pub const MDIO_AN_10GBT_STAT_LPLTABLE: u32 = 1024;
pub const MDIO_AN_10GBT_STAT_LP10G: u32 = 2048;
pub const MDIO_AN_10GBT_STAT_REMOK: u32 = 4096;
pub const MDIO_AN_10GBT_STAT_LOCOK: u32 = 8192;
pub const MDIO_AN_10GBT_STAT_MS: u32 = 16384;
pub const MDIO_AN_10GBT_STAT_MSFLT: u32 = 32768;
pub const MDIO_PMA_10T1L_CTRL_LB_EN: u32 = 1;
pub const MDIO_PMA_10T1L_CTRL_EEE_EN: u32 = 1024;
pub const MDIO_PMA_10T1L_CTRL_LOW_POWER: u32 = 2048;
pub const MDIO_PMA_10T1L_CTRL_2V4_EN: u32 = 4096;
pub const MDIO_PMA_10T1L_CTRL_TX_DIS: u32 = 16384;
pub const MDIO_PMA_10T1L_CTRL_PMA_RST: u32 = 32768;
pub const MDIO_PMA_10T1L_STAT_LINK: u32 = 1;
pub const MDIO_PMA_10T1L_STAT_FAULT: u32 = 2;
pub const MDIO_PMA_10T1L_STAT_POLARITY: u32 = 4;
pub const MDIO_PMA_10T1L_STAT_RECV_FAULT: u32 = 512;
pub const MDIO_PMA_10T1L_STAT_EEE: u32 = 1024;
pub const MDIO_PMA_10T1L_STAT_LOW_POWER: u32 = 2048;
pub const MDIO_PMA_10T1L_STAT_2V4_ABLE: u32 = 4096;
pub const MDIO_PMA_10T1L_STAT_LB_ABLE: u32 = 8192;
pub const MDIO_PCS_10T1L_CTRL_LB: u32 = 16384;
pub const MDIO_PCS_10T1L_CTRL_RESET: u32 = 32768;
pub const MDIO_PMA_PMD_BT1_B100_ABLE: u32 = 1;
pub const MDIO_PMA_PMD_BT1_B1000_ABLE: u32 = 2;
pub const MDIO_PMA_PMD_BT1_B10L_ABLE: u32 = 4;
pub const MDIO_AN_T1_ADV_L_PAUSE_CAP: u32 = 1024;
pub const MDIO_AN_T1_ADV_L_PAUSE_ASYM: u32 = 2048;
pub const MDIO_AN_T1_ADV_L_FORCE_MS: u32 = 4096;
pub const MDIO_AN_T1_ADV_L_REMOTE_FAULT: u32 = 8192;
pub const MDIO_AN_T1_ADV_L_ACK: u32 = 16384;
pub const MDIO_AN_T1_ADV_L_NEXT_PAGE_REQ: u32 = 32768;
pub const MDIO_AN_T1_ADV_M_B10L: u32 = 16384;
pub const MDIO_AN_T1_ADV_M_1000BT1: u32 = 128;
pub const MDIO_AN_T1_ADV_M_100BT1: u32 = 32;
pub const MDIO_AN_T1_ADV_M_MST: u32 = 16;
pub const MDIO_AN_T1_ADV_H_10L_TX_HI_REQ: u32 = 4096;
pub const MDIO_AN_T1_ADV_H_10L_TX_HI: u32 = 8192;
pub const MDIO_AN_T1_LP_L_PAUSE_CAP: u32 = 1024;
pub const MDIO_AN_T1_LP_L_PAUSE_ASYM: u32 = 2048;
pub const MDIO_AN_T1_LP_L_FORCE_MS: u32 = 4096;
pub const MDIO_AN_T1_LP_L_REMOTE_FAULT: u32 = 8192;
pub const MDIO_AN_T1_LP_L_ACK: u32 = 16384;
pub const MDIO_AN_T1_LP_L_NEXT_PAGE_REQ: u32 = 32768;
pub const MDIO_AN_T1_LP_M_MST: u32 = 16;
pub const MDIO_AN_T1_LP_M_B10L: u32 = 16384;
pub const MDIO_AN_T1_LP_H_10L_TX_HI_REQ: u32 = 4096;
pub const MDIO_AN_T1_LP_H_10L_TX_HI: u32 = 8192;
pub const MDIO_AN_10BT1_AN_CTRL_ADV_EEE_T1L: u32 = 16384;
pub const MDIO_AN_10BT1_AN_STAT_LPA_EEE_T1L: u32 = 16384;
pub const MDIO_PMA_PMD_BT1_CTRL_STRAP: u32 = 15;
pub const MDIO_PMA_PMD_BT1_CTRL_STRAP_B1000: u32 = 1;
pub const MDIO_PMA_PMD_BT1_CTRL_CFG_MST: u32 = 16384;
pub const MDIO_PCS_1000BT1_CTRL_LOW_POWER: u32 = 2048;
pub const MDIO_PCS_1000BT1_CTRL_DISABLE_TX: u32 = 16384;
pub const MDIO_PCS_1000BT1_CTRL_RESET: u32 = 32768;
pub const MDIO_PCS_1000BT1_STAT_LINK: u32 = 4;
pub const MDIO_PCS_1000BT1_STAT_FAULT: u32 = 128;
pub const MDIO_AN_EEE_ADV_100TX: u32 = 2;
pub const MDIO_AN_EEE_ADV_1000T: u32 = 4;
pub const MDIO_EEE_100TX: u32 = 2;
pub const MDIO_EEE_1000T: u32 = 4;
pub const MDIO_EEE_10GT: u32 = 8;
pub const MDIO_EEE_1000KX: u32 = 16;
pub const MDIO_EEE_10GKX4: u32 = 32;
pub const MDIO_EEE_10GKR: u32 = 64;
pub const MDIO_EEE_40GR_FW: u32 = 256;
pub const MDIO_EEE_40GR_DS: u32 = 512;
pub const MDIO_EEE_100GR_FW: u32 = 4096;
pub const MDIO_EEE_100GR_DS: u32 = 8192;
pub const MDIO_EEE_2_5GT: u32 = 1;
pub const MDIO_EEE_5GT: u32 = 2;
pub const MDIO_AN_THP_BP2_5GT: u32 = 8;
pub const MDIO_PMA_NG_EXTABLE_2_5GBT: u32 = 1;
pub const MDIO_PMA_NG_EXTABLE_5GBT: u32 = 2;
pub const MDIO_PMA_LASI_RX_PHYXSLFLT: u32 = 1;
pub const MDIO_PMA_LASI_RX_PCSLFLT: u32 = 8;
pub const MDIO_PMA_LASI_RX_PMALFLT: u32 = 16;
pub const MDIO_PMA_LASI_RX_OPTICPOWERFLT: u32 = 32;
pub const MDIO_PMA_LASI_RX_WISLFLT: u32 = 512;
pub const MDIO_PMA_LASI_TX_PHYXSLFLT: u32 = 1;
pub const MDIO_PMA_LASI_TX_PCSLFLT: u32 = 8;
pub const MDIO_PMA_LASI_TX_PMALFLT: u32 = 16;
pub const MDIO_PMA_LASI_TX_LASERPOWERFLT: u32 = 128;
pub const MDIO_PMA_LASI_TX_LASERTEMPFLT: u32 = 256;
pub const MDIO_PMA_LASI_TX_LASERBICURRFLT: u32 = 512;
pub const MDIO_PMA_LASI_LSALARM: u32 = 1;
pub const MDIO_PMA_LASI_TXALARM: u32 = 2;
pub const MDIO_PMA_LASI_RXALARM: u32 = 4;
pub const MDIO_PHY_ID_C45: u32 = 32768;
pub const MDIO_PHY_ID_PRTAD: u32 = 992;
pub const MDIO_PHY_ID_DEVAD: u32 = 31;
pub const MDIO_PHY_ID_C45_MASK: u32 = 33791;
pub const MDIO_USXGMII_EEE_CLK_STP: u32 = 128;
pub const MDIO_USXGMII_EEE: u32 = 256;
pub const MDIO_USXGMII_SPD_MASK: u32 = 3584;
pub const MDIO_USXGMII_FULL_DUPLEX: u32 = 4096;
pub const MDIO_USXGMII_DPX_SPD_MASK: u32 = 7680;
pub const MDIO_USXGMII_10: u32 = 0;
pub const MDIO_USXGMII_10HALF: u32 = 0;
pub const MDIO_USXGMII_10FULL: u32 = 4096;
pub const MDIO_USXGMII_100: u32 = 512;
pub const MDIO_USXGMII_100HALF: u32 = 512;
pub const MDIO_USXGMII_100FULL: u32 = 4608;
pub const MDIO_USXGMII_1000: u32 = 1024;
pub const MDIO_USXGMII_1000HALF: u32 = 1024;
pub const MDIO_USXGMII_1000FULL: u32 = 5120;
pub const MDIO_USXGMII_10G: u32 = 1536;
pub const MDIO_USXGMII_10GHALF: u32 = 1536;
pub const MDIO_USXGMII_10GFULL: u32 = 5632;
pub const MDIO_USXGMII_2500: u32 = 2048;
pub const MDIO_USXGMII_2500HALF: u32 = 2048;
pub const MDIO_USXGMII_2500FULL: u32 = 6144;
pub const MDIO_USXGMII_5000: u32 = 2560;
pub const MDIO_USXGMII_5000HALF: u32 = 2560;
pub const MDIO_USXGMII_5000FULL: u32 = 6656;
pub const MDIO_USXGMII_LINK: u32 = 32768;
pub const MDIO_DEVICE_FLAG_PHY: u32 = 1;
pub const MDIO_PRTAD_NONE: i32 = -1;
pub const MDIO_DEVAD_NONE: i32 = -1;
pub const MDIO_SUPPORTS_C22: u32 = 1;
pub const MDIO_SUPPORTS_C45: u32 = 2;
pub const MDIO_EMULATE_C22: u32 = 4;
pub const UNNAMED_MAJOR: u32 = 0;
pub const MEM_MAJOR: u32 = 1;
pub const RAMDISK_MAJOR: u32 = 1;
pub const FLOPPY_MAJOR: u32 = 2;
pub const PTY_MASTER_MAJOR: u32 = 2;
pub const IDE0_MAJOR: u32 = 3;
pub const HD_MAJOR: u32 = 3;
pub const PTY_SLAVE_MAJOR: u32 = 3;
pub const TTY_MAJOR: u32 = 4;
pub const TTYAUX_MAJOR: u32 = 5;
pub const LP_MAJOR: u32 = 6;
pub const VCS_MAJOR: u32 = 7;
pub const LOOP_MAJOR: u32 = 7;
pub const SCSI_DISK0_MAJOR: u32 = 8;
pub const SCSI_TAPE_MAJOR: u32 = 9;
pub const MD_MAJOR: u32 = 9;
pub const MISC_MAJOR: u32 = 10;
pub const SCSI_CDROM_MAJOR: u32 = 11;
pub const MUX_MAJOR: u32 = 11;
pub const XT_DISK_MAJOR: u32 = 13;
pub const INPUT_MAJOR: u32 = 13;
pub const SOUND_MAJOR: u32 = 14;
pub const CDU31A_CDROM_MAJOR: u32 = 15;
pub const JOYSTICK_MAJOR: u32 = 15;
pub const GOLDSTAR_CDROM_MAJOR: u32 = 16;
pub const OPTICS_CDROM_MAJOR: u32 = 17;
pub const SANYO_CDROM_MAJOR: u32 = 18;
pub const MITSUMI_X_CDROM_MAJOR: u32 = 20;
pub const MFM_ACORN_MAJOR: u32 = 21;
pub const SCSI_GENERIC_MAJOR: u32 = 21;
pub const IDE1_MAJOR: u32 = 22;
pub const DIGICU_MAJOR: u32 = 22;
pub const DIGI_MAJOR: u32 = 23;
pub const MITSUMI_CDROM_MAJOR: u32 = 23;
pub const CDU535_CDROM_MAJOR: u32 = 24;
pub const STL_SERIALMAJOR: u32 = 24;
pub const MATSUSHITA_CDROM_MAJOR: u32 = 25;
pub const STL_CALLOUTMAJOR: u32 = 25;
pub const MATSUSHITA_CDROM2_MAJOR: u32 = 26;
pub const QIC117_TAPE_MAJOR: u32 = 27;
pub const MATSUSHITA_CDROM3_MAJOR: u32 = 27;
pub const MATSUSHITA_CDROM4_MAJOR: u32 = 28;
pub const STL_SIOMEMMAJOR: u32 = 28;
pub const ACSI_MAJOR: u32 = 28;
pub const AZTECH_CDROM_MAJOR: u32 = 29;
pub const FB_MAJOR: u32 = 29;
pub const MTD_BLOCK_MAJOR: u32 = 31;
pub const CM206_CDROM_MAJOR: u32 = 32;
pub const IDE2_MAJOR: u32 = 33;
pub const IDE3_MAJOR: u32 = 34;
pub const Z8530_MAJOR: u32 = 34;
pub const XPRAM_MAJOR: u32 = 35;
pub const NETLINK_MAJOR: u32 = 36;
pub const PS2ESDI_MAJOR: u32 = 36;
pub const IDETAPE_MAJOR: u32 = 37;
pub const Z2RAM_MAJOR: u32 = 37;
pub const APBLOCK_MAJOR: u32 = 38;
pub const DDV_MAJOR: u32 = 39;
pub const NBD_MAJOR: u32 = 43;
pub const RISCOM8_NORMAL_MAJOR: u32 = 48;
pub const DAC960_MAJOR: u32 = 48;
pub const RISCOM8_CALLOUT_MAJOR: u32 = 49;
pub const MKISS_MAJOR: u32 = 55;
pub const DSP56K_MAJOR: u32 = 55;
pub const IDE4_MAJOR: u32 = 56;
pub const IDE5_MAJOR: u32 = 57;
pub const SCSI_DISK1_MAJOR: u32 = 65;
pub const SCSI_DISK2_MAJOR: u32 = 66;
pub const SCSI_DISK3_MAJOR: u32 = 67;
pub const SCSI_DISK4_MAJOR: u32 = 68;
pub const SCSI_DISK5_MAJOR: u32 = 69;
pub const SCSI_DISK6_MAJOR: u32 = 70;
pub const SCSI_DISK7_MAJOR: u32 = 71;
pub const COMPAQ_SMART2_MAJOR: u32 = 72;
pub const COMPAQ_SMART2_MAJOR1: u32 = 73;
pub const COMPAQ_SMART2_MAJOR2: u32 = 74;
pub const COMPAQ_SMART2_MAJOR3: u32 = 75;
pub const COMPAQ_SMART2_MAJOR4: u32 = 76;
pub const COMPAQ_SMART2_MAJOR5: u32 = 77;
pub const COMPAQ_SMART2_MAJOR6: u32 = 78;
pub const COMPAQ_SMART2_MAJOR7: u32 = 79;
pub const SPECIALIX_NORMAL_MAJOR: u32 = 75;
pub const SPECIALIX_CALLOUT_MAJOR: u32 = 76;
pub const AURORA_MAJOR: u32 = 79;
pub const I2O_MAJOR: u32 = 80;
pub const SHMIQ_MAJOR: u32 = 85;
pub const SCSI_CHANGER_MAJOR: u32 = 86;
pub const IDE6_MAJOR: u32 = 88;
pub const IDE7_MAJOR: u32 = 89;
pub const IDE8_MAJOR: u32 = 90;
pub const MTD_CHAR_MAJOR: u32 = 90;
pub const IDE9_MAJOR: u32 = 91;
pub const DASD_MAJOR: u32 = 94;
pub const MDISK_MAJOR: u32 = 95;
pub const UBD_MAJOR: u32 = 98;
pub const PP_MAJOR: u32 = 99;
pub const JSFD_MAJOR: u32 = 99;
pub const PHONE_MAJOR: u32 = 100;
pub const COMPAQ_CISS_MAJOR: u32 = 104;
pub const COMPAQ_CISS_MAJOR1: u32 = 105;
pub const COMPAQ_CISS_MAJOR2: u32 = 106;
pub const COMPAQ_CISS_MAJOR3: u32 = 107;
pub const COMPAQ_CISS_MAJOR4: u32 = 108;
pub const COMPAQ_CISS_MAJOR5: u32 = 109;
pub const COMPAQ_CISS_MAJOR6: u32 = 110;
pub const COMPAQ_CISS_MAJOR7: u32 = 111;
pub const VIODASD_MAJOR: u32 = 112;
pub const VIOCD_MAJOR: u32 = 113;
pub const ATARAID_MAJOR: u32 = 114;
pub const SCSI_DISK8_MAJOR: u32 = 128;
pub const SCSI_DISK9_MAJOR: u32 = 129;
pub const SCSI_DISK10_MAJOR: u32 = 130;
pub const SCSI_DISK11_MAJOR: u32 = 131;
pub const SCSI_DISK12_MAJOR: u32 = 132;
pub const SCSI_DISK13_MAJOR: u32 = 133;
pub const SCSI_DISK14_MAJOR: u32 = 134;
pub const SCSI_DISK15_MAJOR: u32 = 135;
pub const UNIX98_PTY_MASTER_MAJOR: u32 = 128;
pub const UNIX98_PTY_MAJOR_COUNT: u32 = 8;
pub const UNIX98_PTY_SLAVE_MAJOR: u32 = 136;
pub const DRBD_MAJOR: u32 = 147;
pub const RTF_MAJOR: u32 = 150;
pub const RAW_MAJOR: u32 = 162;
pub const USB_ACM_MAJOR: u32 = 166;
pub const USB_ACM_AUX_MAJOR: u32 = 167;
pub const USB_CHAR_MAJOR: u32 = 180;
pub const MMC_BLOCK_MAJOR: u32 = 179;
pub const VXVM_MAJOR: u32 = 199;
pub const VXSPEC_MAJOR: u32 = 200;
pub const VXDMP_MAJOR: u32 = 201;
pub const XENVBD_MAJOR: u32 = 202;
pub const MSR_MAJOR: u32 = 202;
pub const CPUID_MAJOR: u32 = 203;
pub const OSST_MAJOR: u32 = 206;
pub const IBM_TTY3270_MAJOR: u32 = 227;
pub const IBM_FS3270_MAJOR: u32 = 228;
pub const VIOTAPE_MAJOR: u32 = 230;
pub const BLOCK_EXT_MAJOR: u32 = 259;
pub const SCSI_OSD_MAJOR: u32 = 260;
pub const PSMOUSE_MINOR: u32 = 1;
pub const MS_BUSMOUSE_MINOR: u32 = 2;
pub const ATIXL_BUSMOUSE_MINOR: u32 = 3;
pub const ATARIMOUSE_MINOR: u32 = 5;
pub const SUN_MOUSE_MINOR: u32 = 6;
pub const APOLLO_MOUSE_MINOR: u32 = 7;
pub const PC110PAD_MINOR: u32 = 9;
pub const WATCHDOG_MINOR: u32 = 130;
pub const TEMP_MINOR: u32 = 131;
pub const APM_MINOR_DEV: u32 = 134;
pub const RTC_MINOR: u32 = 135;
pub const VHCI_MINOR: u32 = 137;
pub const SUN_OPENPROM_MINOR: u32 = 139;
pub const DMAPI_MINOR: u32 = 140;
pub const NVRAM_MINOR: u32 = 144;
pub const SBUS_FLASH_MINOR: u32 = 152;
pub const SGI_MMTIMER: u32 = 153;
pub const PMU_MINOR: u32 = 154;
pub const STORE_QUEUE_MINOR: u32 = 155;
pub const LCD_MINOR: u32 = 156;
pub const AC_MINOR: u32 = 157;
pub const BUTTON_MINOR: u32 = 158;
pub const NWFLASH_MINOR: u32 = 160;
pub const ENVCTRL_MINOR: u32 = 162;
pub const I2O_MINOR: u32 = 166;
pub const UCTRL_MINOR: u32 = 174;
pub const AGPGART_MINOR: u32 = 175;
pub const TOSH_MINOR_DEV: u32 = 181;
pub const HWRNG_MINOR: u32 = 183;
pub const KEYPAD_MINOR: u32 = 185;
pub const IRNET_MINOR: u32 = 187;
pub const D7S_MINOR: u32 = 193;
pub const VFIO_MINOR: u32 = 196;
pub const PXA3XX_GCU_MINOR: u32 = 197;
pub const TUN_MINOR: u32 = 200;
pub const CUSE_MINOR: u32 = 203;
pub const MWAVE_MINOR: u32 = 219;
pub const MPT_MINOR: u32 = 220;
pub const MPT2SAS_MINOR: u32 = 221;
pub const MPT3SAS_MINOR: u32 = 222;
pub const UINPUT_MINOR: u32 = 223;
pub const MISC_MCELOG_MINOR: u32 = 227;
pub const HPET_MINOR: u32 = 228;
pub const FUSE_MINOR: u32 = 229;
pub const SNAPSHOT_MINOR: u32 = 231;
pub const KVM_MINOR: u32 = 232;
pub const BTRFS_MINOR: u32 = 234;
pub const AUTOFS_MINOR: u32 = 235;
pub const MAPPER_CTRL_MINOR: u32 = 236;
pub const LOOP_CTRL_MINOR: u32 = 237;
pub const VHOST_NET_MINOR: u32 = 238;
pub const UHID_MINOR: u32 = 239;
pub const USERIO_MINOR: u32 = 240;
pub const VHOST_VSOCK_MINOR: u32 = 241;
pub const RFKILL_MINOR: u32 = 242;
pub const MISC_DYNAMIC_MINOR: u32 = 255;
pub const MSI_ANY_INDEX: i32 = -1;
pub const PCI_CFG_SPACE_SIZE: u32 = 256;
pub const PCI_CFG_SPACE_EXP_SIZE: u32 = 4096;
pub const PCI_STD_HEADER_SIZEOF: u32 = 64;
pub const PCI_STD_NUM_BARS: u32 = 6;
pub const PCI_VENDOR_ID: u32 = 0;
pub const PCI_DEVICE_ID: u32 = 2;
pub const PCI_COMMAND: u32 = 4;
pub const PCI_COMMAND_IO: u32 = 1;
pub const PCI_COMMAND_MEMORY: u32 = 2;
pub const PCI_COMMAND_MASTER: u32 = 4;
pub const PCI_COMMAND_SPECIAL: u32 = 8;
pub const PCI_COMMAND_INVALIDATE: u32 = 16;
pub const PCI_COMMAND_VGA_PALETTE: u32 = 32;
pub const PCI_COMMAND_PARITY: u32 = 64;
pub const PCI_COMMAND_WAIT: u32 = 128;
pub const PCI_COMMAND_SERR: u32 = 256;
pub const PCI_COMMAND_FAST_BACK: u32 = 512;
pub const PCI_COMMAND_INTX_DISABLE: u32 = 1024;
pub const PCI_STATUS: u32 = 6;
pub const PCI_STATUS_IMM_READY: u32 = 1;
pub const PCI_STATUS_INTERRUPT: u32 = 8;
pub const PCI_STATUS_CAP_LIST: u32 = 16;
pub const PCI_STATUS_66MHZ: u32 = 32;
pub const PCI_STATUS_UDF: u32 = 64;
pub const PCI_STATUS_FAST_BACK: u32 = 128;
pub const PCI_STATUS_PARITY: u32 = 256;
pub const PCI_STATUS_DEVSEL_MASK: u32 = 1536;
pub const PCI_STATUS_DEVSEL_FAST: u32 = 0;
pub const PCI_STATUS_DEVSEL_MEDIUM: u32 = 512;
pub const PCI_STATUS_DEVSEL_SLOW: u32 = 1024;
pub const PCI_STATUS_SIG_TARGET_ABORT: u32 = 2048;
pub const PCI_STATUS_REC_TARGET_ABORT: u32 = 4096;
pub const PCI_STATUS_REC_MASTER_ABORT: u32 = 8192;
pub const PCI_STATUS_SIG_SYSTEM_ERROR: u32 = 16384;
pub const PCI_STATUS_DETECTED_PARITY: u32 = 32768;
pub const PCI_CLASS_REVISION: u32 = 8;
pub const PCI_REVISION_ID: u32 = 8;
pub const PCI_CLASS_PROG: u32 = 9;
pub const PCI_CLASS_DEVICE: u32 = 10;
pub const PCI_CACHE_LINE_SIZE: u32 = 12;
pub const PCI_LATENCY_TIMER: u32 = 13;
pub const PCI_HEADER_TYPE: u32 = 14;
pub const PCI_HEADER_TYPE_MASK: u32 = 127;
pub const PCI_HEADER_TYPE_NORMAL: u32 = 0;
pub const PCI_HEADER_TYPE_BRIDGE: u32 = 1;
pub const PCI_HEADER_TYPE_CARDBUS: u32 = 2;
pub const PCI_HEADER_TYPE_MFD: u32 = 128;
pub const PCI_BIST: u32 = 15;
pub const PCI_BIST_CODE_MASK: u32 = 15;
pub const PCI_BIST_START: u32 = 64;
pub const PCI_BIST_CAPABLE: u32 = 128;
pub const PCI_BASE_ADDRESS_0: u32 = 16;
pub const PCI_BASE_ADDRESS_1: u32 = 20;
pub const PCI_BASE_ADDRESS_2: u32 = 24;
pub const PCI_BASE_ADDRESS_3: u32 = 28;
pub const PCI_BASE_ADDRESS_4: u32 = 32;
pub const PCI_BASE_ADDRESS_5: u32 = 36;
pub const PCI_BASE_ADDRESS_SPACE: u32 = 1;
pub const PCI_BASE_ADDRESS_SPACE_IO: u32 = 1;
pub const PCI_BASE_ADDRESS_SPACE_MEMORY: u32 = 0;
pub const PCI_BASE_ADDRESS_MEM_TYPE_MASK: u32 = 6;
pub const PCI_BASE_ADDRESS_MEM_TYPE_32: u32 = 0;
pub const PCI_BASE_ADDRESS_MEM_TYPE_1M: u32 = 2;
pub const PCI_BASE_ADDRESS_MEM_TYPE_64: u32 = 4;
pub const PCI_BASE_ADDRESS_MEM_PREFETCH: u32 = 8;
pub const PCI_BASE_ADDRESS_MEM_MASK: i32 = -16;
pub const PCI_BASE_ADDRESS_IO_MASK: i32 = -4;
pub const PCI_CARDBUS_CIS: u32 = 40;
pub const PCI_SUBSYSTEM_VENDOR_ID: u32 = 44;
pub const PCI_SUBSYSTEM_ID: u32 = 46;
pub const PCI_ROM_ADDRESS: u32 = 48;
pub const PCI_ROM_ADDRESS_ENABLE: u32 = 1;
pub const PCI_ROM_ADDRESS_MASK: i32 = -2048;
pub const PCI_CAPABILITY_LIST: u32 = 52;
pub const PCI_INTERRUPT_LINE: u32 = 60;
pub const PCI_INTERRUPT_PIN: u32 = 61;
pub const PCI_MIN_GNT: u32 = 62;
pub const PCI_MAX_LAT: u32 = 63;
pub const PCI_PRIMARY_BUS: u32 = 24;
pub const PCI_SECONDARY_BUS: u32 = 25;
pub const PCI_SUBORDINATE_BUS: u32 = 26;
pub const PCI_SEC_LATENCY_TIMER: u32 = 27;
pub const PCI_IO_BASE: u32 = 28;
pub const PCI_IO_LIMIT: u32 = 29;
pub const PCI_IO_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_IO_RANGE_TYPE_16: u32 = 0;
pub const PCI_IO_RANGE_TYPE_32: u32 = 1;
pub const PCI_IO_RANGE_MASK: i32 = -16;
pub const PCI_IO_1K_RANGE_MASK: i32 = -4;
pub const PCI_SEC_STATUS: u32 = 30;
pub const PCI_MEMORY_BASE: u32 = 32;
pub const PCI_MEMORY_LIMIT: u32 = 34;
pub const PCI_MEMORY_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_MEMORY_RANGE_MASK: i32 = -16;
pub const PCI_PREF_MEMORY_BASE: u32 = 36;
pub const PCI_PREF_MEMORY_LIMIT: u32 = 38;
pub const PCI_PREF_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_PREF_RANGE_TYPE_32: u32 = 0;
pub const PCI_PREF_RANGE_TYPE_64: u32 = 1;
pub const PCI_PREF_RANGE_MASK: i32 = -16;
pub const PCI_PREF_BASE_UPPER32: u32 = 40;
pub const PCI_PREF_LIMIT_UPPER32: u32 = 44;
pub const PCI_IO_BASE_UPPER16: u32 = 48;
pub const PCI_IO_LIMIT_UPPER16: u32 = 50;
pub const PCI_ROM_ADDRESS1: u32 = 56;
pub const PCI_BRIDGE_CONTROL: u32 = 62;
pub const PCI_BRIDGE_CTL_PARITY: u32 = 1;
pub const PCI_BRIDGE_CTL_SERR: u32 = 2;
pub const PCI_BRIDGE_CTL_ISA: u32 = 4;
pub const PCI_BRIDGE_CTL_VGA: u32 = 8;
pub const PCI_BRIDGE_CTL_MASTER_ABORT: u32 = 32;
pub const PCI_BRIDGE_CTL_BUS_RESET: u32 = 64;
pub const PCI_BRIDGE_CTL_FAST_BACK: u32 = 128;
pub const PCI_CB_CAPABILITY_LIST: u32 = 20;
pub const PCI_CB_SEC_STATUS: u32 = 22;
pub const PCI_CB_PRIMARY_BUS: u32 = 24;
pub const PCI_CB_CARD_BUS: u32 = 25;
pub const PCI_CB_SUBORDINATE_BUS: u32 = 26;
pub const PCI_CB_LATENCY_TIMER: u32 = 27;
pub const PCI_CB_MEMORY_BASE_0: u32 = 28;
pub const PCI_CB_MEMORY_LIMIT_0: u32 = 32;
pub const PCI_CB_MEMORY_BASE_1: u32 = 36;
pub const PCI_CB_MEMORY_LIMIT_1: u32 = 40;
pub const PCI_CB_IO_BASE_0: u32 = 44;
pub const PCI_CB_IO_BASE_0_HI: u32 = 46;
pub const PCI_CB_IO_LIMIT_0: u32 = 48;
pub const PCI_CB_IO_LIMIT_0_HI: u32 = 50;
pub const PCI_CB_IO_BASE_1: u32 = 52;
pub const PCI_CB_IO_BASE_1_HI: u32 = 54;
pub const PCI_CB_IO_LIMIT_1: u32 = 56;
pub const PCI_CB_IO_LIMIT_1_HI: u32 = 58;
pub const PCI_CB_IO_RANGE_MASK: i32 = -4;
pub const PCI_CB_BRIDGE_CONTROL: u32 = 62;
pub const PCI_CB_BRIDGE_CTL_PARITY: u32 = 1;
pub const PCI_CB_BRIDGE_CTL_SERR: u32 = 2;
pub const PCI_CB_BRIDGE_CTL_ISA: u32 = 4;
pub const PCI_CB_BRIDGE_CTL_VGA: u32 = 8;
pub const PCI_CB_BRIDGE_CTL_MASTER_ABORT: u32 = 32;
pub const PCI_CB_BRIDGE_CTL_CB_RESET: u32 = 64;
pub const PCI_CB_BRIDGE_CTL_16BIT_INT: u32 = 128;
pub const PCI_CB_BRIDGE_CTL_PREFETCH_MEM0: u32 = 256;
pub const PCI_CB_BRIDGE_CTL_PREFETCH_MEM1: u32 = 512;
pub const PCI_CB_BRIDGE_CTL_POST_WRITES: u32 = 1024;
pub const PCI_CB_SUBSYSTEM_VENDOR_ID: u32 = 64;
pub const PCI_CB_SUBSYSTEM_ID: u32 = 66;
pub const PCI_CB_LEGACY_MODE_BASE: u32 = 68;
pub const PCI_CAP_LIST_ID: u32 = 0;
pub const PCI_CAP_ID_PM: u32 = 1;
pub const PCI_CAP_ID_AGP: u32 = 2;
pub const PCI_CAP_ID_VPD: u32 = 3;
pub const PCI_CAP_ID_SLOTID: u32 = 4;
pub const PCI_CAP_ID_MSI: u32 = 5;
pub const PCI_CAP_ID_CHSWP: u32 = 6;
pub const PCI_CAP_ID_PCIX: u32 = 7;
pub const PCI_CAP_ID_HT: u32 = 8;
pub const PCI_CAP_ID_VNDR: u32 = 9;
pub const PCI_CAP_ID_DBG: u32 = 10;
pub const PCI_CAP_ID_CCRC: u32 = 11;
pub const PCI_CAP_ID_SHPC: u32 = 12;
pub const PCI_CAP_ID_SSVID: u32 = 13;
pub const PCI_CAP_ID_AGP3: u32 = 14;
pub const PCI_CAP_ID_SECDEV: u32 = 15;
pub const PCI_CAP_ID_EXP: u32 = 16;
pub const PCI_CAP_ID_MSIX: u32 = 17;
pub const PCI_CAP_ID_SATA: u32 = 18;
pub const PCI_CAP_ID_AF: u32 = 19;
pub const PCI_CAP_ID_EA: u32 = 20;
pub const PCI_CAP_ID_MAX: u32 = 20;
pub const PCI_CAP_LIST_NEXT: u32 = 1;
pub const PCI_CAP_FLAGS: u32 = 2;
pub const PCI_CAP_SIZEOF: u32 = 4;
pub const PCI_PM_PMC: u32 = 2;
pub const PCI_PM_CAP_VER_MASK: u32 = 7;
pub const PCI_PM_CAP_PME_CLOCK: u32 = 8;
pub const PCI_PM_CAP_RESERVED: u32 = 16;
pub const PCI_PM_CAP_DSI: u32 = 32;
pub const PCI_PM_CAP_AUX_POWER: u32 = 448;
pub const PCI_PM_CAP_D1: u32 = 512;
pub const PCI_PM_CAP_D2: u32 = 1024;
pub const PCI_PM_CAP_PME: u32 = 2048;
pub const PCI_PM_CAP_PME_MASK: u32 = 63488;
pub const PCI_PM_CAP_PME_D0: u32 = 2048;
pub const PCI_PM_CAP_PME_D1: u32 = 4096;
pub const PCI_PM_CAP_PME_D2: u32 = 8192;
pub const PCI_PM_CAP_PME_D3hot: u32 = 16384;
pub const PCI_PM_CAP_PME_D3cold: u32 = 32768;
pub const PCI_PM_CAP_PME_SHIFT: u32 = 11;
pub const PCI_PM_CTRL: u32 = 4;
pub const PCI_PM_CTRL_STATE_MASK: u32 = 3;
pub const PCI_PM_CTRL_NO_SOFT_RESET: u32 = 8;
pub const PCI_PM_CTRL_PME_ENABLE: u32 = 256;
pub const PCI_PM_CTRL_DATA_SEL_MASK: u32 = 7680;
pub const PCI_PM_CTRL_DATA_SCALE_MASK: u32 = 24576;
pub const PCI_PM_CTRL_PME_STATUS: u32 = 32768;
pub const PCI_PM_PPB_EXTENSIONS: u32 = 6;
pub const PCI_PM_PPB_B2_B3: u32 = 64;
pub const PCI_PM_BPCC_ENABLE: u32 = 128;
pub const PCI_PM_DATA_REGISTER: u32 = 7;
pub const PCI_PM_SIZEOF: u32 = 8;
pub const PCI_AGP_VERSION: u32 = 2;
pub const PCI_AGP_RFU: u32 = 3;
pub const PCI_AGP_STATUS: u32 = 4;
pub const PCI_AGP_STATUS_RQ_MASK: u32 = 4278190080;
pub const PCI_AGP_STATUS_SBA: u32 = 512;
pub const PCI_AGP_STATUS_64BIT: u32 = 32;
pub const PCI_AGP_STATUS_FW: u32 = 16;
pub const PCI_AGP_STATUS_RATE4: u32 = 4;
pub const PCI_AGP_STATUS_RATE2: u32 = 2;
pub const PCI_AGP_STATUS_RATE1: u32 = 1;
pub const PCI_AGP_COMMAND: u32 = 8;
pub const PCI_AGP_COMMAND_RQ_MASK: u32 = 4278190080;
pub const PCI_AGP_COMMAND_SBA: u32 = 512;
pub const PCI_AGP_COMMAND_AGP: u32 = 256;
pub const PCI_AGP_COMMAND_64BIT: u32 = 32;
pub const PCI_AGP_COMMAND_FW: u32 = 16;
pub const PCI_AGP_COMMAND_RATE4: u32 = 4;
pub const PCI_AGP_COMMAND_RATE2: u32 = 2;
pub const PCI_AGP_COMMAND_RATE1: u32 = 1;
pub const PCI_AGP_SIZEOF: u32 = 12;
pub const PCI_VPD_ADDR: u32 = 2;
pub const PCI_VPD_ADDR_MASK: u32 = 32767;
pub const PCI_VPD_ADDR_F: u32 = 32768;
pub const PCI_VPD_DATA: u32 = 4;
pub const PCI_CAP_VPD_SIZEOF: u32 = 8;
pub const PCI_SID_ESR: u32 = 2;
pub const PCI_SID_ESR_NSLOTS: u32 = 31;
pub const PCI_SID_ESR_FIC: u32 = 32;
pub const PCI_SID_CHASSIS_NR: u32 = 3;
pub const PCI_MSI_FLAGS: u32 = 2;
pub const PCI_MSI_FLAGS_ENABLE: u32 = 1;
pub const PCI_MSI_FLAGS_QMASK: u32 = 14;
pub const PCI_MSI_FLAGS_QSIZE: u32 = 112;
pub const PCI_MSI_FLAGS_64BIT: u32 = 128;
pub const PCI_MSI_FLAGS_MASKBIT: u32 = 256;
pub const PCI_MSI_RFU: u32 = 3;
pub const PCI_MSI_ADDRESS_LO: u32 = 4;
pub const PCI_MSI_ADDRESS_HI: u32 = 8;
pub const PCI_MSI_DATA_32: u32 = 8;
pub const PCI_MSI_MASK_32: u32 = 12;
pub const PCI_MSI_PENDING_32: u32 = 16;
pub const PCI_MSI_DATA_64: u32 = 12;
pub const PCI_MSI_MASK_64: u32 = 16;
pub const PCI_MSI_PENDING_64: u32 = 20;
pub const PCI_MSIX_FLAGS: u32 = 2;
pub const PCI_MSIX_FLAGS_QSIZE: u32 = 2047;
pub const PCI_MSIX_FLAGS_MASKALL: u32 = 16384;
pub const PCI_MSIX_FLAGS_ENABLE: u32 = 32768;
pub const PCI_MSIX_TABLE: u32 = 4;
pub const PCI_MSIX_TABLE_BIR: u32 = 7;
pub const PCI_MSIX_TABLE_OFFSET: u32 = 4294967288;
pub const PCI_MSIX_PBA: u32 = 8;
pub const PCI_MSIX_PBA_BIR: u32 = 7;
pub const PCI_MSIX_PBA_OFFSET: u32 = 4294967288;
pub const PCI_MSIX_FLAGS_BIRMASK: u32 = 7;
pub const PCI_CAP_MSIX_SIZEOF: u32 = 12;
pub const PCI_MSIX_ENTRY_SIZE: u32 = 16;
pub const PCI_MSIX_ENTRY_LOWER_ADDR: u32 = 0;
pub const PCI_MSIX_ENTRY_UPPER_ADDR: u32 = 4;
pub const PCI_MSIX_ENTRY_DATA: u32 = 8;
pub const PCI_MSIX_ENTRY_VECTOR_CTRL: u32 = 12;
pub const PCI_MSIX_ENTRY_CTRL_MASKBIT: u32 = 1;
pub const PCI_MSIX_ENTRY_CTRL_ST: u32 = 4294901760;
pub const PCI_CHSWP_CSR: u32 = 2;
pub const PCI_CHSWP_DHA: u32 = 1;
pub const PCI_CHSWP_EIM: u32 = 2;
pub const PCI_CHSWP_PIE: u32 = 4;
pub const PCI_CHSWP_LOO: u32 = 8;
pub const PCI_CHSWP_PI: u32 = 48;
pub const PCI_CHSWP_EXT: u32 = 64;
pub const PCI_CHSWP_INS: u32 = 128;
pub const PCI_AF_LENGTH: u32 = 2;
pub const PCI_AF_CAP: u32 = 3;
pub const PCI_AF_CAP_TP: u32 = 1;
pub const PCI_AF_CAP_FLR: u32 = 2;
pub const PCI_AF_CTRL: u32 = 4;
pub const PCI_AF_CTRL_FLR: u32 = 1;
pub const PCI_AF_STATUS: u32 = 5;
pub const PCI_AF_STATUS_TP: u32 = 1;
pub const PCI_CAP_AF_SIZEOF: u32 = 6;
pub const PCI_EA_NUM_ENT: u32 = 2;
pub const PCI_EA_NUM_ENT_MASK: u32 = 63;
pub const PCI_EA_FIRST_ENT: u32 = 4;
pub const PCI_EA_FIRST_ENT_BRIDGE: u32 = 8;
pub const PCI_EA_ES: u32 = 7;
pub const PCI_EA_BEI: u32 = 240;
pub const PCI_EA_SEC_BUS_MASK: u32 = 255;
pub const PCI_EA_SUB_BUS_MASK: u32 = 65280;
pub const PCI_EA_SUB_BUS_SHIFT: u32 = 8;
pub const PCI_EA_BEI_BAR0: u32 = 0;
pub const PCI_EA_BEI_BAR5: u32 = 5;
pub const PCI_EA_BEI_BRIDGE: u32 = 6;
pub const PCI_EA_BEI_ENI: u32 = 7;
pub const PCI_EA_BEI_ROM: u32 = 8;
pub const PCI_EA_BEI_VF_BAR0: u32 = 9;
pub const PCI_EA_BEI_VF_BAR5: u32 = 14;
pub const PCI_EA_BEI_RESERVED: u32 = 15;
pub const PCI_EA_PP: u32 = 65280;
pub const PCI_EA_SP: u32 = 16711680;
pub const PCI_EA_P_MEM: u32 = 0;
pub const PCI_EA_P_MEM_PREFETCH: u32 = 1;
pub const PCI_EA_P_IO: u32 = 2;
pub const PCI_EA_P_VF_MEM_PREFETCH: u32 = 3;
pub const PCI_EA_P_VF_MEM: u32 = 4;
pub const PCI_EA_P_BRIDGE_MEM: u32 = 5;
pub const PCI_EA_P_BRIDGE_MEM_PREFETCH: u32 = 6;
pub const PCI_EA_P_BRIDGE_IO: u32 = 7;
pub const PCI_EA_P_MEM_RESERVED: u32 = 253;
pub const PCI_EA_P_IO_RESERVED: u32 = 254;
pub const PCI_EA_P_UNAVAILABLE: u32 = 255;
pub const PCI_EA_WRITABLE: u32 = 1073741824;
pub const PCI_EA_ENABLE: u32 = 2147483648;
pub const PCI_EA_BASE: u32 = 4;
pub const PCI_EA_MAX_OFFSET: u32 = 8;
pub const PCI_EA_IS_64: u32 = 2;
pub const PCI_EA_FIELD_MASK: u32 = 4294967292;
pub const PCI_X_CMD: u32 = 2;
pub const PCI_X_CMD_DPERR_E: u32 = 1;
pub const PCI_X_CMD_ERO: u32 = 2;
pub const PCI_X_CMD_READ_512: u32 = 0;
pub const PCI_X_CMD_READ_1K: u32 = 4;
pub const PCI_X_CMD_READ_2K: u32 = 8;
pub const PCI_X_CMD_READ_4K: u32 = 12;
pub const PCI_X_CMD_MAX_READ: u32 = 12;
pub const PCI_X_CMD_SPLIT_1: u32 = 0;
pub const PCI_X_CMD_SPLIT_2: u32 = 16;
pub const PCI_X_CMD_SPLIT_3: u32 = 32;
pub const PCI_X_CMD_SPLIT_4: u32 = 48;
pub const PCI_X_CMD_SPLIT_8: u32 = 64;
pub const PCI_X_CMD_SPLIT_12: u32 = 80;
pub const PCI_X_CMD_SPLIT_16: u32 = 96;
pub const PCI_X_CMD_SPLIT_32: u32 = 112;
pub const PCI_X_CMD_MAX_SPLIT: u32 = 112;
pub const PCI_X_STATUS: u32 = 4;
pub const PCI_X_STATUS_DEVFN: u32 = 255;
pub const PCI_X_STATUS_BUS: u32 = 65280;
pub const PCI_X_STATUS_64BIT: u32 = 65536;
pub const PCI_X_STATUS_133MHZ: u32 = 131072;
pub const PCI_X_STATUS_SPL_DISC: u32 = 262144;
pub const PCI_X_STATUS_UNX_SPL: u32 = 524288;
pub const PCI_X_STATUS_COMPLEX: u32 = 1048576;
pub const PCI_X_STATUS_MAX_READ: u32 = 6291456;
pub const PCI_X_STATUS_MAX_SPLIT: u32 = 58720256;
pub const PCI_X_STATUS_MAX_CUM: u32 = 469762048;
pub const PCI_X_STATUS_SPL_ERR: u32 = 536870912;
pub const PCI_X_STATUS_266MHZ: u32 = 1073741824;
pub const PCI_X_STATUS_533MHZ: u32 = 2147483648;
pub const PCI_X_ECC_CSR: u32 = 8;
pub const PCI_CAP_PCIX_SIZEOF_V0: u32 = 8;
pub const PCI_CAP_PCIX_SIZEOF_V1: u32 = 24;
pub const PCI_CAP_PCIX_SIZEOF_V2: u32 = 24;
pub const PCI_X_BRIDGE_SSTATUS: u32 = 2;
pub const PCI_X_SSTATUS_64BIT: u32 = 1;
pub const PCI_X_SSTATUS_133MHZ: u32 = 2;
pub const PCI_X_SSTATUS_FREQ: u32 = 960;
pub const PCI_X_SSTATUS_VERS: u32 = 12288;
pub const PCI_X_SSTATUS_V1: u32 = 4096;
pub const PCI_X_SSTATUS_V2: u32 = 8192;
pub const PCI_X_SSTATUS_266MHZ: u32 = 16384;
pub const PCI_X_SSTATUS_533MHZ: u32 = 32768;
pub const PCI_X_BRIDGE_STATUS: u32 = 4;
pub const PCI_SSVID_VENDOR_ID: u32 = 4;
pub const PCI_SSVID_DEVICE_ID: u32 = 6;
pub const PCI_EXP_FLAGS: u32 = 2;
pub const PCI_EXP_FLAGS_VERS: u32 = 15;
pub const PCI_EXP_FLAGS_TYPE: u32 = 240;
pub const PCI_EXP_TYPE_ENDPOINT: u32 = 0;
pub const PCI_EXP_TYPE_LEG_END: u32 = 1;
pub const PCI_EXP_TYPE_ROOT_PORT: u32 = 4;
pub const PCI_EXP_TYPE_UPSTREAM: u32 = 5;
pub const PCI_EXP_TYPE_DOWNSTREAM: u32 = 6;
pub const PCI_EXP_TYPE_PCI_BRIDGE: u32 = 7;
pub const PCI_EXP_TYPE_PCIE_BRIDGE: u32 = 8;
pub const PCI_EXP_TYPE_RC_END: u32 = 9;
pub const PCI_EXP_TYPE_RC_EC: u32 = 10;
pub const PCI_EXP_FLAGS_SLOT: u32 = 256;
pub const PCI_EXP_FLAGS_IRQ: u32 = 15872;
pub const PCI_EXP_FLAGS_FLIT: u32 = 32768;
pub const PCI_EXP_DEVCAP: u32 = 4;
pub const PCI_EXP_DEVCAP_PAYLOAD: u32 = 7;
pub const PCI_EXP_DEVCAP_PHANTOM: u32 = 24;
pub const PCI_EXP_DEVCAP_EXT_TAG: u32 = 32;
pub const PCI_EXP_DEVCAP_L0S: u32 = 448;
pub const PCI_EXP_DEVCAP_L1: u32 = 3584;
pub const PCI_EXP_DEVCAP_ATN_BUT: u32 = 4096;
pub const PCI_EXP_DEVCAP_ATN_IND: u32 = 8192;
pub const PCI_EXP_DEVCAP_PWR_IND: u32 = 16384;
pub const PCI_EXP_DEVCAP_RBER: u32 = 32768;
pub const PCI_EXP_DEVCAP_PWR_VAL: u32 = 66846720;
pub const PCI_EXP_DEVCAP_PWR_SCL: u32 = 201326592;
pub const PCI_EXP_DEVCAP_FLR: u32 = 268435456;
pub const PCI_EXP_DEVCTL: u32 = 8;
pub const PCI_EXP_DEVCTL_CERE: u32 = 1;
pub const PCI_EXP_DEVCTL_NFERE: u32 = 2;
pub const PCI_EXP_DEVCTL_FERE: u32 = 4;
pub const PCI_EXP_DEVCTL_URRE: u32 = 8;
pub const PCI_EXP_DEVCTL_RELAX_EN: u32 = 16;
pub const PCI_EXP_DEVCTL_PAYLOAD: u32 = 224;
pub const PCI_EXP_DEVCTL_PAYLOAD_128B: u32 = 0;
pub const PCI_EXP_DEVCTL_PAYLOAD_256B: u32 = 32;
pub const PCI_EXP_DEVCTL_PAYLOAD_512B: u32 = 64;
pub const PCI_EXP_DEVCTL_PAYLOAD_1024B: u32 = 96;
pub const PCI_EXP_DEVCTL_PAYLOAD_2048B: u32 = 128;
pub const PCI_EXP_DEVCTL_PAYLOAD_4096B: u32 = 160;
pub const PCI_EXP_DEVCTL_EXT_TAG: u32 = 256;
pub const PCI_EXP_DEVCTL_PHANTOM: u32 = 512;
pub const PCI_EXP_DEVCTL_AUX_PME: u32 = 1024;
pub const PCI_EXP_DEVCTL_NOSNOOP_EN: u32 = 2048;
pub const PCI_EXP_DEVCTL_READRQ: u32 = 28672;
pub const PCI_EXP_DEVCTL_READRQ_128B: u32 = 0;
pub const PCI_EXP_DEVCTL_READRQ_256B: u32 = 4096;
pub const PCI_EXP_DEVCTL_READRQ_512B: u32 = 8192;
pub const PCI_EXP_DEVCTL_READRQ_1024B: u32 = 12288;
pub const PCI_EXP_DEVCTL_READRQ_2048B: u32 = 16384;
pub const PCI_EXP_DEVCTL_READRQ_4096B: u32 = 20480;
pub const PCI_EXP_DEVCTL_BCR_FLR: u32 = 32768;
pub const PCI_EXP_DEVSTA: u32 = 10;
pub const PCI_EXP_DEVSTA_CED: u32 = 1;
pub const PCI_EXP_DEVSTA_NFED: u32 = 2;
pub const PCI_EXP_DEVSTA_FED: u32 = 4;
pub const PCI_EXP_DEVSTA_URD: u32 = 8;
pub const PCI_EXP_DEVSTA_AUXPD: u32 = 16;
pub const PCI_EXP_DEVSTA_TRPND: u32 = 32;
pub const PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V1: u32 = 12;
pub const PCI_EXP_LNKCAP: u32 = 12;
pub const PCI_EXP_LNKCAP_SLS: u32 = 15;
pub const PCI_EXP_LNKCAP_SLS_2_5GB: u32 = 1;
pub const PCI_EXP_LNKCAP_SLS_5_0GB: u32 = 2;
pub const PCI_EXP_LNKCAP_SLS_8_0GB: u32 = 3;
pub const PCI_EXP_LNKCAP_SLS_16_0GB: u32 = 4;
pub const PCI_EXP_LNKCAP_SLS_32_0GB: u32 = 5;
pub const PCI_EXP_LNKCAP_SLS_64_0GB: u32 = 6;
pub const PCI_EXP_LNKCAP_MLW: u32 = 1008;
pub const PCI_EXP_LNKCAP_ASPMS: u32 = 3072;
pub const PCI_EXP_LNKCAP_ASPM_L0S: u32 = 1024;
pub const PCI_EXP_LNKCAP_ASPM_L1: u32 = 2048;
pub const PCI_EXP_LNKCAP_L0SEL: u32 = 28672;
pub const PCI_EXP_LNKCAP_L1EL: u32 = 229376;
pub const PCI_EXP_LNKCAP_CLKPM: u32 = 262144;
pub const PCI_EXP_LNKCAP_SDERC: u32 = 524288;
pub const PCI_EXP_LNKCAP_DLLLARC: u32 = 1048576;
pub const PCI_EXP_LNKCAP_LBNC: u32 = 2097152;
pub const PCI_EXP_LNKCAP_PN: u32 = 4278190080;
pub const PCI_EXP_LNKCTL: u32 = 16;
pub const PCI_EXP_LNKCTL_ASPMC: u32 = 3;
pub const PCI_EXP_LNKCTL_ASPM_L0S: u32 = 1;
pub const PCI_EXP_LNKCTL_ASPM_L1: u32 = 2;
pub const PCI_EXP_LNKCTL_RCB: u32 = 8;
pub const PCI_EXP_LNKCTL_LD: u32 = 16;
pub const PCI_EXP_LNKCTL_RL: u32 = 32;
pub const PCI_EXP_LNKCTL_CCC: u32 = 64;
pub const PCI_EXP_LNKCTL_ES: u32 = 128;
pub const PCI_EXP_LNKCTL_CLKREQ_EN: u32 = 256;
pub const PCI_EXP_LNKCTL_HAWD: u32 = 512;
pub const PCI_EXP_LNKCTL_LBMIE: u32 = 1024;
pub const PCI_EXP_LNKCTL_LABIE: u32 = 2048;
pub const PCI_EXP_LNKSTA: u32 = 18;
pub const PCI_EXP_LNKSTA_CLS: u32 = 15;
pub const PCI_EXP_LNKSTA_CLS_2_5GB: u32 = 1;
pub const PCI_EXP_LNKSTA_CLS_5_0GB: u32 = 2;
pub const PCI_EXP_LNKSTA_CLS_8_0GB: u32 = 3;
pub const PCI_EXP_LNKSTA_CLS_16_0GB: u32 = 4;
pub const PCI_EXP_LNKSTA_CLS_32_0GB: u32 = 5;
pub const PCI_EXP_LNKSTA_CLS_64_0GB: u32 = 6;
pub const PCI_EXP_LNKSTA_NLW: u32 = 1008;
pub const PCI_EXP_LNKSTA_NLW_X1: u32 = 16;
pub const PCI_EXP_LNKSTA_NLW_X2: u32 = 32;
pub const PCI_EXP_LNKSTA_NLW_X4: u32 = 64;
pub const PCI_EXP_LNKSTA_NLW_X8: u32 = 128;
pub const PCI_EXP_LNKSTA_NLW_SHIFT: u32 = 4;
pub const PCI_EXP_LNKSTA_LT: u32 = 2048;
pub const PCI_EXP_LNKSTA_SLC: u32 = 4096;
pub const PCI_EXP_LNKSTA_DLLLA: u32 = 8192;
pub const PCI_EXP_LNKSTA_LBMS: u32 = 16384;
pub const PCI_EXP_LNKSTA_LABS: u32 = 32768;
pub const PCI_CAP_EXP_ENDPOINT_SIZEOF_V1: u32 = 20;
pub const PCI_EXP_SLTCAP: u32 = 20;
pub const PCI_EXP_SLTCAP_ABP: u32 = 1;
pub const PCI_EXP_SLTCAP_PCP: u32 = 2;
pub const PCI_EXP_SLTCAP_MRLSP: u32 = 4;
pub const PCI_EXP_SLTCAP_AIP: u32 = 8;
pub const PCI_EXP_SLTCAP_PIP: u32 = 16;
pub const PCI_EXP_SLTCAP_HPS: u32 = 32;
pub const PCI_EXP_SLTCAP_HPC: u32 = 64;
pub const PCI_EXP_SLTCAP_SPLV: u32 = 32640;
pub const PCI_EXP_SLTCAP_SPLS: u32 = 98304;
pub const PCI_EXP_SLTCAP_EIP: u32 = 131072;
pub const PCI_EXP_SLTCAP_NCCS: u32 = 262144;
pub const PCI_EXP_SLTCAP_PSN: u32 = 4294443008;
pub const PCI_EXP_SLTCTL: u32 = 24;
pub const PCI_EXP_SLTCTL_ABPE: u32 = 1;
pub const PCI_EXP_SLTCTL_PFDE: u32 = 2;
pub const PCI_EXP_SLTCTL_MRLSCE: u32 = 4;
pub const PCI_EXP_SLTCTL_PDCE: u32 = 8;
pub const PCI_EXP_SLTCTL_CCIE: u32 = 16;
pub const PCI_EXP_SLTCTL_HPIE: u32 = 32;
pub const PCI_EXP_SLTCTL_AIC: u32 = 192;
pub const PCI_EXP_SLTCTL_ATTN_IND_SHIFT: u32 = 6;
pub const PCI_EXP_SLTCTL_ATTN_IND_ON: u32 = 64;
pub const PCI_EXP_SLTCTL_ATTN_IND_BLINK: u32 = 128;
pub const PCI_EXP_SLTCTL_ATTN_IND_OFF: u32 = 192;
pub const PCI_EXP_SLTCTL_PIC: u32 = 768;
pub const PCI_EXP_SLTCTL_PWR_IND_ON: u32 = 256;
pub const PCI_EXP_SLTCTL_PWR_IND_BLINK: u32 = 512;
pub const PCI_EXP_SLTCTL_PWR_IND_OFF: u32 = 768;
pub const PCI_EXP_SLTCTL_PCC: u32 = 1024;
pub const PCI_EXP_SLTCTL_PWR_ON: u32 = 0;
pub const PCI_EXP_SLTCTL_PWR_OFF: u32 = 1024;
pub const PCI_EXP_SLTCTL_EIC: u32 = 2048;
pub const PCI_EXP_SLTCTL_DLLSCE: u32 = 4096;
pub const PCI_EXP_SLTCTL_ASPL_DISABLE: u32 = 8192;
pub const PCI_EXP_SLTCTL_IBPD_DISABLE: u32 = 16384;
pub const PCI_EXP_SLTSTA: u32 = 26;
pub const PCI_EXP_SLTSTA_ABP: u32 = 1;
pub const PCI_EXP_SLTSTA_PFD: u32 = 2;
pub const PCI_EXP_SLTSTA_MRLSC: u32 = 4;
pub const PCI_EXP_SLTSTA_PDC: u32 = 8;
pub const PCI_EXP_SLTSTA_CC: u32 = 16;
pub const PCI_EXP_SLTSTA_MRLSS: u32 = 32;
pub const PCI_EXP_SLTSTA_PDS: u32 = 64;
pub const PCI_EXP_SLTSTA_EIS: u32 = 128;
pub const PCI_EXP_SLTSTA_DLLSC: u32 = 256;
pub const PCI_EXP_RTCTL: u32 = 28;
pub const PCI_EXP_RTCTL_SECEE: u32 = 1;
pub const PCI_EXP_RTCTL_SENFEE: u32 = 2;
pub const PCI_EXP_RTCTL_SEFEE: u32 = 4;
pub const PCI_EXP_RTCTL_PMEIE: u32 = 8;
pub const PCI_EXP_RTCTL_RRS_SVE: u32 = 16;
pub const PCI_EXP_RTCTL_CRSSVE: u32 = 16;
pub const PCI_EXP_RTCAP: u32 = 30;
pub const PCI_EXP_RTCAP_RRS_SV: u32 = 1;
pub const PCI_EXP_RTCAP_CRSVIS: u32 = 1;
pub const PCI_EXP_RTSTA: u32 = 32;
pub const PCI_EXP_RTSTA_PME_RQ_ID: u32 = 65535;
pub const PCI_EXP_RTSTA_PME: u32 = 65536;
pub const PCI_EXP_RTSTA_PENDING: u32 = 131072;
pub const PCI_EXP_DEVCAP2: u32 = 36;
pub const PCI_EXP_DEVCAP2_COMP_TMOUT_DIS: u32 = 16;
pub const PCI_EXP_DEVCAP2_ARI: u32 = 32;
pub const PCI_EXP_DEVCAP2_ATOMIC_ROUTE: u32 = 64;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP32: u32 = 128;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP64: u32 = 256;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP128: u32 = 512;
pub const PCI_EXP_DEVCAP2_LTR: u32 = 2048;
pub const PCI_EXP_DEVCAP2_TPH_COMP_MASK: u32 = 12288;
pub const PCI_EXP_DEVCAP2_OBFF_MASK: u32 = 786432;
pub const PCI_EXP_DEVCAP2_OBFF_MSG: u32 = 262144;
pub const PCI_EXP_DEVCAP2_OBFF_WAKE: u32 = 524288;
pub const PCI_EXP_DEVCAP2_EE_PREFIX: u32 = 2097152;
pub const PCI_EXP_DEVCAP2_EE_PREFIX_MAX: u32 = 12582912;
pub const PCI_EXP_DEVCTL2: u32 = 40;
pub const PCI_EXP_DEVCTL2_COMP_TIMEOUT: u32 = 15;
pub const PCI_EXP_DEVCTL2_COMP_TMOUT_DIS: u32 = 16;
pub const PCI_EXP_DEVCTL2_ARI: u32 = 32;
pub const PCI_EXP_DEVCTL2_ATOMIC_REQ: u32 = 64;
pub const PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK: u32 = 128;
pub const PCI_EXP_DEVCTL2_IDO_REQ_EN: u32 = 256;
pub const PCI_EXP_DEVCTL2_IDO_CMP_EN: u32 = 512;
pub const PCI_EXP_DEVCTL2_LTR_EN: u32 = 1024;
pub const PCI_EXP_DEVCTL2_OBFF_MSGA_EN: u32 = 8192;
pub const PCI_EXP_DEVCTL2_OBFF_MSGB_EN: u32 = 16384;
pub const PCI_EXP_DEVCTL2_OBFF_WAKE_EN: u32 = 24576;
pub const PCI_EXP_DEVSTA2: u32 = 42;
pub const PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V2: u32 = 44;
pub const PCI_EXP_LNKCAP2: u32 = 44;
pub const PCI_EXP_LNKCAP2_SLS: u32 = 254;
pub const PCI_EXP_LNKCAP2_SLS_2_5GB: u32 = 2;
pub const PCI_EXP_LNKCAP2_SLS_5_0GB: u32 = 4;
pub const PCI_EXP_LNKCAP2_SLS_8_0GB: u32 = 8;
pub const PCI_EXP_LNKCAP2_SLS_16_0GB: u32 = 16;
pub const PCI_EXP_LNKCAP2_SLS_32_0GB: u32 = 32;
pub const PCI_EXP_LNKCAP2_SLS_64_0GB: u32 = 64;
pub const PCI_EXP_LNKCAP2_CROSSLINK: u32 = 256;
pub const PCI_EXP_LNKCTL2: u32 = 48;
pub const PCI_EXP_LNKCTL2_TLS: u32 = 15;
pub const PCI_EXP_LNKCTL2_TLS_2_5GT: u32 = 1;
pub const PCI_EXP_LNKCTL2_TLS_5_0GT: u32 = 2;
pub const PCI_EXP_LNKCTL2_TLS_8_0GT: u32 = 3;
pub const PCI_EXP_LNKCTL2_TLS_16_0GT: u32 = 4;
pub const PCI_EXP_LNKCTL2_TLS_32_0GT: u32 = 5;
pub const PCI_EXP_LNKCTL2_TLS_64_0GT: u32 = 6;
pub const PCI_EXP_LNKCTL2_ENTER_COMP: u32 = 16;
pub const PCI_EXP_LNKCTL2_TX_MARGIN: u32 = 896;
pub const PCI_EXP_LNKCTL2_HASD: u32 = 32;
pub const PCI_EXP_LNKSTA2: u32 = 50;
pub const PCI_EXP_LNKSTA2_FLIT: u32 = 1024;
pub const PCI_CAP_EXP_ENDPOINT_SIZEOF_V2: u32 = 50;
pub const PCI_EXP_SLTCAP2: u32 = 52;
pub const PCI_EXP_SLTCAP2_IBPD: u32 = 1;
pub const PCI_EXP_SLTCTL2: u32 = 56;
pub const PCI_EXP_SLTSTA2: u32 = 58;
pub const PCI_EXT_CAP_ID_ERR: u32 = 1;
pub const PCI_EXT_CAP_ID_VC: u32 = 2;
pub const PCI_EXT_CAP_ID_DSN: u32 = 3;
pub const PCI_EXT_CAP_ID_PWR: u32 = 4;
pub const PCI_EXT_CAP_ID_RCLD: u32 = 5;
pub const PCI_EXT_CAP_ID_RCILC: u32 = 6;
pub const PCI_EXT_CAP_ID_RCEC: u32 = 7;
pub const PCI_EXT_CAP_ID_MFVC: u32 = 8;
pub const PCI_EXT_CAP_ID_VC9: u32 = 9;
pub const PCI_EXT_CAP_ID_RCRB: u32 = 10;
pub const PCI_EXT_CAP_ID_VNDR: u32 = 11;
pub const PCI_EXT_CAP_ID_CAC: u32 = 12;
pub const PCI_EXT_CAP_ID_ACS: u32 = 13;
pub const PCI_EXT_CAP_ID_ARI: u32 = 14;
pub const PCI_EXT_CAP_ID_ATS: u32 = 15;
pub const PCI_EXT_CAP_ID_SRIOV: u32 = 16;
pub const PCI_EXT_CAP_ID_MRIOV: u32 = 17;
pub const PCI_EXT_CAP_ID_MCAST: u32 = 18;
pub const PCI_EXT_CAP_ID_PRI: u32 = 19;
pub const PCI_EXT_CAP_ID_AMD_XXX: u32 = 20;
pub const PCI_EXT_CAP_ID_REBAR: u32 = 21;
pub const PCI_EXT_CAP_ID_DPA: u32 = 22;
pub const PCI_EXT_CAP_ID_TPH: u32 = 23;
pub const PCI_EXT_CAP_ID_LTR: u32 = 24;
pub const PCI_EXT_CAP_ID_SECPCI: u32 = 25;
pub const PCI_EXT_CAP_ID_PMUX: u32 = 26;
pub const PCI_EXT_CAP_ID_PASID: u32 = 27;
pub const PCI_EXT_CAP_ID_DPC: u32 = 29;
pub const PCI_EXT_CAP_ID_L1SS: u32 = 30;
pub const PCI_EXT_CAP_ID_PTM: u32 = 31;
pub const PCI_EXT_CAP_ID_DVSEC: u32 = 35;
pub const PCI_EXT_CAP_ID_VF_REBAR: u32 = 36;
pub const PCI_EXT_CAP_ID_DLF: u32 = 37;
pub const PCI_EXT_CAP_ID_PL_16GT: u32 = 38;
pub const PCI_EXT_CAP_ID_NPEM: u32 = 41;
pub const PCI_EXT_CAP_ID_PL_32GT: u32 = 42;
pub const PCI_EXT_CAP_ID_DOE: u32 = 46;
pub const PCI_EXT_CAP_ID_PL_64GT: u32 = 49;
pub const PCI_EXT_CAP_ID_MAX: u32 = 49;
pub const PCI_EXT_CAP_DSN_SIZEOF: u32 = 12;
pub const PCI_EXT_CAP_MCAST_ENDPOINT_SIZEOF: u32 = 40;
pub const PCI_ERR_UNCOR_STATUS: u32 = 4;
pub const PCI_ERR_UNC_UND: u32 = 1;
pub const PCI_ERR_UNC_DLP: u32 = 16;
pub const PCI_ERR_UNC_SURPDN: u32 = 32;
pub const PCI_ERR_UNC_POISON_TLP: u32 = 4096;
pub const PCI_ERR_UNC_FCP: u32 = 8192;
pub const PCI_ERR_UNC_COMP_TIME: u32 = 16384;
pub const PCI_ERR_UNC_COMP_ABORT: u32 = 32768;
pub const PCI_ERR_UNC_UNX_COMP: u32 = 65536;
pub const PCI_ERR_UNC_RX_OVER: u32 = 131072;
pub const PCI_ERR_UNC_MALF_TLP: u32 = 262144;
pub const PCI_ERR_UNC_ECRC: u32 = 524288;
pub const PCI_ERR_UNC_UNSUP: u32 = 1048576;
pub const PCI_ERR_UNC_ACSV: u32 = 2097152;
pub const PCI_ERR_UNC_INTN: u32 = 4194304;
pub const PCI_ERR_UNC_MCBTLP: u32 = 8388608;
pub const PCI_ERR_UNC_ATOMEG: u32 = 16777216;
pub const PCI_ERR_UNC_TLPPRE: u32 = 33554432;
pub const PCI_ERR_UNCOR_MASK: u32 = 8;
pub const PCI_ERR_UNCOR_SEVER: u32 = 12;
pub const PCI_ERR_COR_STATUS: u32 = 16;
pub const PCI_ERR_COR_RCVR: u32 = 1;
pub const PCI_ERR_COR_BAD_TLP: u32 = 64;
pub const PCI_ERR_COR_BAD_DLLP: u32 = 128;
pub const PCI_ERR_COR_REP_ROLL: u32 = 256;
pub const PCI_ERR_COR_REP_TIMER: u32 = 4096;
pub const PCI_ERR_COR_ADV_NFAT: u32 = 8192;
pub const PCI_ERR_COR_INTERNAL: u32 = 16384;
pub const PCI_ERR_COR_LOG_OVER: u32 = 32768;
pub const PCI_ERR_COR_MASK: u32 = 20;
pub const PCI_ERR_CAP: u32 = 24;
pub const PCI_ERR_CAP_ECRC_GENC: u32 = 32;
pub const PCI_ERR_CAP_ECRC_GENE: u32 = 64;
pub const PCI_ERR_CAP_ECRC_CHKC: u32 = 128;
pub const PCI_ERR_CAP_ECRC_CHKE: u32 = 256;
pub const PCI_ERR_CAP_PREFIX_LOG_PRESENT: u32 = 2048;
pub const PCI_ERR_CAP_TLP_LOG_FLIT: u32 = 262144;
pub const PCI_ERR_CAP_TLP_LOG_SIZE: u32 = 16252928;
pub const PCI_ERR_HEADER_LOG: u32 = 28;
pub const PCI_ERR_ROOT_COMMAND: u32 = 44;
pub const PCI_ERR_ROOT_CMD_COR_EN: u32 = 1;
pub const PCI_ERR_ROOT_CMD_NONFATAL_EN: u32 = 2;
pub const PCI_ERR_ROOT_CMD_FATAL_EN: u32 = 4;
pub const PCI_ERR_ROOT_STATUS: u32 = 48;
pub const PCI_ERR_ROOT_COR_RCV: u32 = 1;
pub const PCI_ERR_ROOT_MULTI_COR_RCV: u32 = 2;
pub const PCI_ERR_ROOT_UNCOR_RCV: u32 = 4;
pub const PCI_ERR_ROOT_MULTI_UNCOR_RCV: u32 = 8;
pub const PCI_ERR_ROOT_FIRST_FATAL: u32 = 16;
pub const PCI_ERR_ROOT_NONFATAL_RCV: u32 = 32;
pub const PCI_ERR_ROOT_FATAL_RCV: u32 = 64;
pub const PCI_ERR_ROOT_AER_IRQ: u32 = 4160749568;
pub const PCI_ERR_ROOT_ERR_SRC: u32 = 52;
pub const PCI_ERR_PREFIX_LOG: u32 = 56;
pub const PCI_VC_PORT_CAP1: u32 = 4;
pub const PCI_VC_CAP1_EVCC: u32 = 7;
pub const PCI_VC_CAP1_LPEVCC: u32 = 112;
pub const PCI_VC_CAP1_ARB_SIZE: u32 = 3072;
pub const PCI_VC_PORT_CAP2: u32 = 8;
pub const PCI_VC_CAP2_32_PHASE: u32 = 2;
pub const PCI_VC_CAP2_64_PHASE: u32 = 4;
pub const PCI_VC_CAP2_128_PHASE: u32 = 8;
pub const PCI_VC_CAP2_ARB_OFF: u32 = 4278190080;
pub const PCI_VC_PORT_CTRL: u32 = 12;
pub const PCI_VC_PORT_CTRL_LOAD_TABLE: u32 = 1;
pub const PCI_VC_PORT_STATUS: u32 = 14;
pub const PCI_VC_PORT_STATUS_TABLE: u32 = 1;
pub const PCI_VC_RES_CAP: u32 = 16;
pub const PCI_VC_RES_CAP_32_PHASE: u32 = 2;
pub const PCI_VC_RES_CAP_64_PHASE: u32 = 4;
pub const PCI_VC_RES_CAP_128_PHASE: u32 = 8;
pub const PCI_VC_RES_CAP_128_PHASE_TB: u32 = 16;
pub const PCI_VC_RES_CAP_256_PHASE: u32 = 32;
pub const PCI_VC_RES_CAP_ARB_OFF: u32 = 4278190080;
pub const PCI_VC_RES_CTRL: u32 = 20;
pub const PCI_VC_RES_CTRL_LOAD_TABLE: u32 = 65536;
pub const PCI_VC_RES_CTRL_ARB_SELECT: u32 = 917504;
pub const PCI_VC_RES_CTRL_ID: u32 = 117440512;
pub const PCI_VC_RES_CTRL_ENABLE: u32 = 2147483648;
pub const PCI_VC_RES_STATUS: u32 = 26;
pub const PCI_VC_RES_STATUS_TABLE: u32 = 1;
pub const PCI_VC_RES_STATUS_NEGO: u32 = 2;
pub const PCI_CAP_VC_BASE_SIZEOF: u32 = 16;
pub const PCI_CAP_VC_PER_VC_SIZEOF: u32 = 12;
pub const PCI_PWR_DSR: u32 = 4;
pub const PCI_PWR_DATA: u32 = 8;
pub const PCI_PWR_CAP: u32 = 12;
pub const PCI_EXT_CAP_PWR_SIZEOF: u32 = 16;
pub const PCI_RCEC_RCIEP_BITMAP: u32 = 4;
pub const PCI_RCEC_BUSN: u32 = 8;
pub const PCI_RCEC_BUSN_REG_VER: u32 = 2;
pub const PCI_VNDR_HEADER: u32 = 4;
pub const HT_3BIT_CAP_MASK: u32 = 224;
pub const HT_CAPTYPE_SLAVE: u32 = 0;
pub const HT_CAPTYPE_HOST: u32 = 32;
pub const HT_5BIT_CAP_MASK: u32 = 248;
pub const HT_CAPTYPE_IRQ: u32 = 128;
pub const HT_CAPTYPE_REMAPPING_40: u32 = 160;
pub const HT_CAPTYPE_REMAPPING_64: u32 = 162;
pub const HT_CAPTYPE_UNITID_CLUMP: u32 = 144;
pub const HT_CAPTYPE_EXTCONF: u32 = 152;
pub const HT_CAPTYPE_MSI_MAPPING: u32 = 168;
pub const HT_MSI_FLAGS: u32 = 2;
pub const HT_MSI_FLAGS_ENABLE: u32 = 1;
pub const HT_MSI_FLAGS_FIXED: u32 = 2;
pub const HT_MSI_FIXED_ADDR: u32 = 4276092928;
pub const HT_MSI_ADDR_LO: u32 = 4;
pub const HT_MSI_ADDR_LO_MASK: u32 = 4293918720;
pub const HT_MSI_ADDR_HI: u32 = 8;
pub const HT_CAPTYPE_DIRECT_ROUTE: u32 = 176;
pub const HT_CAPTYPE_VCSET: u32 = 184;
pub const HT_CAPTYPE_ERROR_RETRY: u32 = 192;
pub const HT_CAPTYPE_GEN3: u32 = 208;
pub const HT_CAPTYPE_PM: u32 = 224;
pub const HT_CAP_SIZEOF_LONG: u32 = 28;
pub const HT_CAP_SIZEOF_SHORT: u32 = 24;
pub const PCI_ARI_CAP: u32 = 4;
pub const PCI_ARI_CAP_MFVC: u32 = 1;
pub const PCI_ARI_CAP_ACS: u32 = 2;
pub const PCI_ARI_CTRL: u32 = 6;
pub const PCI_ARI_CTRL_MFVC: u32 = 1;
pub const PCI_ARI_CTRL_ACS: u32 = 2;
pub const PCI_EXT_CAP_ARI_SIZEOF: u32 = 8;
pub const PCI_ATS_CAP: u32 = 4;
pub const PCI_ATS_MAX_QDEP: u32 = 32;
pub const PCI_ATS_CAP_PAGE_ALIGNED: u32 = 32;
pub const PCI_ATS_CTRL: u32 = 6;
pub const PCI_ATS_CTRL_ENABLE: u32 = 32768;
pub const PCI_ATS_MIN_STU: u32 = 12;
pub const PCI_EXT_CAP_ATS_SIZEOF: u32 = 8;
pub const PCI_PRI_CTRL: u32 = 4;
pub const PCI_PRI_CTRL_ENABLE: u32 = 1;
pub const PCI_PRI_CTRL_RESET: u32 = 2;
pub const PCI_PRI_STATUS: u32 = 6;
pub const PCI_PRI_STATUS_RF: u32 = 1;
pub const PCI_PRI_STATUS_UPRGI: u32 = 2;
pub const PCI_PRI_STATUS_STOPPED: u32 = 256;
pub const PCI_PRI_STATUS_PASID: u32 = 32768;
pub const PCI_PRI_MAX_REQ: u32 = 8;
pub const PCI_PRI_ALLOC_REQ: u32 = 12;
pub const PCI_EXT_CAP_PRI_SIZEOF: u32 = 16;
pub const PCI_PASID_CAP: u32 = 4;
pub const PCI_PASID_CAP_EXEC: u32 = 2;
pub const PCI_PASID_CAP_PRIV: u32 = 4;
pub const PCI_PASID_CAP_WIDTH: u32 = 7936;
pub const PCI_PASID_CTRL: u32 = 6;
pub const PCI_PASID_CTRL_ENABLE: u32 = 1;
pub const PCI_PASID_CTRL_EXEC: u32 = 2;
pub const PCI_PASID_CTRL_PRIV: u32 = 4;
pub const PCI_EXT_CAP_PASID_SIZEOF: u32 = 8;
pub const PCI_SRIOV_CAP: u32 = 4;
pub const PCI_SRIOV_CAP_VFM: u32 = 1;
pub const PCI_SRIOV_CTRL: u32 = 8;
pub const PCI_SRIOV_CTRL_VFE: u32 = 1;
pub const PCI_SRIOV_CTRL_VFM: u32 = 2;
pub const PCI_SRIOV_CTRL_INTR: u32 = 4;
pub const PCI_SRIOV_CTRL_MSE: u32 = 8;
pub const PCI_SRIOV_CTRL_ARI: u32 = 16;
pub const PCI_SRIOV_STATUS: u32 = 10;
pub const PCI_SRIOV_STATUS_VFM: u32 = 1;
pub const PCI_SRIOV_INITIAL_VF: u32 = 12;
pub const PCI_SRIOV_TOTAL_VF: u32 = 14;
pub const PCI_SRIOV_NUM_VF: u32 = 16;
pub const PCI_SRIOV_FUNC_LINK: u32 = 18;
pub const PCI_SRIOV_VF_OFFSET: u32 = 20;
pub const PCI_SRIOV_VF_STRIDE: u32 = 22;
pub const PCI_SRIOV_VF_DID: u32 = 26;
pub const PCI_SRIOV_SUP_PGSIZE: u32 = 28;
pub const PCI_SRIOV_SYS_PGSIZE: u32 = 32;
pub const PCI_SRIOV_BAR: u32 = 36;
pub const PCI_SRIOV_NUM_BARS: u32 = 6;
pub const PCI_SRIOV_VFM: u32 = 60;
pub const PCI_SRIOV_VFM_UA: u32 = 0;
pub const PCI_SRIOV_VFM_MI: u32 = 1;
pub const PCI_SRIOV_VFM_MO: u32 = 2;
pub const PCI_SRIOV_VFM_AV: u32 = 3;
pub const PCI_EXT_CAP_SRIOV_SIZEOF: u32 = 64;
pub const PCI_LTR_MAX_SNOOP_LAT: u32 = 4;
pub const PCI_LTR_MAX_NOSNOOP_LAT: u32 = 6;
pub const PCI_LTR_VALUE_MASK: u32 = 1023;
pub const PCI_LTR_SCALE_MASK: u32 = 7168;
pub const PCI_LTR_SCALE_SHIFT: u32 = 10;
pub const PCI_LTR_NOSNOOP_VALUE: u32 = 67043328;
pub const PCI_LTR_NOSNOOP_SCALE: u32 = 469762048;
pub const PCI_EXT_CAP_LTR_SIZEOF: u32 = 8;
pub const PCI_ACS_CAP: u32 = 4;
pub const PCI_ACS_SV: u32 = 1;
pub const PCI_ACS_TB: u32 = 2;
pub const PCI_ACS_RR: u32 = 4;
pub const PCI_ACS_CR: u32 = 8;
pub const PCI_ACS_UF: u32 = 16;
pub const PCI_ACS_EC: u32 = 32;
pub const PCI_ACS_DT: u32 = 64;
pub const PCI_ACS_EGRESS_BITS: u32 = 5;
pub const PCI_ACS_CTRL: u32 = 6;
pub const PCI_ACS_EGRESS_CTL_V: u32 = 8;
pub const PCI_SATA_REGS: u32 = 4;
pub const PCI_SATA_REGS_MASK: u32 = 15;
pub const PCI_SATA_REGS_INLINE: u32 = 15;
pub const PCI_SATA_SIZEOF_SHORT: u32 = 8;
pub const PCI_SATA_SIZEOF_LONG: u32 = 16;
pub const PCI_REBAR_CAP: u32 = 4;
pub const PCI_REBAR_CAP_SIZES: u32 = 4294967280;
pub const PCI_REBAR_CTRL: u32 = 8;
pub const PCI_REBAR_CTRL_BAR_IDX: u32 = 7;
pub const PCI_REBAR_CTRL_NBAR_MASK: u32 = 224;
pub const PCI_REBAR_CTRL_NBAR_SHIFT: u32 = 5;
pub const PCI_REBAR_CTRL_BAR_SIZE: u32 = 7936;
pub const PCI_REBAR_CTRL_BAR_SHIFT: u32 = 8;
pub const PCI_DPA_CAP: u32 = 4;
pub const PCI_DPA_CAP_SUBSTATE_MASK: u32 = 31;
pub const PCI_DPA_BASE_SIZEOF: u32 = 16;
pub const PCI_EXP_DEVCAP2_TPH_COMP_NONE: u32 = 0;
pub const PCI_EXP_DEVCAP2_TPH_COMP_TPH_ONLY: u32 = 1;
pub const PCI_EXP_DEVCAP2_TPH_COMP_EXT_TPH: u32 = 3;
pub const PCI_TPH_CAP: u32 = 4;
pub const PCI_TPH_CAP_ST_NS: u32 = 1;
pub const PCI_TPH_CAP_ST_IV: u32 = 2;
pub const PCI_TPH_CAP_ST_DS: u32 = 4;
pub const PCI_TPH_CAP_EXT_TPH: u32 = 256;
pub const PCI_TPH_CAP_LOC_MASK: u32 = 1536;
pub const PCI_TPH_LOC_NONE: u32 = 0;
pub const PCI_TPH_LOC_CAP: u32 = 512;
pub const PCI_TPH_LOC_MSIX: u32 = 1024;
pub const PCI_TPH_CAP_ST_MASK: u32 = 134152192;
pub const PCI_TPH_CAP_ST_SHIFT: u32 = 16;
pub const PCI_TPH_BASE_SIZEOF: u32 = 12;
pub const PCI_TPH_CTRL: u32 = 8;
pub const PCI_TPH_CTRL_MODE_SEL_MASK: u32 = 7;
pub const PCI_TPH_ST_NS_MODE: u32 = 0;
pub const PCI_TPH_ST_IV_MODE: u32 = 1;
pub const PCI_TPH_ST_DS_MODE: u32 = 2;
pub const PCI_TPH_CTRL_REQ_EN_MASK: u32 = 768;
pub const PCI_TPH_REQ_DISABLE: u32 = 0;
pub const PCI_TPH_REQ_TPH_ONLY: u32 = 1;
pub const PCI_TPH_REQ_EXT_TPH: u32 = 3;
pub const PCI_EXP_DPC_CAP: u32 = 4;
pub const PCI_EXP_DPC_IRQ: u32 = 31;
pub const PCI_EXP_DPC_CAP_RP_EXT: u32 = 32;
pub const PCI_EXP_DPC_CAP_POISONED_TLP: u32 = 64;
pub const PCI_EXP_DPC_CAP_SW_TRIGGER: u32 = 128;
pub const PCI_EXP_DPC_RP_PIO_LOG_SIZE: u32 = 3840;
pub const PCI_EXP_DPC_CAP_DL_ACTIVE: u32 = 4096;
pub const PCI_EXP_DPC_RP_PIO_LOG_SIZE4: u32 = 8192;
pub const PCI_EXP_DPC_CTL: u32 = 6;
pub const PCI_EXP_DPC_CTL_EN_FATAL: u32 = 1;
pub const PCI_EXP_DPC_CTL_EN_NONFATAL: u32 = 2;
pub const PCI_EXP_DPC_CTL_INT_EN: u32 = 8;
pub const PCI_EXP_DPC_STATUS: u32 = 8;
pub const PCI_EXP_DPC_STATUS_TRIGGER: u32 = 1;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN: u32 = 6;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_UNCOR: u32 = 0;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_NFE: u32 = 2;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_FE: u32 = 4;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_IN_EXT: u32 = 6;
pub const PCI_EXP_DPC_STATUS_INTERRUPT: u32 = 8;
pub const PCI_EXP_DPC_RP_BUSY: u32 = 16;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_EXT: u32 = 96;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_RP_PIO: u32 = 0;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_SW_TRIGGER: u32 = 32;
pub const PCI_EXP_DPC_RP_PIO_FEP: u32 = 7936;
pub const PCI_EXP_DPC_SOURCE_ID: u32 = 10;
pub const PCI_EXP_DPC_RP_PIO_STATUS: u32 = 12;
pub const PCI_EXP_DPC_RP_PIO_MASK: u32 = 16;
pub const PCI_EXP_DPC_RP_PIO_SEVERITY: u32 = 20;
pub const PCI_EXP_DPC_RP_PIO_SYSERROR: u32 = 24;
pub const PCI_EXP_DPC_RP_PIO_EXCEPTION: u32 = 28;
pub const PCI_EXP_DPC_RP_PIO_HEADER_LOG: u32 = 32;
pub const PCI_EXP_DPC_RP_PIO_IMPSPEC_LOG: u32 = 48;
pub const PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG: u32 = 52;
pub const PCI_PTM_CAP: u32 = 4;
pub const PCI_PTM_CAP_REQ: u32 = 1;
pub const PCI_PTM_CAP_RES: u32 = 2;
pub const PCI_PTM_CAP_ROOT: u32 = 4;
pub const PCI_PTM_GRANULARITY_MASK: u32 = 65280;
pub const PCI_PTM_CTRL: u32 = 8;
pub const PCI_PTM_CTRL_ENABLE: u32 = 1;
pub const PCI_PTM_CTRL_ROOT: u32 = 2;
pub const PCI_L1SS_CAP: u32 = 4;
pub const PCI_L1SS_CAP_PCIPM_L1_2: u32 = 1;
pub const PCI_L1SS_CAP_PCIPM_L1_1: u32 = 2;
pub const PCI_L1SS_CAP_ASPM_L1_2: u32 = 4;
pub const PCI_L1SS_CAP_ASPM_L1_1: u32 = 8;
pub const PCI_L1SS_CAP_L1_PM_SS: u32 = 16;
pub const PCI_L1SS_CAP_CM_RESTORE_TIME: u32 = 65280;
pub const PCI_L1SS_CAP_P_PWR_ON_SCALE: u32 = 196608;
pub const PCI_L1SS_CAP_P_PWR_ON_VALUE: u32 = 16252928;
pub const PCI_L1SS_CTL1: u32 = 8;
pub const PCI_L1SS_CTL1_PCIPM_L1_2: u32 = 1;
pub const PCI_L1SS_CTL1_PCIPM_L1_1: u32 = 2;
pub const PCI_L1SS_CTL1_ASPM_L1_2: u32 = 4;
pub const PCI_L1SS_CTL1_ASPM_L1_1: u32 = 8;
pub const PCI_L1SS_CTL1_L1_2_MASK: u32 = 5;
pub const PCI_L1SS_CTL1_L1SS_MASK: u32 = 15;
pub const PCI_L1SS_CTL1_CM_RESTORE_TIME: u32 = 65280;
pub const PCI_L1SS_CTL1_LTR_L12_TH_VALUE: u32 = 67043328;
pub const PCI_L1SS_CTL1_LTR_L12_TH_SCALE: u32 = 3758096384;
pub const PCI_L1SS_CTL2: u32 = 12;
pub const PCI_L1SS_CTL2_T_PWR_ON_SCALE: u32 = 3;
pub const PCI_L1SS_CTL2_T_PWR_ON_VALUE: u32 = 248;
pub const PCI_DVSEC_HEADER1: u32 = 4;
pub const PCI_DVSEC_HEADER2: u32 = 8;
pub const PCI_VF_REBAR_CAP: u32 = 4;
pub const PCI_VF_REBAR_CAP_SIZES: u32 = 4294967280;
pub const PCI_VF_REBAR_CTRL: u32 = 8;
pub const PCI_VF_REBAR_CTRL_BAR_IDX: u32 = 7;
pub const PCI_VF_REBAR_CTRL_NBAR_MASK: u32 = 224;
pub const PCI_VF_REBAR_CTRL_BAR_SIZE: u32 = 7936;
pub const PCI_DLF_CAP: u32 = 4;
pub const PCI_DLF_EXCHANGE_ENABLE: u32 = 2147483648;
pub const PCI_SECPCI_LE_CTRL: u32 = 12;
pub const PCI_PL_16GT_LE_CTRL: u32 = 32;
pub const PCI_PL_16GT_LE_CTRL_DSP_TX_PRESET_MASK: u32 = 15;
pub const PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_MASK: u32 = 240;
pub const PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_SHIFT: u32 = 4;
pub const PCI_PL_32GT_LE_CTRL: u32 = 32;
pub const PCI_PL_64GT_LE_CTRL: u32 = 32;
pub const PCI_NPEM_CAP: u32 = 4;
pub const PCI_NPEM_CAP_CAPABLE: u32 = 1;
pub const PCI_NPEM_CTRL: u32 = 8;
pub const PCI_NPEM_CTRL_ENABLE: u32 = 1;
pub const PCI_NPEM_CMD_RESET: u32 = 2;
pub const PCI_NPEM_IND_OK: u32 = 4;
pub const PCI_NPEM_IND_LOCATE: u32 = 8;
pub const PCI_NPEM_IND_FAIL: u32 = 16;
pub const PCI_NPEM_IND_REBUILD: u32 = 32;
pub const PCI_NPEM_IND_PFA: u32 = 64;
pub const PCI_NPEM_IND_HOTSPARE: u32 = 128;
pub const PCI_NPEM_IND_ICA: u32 = 256;
pub const PCI_NPEM_IND_IFA: u32 = 512;
pub const PCI_NPEM_IND_IDT: u32 = 1024;
pub const PCI_NPEM_IND_DISABLED: u32 = 2048;
pub const PCI_NPEM_IND_SPEC_0: u32 = 16777216;
pub const PCI_NPEM_IND_SPEC_1: u32 = 33554432;
pub const PCI_NPEM_IND_SPEC_2: u32 = 67108864;
pub const PCI_NPEM_IND_SPEC_3: u32 = 134217728;
pub const PCI_NPEM_IND_SPEC_4: u32 = 268435456;
pub const PCI_NPEM_IND_SPEC_5: u32 = 536870912;
pub const PCI_NPEM_IND_SPEC_6: u32 = 1073741824;
pub const PCI_NPEM_IND_SPEC_7: u32 = 2147483648;
pub const PCI_NPEM_STATUS: u32 = 12;
pub const PCI_NPEM_STATUS_CC: u32 = 1;
pub const PCI_DOE_CAP: u32 = 4;
pub const PCI_DOE_CAP_INT_SUP: u32 = 1;
pub const PCI_DOE_CAP_INT_MSG_NUM: u32 = 4094;
pub const PCI_DOE_CTRL: u32 = 8;
pub const PCI_DOE_CTRL_ABORT: u32 = 1;
pub const PCI_DOE_CTRL_INT_EN: u32 = 2;
pub const PCI_DOE_CTRL_GO: u32 = 2147483648;
pub const PCI_DOE_STATUS: u32 = 12;
pub const PCI_DOE_STATUS_BUSY: u32 = 1;
pub const PCI_DOE_STATUS_INT_STATUS: u32 = 2;
pub const PCI_DOE_STATUS_ERROR: u32 = 4;
pub const PCI_DOE_STATUS_DATA_OBJECT_READY: u32 = 2147483648;
pub const PCI_DOE_WRITE: u32 = 16;
pub const PCI_DOE_READ: u32 = 20;
pub const PCI_DOE_CAP_SIZEOF: u32 = 24;
pub const PCI_DOE_DATA_OBJECT_HEADER_1_VID: u32 = 65535;
pub const PCI_DOE_DATA_OBJECT_HEADER_1_TYPE: u32 = 16711680;
pub const PCI_DOE_DATA_OBJECT_HEADER_2_LENGTH: u32 = 262143;
pub const PCI_DOE_DATA_OBJECT_DISC_REQ_3_INDEX: u32 = 255;
pub const PCI_DOE_DATA_OBJECT_DISC_REQ_3_VER: u32 = 65280;
pub const PCI_DOE_DATA_OBJECT_DISC_RSP_3_VID: u32 = 65535;
pub const PCI_DOE_DATA_OBJECT_DISC_RSP_3_TYPE: u32 = 16711680;
pub const PCI_DOE_DATA_OBJECT_DISC_RSP_3_NEXT_INDEX: u32 = 4278190080;
pub const PCI_DOE_DATA_OBJECT_DISC_RSP_3_PROTOCOL: u32 = 16711680;
pub const PCI_DVSEC_CXL_PORT: u32 = 3;
pub const PCI_DVSEC_CXL_PORT_CTL: u32 = 12;
pub const PCI_DVSEC_CXL_PORT_CTL_UNMASK_SBR: u32 = 1;
pub const PCI_CLASS_NOT_DEFINED: u32 = 0;
pub const PCI_CLASS_NOT_DEFINED_VGA: u32 = 1;
pub const PCI_BASE_CLASS_STORAGE: u32 = 1;
pub const PCI_CLASS_STORAGE_SCSI: u32 = 256;
pub const PCI_CLASS_STORAGE_IDE: u32 = 257;
pub const PCI_CLASS_STORAGE_FLOPPY: u32 = 258;
pub const PCI_CLASS_STORAGE_IPI: u32 = 259;
pub const PCI_CLASS_STORAGE_RAID: u32 = 260;
pub const PCI_CLASS_STORAGE_SATA: u32 = 262;
pub const PCI_CLASS_STORAGE_SATA_AHCI: u32 = 67073;
pub const PCI_CLASS_STORAGE_SAS: u32 = 263;
pub const PCI_CLASS_STORAGE_EXPRESS: u32 = 67586;
pub const PCI_CLASS_STORAGE_OTHER: u32 = 384;
pub const PCI_BASE_CLASS_NETWORK: u32 = 2;
pub const PCI_CLASS_NETWORK_ETHERNET: u32 = 512;
pub const PCI_CLASS_NETWORK_TOKEN_RING: u32 = 513;
pub const PCI_CLASS_NETWORK_FDDI: u32 = 514;
pub const PCI_CLASS_NETWORK_ATM: u32 = 515;
pub const PCI_CLASS_NETWORK_OTHER: u32 = 640;
pub const PCI_BASE_CLASS_DISPLAY: u32 = 3;
pub const PCI_CLASS_DISPLAY_VGA: u32 = 768;
pub const PCI_CLASS_DISPLAY_XGA: u32 = 769;
pub const PCI_CLASS_DISPLAY_3D: u32 = 770;
pub const PCI_CLASS_DISPLAY_OTHER: u32 = 896;
pub const PCI_BASE_CLASS_MULTIMEDIA: u32 = 4;
pub const PCI_CLASS_MULTIMEDIA_VIDEO: u32 = 1024;
pub const PCI_CLASS_MULTIMEDIA_AUDIO: u32 = 1025;
pub const PCI_CLASS_MULTIMEDIA_PHONE: u32 = 1026;
pub const PCI_CLASS_MULTIMEDIA_HD_AUDIO: u32 = 1027;
pub const PCI_CLASS_MULTIMEDIA_OTHER: u32 = 1152;
pub const PCI_BASE_CLASS_MEMORY: u32 = 5;
pub const PCI_CLASS_MEMORY_RAM: u32 = 1280;
pub const PCI_CLASS_MEMORY_FLASH: u32 = 1281;
pub const PCI_CLASS_MEMORY_CXL: u32 = 1282;
pub const PCI_CLASS_MEMORY_OTHER: u32 = 1408;
pub const PCI_BASE_CLASS_BRIDGE: u32 = 6;
pub const PCI_CLASS_BRIDGE_HOST: u32 = 1536;
pub const PCI_CLASS_BRIDGE_ISA: u32 = 1537;
pub const PCI_CLASS_BRIDGE_EISA: u32 = 1538;
pub const PCI_CLASS_BRIDGE_MC: u32 = 1539;
pub const PCI_CLASS_BRIDGE_PCI: u32 = 1540;
pub const PCI_CLASS_BRIDGE_PCI_NORMAL: u32 = 394240;
pub const PCI_CLASS_BRIDGE_PCI_SUBTRACTIVE: u32 = 394241;
pub const PCI_CLASS_BRIDGE_PCMCIA: u32 = 1541;
pub const PCI_CLASS_BRIDGE_NUBUS: u32 = 1542;
pub const PCI_CLASS_BRIDGE_CARDBUS: u32 = 1543;
pub const PCI_CLASS_BRIDGE_RACEWAY: u32 = 1544;
pub const PCI_CLASS_BRIDGE_OTHER: u32 = 1664;
pub const PCI_BASE_CLASS_COMMUNICATION: u32 = 7;
pub const PCI_CLASS_COMMUNICATION_SERIAL: u32 = 1792;
pub const PCI_CLASS_COMMUNICATION_PARALLEL: u32 = 1793;
pub const PCI_CLASS_COMMUNICATION_MULTISERIAL: u32 = 1794;
pub const PCI_CLASS_COMMUNICATION_MODEM: u32 = 1795;
pub const PCI_CLASS_COMMUNICATION_OTHER: u32 = 1920;
pub const PCI_SERIAL_16550_COMPATIBLE: u32 = 2;
pub const PCI_BASE_CLASS_SYSTEM: u32 = 8;
pub const PCI_CLASS_SYSTEM_PIC: u32 = 2048;
pub const PCI_CLASS_SYSTEM_PIC_IOAPIC: u32 = 524304;
pub const PCI_CLASS_SYSTEM_PIC_IOXAPIC: u32 = 524320;
pub const PCI_CLASS_SYSTEM_DMA: u32 = 2049;
pub const PCI_CLASS_SYSTEM_TIMER: u32 = 2050;
pub const PCI_CLASS_SYSTEM_RTC: u32 = 2051;
pub const PCI_CLASS_SYSTEM_PCI_HOTPLUG: u32 = 2052;
pub const PCI_CLASS_SYSTEM_SDHCI: u32 = 2053;
pub const PCI_CLASS_SYSTEM_RCEC: u32 = 2055;
pub const PCI_CLASS_SYSTEM_OTHER: u32 = 2176;
pub const PCI_BASE_CLASS_INPUT: u32 = 9;
pub const PCI_CLASS_INPUT_KEYBOARD: u32 = 2304;
pub const PCI_CLASS_INPUT_PEN: u32 = 2305;
pub const PCI_CLASS_INPUT_MOUSE: u32 = 2306;
pub const PCI_CLASS_INPUT_SCANNER: u32 = 2307;
pub const PCI_CLASS_INPUT_GAMEPORT: u32 = 2308;
pub const PCI_CLASS_INPUT_OTHER: u32 = 2432;
pub const PCI_BASE_CLASS_DOCKING: u32 = 10;
pub const PCI_CLASS_DOCKING_GENERIC: u32 = 2560;
pub const PCI_CLASS_DOCKING_OTHER: u32 = 2688;
pub const PCI_BASE_CLASS_PROCESSOR: u32 = 11;
pub const PCI_CLASS_PROCESSOR_386: u32 = 2816;
pub const PCI_CLASS_PROCESSOR_486: u32 = 2817;
pub const PCI_CLASS_PROCESSOR_PENTIUM: u32 = 2818;
pub const PCI_CLASS_PROCESSOR_ALPHA: u32 = 2832;
pub const PCI_CLASS_PROCESSOR_POWERPC: u32 = 2848;
pub const PCI_CLASS_PROCESSOR_MIPS: u32 = 2864;
pub const PCI_CLASS_PROCESSOR_CO: u32 = 2880;
pub const PCI_BASE_CLASS_SERIAL: u32 = 12;
pub const PCI_CLASS_SERIAL_FIREWIRE: u32 = 3072;
pub const PCI_CLASS_SERIAL_FIREWIRE_OHCI: u32 = 786448;
pub const PCI_CLASS_SERIAL_ACCESS: u32 = 3073;
pub const PCI_CLASS_SERIAL_SSA: u32 = 3074;
pub const PCI_CLASS_SERIAL_USB: u32 = 3075;
pub const PCI_CLASS_SERIAL_USB_UHCI: u32 = 787200;
pub const PCI_CLASS_SERIAL_USB_OHCI: u32 = 787216;
pub const PCI_CLASS_SERIAL_USB_EHCI: u32 = 787232;
pub const PCI_CLASS_SERIAL_USB_XHCI: u32 = 787248;
pub const PCI_CLASS_SERIAL_USB_CDNS: u32 = 787328;
pub const PCI_CLASS_SERIAL_USB_DEVICE: u32 = 787454;
pub const PCI_CLASS_SERIAL_FIBER: u32 = 3076;
pub const PCI_CLASS_SERIAL_SMBUS: u32 = 3077;
pub const PCI_CLASS_SERIAL_IPMI: u32 = 3079;
pub const PCI_CLASS_SERIAL_IPMI_SMIC: u32 = 788224;
pub const PCI_CLASS_SERIAL_IPMI_KCS: u32 = 788225;
pub const PCI_CLASS_SERIAL_IPMI_BT: u32 = 788226;
pub const PCI_BASE_CLASS_WIRELESS: u32 = 13;
pub const PCI_CLASS_WIRELESS_RF_CONTROLLER: u32 = 3344;
pub const PCI_CLASS_WIRELESS_WHCI: u32 = 856080;
pub const PCI_BASE_CLASS_INTELLIGENT: u32 = 14;
pub const PCI_CLASS_INTELLIGENT_I2O: u32 = 3584;
pub const PCI_BASE_CLASS_SATELLITE: u32 = 15;
pub const PCI_CLASS_SATELLITE_TV: u32 = 3840;
pub const PCI_CLASS_SATELLITE_AUDIO: u32 = 3841;
pub const PCI_CLASS_SATELLITE_VOICE: u32 = 3843;
pub const PCI_CLASS_SATELLITE_DATA: u32 = 3844;
pub const PCI_BASE_CLASS_CRYPT: u32 = 16;
pub const PCI_CLASS_CRYPT_NETWORK: u32 = 4096;
pub const PCI_CLASS_CRYPT_ENTERTAINMENT: u32 = 4097;
pub const PCI_CLASS_CRYPT_OTHER: u32 = 4224;
pub const PCI_BASE_CLASS_SIGNAL_PROCESSING: u32 = 17;
pub const PCI_CLASS_SP_DPIO: u32 = 4352;
pub const PCI_CLASS_SP_OTHER: u32 = 4480;
pub const PCI_BASE_CLASS_ACCELERATOR: u32 = 18;
pub const PCI_CLASS_ACCELERATOR_PROCESSING: u32 = 4608;
pub const PCI_CLASS_OTHERS: u32 = 255;
pub const PCI_VENDOR_ID_PCI_SIG: u32 = 1;
pub const PCI_VENDOR_ID_LOONGSON: u32 = 20;
pub const PCI_DEVICE_ID_LOONGSON_HDA: u32 = 31239;
pub const PCI_DEVICE_ID_LOONGSON_HDMI: u32 = 31287;
pub const PCI_VENDOR_ID_SOLIDIGM: u32 = 606;
pub const PCI_VENDOR_ID_TTTECH: u32 = 855;
pub const PCI_DEVICE_ID_TTTECH_MC322: u32 = 10;
pub const PCI_VENDOR_ID_DYNALINK: u32 = 1653;
pub const PCI_DEVICE_ID_DYNALINK_IS64PH: u32 = 5890;
pub const PCI_VENDOR_ID_UBIQUITI: u32 = 1911;
pub const PCI_VENDOR_ID_BERKOM: u32 = 2161;
pub const PCI_DEVICE_ID_BERKOM_A1T: u32 = 65441;
pub const PCI_DEVICE_ID_BERKOM_T_CONCEPT: u32 = 65442;
pub const PCI_DEVICE_ID_BERKOM_A4T: u32 = 65444;
pub const PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO: u32 = 65448;
pub const PCI_VENDOR_ID_ITTIM: u32 = 2888;
pub const PCI_VENDOR_ID_COMPAQ: u32 = 3601;
pub const PCI_DEVICE_ID_COMPAQ_TOKENRING: u32 = 1288;
pub const PCI_DEVICE_ID_COMPAQ_TACHYON: u32 = 41212;
pub const PCI_DEVICE_ID_COMPAQ_SMART2P: u32 = 44560;
pub const PCI_DEVICE_ID_COMPAQ_NETEL100: u32 = 44594;
pub const PCI_DEVICE_ID_COMPAQ_NETEL10: u32 = 44596;
pub const PCI_DEVICE_ID_COMPAQ_TRIFLEX_IDE: u32 = 44595;
pub const PCI_DEVICE_ID_COMPAQ_NETFLEX3I: u32 = 44597;
pub const PCI_DEVICE_ID_COMPAQ_NETEL100D: u32 = 44608;
pub const PCI_DEVICE_ID_COMPAQ_NETEL100PI: u32 = 44611;
pub const PCI_DEVICE_ID_COMPAQ_NETEL100I: u32 = 45073;
pub const PCI_DEVICE_ID_COMPAQ_CISS: u32 = 45152;
pub const PCI_DEVICE_ID_COMPAQ_CISSB: u32 = 45432;
pub const PCI_DEVICE_ID_COMPAQ_CISSC: u32 = 70;
pub const PCI_DEVICE_ID_COMPAQ_THUNDER: u32 = 61744;
pub const PCI_DEVICE_ID_COMPAQ_NETFLEX3B: u32 = 61776;
pub const PCI_VENDOR_ID_NCR: u32 = 4096;
pub const PCI_VENDOR_ID_LSI_LOGIC: u32 = 4096;
pub const PCI_DEVICE_ID_NCR_53C810: u32 = 1;
pub const PCI_DEVICE_ID_NCR_53C820: u32 = 2;
pub const PCI_DEVICE_ID_NCR_53C825: u32 = 3;
pub const PCI_DEVICE_ID_NCR_53C815: u32 = 4;
pub const PCI_DEVICE_ID_LSI_53C810AP: u32 = 5;
pub const PCI_DEVICE_ID_NCR_53C860: u32 = 6;
pub const PCI_DEVICE_ID_LSI_53C1510: u32 = 10;
pub const PCI_DEVICE_ID_NCR_53C896: u32 = 11;
pub const PCI_DEVICE_ID_NCR_53C895: u32 = 12;
pub const PCI_DEVICE_ID_NCR_53C885: u32 = 13;
pub const PCI_DEVICE_ID_NCR_53C875: u32 = 15;
pub const PCI_DEVICE_ID_NCR_53C1510: u32 = 16;
pub const PCI_DEVICE_ID_LSI_53C895A: u32 = 18;
pub const PCI_DEVICE_ID_LSI_53C875A: u32 = 19;
pub const PCI_DEVICE_ID_LSI_53C1010_33: u32 = 32;
pub const PCI_DEVICE_ID_LSI_53C1010_66: u32 = 33;
pub const PCI_DEVICE_ID_LSI_53C1030: u32 = 48;
pub const PCI_DEVICE_ID_LSI_1030_53C1035: u32 = 50;
pub const PCI_DEVICE_ID_LSI_53C1035: u32 = 64;
pub const PCI_DEVICE_ID_NCR_53C875J: u32 = 143;
pub const PCI_DEVICE_ID_LSI_FC909: u32 = 1569;
pub const PCI_DEVICE_ID_LSI_FC929: u32 = 1570;
pub const PCI_DEVICE_ID_LSI_FC929_LAN: u32 = 1571;
pub const PCI_DEVICE_ID_LSI_FC919: u32 = 1572;
pub const PCI_DEVICE_ID_LSI_FC919_LAN: u32 = 1573;
pub const PCI_DEVICE_ID_LSI_FC929X: u32 = 1574;
pub const PCI_DEVICE_ID_LSI_FC939X: u32 = 1602;
pub const PCI_DEVICE_ID_LSI_FC949X: u32 = 1600;
pub const PCI_DEVICE_ID_LSI_FC949ES: u32 = 1606;
pub const PCI_DEVICE_ID_LSI_FC919X: u32 = 1576;
pub const PCI_DEVICE_ID_NCR_YELLOWFIN: u32 = 1793;
pub const PCI_DEVICE_ID_LSI_61C102: u32 = 2305;
pub const PCI_DEVICE_ID_LSI_63C815: u32 = 4096;
pub const PCI_DEVICE_ID_LSI_SAS1064: u32 = 80;
pub const PCI_DEVICE_ID_LSI_SAS1064R: u32 = 1041;
pub const PCI_DEVICE_ID_LSI_SAS1066: u32 = 94;
pub const PCI_DEVICE_ID_LSI_SAS1068: u32 = 84;
pub const PCI_DEVICE_ID_LSI_SAS1064A: u32 = 92;
pub const PCI_DEVICE_ID_LSI_SAS1064E: u32 = 86;
pub const PCI_DEVICE_ID_LSI_SAS1066E: u32 = 90;
pub const PCI_DEVICE_ID_LSI_SAS1068E: u32 = 88;
pub const PCI_DEVICE_ID_LSI_SAS1078: u32 = 96;
pub const PCI_VENDOR_ID_ATI: u32 = 4098;
pub const PCI_DEVICE_ID_ATI_68800: u32 = 16728;
pub const PCI_DEVICE_ID_ATI_215CT222: u32 = 17236;
pub const PCI_DEVICE_ID_ATI_210888CX: u32 = 17240;
pub const PCI_DEVICE_ID_ATI_215ET222: u32 = 17748;
pub const PCI_DEVICE_ID_ATI_215GB: u32 = 18242;
pub const PCI_DEVICE_ID_ATI_215GD: u32 = 18244;
pub const PCI_DEVICE_ID_ATI_215GI: u32 = 18249;
pub const PCI_DEVICE_ID_ATI_215GP: u32 = 18256;
pub const PCI_DEVICE_ID_ATI_215GQ: u32 = 18257;
pub const PCI_DEVICE_ID_ATI_215XL: u32 = 18258;
pub const PCI_DEVICE_ID_ATI_215GT: u32 = 18260;
pub const PCI_DEVICE_ID_ATI_215GTB: u32 = 18261;
pub const PCI_DEVICE_ID_ATI_215_IV: u32 = 18262;
pub const PCI_DEVICE_ID_ATI_215_IW: u32 = 18263;
pub const PCI_DEVICE_ID_ATI_215_IZ: u32 = 18266;
pub const PCI_DEVICE_ID_ATI_210888GX: u32 = 18264;
pub const PCI_DEVICE_ID_ATI_215_LB: u32 = 19522;
pub const PCI_DEVICE_ID_ATI_215_LD: u32 = 19524;
pub const PCI_DEVICE_ID_ATI_215_LG: u32 = 19527;
pub const PCI_DEVICE_ID_ATI_215_LI: u32 = 19529;
pub const PCI_DEVICE_ID_ATI_215_LM: u32 = 19533;
pub const PCI_DEVICE_ID_ATI_215_LN: u32 = 19534;
pub const PCI_DEVICE_ID_ATI_215_LR: u32 = 19538;
pub const PCI_DEVICE_ID_ATI_215_LS: u32 = 19539;
pub const PCI_DEVICE_ID_ATI_264_LT: u32 = 19540;
pub const PCI_DEVICE_ID_ATI_264VT: u32 = 22100;
pub const PCI_DEVICE_ID_ATI_264VU: u32 = 22101;
pub const PCI_DEVICE_ID_ATI_264VV: u32 = 22102;
pub const PCI_DEVICE_ID_ATI_RAGE128_RE: u32 = 21061;
pub const PCI_DEVICE_ID_ATI_RAGE128_RF: u32 = 21062;
pub const PCI_DEVICE_ID_ATI_RAGE128_RG: u32 = 21063;
pub const PCI_DEVICE_ID_ATI_RAGE128_RK: u32 = 21067;
pub const PCI_DEVICE_ID_ATI_RAGE128_RL: u32 = 21068;
pub const PCI_DEVICE_ID_ATI_RAGE128_SE: u32 = 21317;
pub const PCI_DEVICE_ID_ATI_RAGE128_SF: u32 = 21318;
pub const PCI_DEVICE_ID_ATI_RAGE128_SG: u32 = 21319;
pub const PCI_DEVICE_ID_ATI_RAGE128_SH: u32 = 21320;
pub const PCI_DEVICE_ID_ATI_RAGE128_SK: u32 = 21323;
pub const PCI_DEVICE_ID_ATI_RAGE128_SL: u32 = 21324;
pub const PCI_DEVICE_ID_ATI_RAGE128_SM: u32 = 21325;
pub const PCI_DEVICE_ID_ATI_RAGE128_SN: u32 = 21326;
pub const PCI_DEVICE_ID_ATI_RAGE128_TF: u32 = 21574;
pub const PCI_DEVICE_ID_ATI_RAGE128_TL: u32 = 21580;
pub const PCI_DEVICE_ID_ATI_RAGE128_TR: u32 = 21586;
pub const PCI_DEVICE_ID_ATI_RAGE128_TS: u32 = 21587;
pub const PCI_DEVICE_ID_ATI_RAGE128_TT: u32 = 21588;
pub const PCI_DEVICE_ID_ATI_RAGE128_TU: u32 = 21589;
pub const PCI_DEVICE_ID_ATI_RAGE128_LE: u32 = 19525;
pub const PCI_DEVICE_ID_ATI_RAGE128_LF: u32 = 19526;
pub const PCI_DEVICE_ID_ATI_RAGE128_MF: u32 = 19782;
pub const PCI_DEVICE_ID_ATI_RAGE128_ML: u32 = 19788;
pub const PCI_DEVICE_ID_ATI_RAGE128_PA: u32 = 20545;
pub const PCI_DEVICE_ID_ATI_RAGE128_PB: u32 = 20546;
pub const PCI_DEVICE_ID_ATI_RAGE128_PC: u32 = 20547;
pub const PCI_DEVICE_ID_ATI_RAGE128_PD: u32 = 20548;
pub const PCI_DEVICE_ID_ATI_RAGE128_PE: u32 = 20549;
pub const PCI_DEVICE_ID_ATI_RAGE128_PF: u32 = 20550;
pub const PCI_DEVICE_ID_ATI_RAGE128_PG: u32 = 20551;
pub const PCI_DEVICE_ID_ATI_RAGE128_PH: u32 = 20552;
pub const PCI_DEVICE_ID_ATI_RAGE128_PI: u32 = 20553;
pub const PCI_DEVICE_ID_ATI_RAGE128_PJ: u32 = 20554;
pub const PCI_DEVICE_ID_ATI_RAGE128_PK: u32 = 20555;
pub const PCI_DEVICE_ID_ATI_RAGE128_PL: u32 = 20556;
pub const PCI_DEVICE_ID_ATI_RAGE128_PM: u32 = 20557;
pub const PCI_DEVICE_ID_ATI_RAGE128_PN: u32 = 20558;
pub const PCI_DEVICE_ID_ATI_RAGE128_PO: u32 = 20559;
pub const PCI_DEVICE_ID_ATI_RAGE128_PP: u32 = 20560;
pub const PCI_DEVICE_ID_ATI_RAGE128_PQ: u32 = 20561;
pub const PCI_DEVICE_ID_ATI_RAGE128_PR: u32 = 20562;
pub const PCI_DEVICE_ID_ATI_RAGE128_PS: u32 = 20563;
pub const PCI_DEVICE_ID_ATI_RAGE128_PT: u32 = 20564;
pub const PCI_DEVICE_ID_ATI_RAGE128_PU: u32 = 20565;
pub const PCI_DEVICE_ID_ATI_RAGE128_PV: u32 = 20566;
pub const PCI_DEVICE_ID_ATI_RAGE128_PW: u32 = 20567;
pub const PCI_DEVICE_ID_ATI_RAGE128_PX: u32 = 20568;
pub const PCI_DEVICE_ID_ATI_RADEON_QD: u32 = 20804;
pub const PCI_DEVICE_ID_ATI_RADEON_QE: u32 = 20805;
pub const PCI_DEVICE_ID_ATI_RADEON_QF: u32 = 20806;
pub const PCI_DEVICE_ID_ATI_RADEON_QG: u32 = 20807;
pub const PCI_DEVICE_ID_ATI_RADEON_QY: u32 = 20825;
pub const PCI_DEVICE_ID_ATI_RADEON_QZ: u32 = 20826;
pub const PCI_DEVICE_ID_ATI_RADEON_QL: u32 = 20812;
pub const PCI_DEVICE_ID_ATI_RADEON_QN: u32 = 20814;
pub const PCI_DEVICE_ID_ATI_RADEON_QO: u32 = 20815;
pub const PCI_DEVICE_ID_ATI_RADEON_Ql: u32 = 20844;
pub const PCI_DEVICE_ID_ATI_RADEON_BB: u32 = 16962;
pub const PCI_DEVICE_ID_ATI_RADEON_QM: u32 = 20813;
pub const PCI_DEVICE_ID_ATI_RADEON_QW: u32 = 20823;
pub const PCI_DEVICE_ID_ATI_RADEON_QX: u32 = 20824;
pub const PCI_DEVICE_ID_ATI_RADEON_Id: u32 = 18788;
pub const PCI_DEVICE_ID_ATI_RADEON_Ie: u32 = 18789;
pub const PCI_DEVICE_ID_ATI_RADEON_If: u32 = 18790;
pub const PCI_DEVICE_ID_ATI_RADEON_Ig: u32 = 18791;
pub const PCI_DEVICE_ID_ATI_RADEON_Ya: u32 = 22881;
pub const PCI_DEVICE_ID_ATI_RADEON_Yd: u32 = 22884;
pub const PCI_DEVICE_ID_ATI_RADEON_ND: u32 = 20036;
pub const PCI_DEVICE_ID_ATI_RADEON_NE: u32 = 20037;
pub const PCI_DEVICE_ID_ATI_RADEON_NF: u32 = 20038;
pub const PCI_DEVICE_ID_ATI_RADEON_NG: u32 = 20039;
pub const PCI_DEVICE_ID_ATI_RADEON_LY: u32 = 19545;
pub const PCI_DEVICE_ID_ATI_RADEON_LZ: u32 = 19546;
pub const PCI_DEVICE_ID_ATI_RADEON_LW: u32 = 19543;
pub const PCI_DEVICE_ID_ATI_RADEON_LX: u32 = 19544;
pub const PCI_DEVICE_ID_ATI_RADEON_Ld: u32 = 19556;
pub const PCI_DEVICE_ID_ATI_RADEON_Le: u32 = 19557;
pub const PCI_DEVICE_ID_ATI_RADEON_Lf: u32 = 19558;
pub const PCI_DEVICE_ID_ATI_RADEON_Lg: u32 = 19559;
pub const PCI_DEVICE_ID_ATI_RS100: u32 = 51888;
pub const PCI_DEVICE_ID_ATI_RS200: u32 = 51890;
pub const PCI_DEVICE_ID_ATI_RS200_B: u32 = 52146;
pub const PCI_DEVICE_ID_ATI_RS250: u32 = 51891;
pub const PCI_DEVICE_ID_ATI_RS300_100: u32 = 22576;
pub const PCI_DEVICE_ID_ATI_RS300_133: u32 = 22577;
pub const PCI_DEVICE_ID_ATI_RS300_166: u32 = 22578;
pub const PCI_DEVICE_ID_ATI_RS300_200: u32 = 22579;
pub const PCI_DEVICE_ID_ATI_RS350_100: u32 = 30768;
pub const PCI_DEVICE_ID_ATI_RS350_133: u32 = 30769;
pub const PCI_DEVICE_ID_ATI_RS350_166: u32 = 30770;
pub const PCI_DEVICE_ID_ATI_RS350_200: u32 = 30771;
pub const PCI_DEVICE_ID_ATI_RS400_100: u32 = 23088;
pub const PCI_DEVICE_ID_ATI_RS400_133: u32 = 23089;
pub const PCI_DEVICE_ID_ATI_RS400_166: u32 = 23090;
pub const PCI_DEVICE_ID_ATI_RS400_200: u32 = 23091;
pub const PCI_DEVICE_ID_ATI_RS480: u32 = 22864;
pub const PCI_DEVICE_ID_ATI_IXP200_IDE: u32 = 17225;
pub const PCI_DEVICE_ID_ATI_IXP200_SMBUS: u32 = 17235;
pub const PCI_DEVICE_ID_ATI_IXP300_SMBUS: u32 = 17251;
pub const PCI_DEVICE_ID_ATI_IXP300_IDE: u32 = 17257;
pub const PCI_DEVICE_ID_ATI_IXP300_SATA: u32 = 17262;
pub const PCI_DEVICE_ID_ATI_IXP400_SMBUS: u32 = 17266;
pub const PCI_DEVICE_ID_ATI_IXP400_IDE: u32 = 17270;
pub const PCI_DEVICE_ID_ATI_IXP400_SATA: u32 = 17273;
pub const PCI_DEVICE_ID_ATI_IXP400_SATA2: u32 = 17274;
pub const PCI_DEVICE_ID_ATI_IXP600_SATA: u32 = 17280;
pub const PCI_DEVICE_ID_ATI_SBX00_SMBUS: u32 = 17285;
pub const PCI_DEVICE_ID_ATI_IXP600_IDE: u32 = 17292;
pub const PCI_DEVICE_ID_ATI_IXP700_SATA: u32 = 17296;
pub const PCI_DEVICE_ID_ATI_IXP700_IDE: u32 = 17308;
pub const PCI_VENDOR_ID_VLSI: u32 = 4100;
pub const PCI_DEVICE_ID_VLSI_82C592: u32 = 5;
pub const PCI_DEVICE_ID_VLSI_82C593: u32 = 6;
pub const PCI_DEVICE_ID_VLSI_82C594: u32 = 7;
pub const PCI_DEVICE_ID_VLSI_82C597: u32 = 9;
pub const PCI_DEVICE_ID_VLSI_82C541: u32 = 12;
pub const PCI_DEVICE_ID_VLSI_82C543: u32 = 13;
pub const PCI_DEVICE_ID_VLSI_82C532: u32 = 257;
pub const PCI_DEVICE_ID_VLSI_82C534: u32 = 258;
pub const PCI_DEVICE_ID_VLSI_82C535: u32 = 260;
pub const PCI_DEVICE_ID_VLSI_82C147: u32 = 261;
pub const PCI_DEVICE_ID_VLSI_VAS96011: u32 = 1794;
pub const PCI_DEVICE_ID_RD890_IOMMU: u32 = 23075;
pub const PCI_VENDOR_ID_ADL: u32 = 4101;
pub const PCI_DEVICE_ID_ADL_2301: u32 = 8961;
pub const PCI_VENDOR_ID_NS: u32 = 4107;
pub const PCI_DEVICE_ID_NS_87415: u32 = 2;
pub const PCI_DEVICE_ID_NS_87560_LIO: u32 = 14;
pub const PCI_DEVICE_ID_NS_87560_USB: u32 = 18;
pub const PCI_DEVICE_ID_NS_83815: u32 = 32;
pub const PCI_DEVICE_ID_NS_83820: u32 = 34;
pub const PCI_DEVICE_ID_NS_CS5535_ISA: u32 = 43;
pub const PCI_DEVICE_ID_NS_CS5535_IDE: u32 = 45;
pub const PCI_DEVICE_ID_NS_CS5535_AUDIO: u32 = 46;
pub const PCI_DEVICE_ID_NS_CS5535_USB: u32 = 47;
pub const PCI_DEVICE_ID_NS_GX_VIDEO: u32 = 48;
pub const PCI_DEVICE_ID_NS_SATURN: u32 = 53;
pub const PCI_DEVICE_ID_NS_SCx200_BRIDGE: u32 = 1280;
pub const PCI_DEVICE_ID_NS_SCx200_SMI: u32 = 1281;
pub const PCI_DEVICE_ID_NS_SCx200_IDE: u32 = 1282;
pub const PCI_DEVICE_ID_NS_SCx200_AUDIO: u32 = 1283;
pub const PCI_DEVICE_ID_NS_SCx200_VIDEO: u32 = 1284;
pub const PCI_DEVICE_ID_NS_SCx200_XBUS: u32 = 1285;
pub const PCI_DEVICE_ID_NS_SC1100_BRIDGE: u32 = 1296;
pub const PCI_DEVICE_ID_NS_SC1100_SMI: u32 = 1297;
pub const PCI_DEVICE_ID_NS_SC1100_XBUS: u32 = 1301;
pub const PCI_DEVICE_ID_NS_87410: u32 = 53249;
pub const PCI_DEVICE_ID_NS_GX_HOST_BRIDGE: u32 = 40;
pub const PCI_VENDOR_ID_TSENG: u32 = 4108;
pub const PCI_DEVICE_ID_TSENG_W32P_2: u32 = 12802;
pub const PCI_DEVICE_ID_TSENG_W32P_b: u32 = 12805;
pub const PCI_DEVICE_ID_TSENG_W32P_c: u32 = 12806;
pub const PCI_DEVICE_ID_TSENG_W32P_d: u32 = 12807;
pub const PCI_DEVICE_ID_TSENG_ET6000: u32 = 12808;
pub const PCI_VENDOR_ID_WEITEK: u32 = 4110;
pub const PCI_DEVICE_ID_WEITEK_P9000: u32 = 36865;
pub const PCI_DEVICE_ID_WEITEK_P9100: u32 = 37120;
pub const PCI_VENDOR_ID_DEC: u32 = 4113;
pub const PCI_DEVICE_ID_DEC_BRD: u32 = 1;
pub const PCI_DEVICE_ID_DEC_TULIP: u32 = 2;
pub const PCI_DEVICE_ID_DEC_TGA: u32 = 4;
pub const PCI_DEVICE_ID_DEC_TULIP_FAST: u32 = 9;
pub const PCI_DEVICE_ID_DEC_TGA2: u32 = 13;
pub const PCI_DEVICE_ID_DEC_FDDI: u32 = 15;
pub const PCI_DEVICE_ID_DEC_TULIP_PLUS: u32 = 20;
pub const PCI_DEVICE_ID_DEC_21142: u32 = 25;
pub const PCI_DEVICE_ID_DEC_21052: u32 = 33;
pub const PCI_DEVICE_ID_DEC_21150: u32 = 34;
pub const PCI_DEVICE_ID_DEC_21152: u32 = 36;
pub const PCI_DEVICE_ID_DEC_21153: u32 = 37;
pub const PCI_DEVICE_ID_DEC_21154: u32 = 38;
pub const PCI_DEVICE_ID_DEC_21285: u32 = 4197;
pub const PCI_DEVICE_ID_COMPAQ_42XX: u32 = 70;
pub const PCI_VENDOR_ID_CIRRUS: u32 = 4115;
pub const PCI_DEVICE_ID_CIRRUS_7548: u32 = 56;
pub const PCI_DEVICE_ID_CIRRUS_5430: u32 = 160;
pub const PCI_DEVICE_ID_CIRRUS_5434_4: u32 = 164;
pub const PCI_DEVICE_ID_CIRRUS_5434_8: u32 = 168;
pub const PCI_DEVICE_ID_CIRRUS_5436: u32 = 172;
pub const PCI_DEVICE_ID_CIRRUS_5446: u32 = 184;
pub const PCI_DEVICE_ID_CIRRUS_5480: u32 = 188;
pub const PCI_DEVICE_ID_CIRRUS_5462: u32 = 208;
pub const PCI_DEVICE_ID_CIRRUS_5464: u32 = 212;
pub const PCI_DEVICE_ID_CIRRUS_5465: u32 = 214;
pub const PCI_DEVICE_ID_CIRRUS_6729: u32 = 4352;
pub const PCI_DEVICE_ID_CIRRUS_6832: u32 = 4368;
pub const PCI_DEVICE_ID_CIRRUS_7543: u32 = 4610;
pub const PCI_DEVICE_ID_CIRRUS_4610: u32 = 24577;
pub const PCI_DEVICE_ID_CIRRUS_4612: u32 = 24579;
pub const PCI_DEVICE_ID_CIRRUS_4615: u32 = 24580;
pub const PCI_VENDOR_ID_IBM: u32 = 4116;
pub const PCI_DEVICE_ID_IBM_TR: u32 = 24;
pub const PCI_DEVICE_ID_IBM_TR_WAKE: u32 = 62;
pub const PCI_DEVICE_ID_IBM_CPC710_PCI64: u32 = 252;
pub const PCI_DEVICE_ID_IBM_SNIPE: u32 = 384;
pub const PCI_DEVICE_ID_IBM_CITRINE: u32 = 652;
pub const PCI_DEVICE_ID_IBM_GEMSTONE: u32 = 45414;
pub const PCI_DEVICE_ID_IBM_OBSIDIAN: u32 = 701;
pub const PCI_DEVICE_ID_IBM_ICOM_DEV_ID_1: u32 = 49;
pub const PCI_DEVICE_ID_IBM_ICOM_DEV_ID_2: u32 = 537;
pub const PCI_DEVICE_ID_IBM_ICOM_V2_TWO_PORTS_RVX: u32 = 538;
pub const PCI_DEVICE_ID_IBM_ICOM_V2_ONE_PORT_RVX_ONE_PORT_MDM: u32 = 593;
pub const PCI_DEVICE_ID_IBM_ICOM_V2_ONE_PORT_RVX_ONE_PORT_MDM_PCIE: u32 = 865;
pub const PCI_DEVICE_ID_IBM_ICOM_FOUR_PORT_MODEL: u32 = 594;
pub const PCI_DEVICE_ID_IBM_ISM: u32 = 1261;
pub const PCI_SUBVENDOR_ID_IBM: u32 = 4116;
pub const PCI_SUBDEVICE_ID_IBM_SATURN_SERIAL_ONE_PORT: u32 = 980;
pub const PCI_VENDOR_ID_UNISYS: u32 = 4120;
pub const PCI_DEVICE_ID_UNISYS_DMA_DIRECTOR: u32 = 28;
pub const PCI_VENDOR_ID_COMPEX2: u32 = 4122;
pub const PCI_DEVICE_ID_COMPEX2_100VG: u32 = 5;
pub const PCI_VENDOR_ID_WD: u32 = 4124;
pub const PCI_DEVICE_ID_WD_90C: u32 = 49738;
pub const PCI_VENDOR_ID_AMI: u32 = 4126;
pub const PCI_DEVICE_ID_AMI_MEGARAID3: u32 = 6496;
pub const PCI_DEVICE_ID_AMI_MEGARAID: u32 = 36880;
pub const PCI_DEVICE_ID_AMI_MEGARAID2: u32 = 36960;
pub const PCI_VENDOR_ID_AMD: u32 = 4130;
pub const PCI_DEVICE_ID_AMD_K8_NB: u32 = 4352;
pub const PCI_DEVICE_ID_AMD_K8_NB_ADDRMAP: u32 = 4353;
pub const PCI_DEVICE_ID_AMD_K8_NB_MEMCTL: u32 = 4354;
pub const PCI_DEVICE_ID_AMD_K8_NB_MISC: u32 = 4355;
pub const PCI_DEVICE_ID_AMD_10H_NB_HT: u32 = 4608;
pub const PCI_DEVICE_ID_AMD_10H_NB_MAP: u32 = 4609;
pub const PCI_DEVICE_ID_AMD_10H_NB_DRAM: u32 = 4610;
pub const PCI_DEVICE_ID_AMD_10H_NB_MISC: u32 = 4611;
pub const PCI_DEVICE_ID_AMD_10H_NB_LINK: u32 = 4612;
pub const PCI_DEVICE_ID_AMD_11H_NB_HT: u32 = 4864;
pub const PCI_DEVICE_ID_AMD_11H_NB_MAP: u32 = 4865;
pub const PCI_DEVICE_ID_AMD_11H_NB_DRAM: u32 = 4866;
pub const PCI_DEVICE_ID_AMD_11H_NB_MISC: u32 = 4867;
pub const PCI_DEVICE_ID_AMD_11H_NB_LINK: u32 = 4868;
pub const PCI_DEVICE_ID_AMD_15H_M10H_F3: u32 = 5123;
pub const PCI_DEVICE_ID_AMD_15H_M30H_NB_F3: u32 = 5149;
pub const PCI_DEVICE_ID_AMD_15H_M30H_NB_F4: u32 = 5150;
pub const PCI_DEVICE_ID_AMD_15H_M60H_NB_F3: u32 = 5491;
pub const PCI_DEVICE_ID_AMD_15H_M60H_NB_F4: u32 = 5492;
pub const PCI_DEVICE_ID_AMD_15H_NB_F0: u32 = 5632;
pub const PCI_DEVICE_ID_AMD_15H_NB_F1: u32 = 5633;
pub const PCI_DEVICE_ID_AMD_15H_NB_F2: u32 = 5634;
pub const PCI_DEVICE_ID_AMD_15H_NB_F3: u32 = 5635;
pub const PCI_DEVICE_ID_AMD_15H_NB_F4: u32 = 5636;
pub const PCI_DEVICE_ID_AMD_15H_NB_F5: u32 = 5637;
pub const PCI_DEVICE_ID_AMD_16H_NB_F3: u32 = 5427;
pub const PCI_DEVICE_ID_AMD_16H_NB_F4: u32 = 5428;
pub const PCI_DEVICE_ID_AMD_16H_M30H_NB_F3: u32 = 5507;
pub const PCI_DEVICE_ID_AMD_16H_M30H_NB_F4: u32 = 5508;
pub const PCI_DEVICE_ID_AMD_17H_DF_F3: u32 = 5219;
pub const PCI_DEVICE_ID_AMD_17H_M10H_DF_F3: u32 = 5611;
pub const PCI_DEVICE_ID_AMD_17H_M30H_DF_F3: u32 = 5267;
pub const PCI_DEVICE_ID_AMD_17H_M40H_DF_F3: u32 = 5107;
pub const PCI_DEVICE_ID_AMD_17H_M60H_DF_F3: u32 = 5195;
pub const PCI_DEVICE_ID_AMD_17H_M70H_DF_F3: u32 = 5187;
pub const PCI_DEVICE_ID_AMD_17H_MA0H_DF_F3: u32 = 5927;
pub const PCI_DEVICE_ID_AMD_19H_DF_F3: u32 = 5715;
pub const PCI_DEVICE_ID_AMD_19H_M10H_DF_F3: u32 = 5296;
pub const PCI_DEVICE_ID_AMD_19H_M40H_DF_F3: u32 = 5756;
pub const PCI_DEVICE_ID_AMD_19H_M50H_DF_F3: u32 = 5741;
pub const PCI_DEVICE_ID_AMD_19H_M60H_DF_F3: u32 = 5347;
pub const PCI_DEVICE_ID_AMD_19H_M70H_DF_F3: u32 = 5363;
pub const PCI_DEVICE_ID_AMD_19H_M78H_DF_F3: u32 = 4859;
pub const PCI_DEVICE_ID_AMD_1AH_M00H_DF_F3: u32 = 4803;
pub const PCI_DEVICE_ID_AMD_1AH_M20H_DF_F3: u32 = 5883;
pub const PCI_DEVICE_ID_AMD_1AH_M60H_DF_F3: u32 = 4683;
pub const PCI_DEVICE_ID_AMD_1AH_M70H_DF_F3: u32 = 4795;
pub const PCI_DEVICE_ID_AMD_MI200_DF_F3: u32 = 5331;
pub const PCI_DEVICE_ID_AMD_MI300_DF_F3: u32 = 5419;
pub const PCI_DEVICE_ID_AMD_VANGOGH_USB: u32 = 5690;
pub const PCI_DEVICE_ID_AMD_CNB17H_F3: u32 = 5891;
pub const PCI_DEVICE_ID_AMD_LANCE: u32 = 8192;
pub const PCI_DEVICE_ID_AMD_LANCE_HOME: u32 = 8193;
pub const PCI_DEVICE_ID_AMD_SCSI: u32 = 8224;
pub const PCI_DEVICE_ID_AMD_SERENADE: u32 = 14016;
pub const PCI_DEVICE_ID_AMD_FE_GATE_7006: u32 = 28678;
pub const PCI_DEVICE_ID_AMD_FE_GATE_7007: u32 = 28679;
pub const PCI_DEVICE_ID_AMD_FE_GATE_700C: u32 = 28684;
pub const PCI_DEVICE_ID_AMD_FE_GATE_700E: u32 = 28686;
pub const PCI_DEVICE_ID_AMD_COBRA_7401: u32 = 29697;
pub const PCI_DEVICE_ID_AMD_VIPER_7409: u32 = 29705;
pub const PCI_DEVICE_ID_AMD_VIPER_740B: u32 = 29707;
pub const PCI_DEVICE_ID_AMD_VIPER_7410: u32 = 29712;
pub const PCI_DEVICE_ID_AMD_VIPER_7411: u32 = 29713;
pub const PCI_DEVICE_ID_AMD_VIPER_7413: u32 = 29715;
pub const PCI_DEVICE_ID_AMD_VIPER_7440: u32 = 29760;
pub const PCI_DEVICE_ID_AMD_OPUS_7441: u32 = 29761;
pub const PCI_DEVICE_ID_AMD_OPUS_7443: u32 = 29763;
pub const PCI_DEVICE_ID_AMD_VIPER_7443: u32 = 29763;
pub const PCI_DEVICE_ID_AMD_OPUS_7445: u32 = 29765;
pub const PCI_DEVICE_ID_AMD_GOLAM_7450: u32 = 29776;
pub const PCI_DEVICE_ID_AMD_8111_PCI: u32 = 29792;
pub const PCI_DEVICE_ID_AMD_8111_LPC: u32 = 29800;
pub const PCI_DEVICE_ID_AMD_8111_IDE: u32 = 29801;
pub const PCI_DEVICE_ID_AMD_8111_SMBUS2: u32 = 29802;
pub const PCI_DEVICE_ID_AMD_8111_SMBUS: u32 = 29803;
pub const PCI_DEVICE_ID_AMD_8111_AUDIO: u32 = 29805;
pub const PCI_DEVICE_ID_AMD_8151_0: u32 = 29780;
pub const PCI_DEVICE_ID_AMD_8131_BRIDGE: u32 = 29776;
pub const PCI_DEVICE_ID_AMD_8131_APIC: u32 = 29777;
pub const PCI_DEVICE_ID_AMD_8132_BRIDGE: u32 = 29784;
pub const PCI_DEVICE_ID_AMD_NL_USB: u32 = 30994;
pub const PCI_DEVICE_ID_AMD_CS5535_IDE: u32 = 8335;
pub const PCI_DEVICE_ID_AMD_CS5536_ISA: u32 = 8336;
pub const PCI_DEVICE_ID_AMD_CS5536_FLASH: u32 = 8337;
pub const PCI_DEVICE_ID_AMD_CS5536_AUDIO: u32 = 8339;
pub const PCI_DEVICE_ID_AMD_CS5536_OHC: u32 = 8340;
pub const PCI_DEVICE_ID_AMD_CS5536_EHC: u32 = 8341;
pub const PCI_DEVICE_ID_AMD_CS5536_UDC: u32 = 8342;
pub const PCI_DEVICE_ID_AMD_CS5536_UOC: u32 = 8343;
pub const PCI_DEVICE_ID_AMD_CS5536_DEV_IDE: u32 = 8338;
pub const PCI_DEVICE_ID_AMD_CS5536_IDE: u32 = 8346;
pub const PCI_DEVICE_ID_AMD_LX_VIDEO: u32 = 8321;
pub const PCI_DEVICE_ID_AMD_LX_AES: u32 = 8322;
pub const PCI_DEVICE_ID_AMD_HUDSON2_SATA_IDE: u32 = 30720;
pub const PCI_DEVICE_ID_AMD_HUDSON2_SMBUS: u32 = 30731;
pub const PCI_DEVICE_ID_AMD_HUDSON2_IDE: u32 = 30732;
pub const PCI_DEVICE_ID_AMD_KERNCZ_SMBUS: u32 = 30987;
pub const PCI_VENDOR_ID_TRIDENT: u32 = 4131;
pub const PCI_DEVICE_ID_TRIDENT_4DWAVE_DX: u32 = 8192;
pub const PCI_DEVICE_ID_TRIDENT_4DWAVE_NX: u32 = 8193;
pub const PCI_DEVICE_ID_TRIDENT_9320: u32 = 37664;
pub const PCI_DEVICE_ID_TRIDENT_9388: u32 = 37768;
pub const PCI_DEVICE_ID_TRIDENT_9397: u32 = 37783;
pub const PCI_DEVICE_ID_TRIDENT_939A: u32 = 37786;
pub const PCI_DEVICE_ID_TRIDENT_9520: u32 = 38176;
pub const PCI_DEVICE_ID_TRIDENT_9525: u32 = 38181;
pub const PCI_DEVICE_ID_TRIDENT_9420: u32 = 37920;
pub const PCI_DEVICE_ID_TRIDENT_9440: u32 = 37952;
pub const PCI_DEVICE_ID_TRIDENT_9660: u32 = 38496;
pub const PCI_DEVICE_ID_TRIDENT_9750: u32 = 38736;
pub const PCI_DEVICE_ID_TRIDENT_9850: u32 = 38992;
pub const PCI_DEVICE_ID_TRIDENT_9880: u32 = 39040;
pub const PCI_DEVICE_ID_TRIDENT_8400: u32 = 33792;
pub const PCI_DEVICE_ID_TRIDENT_8420: u32 = 33824;
pub const PCI_DEVICE_ID_TRIDENT_8500: u32 = 34048;
pub const PCI_VENDOR_ID_AI: u32 = 4133;
pub const PCI_DEVICE_ID_AI_M1435: u32 = 5173;
pub const PCI_VENDOR_ID_DELL: u32 = 4136;
pub const PCI_DEVICE_ID_DELL_RACIII: u32 = 8;
pub const PCI_DEVICE_ID_DELL_RAC4: u32 = 18;
pub const PCI_DEVICE_ID_DELL_PERC5: u32 = 21;
pub const PCI_SUBVENDOR_ID_DELL: u32 = 4136;
pub const PCI_VENDOR_ID_MATROX: u32 = 4139;
pub const PCI_DEVICE_ID_MATROX_MGA_2: u32 = 1304;
pub const PCI_DEVICE_ID_MATROX_MIL: u32 = 1305;
pub const PCI_DEVICE_ID_MATROX_MYS: u32 = 1306;
pub const PCI_DEVICE_ID_MATROX_MIL_2: u32 = 1307;
pub const PCI_DEVICE_ID_MATROX_MYS_AGP: u32 = 1310;
pub const PCI_DEVICE_ID_MATROX_MIL_2_AGP: u32 = 1311;
pub const PCI_DEVICE_ID_MATROX_MGA_IMP: u32 = 3344;
pub const PCI_DEVICE_ID_MATROX_G100_MM: u32 = 4096;
pub const PCI_DEVICE_ID_MATROX_G100_AGP: u32 = 4097;
pub const PCI_DEVICE_ID_MATROX_G200_PCI: u32 = 1312;
pub const PCI_DEVICE_ID_MATROX_G200_AGP: u32 = 1313;
pub const PCI_DEVICE_ID_MATROX_G400: u32 = 1317;
pub const PCI_DEVICE_ID_MATROX_G200EV_PCI: u32 = 1328;
pub const PCI_DEVICE_ID_MATROX_G550: u32 = 9511;
pub const PCI_DEVICE_ID_MATROX_VIA: u32 = 17718;
pub const PCI_VENDOR_ID_MOBILITY_ELECTRONICS: u32 = 5362;
pub const PCI_VENDOR_ID_CT: u32 = 4140;
pub const PCI_DEVICE_ID_CT_69000: u32 = 192;
pub const PCI_DEVICE_ID_CT_65545: u32 = 216;
pub const PCI_DEVICE_ID_CT_65548: u32 = 220;
pub const PCI_DEVICE_ID_CT_65550: u32 = 224;
pub const PCI_DEVICE_ID_CT_65554: u32 = 228;
pub const PCI_DEVICE_ID_CT_65555: u32 = 229;
pub const PCI_VENDOR_ID_MIRO: u32 = 4145;
pub const PCI_DEVICE_ID_MIRO_36050: u32 = 22017;
pub const PCI_DEVICE_ID_MIRO_DC10PLUS: u32 = 32510;
pub const PCI_DEVICE_ID_MIRO_DC30PLUS: u32 = 55297;
pub const PCI_VENDOR_ID_NEC: u32 = 4147;
pub const PCI_DEVICE_ID_NEC_CBUS_1: u32 = 1;
pub const PCI_DEVICE_ID_NEC_LOCAL: u32 = 2;
pub const PCI_DEVICE_ID_NEC_ATM: u32 = 3;
pub const PCI_DEVICE_ID_NEC_R4000: u32 = 4;
pub const PCI_DEVICE_ID_NEC_486: u32 = 5;
pub const PCI_DEVICE_ID_NEC_ACCEL_1: u32 = 6;
pub const PCI_DEVICE_ID_NEC_UXBUS: u32 = 7;
pub const PCI_DEVICE_ID_NEC_ACCEL_2: u32 = 8;
pub const PCI_DEVICE_ID_NEC_GRAPH: u32 = 9;
pub const PCI_DEVICE_ID_NEC_VL: u32 = 22;
pub const PCI_DEVICE_ID_NEC_STARALPHA2: u32 = 44;
pub const PCI_DEVICE_ID_NEC_CBUS_2: u32 = 45;
pub const PCI_DEVICE_ID_NEC_USB: u32 = 53;
pub const PCI_DEVICE_ID_NEC_CBUS_3: u32 = 59;
pub const PCI_DEVICE_ID_NEC_NAPCCARD: u32 = 62;
pub const PCI_DEVICE_ID_NEC_PCX2: u32 = 70;
pub const PCI_DEVICE_ID_NEC_VRC5476: u32 = 155;
pub const PCI_DEVICE_ID_NEC_VRC4173: u32 = 165;
pub const PCI_DEVICE_ID_NEC_VRC5477_AC97: u32 = 166;
pub const PCI_DEVICE_ID_NEC_PC9821CS01: u32 = 32780;
pub const PCI_DEVICE_ID_NEC_PC9821NRB06: u32 = 32781;
pub const PCI_VENDOR_ID_FD: u32 = 4150;
pub const PCI_DEVICE_ID_FD_36C70: u32 = 0;
pub const PCI_VENDOR_ID_SI: u32 = 4153;
pub const PCI_DEVICE_ID_SI_5591_AGP: u32 = 1;
pub const PCI_DEVICE_ID_SI_6202: u32 = 2;
pub const PCI_DEVICE_ID_SI_503: u32 = 8;
pub const PCI_DEVICE_ID_SI_ACPI: u32 = 9;
pub const PCI_DEVICE_ID_SI_SMBUS: u32 = 22;
pub const PCI_DEVICE_ID_SI_LPC: u32 = 24;
pub const PCI_DEVICE_ID_SI_5597_VGA: u32 = 512;
pub const PCI_DEVICE_ID_SI_6205: u32 = 517;
pub const PCI_DEVICE_ID_SI_501: u32 = 1030;
pub const PCI_DEVICE_ID_SI_496: u32 = 1174;
pub const PCI_DEVICE_ID_SI_300: u32 = 768;
pub const PCI_DEVICE_ID_SI_315H: u32 = 784;
pub const PCI_DEVICE_ID_SI_315: u32 = 789;
pub const PCI_DEVICE_ID_SI_315PRO: u32 = 805;
pub const PCI_DEVICE_ID_SI_530: u32 = 1328;
pub const PCI_DEVICE_ID_SI_540: u32 = 1344;
pub const PCI_DEVICE_ID_SI_550: u32 = 1360;
pub const PCI_DEVICE_ID_SI_540_VGA: u32 = 21248;
pub const PCI_DEVICE_ID_SI_550_VGA: u32 = 21269;
pub const PCI_DEVICE_ID_SI_620: u32 = 1568;
pub const PCI_DEVICE_ID_SI_630: u32 = 1584;
pub const PCI_DEVICE_ID_SI_633: u32 = 1587;
pub const PCI_DEVICE_ID_SI_635: u32 = 1589;
pub const PCI_DEVICE_ID_SI_640: u32 = 1600;
pub const PCI_DEVICE_ID_SI_645: u32 = 1605;
pub const PCI_DEVICE_ID_SI_646: u32 = 1606;
pub const PCI_DEVICE_ID_SI_648: u32 = 1608;
pub const PCI_DEVICE_ID_SI_650: u32 = 1616;
pub const PCI_DEVICE_ID_SI_651: u32 = 1617;
pub const PCI_DEVICE_ID_SI_655: u32 = 1621;
pub const PCI_DEVICE_ID_SI_661: u32 = 1633;
pub const PCI_DEVICE_ID_SI_730: u32 = 1840;
pub const PCI_DEVICE_ID_SI_733: u32 = 1843;
pub const PCI_DEVICE_ID_SI_630_VGA: u32 = 25344;
pub const PCI_DEVICE_ID_SI_735: u32 = 1845;
pub const PCI_DEVICE_ID_SI_740: u32 = 1856;
pub const PCI_DEVICE_ID_SI_741: u32 = 1857;
pub const PCI_DEVICE_ID_SI_745: u32 = 1861;
pub const PCI_DEVICE_ID_SI_746: u32 = 1862;
pub const PCI_DEVICE_ID_SI_755: u32 = 1877;
pub const PCI_DEVICE_ID_SI_760: u32 = 1888;
pub const PCI_DEVICE_ID_SI_900: u32 = 2304;
pub const PCI_DEVICE_ID_SI_961: u32 = 2401;
pub const PCI_DEVICE_ID_SI_962: u32 = 2402;
pub const PCI_DEVICE_ID_SI_963: u32 = 2403;
pub const PCI_DEVICE_ID_SI_965: u32 = 2405;
pub const PCI_DEVICE_ID_SI_966: u32 = 2406;
pub const PCI_DEVICE_ID_SI_968: u32 = 2408;
pub const PCI_DEVICE_ID_SI_1180: u32 = 4480;
pub const PCI_DEVICE_ID_SI_5511: u32 = 21777;
pub const PCI_DEVICE_ID_SI_5513: u32 = 21779;
pub const PCI_DEVICE_ID_SI_5517: u32 = 21783;
pub const PCI_DEVICE_ID_SI_5518: u32 = 21784;
pub const PCI_DEVICE_ID_SI_5571: u32 = 21873;
pub const PCI_DEVICE_ID_SI_5581: u32 = 21889;
pub const PCI_DEVICE_ID_SI_5582: u32 = 21890;
pub const PCI_DEVICE_ID_SI_5591: u32 = 21905;
pub const PCI_DEVICE_ID_SI_5596: u32 = 21910;
pub const PCI_DEVICE_ID_SI_5597: u32 = 21911;
pub const PCI_DEVICE_ID_SI_5598: u32 = 21912;
pub const PCI_DEVICE_ID_SI_5600: u32 = 22016;
pub const PCI_DEVICE_ID_SI_7012: u32 = 28690;
pub const PCI_DEVICE_ID_SI_7013: u32 = 28691;
pub const PCI_DEVICE_ID_SI_7016: u32 = 28694;
pub const PCI_DEVICE_ID_SI_7018: u32 = 28696;
pub const PCI_VENDOR_ID_HP: u32 = 4156;
pub const PCI_VENDOR_ID_HP_3PAR: u32 = 5520;
pub const PCI_DEVICE_ID_HP_VISUALIZE_EG: u32 = 4101;
pub const PCI_DEVICE_ID_HP_VISUALIZE_FX6: u32 = 4102;
pub const PCI_DEVICE_ID_HP_VISUALIZE_FX4: u32 = 4104;
pub const PCI_DEVICE_ID_HP_VISUALIZE_FX2: u32 = 4106;
pub const PCI_DEVICE_ID_HP_TACHYON: u32 = 4136;
pub const PCI_DEVICE_ID_HP_TACHLITE: u32 = 4137;
pub const PCI_DEVICE_ID_HP_J2585A: u32 = 4144;
pub const PCI_DEVICE_ID_HP_J2585B: u32 = 4145;
pub const PCI_DEVICE_ID_HP_J2973A: u32 = 4160;
pub const PCI_DEVICE_ID_HP_J2970A: u32 = 4162;
pub const PCI_DEVICE_ID_HP_DIVA: u32 = 4168;
pub const PCI_DEVICE_ID_HP_DIVA_TOSCA1: u32 = 4169;
pub const PCI_DEVICE_ID_HP_DIVA_TOSCA2: u32 = 4170;
pub const PCI_DEVICE_ID_HP_DIVA_MAESTRO: u32 = 4171;
pub const PCI_DEVICE_ID_HP_REO_IOC: u32 = 4337;
pub const PCI_DEVICE_ID_HP_VISUALIZE_FXE: u32 = 4235;
pub const PCI_DEVICE_ID_HP_DIVA_HALFDOME: u32 = 4643;
pub const PCI_DEVICE_ID_HP_DIVA_KEYSTONE: u32 = 4646;
pub const PCI_DEVICE_ID_HP_DIVA_POWERBAR: u32 = 4647;
pub const PCI_DEVICE_ID_HP_ZX1_IOC: u32 = 4650;
pub const PCI_DEVICE_ID_HP_PCIX_LBA: u32 = 4654;
pub const PCI_DEVICE_ID_HP_SX1000_IOC: u32 = 4732;
pub const PCI_DEVICE_ID_HP_DIVA_EVEREST: u32 = 4738;
pub const PCI_DEVICE_ID_HP_DIVA_AUX: u32 = 4752;
pub const PCI_DEVICE_ID_HP_DIVA_RMP3: u32 = 4865;
pub const PCI_DEVICE_ID_HP_DIVA_HURRICANE: u32 = 4906;
pub const PCI_DEVICE_ID_HP_CISSA: u32 = 12832;
pub const PCI_DEVICE_ID_HP_CISSC: u32 = 12848;
pub const PCI_DEVICE_ID_HP_CISSD: u32 = 12856;
pub const PCI_DEVICE_ID_HP_CISSE: u32 = 12858;
pub const PCI_DEVICE_ID_HP_CISSF: u32 = 12859;
pub const PCI_DEVICE_ID_HP_CISSH: u32 = 12860;
pub const PCI_DEVICE_ID_HP_CISSI: u32 = 12857;
pub const PCI_DEVICE_ID_HP_ZX2_IOC: u32 = 16433;
pub const PCI_VENDOR_ID_PCTECH: u32 = 4162;
pub const PCI_DEVICE_ID_PCTECH_RZ1000: u32 = 4096;
pub const PCI_DEVICE_ID_PCTECH_RZ1001: u32 = 4097;
pub const PCI_DEVICE_ID_PCTECH_SAMURAI_IDE: u32 = 12320;
pub const PCI_VENDOR_ID_ASUSTEK: u32 = 4163;
pub const PCI_DEVICE_ID_ASUSTEK_0675: u32 = 1653;
pub const PCI_VENDOR_ID_DPT: u32 = 4164;
pub const PCI_DEVICE_ID_DPT: u32 = 41984;
pub const PCI_VENDOR_ID_OPTI: u32 = 4165;
pub const PCI_DEVICE_ID_OPTI_82C558: u32 = 50520;
pub const PCI_DEVICE_ID_OPTI_82C621: u32 = 50721;
pub const PCI_DEVICE_ID_OPTI_82C700: u32 = 50944;
pub const PCI_DEVICE_ID_OPTI_82C825: u32 = 54632;
pub const PCI_VENDOR_ID_ELSA: u32 = 4168;
pub const PCI_DEVICE_ID_ELSA_MICROLINK: u32 = 4096;
pub const PCI_DEVICE_ID_ELSA_QS3000: u32 = 12288;
pub const PCI_VENDOR_ID_STMICRO: u32 = 4170;
pub const PCI_DEVICE_ID_STMICRO_USB_HOST: u32 = 52224;
pub const PCI_DEVICE_ID_STMICRO_USB_OHCI: u32 = 52225;
pub const PCI_DEVICE_ID_STMICRO_USB_OTG: u32 = 52226;
pub const PCI_DEVICE_ID_STMICRO_UART_HWFC: u32 = 52227;
pub const PCI_DEVICE_ID_STMICRO_UART_NO_HWFC: u32 = 52228;
pub const PCI_DEVICE_ID_STMICRO_SOC_DMA: u32 = 52229;
pub const PCI_DEVICE_ID_STMICRO_SATA: u32 = 52230;
pub const PCI_DEVICE_ID_STMICRO_I2C: u32 = 52231;
pub const PCI_DEVICE_ID_STMICRO_SPI_HS: u32 = 52232;
pub const PCI_DEVICE_ID_STMICRO_MAC: u32 = 52233;
pub const PCI_DEVICE_ID_STMICRO_SDIO_EMMC: u32 = 52234;
pub const PCI_DEVICE_ID_STMICRO_SDIO: u32 = 52235;
pub const PCI_DEVICE_ID_STMICRO_GPIO: u32 = 52236;
pub const PCI_DEVICE_ID_STMICRO_VIP: u32 = 52237;
pub const PCI_DEVICE_ID_STMICRO_AUDIO_ROUTER_DMA: u32 = 52238;
pub const PCI_DEVICE_ID_STMICRO_AUDIO_ROUTER_SRCS: u32 = 52239;
pub const PCI_DEVICE_ID_STMICRO_AUDIO_ROUTER_MSPS: u32 = 52240;
pub const PCI_DEVICE_ID_STMICRO_CAN: u32 = 52241;
pub const PCI_DEVICE_ID_STMICRO_MLB: u32 = 52242;
pub const PCI_DEVICE_ID_STMICRO_DBP: u32 = 52243;
pub const PCI_DEVICE_ID_STMICRO_SATA_PHY: u32 = 52244;
pub const PCI_DEVICE_ID_STMICRO_ESRAM: u32 = 52245;
pub const PCI_DEVICE_ID_STMICRO_VIC: u32 = 52246;
pub const PCI_VENDOR_ID_BUSLOGIC: u32 = 4171;
pub const PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC: u32 = 320;
pub const PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER: u32 = 4160;
pub const PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT: u32 = 33072;
pub const PCI_VENDOR_ID_TI: u32 = 4172;
pub const PCI_DEVICE_ID_TI_TVP4020: u32 = 15623;
pub const PCI_DEVICE_ID_TI_4450: u32 = 32785;
pub const PCI_DEVICE_ID_TI_XX21_XX11: u32 = 32817;
pub const PCI_DEVICE_ID_TI_XX21_XX11_FM: u32 = 32819;
pub const PCI_DEVICE_ID_TI_XX21_XX11_SD: u32 = 32820;
pub const PCI_DEVICE_ID_TI_X515: u32 = 32822;
pub const PCI_DEVICE_ID_TI_XX12: u32 = 32825;
pub const PCI_DEVICE_ID_TI_XX12_FM: u32 = 32827;
pub const PCI_DEVICE_ID_TI_XIO2000A: u32 = 33329;
pub const PCI_DEVICE_ID_TI_1130: u32 = 44050;
pub const PCI_DEVICE_ID_TI_1031: u32 = 44051;
pub const PCI_DEVICE_ID_TI_1131: u32 = 44053;
pub const PCI_DEVICE_ID_TI_1250: u32 = 44054;
pub const PCI_DEVICE_ID_TI_1220: u32 = 44055;
pub const PCI_DEVICE_ID_TI_1221: u32 = 44057;
pub const PCI_DEVICE_ID_TI_1210: u32 = 44058;
pub const PCI_DEVICE_ID_TI_1450: u32 = 44059;
pub const PCI_DEVICE_ID_TI_1225: u32 = 44060;
pub const PCI_DEVICE_ID_TI_1251A: u32 = 44061;
pub const PCI_DEVICE_ID_TI_1211: u32 = 44062;
pub const PCI_DEVICE_ID_TI_1251B: u32 = 44063;
pub const PCI_DEVICE_ID_TI_4410: u32 = 44097;
pub const PCI_DEVICE_ID_TI_4451: u32 = 44098;
pub const PCI_DEVICE_ID_TI_4510: u32 = 44100;
pub const PCI_DEVICE_ID_TI_4520: u32 = 44102;
pub const PCI_DEVICE_ID_TI_7510: u32 = 44103;
pub const PCI_DEVICE_ID_TI_7610: u32 = 44104;
pub const PCI_DEVICE_ID_TI_7410: u32 = 44105;
pub const PCI_DEVICE_ID_TI_1410: u32 = 44112;
pub const PCI_DEVICE_ID_TI_1420: u32 = 44113;
pub const PCI_DEVICE_ID_TI_1451A: u32 = 44114;
pub const PCI_DEVICE_ID_TI_1620: u32 = 44116;
pub const PCI_DEVICE_ID_TI_1520: u32 = 44117;
pub const PCI_DEVICE_ID_TI_1510: u32 = 44118;
pub const PCI_DEVICE_ID_TI_X620: u32 = 44173;
pub const PCI_DEVICE_ID_TI_X420: u32 = 44174;
pub const PCI_DEVICE_ID_TI_XX20_FM: u32 = 44175;
pub const PCI_DEVICE_ID_TI_J721E: u32 = 45069;
pub const PCI_DEVICE_ID_TI_DRA74x: u32 = 46336;
pub const PCI_DEVICE_ID_TI_DRA72x: u32 = 46337;
pub const PCI_VENDOR_ID_SONY: u32 = 4173;
pub const PCI_VENDOR_ID_WINBOND2: u32 = 4176;
pub const PCI_DEVICE_ID_WINBOND2_89C940F: u32 = 23130;
pub const PCI_DEVICE_ID_WINBOND2_6692: u32 = 26258;
pub const PCI_VENDOR_ID_ANIGMA: u32 = 4177;
pub const PCI_DEVICE_ID_ANIGMA_MC145575: u32 = 256;
pub const PCI_VENDOR_ID_EFAR: u32 = 4181;
pub const PCI_DEVICE_ID_EFAR_SLC90E66_1: u32 = 37168;
pub const PCI_DEVICE_ID_EFAR_SLC90E66_3: u32 = 37987;
pub const PCI_VENDOR_ID_MOTOROLA: u32 = 4183;
pub const PCI_DEVICE_ID_MOTOROLA_MPC105: u32 = 1;
pub const PCI_DEVICE_ID_MOTOROLA_MPC106: u32 = 2;
pub const PCI_DEVICE_ID_MOTOROLA_MPC107: u32 = 4;
pub const PCI_DEVICE_ID_MOTOROLA_RAVEN: u32 = 18433;
pub const PCI_DEVICE_ID_MOTOROLA_FALCON: u32 = 18434;
pub const PCI_DEVICE_ID_MOTOROLA_HAWK: u32 = 18435;
pub const PCI_DEVICE_ID_MOTOROLA_HARRIER: u32 = 18443;
pub const PCI_DEVICE_ID_MOTOROLA_MPC5200: u32 = 22531;
pub const PCI_DEVICE_ID_MOTOROLA_MPC5200B: u32 = 22537;
pub const PCI_VENDOR_ID_PROMISE: u32 = 4186;
pub const PCI_DEVICE_ID_PROMISE_20265: u32 = 3376;
pub const PCI_DEVICE_ID_PROMISE_20267: u32 = 19760;
pub const PCI_DEVICE_ID_PROMISE_20246: u32 = 19763;
pub const PCI_DEVICE_ID_PROMISE_20262: u32 = 19768;
pub const PCI_DEVICE_ID_PROMISE_20263: u32 = 3384;
pub const PCI_DEVICE_ID_PROMISE_20268: u32 = 19816;
pub const PCI_DEVICE_ID_PROMISE_20269: u32 = 19817;
pub const PCI_DEVICE_ID_PROMISE_20270: u32 = 25192;
pub const PCI_DEVICE_ID_PROMISE_20271: u32 = 25193;
pub const PCI_DEVICE_ID_PROMISE_20275: u32 = 4725;
pub const PCI_DEVICE_ID_PROMISE_20276: u32 = 21109;
pub const PCI_DEVICE_ID_PROMISE_20277: u32 = 29301;
pub const PCI_VENDOR_ID_FOXCONN: u32 = 4187;
pub const PCI_VENDOR_ID_UMC: u32 = 4192;
pub const PCI_DEVICE_ID_UMC_UM8673F: u32 = 257;
pub const PCI_DEVICE_ID_UMC_UM8886BF: u32 = 26426;
pub const PCI_DEVICE_ID_UMC_UM8886A: u32 = 34922;
pub const PCI_VENDOR_ID_PICOPOWER: u32 = 4198;
pub const PCI_DEVICE_ID_PICOPOWER_PT86C523: u32 = 2;
pub const PCI_DEVICE_ID_PICOPOWER_PT86C523BBP: u32 = 32770;
pub const PCI_VENDOR_ID_MYLEX: u32 = 4201;
pub const PCI_DEVICE_ID_MYLEX_DAC960_P: u32 = 1;
pub const PCI_DEVICE_ID_MYLEX_DAC960_PD: u32 = 2;
pub const PCI_DEVICE_ID_MYLEX_DAC960_PG: u32 = 16;
pub const PCI_DEVICE_ID_MYLEX_DAC960_LA: u32 = 32;
pub const PCI_DEVICE_ID_MYLEX_DAC960_LP: u32 = 80;
pub const PCI_DEVICE_ID_MYLEX_DAC960_BA: u32 = 47702;
pub const PCI_DEVICE_ID_MYLEX_DAC960_GEM: u32 = 45414;
pub const PCI_VENDOR_ID_APPLE: u32 = 4203;
pub const PCI_DEVICE_ID_APPLE_BANDIT: u32 = 1;
pub const PCI_DEVICE_ID_APPLE_HYDRA: u32 = 14;
pub const PCI_DEVICE_ID_APPLE_UNI_N_FW: u32 = 24;
pub const PCI_DEVICE_ID_APPLE_UNI_N_AGP: u32 = 32;
pub const PCI_DEVICE_ID_APPLE_UNI_N_GMAC: u32 = 33;
pub const PCI_DEVICE_ID_APPLE_UNI_N_GMACP: u32 = 36;
pub const PCI_DEVICE_ID_APPLE_UNI_N_AGP_P: u32 = 39;
pub const PCI_DEVICE_ID_APPLE_UNI_N_AGP15: u32 = 45;
pub const PCI_DEVICE_ID_APPLE_UNI_N_PCI15: u32 = 46;
pub const PCI_DEVICE_ID_APPLE_UNI_N_GMAC2: u32 = 50;
pub const PCI_DEVICE_ID_APPLE_UNI_N_ATA: u32 = 51;
pub const PCI_DEVICE_ID_APPLE_UNI_N_AGP2: u32 = 52;
pub const PCI_DEVICE_ID_APPLE_IPID_ATA100: u32 = 59;
pub const PCI_DEVICE_ID_APPLE_K2_ATA100: u32 = 67;
pub const PCI_DEVICE_ID_APPLE_U3_AGP: u32 = 75;
pub const PCI_DEVICE_ID_APPLE_K2_GMAC: u32 = 76;
pub const PCI_DEVICE_ID_APPLE_SH_ATA: u32 = 80;
pub const PCI_DEVICE_ID_APPLE_SH_SUNGEM: u32 = 81;
pub const PCI_DEVICE_ID_APPLE_U3L_AGP: u32 = 88;
pub const PCI_DEVICE_ID_APPLE_U3H_AGP: u32 = 89;
pub const PCI_DEVICE_ID_APPLE_U4_PCIE: u32 = 91;
pub const PCI_DEVICE_ID_APPLE_IPID2_AGP: u32 = 102;
pub const PCI_DEVICE_ID_APPLE_IPID2_ATA: u32 = 105;
pub const PCI_DEVICE_ID_APPLE_IPID2_FW: u32 = 106;
pub const PCI_DEVICE_ID_APPLE_IPID2_GMAC: u32 = 107;
pub const PCI_DEVICE_ID_APPLE_TIGON3: u32 = 5701;
pub const PCI_VENDOR_ID_YAMAHA: u32 = 4211;
pub const PCI_DEVICE_ID_YAMAHA_724: u32 = 4;
pub const PCI_DEVICE_ID_YAMAHA_724F: u32 = 13;
pub const PCI_DEVICE_ID_YAMAHA_740: u32 = 10;
pub const PCI_DEVICE_ID_YAMAHA_740C: u32 = 12;
pub const PCI_DEVICE_ID_YAMAHA_744: u32 = 16;
pub const PCI_DEVICE_ID_YAMAHA_754: u32 = 18;
pub const PCI_VENDOR_ID_QLOGIC: u32 = 4215;
pub const PCI_DEVICE_ID_QLOGIC_ISP10160: u32 = 4118;
pub const PCI_DEVICE_ID_QLOGIC_ISP1020: u32 = 4128;
pub const PCI_DEVICE_ID_QLOGIC_ISP1080: u32 = 4224;
pub const PCI_DEVICE_ID_QLOGIC_ISP12160: u32 = 4630;
pub const PCI_DEVICE_ID_QLOGIC_ISP1240: u32 = 4672;
pub const PCI_DEVICE_ID_QLOGIC_ISP1280: u32 = 4736;
pub const PCI_DEVICE_ID_QLOGIC_ISP2100: u32 = 8448;
pub const PCI_DEVICE_ID_QLOGIC_ISP2200: u32 = 8704;
pub const PCI_DEVICE_ID_QLOGIC_ISP2300: u32 = 8960;
pub const PCI_DEVICE_ID_QLOGIC_ISP2312: u32 = 8978;
pub const PCI_DEVICE_ID_QLOGIC_ISP2322: u32 = 8994;
pub const PCI_DEVICE_ID_QLOGIC_ISP6312: u32 = 25362;
pub const PCI_DEVICE_ID_QLOGIC_ISP6322: u32 = 25378;
pub const PCI_DEVICE_ID_QLOGIC_ISP2422: u32 = 9250;
pub const PCI_DEVICE_ID_QLOGIC_ISP2432: u32 = 9266;
pub const PCI_DEVICE_ID_QLOGIC_ISP2512: u32 = 9490;
pub const PCI_DEVICE_ID_QLOGIC_ISP2522: u32 = 9506;
pub const PCI_DEVICE_ID_QLOGIC_ISP5422: u32 = 21538;
pub const PCI_DEVICE_ID_QLOGIC_ISP5432: u32 = 21554;
pub const PCI_VENDOR_ID_CYRIX: u32 = 4216;
pub const PCI_DEVICE_ID_CYRIX_5510: u32 = 0;
pub const PCI_DEVICE_ID_CYRIX_PCI_MASTER: u32 = 1;
pub const PCI_DEVICE_ID_CYRIX_5520: u32 = 2;
pub const PCI_DEVICE_ID_CYRIX_5530_LEGACY: u32 = 256;
pub const PCI_DEVICE_ID_CYRIX_5530_IDE: u32 = 258;
pub const PCI_DEVICE_ID_CYRIX_5530_AUDIO: u32 = 259;
pub const PCI_DEVICE_ID_CYRIX_5530_VIDEO: u32 = 260;
pub const PCI_VENDOR_ID_CONTAQ: u32 = 4224;
pub const PCI_DEVICE_ID_CONTAQ_82C693: u32 = 50835;
pub const PCI_VENDOR_ID_OLICOM: u32 = 4237;
pub const PCI_DEVICE_ID_OLICOM_OC2325: u32 = 18;
pub const PCI_DEVICE_ID_OLICOM_OC2183: u32 = 19;
pub const PCI_DEVICE_ID_OLICOM_OC2326: u32 = 20;
pub const PCI_VENDOR_ID_SUN: u32 = 4238;
pub const PCI_DEVICE_ID_SUN_EBUS: u32 = 4096;
pub const PCI_DEVICE_ID_SUN_HAPPYMEAL: u32 = 4097;
pub const PCI_DEVICE_ID_SUN_RIO_EBUS: u32 = 4352;
pub const PCI_DEVICE_ID_SUN_RIO_GEM: u32 = 4353;
pub const PCI_DEVICE_ID_SUN_RIO_1394: u32 = 4354;
pub const PCI_DEVICE_ID_SUN_RIO_USB: u32 = 4355;
pub const PCI_DEVICE_ID_SUN_GEM: u32 = 11181;
pub const PCI_DEVICE_ID_SUN_SIMBA: u32 = 20480;
pub const PCI_DEVICE_ID_SUN_PBM: u32 = 32768;
pub const PCI_DEVICE_ID_SUN_SCHIZO: u32 = 32769;
pub const PCI_DEVICE_ID_SUN_SABRE: u32 = 40960;
pub const PCI_DEVICE_ID_SUN_HUMMINGBIRD: u32 = 40961;
pub const PCI_DEVICE_ID_SUN_TOMATILLO: u32 = 43009;
pub const PCI_DEVICE_ID_SUN_CASSINI: u32 = 43962;
pub const PCI_VENDOR_ID_NI: u32 = 4243;
pub const PCI_DEVICE_ID_NI_PCI2322: u32 = 53552;
pub const PCI_DEVICE_ID_NI_PCI2324: u32 = 53568;
pub const PCI_DEVICE_ID_NI_PCI2328: u32 = 53584;
pub const PCI_DEVICE_ID_NI_PXI8422_2322: u32 = 53648;
pub const PCI_DEVICE_ID_NI_PXI8422_2324: u32 = 53664;
pub const PCI_DEVICE_ID_NI_PXI8420_2322: u32 = 53712;
pub const PCI_DEVICE_ID_NI_PXI8420_2324: u32 = 53728;
pub const PCI_DEVICE_ID_NI_PXI8420_2328: u32 = 53744;
pub const PCI_DEVICE_ID_NI_PXI8420_23216: u32 = 53745;
pub const PCI_DEVICE_ID_NI_PCI2322I: u32 = 53840;
pub const PCI_DEVICE_ID_NI_PCI2324I: u32 = 53872;
pub const PCI_DEVICE_ID_NI_PCI23216: u32 = 53936;
pub const PCI_DEVICE_ID_NI_PXI8430_2322: u32 = 28800;
pub const PCI_DEVICE_ID_NI_PCI8430_2322: u32 = 28891;
pub const PCI_DEVICE_ID_NI_PXI8430_2324: u32 = 28893;
pub const PCI_DEVICE_ID_NI_PCI8430_2324: u32 = 28895;
pub const PCI_DEVICE_ID_NI_PXI8430_2328: u32 = 28898;
pub const PCI_DEVICE_ID_NI_PCI8430_2328: u32 = 28900;
pub const PCI_DEVICE_ID_NI_PXI8430_23216: u32 = 28902;
pub const PCI_DEVICE_ID_NI_PCI8430_23216: u32 = 28903;
pub const PCI_DEVICE_ID_NI_PXI8432_2322: u32 = 28904;
pub const PCI_DEVICE_ID_NI_PCI8432_2322: u32 = 28906;
pub const PCI_DEVICE_ID_NI_PXI8432_2324: u32 = 28908;
pub const PCI_DEVICE_ID_NI_PCI8432_2324: u32 = 28910;
pub const PCI_VENDOR_ID_CMD: u32 = 4245;
pub const PCI_DEVICE_ID_CMD_643: u32 = 1603;
pub const PCI_DEVICE_ID_CMD_646: u32 = 1606;
pub const PCI_DEVICE_ID_CMD_648: u32 = 1608;
pub const PCI_DEVICE_ID_CMD_649: u32 = 1609;
pub const PCI_DEVICE_ID_SII_680: u32 = 1664;
pub const PCI_DEVICE_ID_SII_3112: u32 = 12562;
pub const PCI_DEVICE_ID_SII_1210SA: u32 = 576;
pub const PCI_VENDOR_ID_BROOKTREE: u32 = 4254;
pub const PCI_DEVICE_ID_BROOKTREE_878: u32 = 2168;
pub const PCI_DEVICE_ID_BROOKTREE_879: u32 = 2169;
pub const PCI_VENDOR_ID_SGI: u32 = 4265;
pub const PCI_DEVICE_ID_SGI_IOC3: u32 = 3;
pub const PCI_DEVICE_ID_SGI_LITHIUM: u32 = 4098;
pub const PCI_VENDOR_ID_WINBOND: u32 = 4269;
pub const PCI_DEVICE_ID_WINBOND_82C105: u32 = 261;
pub const PCI_DEVICE_ID_WINBOND_83C553: u32 = 1381;
pub const PCI_VENDOR_ID_PLX: u32 = 4277;
pub const PCI_DEVICE_ID_PLX_R685: u32 = 4144;
pub const PCI_DEVICE_ID_PLX_ROMULUS: u32 = 4202;
pub const PCI_DEVICE_ID_PLX_SPCOM800: u32 = 4214;
pub const PCI_DEVICE_ID_PLX_1077: u32 = 4215;
pub const PCI_DEVICE_ID_PLX_SPCOM200: u32 = 4355;
pub const PCI_DEVICE_ID_PLX_DJINN_ITOO: u32 = 4433;
pub const PCI_DEVICE_ID_PLX_R753: u32 = 4434;
pub const PCI_DEVICE_ID_PLX_OLITEC: u32 = 4487;
pub const PCI_DEVICE_ID_PLX_PCI200SYN: u32 = 12694;
pub const PCI_DEVICE_ID_PLX_9030: u32 = 36912;
pub const PCI_DEVICE_ID_PLX_9050: u32 = 36944;
pub const PCI_DEVICE_ID_PLX_9056: u32 = 36950;
pub const PCI_DEVICE_ID_PLX_9080: u32 = 36992;
pub const PCI_DEVICE_ID_PLX_GTEK_SERIAL2: u32 = 40961;
pub const PCI_VENDOR_ID_MADGE: u32 = 4278;
pub const PCI_DEVICE_ID_MADGE_MK2: u32 = 2;
pub const PCI_VENDOR_ID_3COM: u32 = 4279;
pub const PCI_DEVICE_ID_3COM_3C985: u32 = 1;
pub const PCI_DEVICE_ID_3COM_3C940: u32 = 5888;
pub const PCI_DEVICE_ID_3COM_3C339: u32 = 13200;
pub const PCI_DEVICE_ID_3COM_3C359: u32 = 13712;
pub const PCI_DEVICE_ID_3COM_3C940B: u32 = 33003;
pub const PCI_DEVICE_ID_3COM_3CR990: u32 = 39168;
pub const PCI_DEVICE_ID_3COM_3CR990_TX_95: u32 = 39170;
pub const PCI_DEVICE_ID_3COM_3CR990_TX_97: u32 = 39171;
pub const PCI_DEVICE_ID_3COM_3CR990B: u32 = 39172;
pub const PCI_DEVICE_ID_3COM_3CR990_FX: u32 = 39173;
pub const PCI_DEVICE_ID_3COM_3CR990SVR95: u32 = 39176;
pub const PCI_DEVICE_ID_3COM_3CR990SVR97: u32 = 39177;
pub const PCI_DEVICE_ID_3COM_3CR990SVR: u32 = 39178;
pub const PCI_VENDOR_ID_AL: u32 = 4281;
pub const PCI_DEVICE_ID_AL_M1489: u32 = 5257;
pub const PCI_DEVICE_ID_AL_M1533: u32 = 5427;
pub const PCI_DEVICE_ID_AL_M1535: u32 = 5429;
pub const PCI_DEVICE_ID_AL_M1541: u32 = 5441;
pub const PCI_DEVICE_ID_AL_M1563: u32 = 5475;
pub const PCI_DEVICE_ID_AL_M1621: u32 = 5665;
pub const PCI_DEVICE_ID_AL_M1631: u32 = 5681;
pub const PCI_DEVICE_ID_AL_M1632: u32 = 5682;
pub const PCI_DEVICE_ID_AL_M1641: u32 = 5697;
pub const PCI_DEVICE_ID_AL_M1644: u32 = 5700;
pub const PCI_DEVICE_ID_AL_M1647: u32 = 5703;
pub const PCI_DEVICE_ID_AL_M1651: u32 = 5713;
pub const PCI_DEVICE_ID_AL_M1671: u32 = 5745;
pub const PCI_DEVICE_ID_AL_M1681: u32 = 5761;
pub const PCI_DEVICE_ID_AL_M1683: u32 = 5763;
pub const PCI_DEVICE_ID_AL_M1689: u32 = 5769;
pub const PCI_DEVICE_ID_AL_M5219: u32 = 21017;
pub const PCI_DEVICE_ID_AL_M5228: u32 = 21032;
pub const PCI_DEVICE_ID_AL_M5229: u32 = 21033;
pub const PCI_DEVICE_ID_AL_M5451: u32 = 21585;
pub const PCI_DEVICE_ID_AL_M7101: u32 = 28929;
pub const PCI_VENDOR_ID_NEOMAGIC: u32 = 4296;
pub const PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO: u32 = 32773;
pub const PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO: u32 = 32774;
pub const PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO: u32 = 32790;
pub const PCI_VENDOR_ID_TCONRAD: u32 = 4314;
pub const PCI_DEVICE_ID_TCONRAD_TOKENRING: u32 = 1288;
pub const PCI_VENDOR_ID_ROHM: u32 = 4315;
pub const PCI_VENDOR_ID_NVIDIA: u32 = 4318;
pub const PCI_DEVICE_ID_NVIDIA_TNT: u32 = 32;
pub const PCI_DEVICE_ID_NVIDIA_TNT2: u32 = 40;
pub const PCI_DEVICE_ID_NVIDIA_UTNT2: u32 = 41;
pub const PCI_DEVICE_ID_NVIDIA_TNT_UNKNOWN: u32 = 42;
pub const PCI_DEVICE_ID_NVIDIA_VTNT2: u32 = 44;
pub const PCI_DEVICE_ID_NVIDIA_UVTNT2: u32 = 45;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SMBUS: u32 = 52;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_IDE: u32 = 53;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SATA: u32 = 54;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SATA2: u32 = 62;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800_ULTRA: u32 = 64;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800: u32 = 65;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800_LE: u32 = 66;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800_GT: u32 = 69;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_4000: u32 = 78;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE4_SMBUS: u32 = 82;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_IDE: u32 = 83;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_SATA: u32 = 84;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_SATA2: u32 = 85;
pub const PCI_DEVICE_ID_NVIDIA_CK804_AUDIO: u32 = 89;
pub const PCI_DEVICE_ID_NVIDIA_CK804_PCIE: u32 = 93;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2_SMBUS: u32 = 100;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE: u32 = 101;
pub const PCI_DEVICE_ID_NVIDIA_MCP2_MODEM: u32 = 105;
pub const PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO: u32 = 106;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2S_SMBUS: u32 = 132;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE: u32 = 133;
pub const PCI_DEVICE_ID_NVIDIA_MCP2S_MODEM: u32 = 137;
pub const PCI_DEVICE_ID_NVIDIA_CK8_AUDIO: u32 = 138;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA: u32 = 142;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_7800_GT: u32 = 144;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_7800_GTX: u32 = 145;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_7800: u32 = 152;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_7800_GTX: u32 = 153;
pub const PCI_DEVICE_ID_NVIDIA_ITNT2: u32 = 160;
pub const PCI_DEVICE_ID_GEFORCE_6800A: u32 = 193;
pub const PCI_DEVICE_ID_GEFORCE_6800A_LE: u32 = 194;
pub const PCI_DEVICE_ID_GEFORCE_GO_6800: u32 = 200;
pub const PCI_DEVICE_ID_GEFORCE_GO_6800_ULTRA: u32 = 201;
pub const PCI_DEVICE_ID_QUADRO_FX_GO1400: u32 = 204;
pub const PCI_DEVICE_ID_QUADRO_FX_1400: u32 = 206;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3: u32 = 209;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3_SMBUS: u32 = 212;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE: u32 = 213;
pub const PCI_DEVICE_ID_NVIDIA_MCP3_MODEM: u32 = 217;
pub const PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO: u32 = 218;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3S: u32 = 225;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA: u32 = 227;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3S_SMBUS: u32 = 228;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE: u32 = 229;
pub const PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO: u32 = 234;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2: u32 = 238;
pub const PCIE_DEVICE_ID_NVIDIA_GEFORCE_6800_ALT1: u32 = 240;
pub const PCIE_DEVICE_ID_NVIDIA_GEFORCE_6600_ALT1: u32 = 241;
pub const PCIE_DEVICE_ID_NVIDIA_GEFORCE_6600_ALT2: u32 = 242;
pub const PCIE_DEVICE_ID_NVIDIA_GEFORCE_6200_ALT1: u32 = 243;
pub const PCIE_DEVICE_ID_NVIDIA_GEFORCE_6800_GT: u32 = 249;
pub const PCIE_DEVICE_ID_NVIDIA_QUADRO_NVS280: u32 = 253;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR: u32 = 256;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR: u32 = 257;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO: u32 = 259;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX: u32 = 272;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2: u32 = 273;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO: u32 = 274;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR: u32 = 275;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6600_GT: u32 = 320;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6600: u32 = 321;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6610_XL: u32 = 325;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_540: u32 = 334;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6200: u32 = 335;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS: u32 = 336;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2: u32 = 337;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA: u32 = 338;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO: u32 = 339;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6200_TURBOCACHE: u32 = 353;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_6200: u32 = 356;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_6250: u32 = 358;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_6200_1: u32 = 359;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_GO_6250_1: u32 = 360;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460: u32 = 368;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440: u32 = 369;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420: u32 = 370;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440_SE: u32 = 371;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO: u32 = 372;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO: u32 = 373;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32: u32 = 374;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_460_GO: u32 = 375;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL: u32 = 376;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64: u32 = 377;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_200: u32 = 378;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL: u32 = 379;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL: u32 = 380;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_410_GO_M16: u32 = 381;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440_8X: u32 = 385;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440SE_8X: u32 = 386;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420_8X: u32 = 387;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_4000: u32 = 389;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_448_GO: u32 = 390;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_488_GO: u32 = 391;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_580_XGL: u32 = 392;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_MAC: u32 = 393;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_280_NVS: u32 = 394;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_380_XGL: u32 = 395;
pub const PCI_DEVICE_ID_NVIDIA_IGEFORCE2: u32 = 416;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE: u32 = 420;
pub const PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO: u32 = 433;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_SMBUS: u32 = 436;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_IDE: u32 = 444;
pub const PCI_DEVICE_ID_NVIDIA_MCP1_MODEM: u32 = 449;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE2: u32 = 480;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE3: u32 = 512;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE3_1: u32 = 513;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE3_2: u32 = 514;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_DDC: u32 = 515;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800B: u32 = 529;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800B_LE: u32 = 530;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_6800B_GT: u32 = 533;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600: u32 = 592;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400: u32 = 593;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200: u32 = 595;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL: u32 = 600;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL: u32 = 601;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL: u32 = 603;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SMBUS: u32 = 612;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_IDE: u32 = 613;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA: u32 = 614;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA2: u32 = 615;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SMBUS: u32 = 872;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_IDE: u32 = 878;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA: u32 = 894;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA2: u32 = 895;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4800: u32 = 640;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4800_8X: u32 = 641;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4800SE: u32 = 642;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE4_4200_GO: u32 = 646;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_980_XGL: u32 = 648;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_780_XGL: u32 = 649;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO4_700_GOGL: u32 = 652;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5800_ULTRA: u32 = 769;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5800: u32 = 770;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_2000: u32 = 776;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_1000: u32 = 777;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5600_ULTRA: u32 = 785;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5600: u32 = 786;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5600SE: u32 = 788;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5600: u32 = 794;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5650: u32 = 795;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_GO700: u32 = 796;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5200: u32 = 800;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5200_ULTRA: u32 = 801;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5200_1: u32 = 802;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5200SE: u32 = 803;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5200: u32 = 804;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5250: u32 = 805;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5500: u32 = 806;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5100: u32 = 807;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5250_32: u32 = 808;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO_5200: u32 = 809;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_NVS_280_PCI: u32 = 810;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_500: u32 = 811;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5300: u32 = 812;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5100: u32 = 813;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5900_ULTRA: u32 = 816;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5900: u32 = 817;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5900XT: u32 = 818;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5950_ULTRA: u32 = 819;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5900ZT: u32 = 820;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_3000: u32 = 824;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_700: u32 = 831;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5700_ULTRA: u32 = 833;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5700: u32 = 834;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5700LE: u32 = 835;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_5700VE: u32 = 836;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5700_1: u32 = 839;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO5700_2: u32 = 840;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_GO1000: u32 = 844;
pub const PCI_DEVICE_ID_NVIDIA_QUADRO_FX_1100: u32 = 846;
pub const PCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V0: u32 = 864;
pub const PCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V4: u32 = 868;
pub const PCI_DEVICE_ID_NVIDIA_NVENET_15: u32 = 883;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_SATA: u32 = 999;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_SMBUS: u32 = 1003;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_IDE: u32 = 1004;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_SATA2: u32 = 1014;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_SATA3: u32 = 1015;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_SMBUS: u32 = 1094;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_IDE: u32 = 1096;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_SMBUS: u32 = 1346;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_IDE: u32 = 1376;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE: u32 = 1388;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP78S_SMBUS: u32 = 1874;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE: u32 = 1881;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_SMBUS: u32 = 2008;
pub const PCI_DEVICE_ID_NVIDIA_GEFORCE_320M: u32 = 2208;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP79_SMBUS: u32 = 2722;
pub const PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA: u32 = 3461;
pub const PCI_VENDOR_ID_IMS: u32 = 4320;
pub const PCI_DEVICE_ID_IMS_TT128: u32 = 37160;
pub const PCI_DEVICE_ID_IMS_TT3D: u32 = 37173;
pub const PCI_VENDOR_ID_AMCC: u32 = 4328;
pub const PCI_VENDOR_ID_AMPERE: u32 = 7663;
pub const PCI_VENDOR_ID_INTERG: u32 = 4330;
pub const PCI_DEVICE_ID_INTERG_1682: u32 = 5762;
pub const PCI_DEVICE_ID_INTERG_2000: u32 = 8192;
pub const PCI_DEVICE_ID_INTERG_2010: u32 = 8208;
pub const PCI_DEVICE_ID_INTERG_5000: u32 = 20480;
pub const PCI_DEVICE_ID_INTERG_5050: u32 = 20560;
pub const PCI_VENDOR_ID_REALTEK: u32 = 4332;
pub const PCI_DEVICE_ID_REALTEK_8139: u32 = 33081;
pub const PCI_VENDOR_ID_XILINX: u32 = 4334;
pub const PCI_DEVICE_ID_RME_DIGI96: u32 = 16320;
pub const PCI_DEVICE_ID_RME_DIGI96_8: u32 = 16321;
pub const PCI_DEVICE_ID_RME_DIGI96_8_PRO: u32 = 16322;
pub const PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST: u32 = 16323;
pub const PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP: u32 = 16325;
pub const PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI: u32 = 16326;
pub const PCI_VENDOR_ID_INIT: u32 = 4353;
pub const PCI_VENDOR_ID_CREATIVE: u32 = 4354;
pub const PCI_DEVICE_ID_CREATIVE_EMU10K1: u32 = 2;
pub const PCI_DEVICE_ID_CREATIVE_20K1: u32 = 5;
pub const PCI_DEVICE_ID_CREATIVE_20K2: u32 = 11;
pub const PCI_SUBDEVICE_ID_CREATIVE_SB0760: u32 = 36;
pub const PCI_SUBDEVICE_ID_CREATIVE_SB08801: u32 = 65;
pub const PCI_SUBDEVICE_ID_CREATIVE_SB08802: u32 = 66;
pub const PCI_SUBDEVICE_ID_CREATIVE_SB08803: u32 = 67;
pub const PCI_SUBDEVICE_ID_CREATIVE_SB1270: u32 = 98;
pub const PCI_SUBDEVICE_ID_CREATIVE_HENDRIX: u32 = 24576;
pub const PCI_VENDOR_ID_ECTIVA: u32 = 4354;
pub const PCI_DEVICE_ID_ECTIVA_EV1938: u32 = 35128;
pub const PCI_VENDOR_ID_TTI: u32 = 4355;
pub const PCI_DEVICE_ID_TTI_HPT343: u32 = 3;
pub const PCI_DEVICE_ID_TTI_HPT366: u32 = 4;
pub const PCI_DEVICE_ID_TTI_HPT372: u32 = 5;
pub const PCI_DEVICE_ID_TTI_HPT302: u32 = 6;
pub const PCI_DEVICE_ID_TTI_HPT371: u32 = 7;
pub const PCI_DEVICE_ID_TTI_HPT374: u32 = 8;
pub const PCI_DEVICE_ID_TTI_HPT372N: u32 = 9;
pub const PCI_VENDOR_ID_SIGMA: u32 = 4357;
pub const PCI_VENDOR_ID_VIA: u32 = 4358;
pub const PCI_DEVICE_ID_VIA_8763_0: u32 = 408;
pub const PCI_DEVICE_ID_VIA_8380_0: u32 = 516;
pub const PCI_DEVICE_ID_VIA_3238_0: u32 = 568;
pub const PCI_DEVICE_ID_VIA_PT880: u32 = 600;
pub const PCI_DEVICE_ID_VIA_PT880ULTRA: u32 = 776;
pub const PCI_DEVICE_ID_VIA_PX8X0_0: u32 = 601;
pub const PCI_DEVICE_ID_VIA_3269_0: u32 = 617;
pub const PCI_DEVICE_ID_VIA_K8T800PRO_0: u32 = 642;
pub const PCI_DEVICE_ID_VIA_3296_0: u32 = 662;
pub const PCI_DEVICE_ID_VIA_8363_0: u32 = 773;
pub const PCI_DEVICE_ID_VIA_P4M800CE: u32 = 788;
pub const PCI_DEVICE_ID_VIA_P4M890: u32 = 807;
pub const PCI_DEVICE_ID_VIA_VT3324: u32 = 804;
pub const PCI_DEVICE_ID_VIA_VT3336: u32 = 822;
pub const PCI_DEVICE_ID_VIA_VT3351: u32 = 849;
pub const PCI_DEVICE_ID_VIA_VT3364: u32 = 868;
pub const PCI_DEVICE_ID_VIA_8371_0: u32 = 913;
pub const PCI_DEVICE_ID_VIA_6415: u32 = 1045;
pub const PCI_DEVICE_ID_VIA_8501_0: u32 = 1281;
pub const PCI_DEVICE_ID_VIA_82C561: u32 = 1377;
pub const PCI_DEVICE_ID_VIA_82C586_1: u32 = 1393;
pub const PCI_DEVICE_ID_VIA_82C576: u32 = 1398;
pub const PCI_DEVICE_ID_VIA_82C586_0: u32 = 1414;
pub const PCI_DEVICE_ID_VIA_82C596: u32 = 1430;
pub const PCI_DEVICE_ID_VIA_82C597_0: u32 = 1431;
pub const PCI_DEVICE_ID_VIA_82C598_0: u32 = 1432;
pub const PCI_DEVICE_ID_VIA_8601_0: u32 = 1537;
pub const PCI_DEVICE_ID_VIA_8605_0: u32 = 1541;
pub const PCI_DEVICE_ID_VIA_82C686: u32 = 1670;
pub const PCI_DEVICE_ID_VIA_82C691_0: u32 = 1681;
pub const PCI_DEVICE_ID_VIA_82C576_1: u32 = 5489;
pub const PCI_DEVICE_ID_VIA_82C586_2: u32 = 12344;
pub const PCI_DEVICE_ID_VIA_82C586_3: u32 = 12352;
pub const PCI_DEVICE_ID_VIA_82C596_3: u32 = 12368;
pub const PCI_DEVICE_ID_VIA_82C596B_3: u32 = 12369;
pub const PCI_DEVICE_ID_VIA_82C686_4: u32 = 12375;
pub const PCI_DEVICE_ID_VIA_82C686_5: u32 = 12376;
pub const PCI_DEVICE_ID_VIA_8233_5: u32 = 12377;
pub const PCI_DEVICE_ID_VIA_8233_0: u32 = 12404;
pub const PCI_DEVICE_ID_VIA_8633_0: u32 = 12433;
pub const PCI_DEVICE_ID_VIA_8367_0: u32 = 12441;
pub const PCI_DEVICE_ID_VIA_8653_0: u32 = 12545;
pub const PCI_DEVICE_ID_VIA_8622: u32 = 12546;
pub const PCI_DEVICE_ID_VIA_8235_USB_2: u32 = 12548;
pub const PCI_DEVICE_ID_VIA_8233C_0: u32 = 12553;
pub const PCI_DEVICE_ID_VIA_8361: u32 = 12562;
pub const PCI_DEVICE_ID_VIA_XM266: u32 = 12566;
pub const PCI_DEVICE_ID_VIA_612X: u32 = 12569;
pub const PCI_DEVICE_ID_VIA_862X_0: u32 = 12579;
pub const PCI_DEVICE_ID_VIA_8753_0: u32 = 12584;
pub const PCI_DEVICE_ID_VIA_8233A: u32 = 12615;
pub const PCI_DEVICE_ID_VIA_8703_51_0: u32 = 12616;
pub const PCI_DEVICE_ID_VIA_8237_SATA: u32 = 12617;
pub const PCI_DEVICE_ID_VIA_XN266: u32 = 12630;
pub const PCI_DEVICE_ID_VIA_6410: u32 = 12644;
pub const PCI_DEVICE_ID_VIA_8754C_0: u32 = 12648;
pub const PCI_DEVICE_ID_VIA_8235: u32 = 12663;
pub const PCI_DEVICE_ID_VIA_8385_0: u32 = 12680;
pub const PCI_DEVICE_ID_VIA_8377_0: u32 = 12681;
pub const PCI_DEVICE_ID_VIA_8378_0: u32 = 12805;
pub const PCI_DEVICE_ID_VIA_8783_0: u32 = 12808;
pub const PCI_DEVICE_ID_VIA_8237: u32 = 12839;
pub const PCI_DEVICE_ID_VIA_8251: u32 = 12935;
pub const PCI_DEVICE_ID_VIA_8261: u32 = 13314;
pub const PCI_DEVICE_ID_VIA_8237A: u32 = 13111;
pub const PCI_DEVICE_ID_VIA_8237S: u32 = 13170;
pub const PCI_DEVICE_ID_VIA_SATA_EIDE: u32 = 21284;
pub const PCI_DEVICE_ID_VIA_8231: u32 = 33329;
pub const PCI_DEVICE_ID_VIA_8231_4: u32 = 33333;
pub const PCI_DEVICE_ID_VIA_8365_1: u32 = 33541;
pub const PCI_DEVICE_ID_VIA_CX700: u32 = 33572;
pub const PCI_DEVICE_ID_VIA_CX700_IDE: u32 = 1409;
pub const PCI_DEVICE_ID_VIA_VX800: u32 = 33619;
pub const PCI_DEVICE_ID_VIA_VX855: u32 = 33801;
pub const PCI_DEVICE_ID_VIA_VX900: u32 = 33808;
pub const PCI_DEVICE_ID_VIA_8371_1: u32 = 33681;
pub const PCI_DEVICE_ID_VIA_82C598_1: u32 = 34200;
pub const PCI_DEVICE_ID_VIA_838X_1: u32 = 45448;
pub const PCI_DEVICE_ID_VIA_83_87XX_1: u32 = 45464;
pub const PCI_DEVICE_ID_VIA_VX855_IDE: u32 = 50185;
pub const PCI_DEVICE_ID_VIA_ANON: u32 = 65535;
pub const PCI_VENDOR_ID_SIEMENS: u32 = 4362;
pub const PCI_DEVICE_ID_SIEMENS_DSCC4: u32 = 8450;
pub const PCI_VENDOR_ID_VORTEX: u32 = 4377;
pub const PCI_DEVICE_ID_VORTEX_GDT60x0: u32 = 0;
pub const PCI_DEVICE_ID_VORTEX_GDT6000B: u32 = 1;
pub const PCI_DEVICE_ID_VORTEX_GDT6x10: u32 = 2;
pub const PCI_DEVICE_ID_VORTEX_GDT6x20: u32 = 3;
pub const PCI_DEVICE_ID_VORTEX_GDT6530: u32 = 4;
pub const PCI_DEVICE_ID_VORTEX_GDT6550: u32 = 5;
pub const PCI_DEVICE_ID_VORTEX_GDT6x17: u32 = 6;
pub const PCI_DEVICE_ID_VORTEX_GDT6x27: u32 = 7;
pub const PCI_DEVICE_ID_VORTEX_GDT6537: u32 = 8;
pub const PCI_DEVICE_ID_VORTEX_GDT6557: u32 = 9;
pub const PCI_DEVICE_ID_VORTEX_GDT6x15: u32 = 10;
pub const PCI_DEVICE_ID_VORTEX_GDT6x25: u32 = 11;
pub const PCI_DEVICE_ID_VORTEX_GDT6535: u32 = 12;
pub const PCI_DEVICE_ID_VORTEX_GDT6555: u32 = 13;
pub const PCI_DEVICE_ID_VORTEX_GDT6x17RP: u32 = 256;
pub const PCI_DEVICE_ID_VORTEX_GDT6x27RP: u32 = 257;
pub const PCI_DEVICE_ID_VORTEX_GDT6537RP: u32 = 258;
pub const PCI_DEVICE_ID_VORTEX_GDT6557RP: u32 = 259;
pub const PCI_DEVICE_ID_VORTEX_GDT6x11RP: u32 = 260;
pub const PCI_DEVICE_ID_VORTEX_GDT6x21RP: u32 = 261;
pub const PCI_VENDOR_ID_EF: u32 = 4378;
pub const PCI_DEVICE_ID_EF_ATM_FPGA: u32 = 0;
pub const PCI_DEVICE_ID_EF_ATM_ASIC: u32 = 2;
pub const PCI_DEVICE_ID_EF_ATM_LANAI2: u32 = 3;
pub const PCI_DEVICE_ID_EF_ATM_LANAIHB: u32 = 5;
pub const PCI_VENDOR_ID_IDT: u32 = 4381;
pub const PCI_DEVICE_ID_IDT_IDT77201: u32 = 1;
pub const PCI_VENDOR_ID_FORE: u32 = 4391;
pub const PCI_DEVICE_ID_FORE_PCA200E: u32 = 768;
pub const PCI_VENDOR_ID_PHILIPS: u32 = 4401;
pub const PCI_DEVICE_ID_PHILIPS_SAA7146: u32 = 28998;
pub const PCI_DEVICE_ID_PHILIPS_SAA9730: u32 = 38704;
pub const PCI_VENDOR_ID_EICON: u32 = 4403;
pub const PCI_DEVICE_ID_EICON_DIVA20: u32 = 57346;
pub const PCI_DEVICE_ID_EICON_DIVA20_U: u32 = 57348;
pub const PCI_DEVICE_ID_EICON_DIVA201: u32 = 57349;
pub const PCI_DEVICE_ID_EICON_DIVA202: u32 = 57355;
pub const PCI_DEVICE_ID_EICON_MAESTRA: u32 = 57360;
pub const PCI_DEVICE_ID_EICON_MAESTRAQ: u32 = 57362;
pub const PCI_DEVICE_ID_EICON_MAESTRAQ_U: u32 = 57363;
pub const PCI_DEVICE_ID_EICON_MAESTRAP: u32 = 57364;
pub const PCI_VENDOR_ID_CISCO: u32 = 4407;
pub const PCI_VENDOR_ID_ZIATECH: u32 = 4408;
pub const PCI_DEVICE_ID_ZIATECH_5550_HC: u32 = 21840;
pub const PCI_VENDOR_ID_SYSKONNECT: u32 = 4424;
pub const PCI_DEVICE_ID_SYSKONNECT_TR: u32 = 16896;
pub const PCI_DEVICE_ID_SYSKONNECT_GE: u32 = 17152;
pub const PCI_DEVICE_ID_SYSKONNECT_YU: u32 = 17184;
pub const PCI_DEVICE_ID_SYSKONNECT_9DXX: u32 = 17408;
pub const PCI_DEVICE_ID_SYSKONNECT_9MXX: u32 = 17664;
pub const PCI_VENDOR_ID_DIGI: u32 = 4431;
pub const PCI_DEVICE_ID_DIGI_DF_M_IOM2_E: u32 = 112;
pub const PCI_DEVICE_ID_DIGI_DF_M_E: u32 = 113;
pub const PCI_DEVICE_ID_DIGI_DF_M_IOM2_A: u32 = 114;
pub const PCI_DEVICE_ID_DIGI_DF_M_A: u32 = 115;
pub const PCI_DEVICE_ID_DIGI_NEO_8: u32 = 177;
pub const PCI_DEVICE_ID_NEO_2DB9: u32 = 200;
pub const PCI_DEVICE_ID_NEO_2DB9PRI: u32 = 201;
pub const PCI_DEVICE_ID_NEO_2RJ45: u32 = 202;
pub const PCI_DEVICE_ID_NEO_2RJ45PRI: u32 = 203;
pub const PCIE_DEVICE_ID_NEO_4_IBM: u32 = 244;
pub const PCI_VENDOR_ID_XIRCOM: u32 = 4445;
pub const PCI_DEVICE_ID_XIRCOM_RBM56G: u32 = 257;
pub const PCI_DEVICE_ID_XIRCOM_X3201_MDM: u32 = 259;
pub const PCI_VENDOR_ID_SERVERWORKS: u32 = 4454;
pub const PCI_DEVICE_ID_SERVERWORKS_HE: u32 = 8;
pub const PCI_DEVICE_ID_SERVERWORKS_LE: u32 = 9;
pub const PCI_DEVICE_ID_SERVERWORKS_GCNB_LE: u32 = 23;
pub const PCI_DEVICE_ID_SERVERWORKS_HT1000_PXB: u32 = 54;
pub const PCI_DEVICE_ID_SERVERWORKS_EPB: u32 = 259;
pub const PCI_DEVICE_ID_SERVERWORKS_HT2000_PCIE: u32 = 306;
pub const PCI_DEVICE_ID_SERVERWORKS_OSB4: u32 = 512;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB5: u32 = 513;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB6: u32 = 515;
pub const PCI_DEVICE_ID_SERVERWORKS_HT1000SB: u32 = 517;
pub const PCI_DEVICE_ID_SERVERWORKS_OSB4IDE: u32 = 529;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB5IDE: u32 = 530;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB6IDE: u32 = 531;
pub const PCI_DEVICE_ID_SERVERWORKS_HT1000IDE: u32 = 532;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2: u32 = 535;
pub const PCI_DEVICE_ID_SERVERWORKS_CSB6LPC: u32 = 551;
pub const PCI_DEVICE_ID_SERVERWORKS_HT1100LD: u32 = 1032;
pub const PCI_VENDOR_ID_ALTERA: u32 = 4466;
pub const PCI_VENDOR_ID_SBE: u32 = 4470;
pub const PCI_DEVICE_ID_SBE_WANXL100: u32 = 769;
pub const PCI_DEVICE_ID_SBE_WANXL200: u32 = 770;
pub const PCI_DEVICE_ID_SBE_WANXL400: u32 = 260;
pub const PCI_SUBDEVICE_ID_SBE_T3E3: u32 = 9;
pub const PCI_SUBDEVICE_ID_SBE_2T3E3_P0: u32 = 2305;
pub const PCI_SUBDEVICE_ID_SBE_2T3E3_P1: u32 = 2306;
pub const PCI_VENDOR_ID_TOSHIBA: u32 = 4473;
pub const PCI_DEVICE_ID_TOSHIBA_PICCOLO_1: u32 = 257;
pub const PCI_DEVICE_ID_TOSHIBA_PICCOLO_2: u32 = 258;
pub const PCI_DEVICE_ID_TOSHIBA_PICCOLO_3: u32 = 259;
pub const PCI_DEVICE_ID_TOSHIBA_PICCOLO_5: u32 = 261;
pub const PCI_DEVICE_ID_TOSHIBA_TOPIC95: u32 = 1546;
pub const PCI_DEVICE_ID_TOSHIBA_TOPIC97: u32 = 1551;
pub const PCI_DEVICE_ID_TOSHIBA_TOPIC100: u32 = 1559;
pub const PCI_VENDOR_ID_TOSHIBA_2: u32 = 4143;
pub const PCI_DEVICE_ID_TOSHIBA_TC35815CF: u32 = 48;
pub const PCI_DEVICE_ID_TOSHIBA_TC35815_NWU: u32 = 49;
pub const PCI_DEVICE_ID_TOSHIBA_TC35815_TX4939: u32 = 50;
pub const PCI_DEVICE_ID_TOSHIBA_TC86C001_IDE: u32 = 261;
pub const PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC: u32 = 264;
pub const PCI_DEVICE_ID_TOSHIBA_SPIDER_NET: u32 = 435;
pub const PCI_VENDOR_ID_ATTO: u32 = 4476;
pub const PCI_VENDOR_ID_RICOH: u32 = 4480;
pub const PCI_DEVICE_ID_RICOH_RL5C465: u32 = 1125;
pub const PCI_DEVICE_ID_RICOH_RL5C466: u32 = 1126;
pub const PCI_DEVICE_ID_RICOH_RL5C475: u32 = 1141;
pub const PCI_DEVICE_ID_RICOH_RL5C476: u32 = 1142;
pub const PCI_DEVICE_ID_RICOH_RL5C478: u32 = 1144;
pub const PCI_DEVICE_ID_RICOH_R5C822: u32 = 2082;
pub const PCI_DEVICE_ID_RICOH_R5CE822: u32 = 59426;
pub const PCI_DEVICE_ID_RICOH_R5CE823: u32 = 59427;
pub const PCI_DEVICE_ID_RICOH_R5C832: u32 = 2098;
pub const PCI_DEVICE_ID_RICOH_R5C843: u32 = 2115;
pub const PCI_VENDOR_ID_DLINK: u32 = 4486;
pub const PCI_DEVICE_ID_DLINK_DGE510T: u32 = 19456;
pub const PCI_VENDOR_ID_ARTOP: u32 = 4497;
pub const PCI_DEVICE_ID_ARTOP_ATP850UF: u32 = 5;
pub const PCI_DEVICE_ID_ARTOP_ATP860: u32 = 6;
pub const PCI_DEVICE_ID_ARTOP_ATP860R: u32 = 7;
pub const PCI_DEVICE_ID_ARTOP_ATP865: u32 = 8;
pub const PCI_DEVICE_ID_ARTOP_ATP865R: u32 = 9;
pub const PCI_DEVICE_ID_ARTOP_ATP867A: u32 = 10;
pub const PCI_DEVICE_ID_ARTOP_ATP867B: u32 = 11;
pub const PCI_DEVICE_ID_ARTOP_AEC7610: u32 = 32770;
pub const PCI_DEVICE_ID_ARTOP_AEC7612UW: u32 = 32784;
pub const PCI_DEVICE_ID_ARTOP_AEC7612U: u32 = 32800;
pub const PCI_DEVICE_ID_ARTOP_AEC7612S: u32 = 32816;
pub const PCI_DEVICE_ID_ARTOP_AEC7612D: u32 = 32832;
pub const PCI_DEVICE_ID_ARTOP_AEC7612SUW: u32 = 32848;
pub const PCI_DEVICE_ID_ARTOP_8060: u32 = 32864;
pub const PCI_VENDOR_ID_ZEITNET: u32 = 4499;
pub const PCI_DEVICE_ID_ZEITNET_1221: u32 = 1;
pub const PCI_DEVICE_ID_ZEITNET_1225: u32 = 2;
pub const PCI_VENDOR_ID_FUJITSU_ME: u32 = 4510;
pub const PCI_DEVICE_ID_FUJITSU_FS155: u32 = 1;
pub const PCI_DEVICE_ID_FUJITSU_FS50: u32 = 3;
pub const PCI_SUBVENDOR_ID_KEYSPAN: u32 = 4521;
pub const PCI_SUBDEVICE_ID_KEYSPAN_SX2: u32 = 21300;
pub const PCI_VENDOR_ID_MARVELL: u32 = 4523;
pub const PCI_VENDOR_ID_MARVELL_EXT: u32 = 6987;
pub const PCI_DEVICE_ID_MARVELL_GT64111: u32 = 16710;
pub const PCI_DEVICE_ID_MARVELL_GT64260: u32 = 25648;
pub const PCI_DEVICE_ID_MARVELL_MV64360: u32 = 25696;
pub const PCI_DEVICE_ID_MARVELL_MV64460: u32 = 25728;
pub const PCI_DEVICE_ID_MARVELL_88ALP01_NAND: u32 = 16640;
pub const PCI_DEVICE_ID_MARVELL_88ALP01_SD: u32 = 16641;
pub const PCI_DEVICE_ID_MARVELL_88ALP01_CCIC: u32 = 16642;
pub const PCI_VENDOR_ID_V3: u32 = 4528;
pub const PCI_DEVICE_ID_V3_V960: u32 = 1;
pub const PCI_DEVICE_ID_V3_V351: u32 = 2;
pub const PCI_VENDOR_ID_ATT: u32 = 4545;
pub const PCI_DEVICE_ID_ATT_VENUS_MODEM: u32 = 1152;
pub const PCI_VENDOR_ID_SPECIALIX: u32 = 4555;
pub const PCI_SUBDEVICE_ID_SPECIALIX_SPEED4: u32 = 40964;
pub const PCI_VENDOR_ID_ANALOG_DEVICES: u32 = 4564;
pub const PCI_DEVICE_ID_AD1889JS: u32 = 6281;
pub const PCI_DEVICE_ID_SEGA_BBA: u32 = 4660;
pub const PCI_VENDOR_ID_ZORAN: u32 = 4574;
pub const PCI_DEVICE_ID_ZORAN_36057: u32 = 24663;
pub const PCI_DEVICE_ID_ZORAN_36120: u32 = 24864;
pub const PCI_VENDOR_ID_COMPEX: u32 = 4598;
pub const PCI_DEVICE_ID_COMPEX_ENET100VG4: u32 = 274;
pub const PCI_VENDOR_ID_PMC_Sierra: u32 = 4600;
pub const PCI_VENDOR_ID_MICROSEMI: u32 = 4600;
pub const PCI_VENDOR_ID_RP: u32 = 4606;
pub const PCI_VENDOR_ID_CYCLADES: u32 = 4622;
pub const PCI_DEVICE_ID_PC300_RX_2: u32 = 768;
pub const PCI_DEVICE_ID_PC300_RX_1: u32 = 769;
pub const PCI_DEVICE_ID_PC300_TE_2: u32 = 784;
pub const PCI_DEVICE_ID_PC300_TE_1: u32 = 785;
pub const PCI_DEVICE_ID_PC300_TE_M_2: u32 = 800;
pub const PCI_DEVICE_ID_PC300_TE_M_1: u32 = 801;
pub const PCI_VENDOR_ID_ESSENTIAL: u32 = 4623;
pub const PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER: u32 = 1;
pub const PCI_VENDOR_ID_O2: u32 = 4631;
pub const PCI_DEVICE_ID_O2_6729: u32 = 26409;
pub const PCI_DEVICE_ID_O2_6730: u32 = 26426;
pub const PCI_DEVICE_ID_O2_6832: u32 = 26674;
pub const PCI_DEVICE_ID_O2_6836: u32 = 26678;
pub const PCI_DEVICE_ID_O2_6812: u32 = 26738;
pub const PCI_DEVICE_ID_O2_6933: u32 = 26931;
pub const PCI_DEVICE_ID_O2_8120: u32 = 33056;
pub const PCI_DEVICE_ID_O2_8220: u32 = 33312;
pub const PCI_DEVICE_ID_O2_8221: u32 = 33313;
pub const PCI_DEVICE_ID_O2_8320: u32 = 33568;
pub const PCI_DEVICE_ID_O2_8321: u32 = 33569;
pub const PCI_VENDOR_ID_3DFX: u32 = 4634;
pub const PCI_DEVICE_ID_3DFX_VOODOO: u32 = 1;
pub const PCI_DEVICE_ID_3DFX_VOODOO2: u32 = 2;
pub const PCI_DEVICE_ID_3DFX_BANSHEE: u32 = 3;
pub const PCI_DEVICE_ID_3DFX_VOODOO3: u32 = 5;
pub const PCI_DEVICE_ID_3DFX_VOODOO5: u32 = 9;
pub const PCI_VENDOR_ID_AVM: u32 = 4676;
pub const PCI_DEVICE_ID_AVM_B1: u32 = 1792;
pub const PCI_DEVICE_ID_AVM_C4: u32 = 2048;
pub const PCI_DEVICE_ID_AVM_A1: u32 = 2560;
pub const PCI_DEVICE_ID_AVM_A1_V2: u32 = 3584;
pub const PCI_DEVICE_ID_AVM_C2: u32 = 4352;
pub const PCI_DEVICE_ID_AVM_T1: u32 = 4608;
pub const PCI_VENDOR_ID_STALLION: u32 = 4685;
pub const PCI_VENDOR_ID_AT: u32 = 4697;
pub const PCI_SUBDEVICE_ID_AT_2700FX: u32 = 9985;
pub const PCI_SUBDEVICE_ID_AT_2701FX: u32 = 9987;
pub const PCI_VENDOR_ID_ASIX: u32 = 4699;
pub const PCI_DEVICE_ID_ASIX_AX99100: u32 = 37120;
pub const PCI_DEVICE_ID_ASIX_AX99100_LB: u32 = 37136;
pub const PCI_VENDOR_ID_ESS: u32 = 4701;
pub const PCI_DEVICE_ID_ESS_ESS1968: u32 = 6504;
pub const PCI_DEVICE_ID_ESS_ESS1978: u32 = 6520;
pub const PCI_DEVICE_ID_ESS_ALLEGRO_1: u32 = 6536;
pub const PCI_DEVICE_ID_ESS_ALLEGRO: u32 = 6537;
pub const PCI_DEVICE_ID_ESS_CANYON3D_2LE: u32 = 6544;
pub const PCI_DEVICE_ID_ESS_CANYON3D_2: u32 = 6546;
pub const PCI_DEVICE_ID_ESS_MAESTRO3: u32 = 6552;
pub const PCI_DEVICE_ID_ESS_MAESTRO3_1: u32 = 6553;
pub const PCI_DEVICE_ID_ESS_MAESTRO3_HW: u32 = 6554;
pub const PCI_DEVICE_ID_ESS_MAESTRO3_2: u32 = 6555;
pub const PCI_VENDOR_ID_SATSAGEM: u32 = 4711;
pub const PCI_DEVICE_ID_SATSAGEM_NICCY: u32 = 4118;
pub const PCI_VENDOR_ID_ENSONIQ: u32 = 4724;
pub const PCI_DEVICE_ID_ENSONIQ_CT5880: u32 = 22656;
pub const PCI_DEVICE_ID_ENSONIQ_ES1370: u32 = 20480;
pub const PCI_DEVICE_ID_ENSONIQ_ES1371: u32 = 4977;
pub const PCI_VENDOR_ID_TRANSMETA: u32 = 4729;
pub const PCI_DEVICE_ID_EFFICEON: u32 = 96;
pub const PCI_VENDOR_ID_ROCKWELL: u32 = 4730;
pub const PCI_VENDOR_ID_ITE: u32 = 4739;
pub const PCI_DEVICE_ID_ITE_8172: u32 = 33138;
pub const PCI_DEVICE_ID_ITE_8211: u32 = 33297;
pub const PCI_DEVICE_ID_ITE_8212: u32 = 33298;
pub const PCI_DEVICE_ID_ITE_8213: u32 = 33299;
pub const PCI_DEVICE_ID_ITE_8152: u32 = 33106;
pub const PCI_DEVICE_ID_ITE_8872: u32 = 34930;
pub const PCI_DEVICE_ID_ITE_IT8330G_0: u32 = 59526;
pub const PCI_DEVICE_ID_ESS_ESS0100: u32 = 256;
pub const PCI_VENDOR_ID_ALTEON: u32 = 4782;
pub const PCI_SUBVENDOR_ID_CONNECT_TECH: u32 = 4804;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_232: u32 = 1;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_232: u32 = 2;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_232: u32 = 3;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485: u32 = 4;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4: u32 = 5;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485: u32 = 6;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2: u32 = 7;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485: u32 = 8;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6: u32 = 9;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH081101V1: u32 = 10;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH041101V1: u32 = 11;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_20MHZ: u32 = 12;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_PTM: u32 = 13;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_NT960PCI: u32 = 256;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_TITAN_2: u32 = 513;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_TITAN_4: u32 = 514;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_2_232: u32 = 768;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_4_232: u32 = 769;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_8_232: u32 = 770;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_1_1: u32 = 784;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_2_2: u32 = 785;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_4_4: u32 = 786;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_2: u32 = 800;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_4: u32 = 801;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_8: u32 = 802;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_2_485: u32 = 816;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_4_485: u32 = 817;
pub const PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_8_485: u32 = 818;
pub const PCI_VENDOR_ID_NVIDIA_SGS: u32 = 4818;
pub const PCI_DEVICE_ID_NVIDIA_SGS_RIVA128: u32 = 24;
pub const PCI_VENDOR_ID_PERICOM: u32 = 4824;
pub const PCI_DEVICE_ID_PERICOM_PI7C9X7951: u32 = 31057;
pub const PCI_DEVICE_ID_PERICOM_PI7C9X7952: u32 = 31058;
pub const PCI_DEVICE_ID_PERICOM_PI7C9X7954: u32 = 31060;
pub const PCI_DEVICE_ID_PERICOM_PI7C9X7958: u32 = 31064;
pub const PCI_SUBVENDOR_ID_CHASE_PCIFAST: u32 = 4832;
pub const PCI_SUBDEVICE_ID_CHASE_PCIFAST4: u32 = 49;
pub const PCI_SUBDEVICE_ID_CHASE_PCIFAST8: u32 = 33;
pub const PCI_SUBDEVICE_ID_CHASE_PCIFAST16: u32 = 17;
pub const PCI_SUBDEVICE_ID_CHASE_PCIFAST16FMC: u32 = 65;
pub const PCI_SUBVENDOR_ID_CHASE_PCIRAS: u32 = 4685;
pub const PCI_SUBDEVICE_ID_CHASE_PCIRAS4: u32 = 61441;
pub const PCI_SUBDEVICE_ID_CHASE_PCIRAS8: u32 = 61456;
pub const PCI_VENDOR_ID_AUREAL: u32 = 4843;
pub const PCI_DEVICE_ID_AUREAL_VORTEX_1: u32 = 1;
pub const PCI_DEVICE_ID_AUREAL_VORTEX_2: u32 = 2;
pub const PCI_DEVICE_ID_AUREAL_ADVANTAGE: u32 = 3;
pub const PCI_VENDOR_ID_ELECTRONICDESIGNGMBH: u32 = 4856;
pub const PCI_DEVICE_ID_LML_33R10: u32 = 35330;
pub const PCI_VENDOR_ID_ESDGMBH: u32 = 4862;
pub const PCI_DEVICE_ID_ESDGMBH_CPCIASIO4: u32 = 273;
pub const PCI_VENDOR_ID_CB: u32 = 4871;
pub const PCI_VENDOR_ID_SIIG: u32 = 4895;
pub const PCI_SUBVENDOR_ID_SIIG: u32 = 4895;
pub const PCI_DEVICE_ID_SIIG_1S_10x_550: u32 = 4096;
pub const PCI_DEVICE_ID_SIIG_1S_10x_650: u32 = 4097;
pub const PCI_DEVICE_ID_SIIG_1S_10x_850: u32 = 4098;
pub const PCI_DEVICE_ID_SIIG_1S1P_10x_550: u32 = 4112;
pub const PCI_DEVICE_ID_SIIG_1S1P_10x_650: u32 = 4113;
pub const PCI_DEVICE_ID_SIIG_1S1P_10x_850: u32 = 4114;
pub const PCI_DEVICE_ID_SIIG_1P_10x: u32 = 4128;
pub const PCI_DEVICE_ID_SIIG_2P_10x: u32 = 4129;
pub const PCI_DEVICE_ID_SIIG_2S_10x_550: u32 = 4144;
pub const PCI_DEVICE_ID_SIIG_2S_10x_650: u32 = 4145;
pub const PCI_DEVICE_ID_SIIG_2S_10x_850: u32 = 4146;
pub const PCI_DEVICE_ID_SIIG_2S1P_10x_550: u32 = 4148;
pub const PCI_DEVICE_ID_SIIG_2S1P_10x_650: u32 = 4149;
pub const PCI_DEVICE_ID_SIIG_2S1P_10x_850: u32 = 4150;
pub const PCI_DEVICE_ID_SIIG_4S_10x_550: u32 = 4176;
pub const PCI_DEVICE_ID_SIIG_4S_10x_650: u32 = 4177;
pub const PCI_DEVICE_ID_SIIG_4S_10x_850: u32 = 4178;
pub const PCI_DEVICE_ID_SIIG_1S_20x_550: u32 = 8192;
pub const PCI_DEVICE_ID_SIIG_1S_20x_650: u32 = 8193;
pub const PCI_DEVICE_ID_SIIG_1S_20x_850: u32 = 8194;
pub const PCI_DEVICE_ID_SIIG_1P_20x: u32 = 8224;
pub const PCI_DEVICE_ID_SIIG_2P_20x: u32 = 8225;
pub const PCI_DEVICE_ID_SIIG_2S_20x_550: u32 = 8240;
pub const PCI_DEVICE_ID_SIIG_2S_20x_650: u32 = 8241;
pub const PCI_DEVICE_ID_SIIG_2S_20x_850: u32 = 8242;
pub const PCI_DEVICE_ID_SIIG_2P1S_20x_550: u32 = 8256;
pub const PCI_DEVICE_ID_SIIG_2P1S_20x_650: u32 = 8257;
pub const PCI_DEVICE_ID_SIIG_2P1S_20x_850: u32 = 8258;
pub const PCI_DEVICE_ID_SIIG_1S1P_20x_550: u32 = 8208;
pub const PCI_DEVICE_ID_SIIG_1S1P_20x_650: u32 = 8209;
pub const PCI_DEVICE_ID_SIIG_1S1P_20x_850: u32 = 8210;
pub const PCI_DEVICE_ID_SIIG_4S_20x_550: u32 = 8272;
pub const PCI_DEVICE_ID_SIIG_4S_20x_650: u32 = 8273;
pub const PCI_DEVICE_ID_SIIG_4S_20x_850: u32 = 8274;
pub const PCI_DEVICE_ID_SIIG_2S1P_20x_550: u32 = 8288;
pub const PCI_DEVICE_ID_SIIG_2S1P_20x_650: u32 = 8289;
pub const PCI_DEVICE_ID_SIIG_2S1P_20x_850: u32 = 8290;
pub const PCI_DEVICE_ID_SIIG_8S_20x_550: u32 = 8320;
pub const PCI_DEVICE_ID_SIIG_8S_20x_650: u32 = 8321;
pub const PCI_DEVICE_ID_SIIG_8S_20x_850: u32 = 8322;
pub const PCI_SUBDEVICE_ID_SIIG_QUARTET_SERIAL: u32 = 8272;
pub const PCI_VENDOR_ID_RADISYS: u32 = 4913;
pub const PCI_VENDOR_ID_MICRO_MEMORY: u32 = 4914;
pub const PCI_DEVICE_ID_MICRO_MEMORY_5415CN: u32 = 21525;
pub const PCI_DEVICE_ID_MICRO_MEMORY_5425CN: u32 = 21541;
pub const PCI_DEVICE_ID_MICRO_MEMORY_6155: u32 = 24917;
pub const PCI_VENDOR_ID_DOMEX: u32 = 4938;
pub const PCI_DEVICE_ID_DOMEX_DMX3191D: u32 = 1;
pub const PCI_VENDOR_ID_INTASHIELD: u32 = 4954;
pub const PCI_DEVICE_ID_INTASHIELD_IS200: u32 = 3456;
pub const PCI_DEVICE_ID_INTASHIELD_IS400: u32 = 3520;
pub const PCI_VENDOR_ID_QUATECH: u32 = 4956;
pub const PCI_DEVICE_ID_QUATECH_QSC100: u32 = 16;
pub const PCI_DEVICE_ID_QUATECH_DSC100: u32 = 32;
pub const PCI_DEVICE_ID_QUATECH_DSC200: u32 = 48;
pub const PCI_DEVICE_ID_QUATECH_QSC200: u32 = 64;
pub const PCI_DEVICE_ID_QUATECH_ESC100D: u32 = 80;
pub const PCI_DEVICE_ID_QUATECH_ESC100M: u32 = 96;
pub const PCI_DEVICE_ID_QUATECH_QSCP100: u32 = 288;
pub const PCI_DEVICE_ID_QUATECH_DSCP100: u32 = 304;
pub const PCI_DEVICE_ID_QUATECH_QSCP200: u32 = 320;
pub const PCI_DEVICE_ID_QUATECH_DSCP200: u32 = 336;
pub const PCI_DEVICE_ID_QUATECH_QSCLP100: u32 = 368;
pub const PCI_DEVICE_ID_QUATECH_DSCLP100: u32 = 384;
pub const PCI_DEVICE_ID_QUATECH_DSC100E: u32 = 385;
pub const PCI_DEVICE_ID_QUATECH_SSCLP100: u32 = 400;
pub const PCI_DEVICE_ID_QUATECH_QSCLP200: u32 = 416;
pub const PCI_DEVICE_ID_QUATECH_DSCLP200: u32 = 432;
pub const PCI_DEVICE_ID_QUATECH_DSC200E: u32 = 433;
pub const PCI_DEVICE_ID_QUATECH_SSCLP200: u32 = 448;
pub const PCI_DEVICE_ID_QUATECH_ESCLP100: u32 = 480;
pub const PCI_DEVICE_ID_QUATECH_SPPXP_100: u32 = 632;
pub const PCI_VENDOR_ID_SEALEVEL: u32 = 4958;
pub const PCI_DEVICE_ID_SEALEVEL_U530: u32 = 28929;
pub const PCI_DEVICE_ID_SEALEVEL_UCOMM2: u32 = 29185;
pub const PCI_DEVICE_ID_SEALEVEL_UCOMM422: u32 = 29698;
pub const PCI_DEVICE_ID_SEALEVEL_UCOMM232: u32 = 29186;
pub const PCI_DEVICE_ID_SEALEVEL_COMM4: u32 = 29697;
pub const PCI_DEVICE_ID_SEALEVEL_COMM8: u32 = 30721;
pub const PCI_DEVICE_ID_SEALEVEL_7803: u32 = 30723;
pub const PCI_DEVICE_ID_SEALEVEL_UCOMM8: u32 = 30724;
pub const PCI_VENDOR_ID_HYPERCOPE: u32 = 4965;
pub const PCI_DEVICE_ID_HYPERCOPE_PLX: u32 = 36944;
pub const PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO: u32 = 260;
pub const PCI_SUBDEVICE_ID_HYPERCOPE_ERGO: u32 = 262;
pub const PCI_SUBDEVICE_ID_HYPERCOPE_METRO: u32 = 263;
pub const PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2: u32 = 264;
pub const PCI_VENDOR_ID_DIGIGRAM: u32 = 4969;
pub const PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM: u32 = 49153;
pub const PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM: u32 = 49154;
pub const PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_SERIAL_SUBSYSTEM: u32 = 49185;
pub const PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_CAE_SERIAL_SUBSYSTEM: u32 = 49186;
pub const PCI_VENDOR_ID_KAWASAKI: u32 = 4971;
pub const PCI_DEVICE_ID_MCHIP_KL5A72002: u32 = 65281;
pub const PCI_VENDOR_ID_CNET: u32 = 4977;
pub const PCI_DEVICE_ID_CNET_GIGACARD: u32 = 17230;
pub const PCI_VENDOR_ID_LMC: u32 = 4982;
pub const PCI_DEVICE_ID_LMC_HSSI: u32 = 3;
pub const PCI_DEVICE_ID_LMC_DS3: u32 = 4;
pub const PCI_DEVICE_ID_LMC_SSI: u32 = 5;
pub const PCI_DEVICE_ID_LMC_T1: u32 = 6;
pub const PCI_VENDOR_ID_NETGEAR: u32 = 4997;
pub const PCI_DEVICE_ID_NETGEAR_GA620: u32 = 25098;
pub const PCI_VENDOR_ID_APPLICOM: u32 = 5001;
pub const PCI_DEVICE_ID_APPLICOM_PCIGENERIC: u32 = 1;
pub const PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN: u32 = 2;
pub const PCI_DEVICE_ID_APPLICOM_PCI2000PFB: u32 = 3;
pub const PCI_VENDOR_ID_MOXA: u32 = 5011;
pub const PCI_DEVICE_ID_MOXA_CP204J: u32 = 8256;
pub const PCI_DEVICE_ID_MOXA_C218: u32 = 8576;
pub const PCI_DEVICE_ID_MOXA_C320: u32 = 12800;
pub const PCI_VENDOR_ID_CCD: u32 = 5015;
pub const PCI_DEVICE_ID_CCD_HFC4S: u32 = 2228;
pub const PCI_SUBDEVICE_ID_CCD_PMX2S: u32 = 4660;
pub const PCI_DEVICE_ID_CCD_HFC8S: u32 = 5816;
pub const PCI_DEVICE_ID_CCD_2BD0: u32 = 11216;
pub const PCI_DEVICE_ID_CCD_HFCE1: u32 = 12465;
pub const PCI_SUBDEVICE_ID_CCD_SPD4S: u32 = 12598;
pub const PCI_SUBDEVICE_ID_CCD_SPDE1: u32 = 12599;
pub const PCI_DEVICE_ID_CCD_B000: u32 = 45056;
pub const PCI_DEVICE_ID_CCD_B006: u32 = 45062;
pub const PCI_DEVICE_ID_CCD_B007: u32 = 45063;
pub const PCI_DEVICE_ID_CCD_B008: u32 = 45064;
pub const PCI_DEVICE_ID_CCD_B009: u32 = 45065;
pub const PCI_DEVICE_ID_CCD_B00A: u32 = 45066;
pub const PCI_DEVICE_ID_CCD_B00B: u32 = 45067;
pub const PCI_DEVICE_ID_CCD_B00C: u32 = 45068;
pub const PCI_DEVICE_ID_CCD_B100: u32 = 45312;
pub const PCI_SUBDEVICE_ID_CCD_IOB4ST: u32 = 46368;
pub const PCI_SUBDEVICE_ID_CCD_IOB8STR: u32 = 46369;
pub const PCI_SUBDEVICE_ID_CCD_IOB8ST: u32 = 46370;
pub const PCI_SUBDEVICE_ID_CCD_IOB1E1: u32 = 46371;
pub const PCI_SUBDEVICE_ID_CCD_SWYX4S: u32 = 46400;
pub const PCI_SUBDEVICE_ID_CCD_JH4S20: u32 = 46416;
pub const PCI_SUBDEVICE_ID_CCD_IOB8ST_1: u32 = 46418;
pub const PCI_SUBDEVICE_ID_CCD_JHSE1: u32 = 46419;
pub const PCI_SUBDEVICE_ID_CCD_JH8S: u32 = 46427;
pub const PCI_SUBDEVICE_ID_CCD_BN4S: u32 = 46432;
pub const PCI_SUBDEVICE_ID_CCD_BN8S: u32 = 46434;
pub const PCI_SUBDEVICE_ID_CCD_BNE1: u32 = 46435;
pub const PCI_SUBDEVICE_ID_CCD_BNE1D: u32 = 46436;
pub const PCI_SUBDEVICE_ID_CCD_BNE1DP: u32 = 46437;
pub const PCI_SUBDEVICE_ID_CCD_BN2S: u32 = 46438;
pub const PCI_SUBDEVICE_ID_CCD_BN1SM: u32 = 46439;
pub const PCI_SUBDEVICE_ID_CCD_BN4SM: u32 = 46440;
pub const PCI_SUBDEVICE_ID_CCD_BN2SM: u32 = 46441;
pub const PCI_SUBDEVICE_ID_CCD_BNE1M: u32 = 46442;
pub const PCI_SUBDEVICE_ID_CCD_BN8SP: u32 = 46443;
pub const PCI_SUBDEVICE_ID_CCD_HFC4S: u32 = 46624;
pub const PCI_SUBDEVICE_ID_CCD_HFC8S: u32 = 46626;
pub const PCI_DEVICE_ID_CCD_B700: u32 = 46848;
pub const PCI_DEVICE_ID_CCD_B701: u32 = 46849;
pub const PCI_SUBDEVICE_ID_CCD_HFCE1: u32 = 50467;
pub const PCI_SUBDEVICE_ID_CCD_OV2S: u32 = 59524;
pub const PCI_SUBDEVICE_ID_CCD_OV4S: u32 = 59528;
pub const PCI_SUBDEVICE_ID_CCD_OV8S: u32 = 59800;
pub const PCI_VENDOR_ID_EXAR: u32 = 5032;
pub const PCI_DEVICE_ID_EXAR_XR17C152: u32 = 338;
pub const PCI_DEVICE_ID_EXAR_XR17C154: u32 = 340;
pub const PCI_DEVICE_ID_EXAR_XR17C158: u32 = 344;
pub const PCI_DEVICE_ID_EXAR_XR17V352: u32 = 850;
pub const PCI_DEVICE_ID_EXAR_XR17V354: u32 = 852;
pub const PCI_DEVICE_ID_EXAR_XR17V358: u32 = 856;
pub const PCI_VENDOR_ID_MICROGATE: u32 = 5056;
pub const PCI_VENDOR_ID_3WARE: u32 = 5057;
pub const PCI_DEVICE_ID_3WARE_1000: u32 = 4096;
pub const PCI_DEVICE_ID_3WARE_7000: u32 = 4097;
pub const PCI_DEVICE_ID_3WARE_9000: u32 = 4098;
pub const PCI_VENDOR_ID_IOMEGA: u32 = 5066;
pub const PCI_DEVICE_ID_IOMEGA_BUZ: u32 = 16945;
pub const PCI_VENDOR_ID_ABOCOM: u32 = 5073;
pub const PCI_DEVICE_ID_ABOCOM_2BD1: u32 = 11217;
pub const PCI_VENDOR_ID_SUNDANCE: u32 = 5104;
pub const PCI_VENDOR_ID_CMEDIA: u32 = 5110;
pub const PCI_DEVICE_ID_CMEDIA_CM8338A: u32 = 256;
pub const PCI_DEVICE_ID_CMEDIA_CM8338B: u32 = 257;
pub const PCI_DEVICE_ID_CMEDIA_CM8738: u32 = 273;
pub const PCI_DEVICE_ID_CMEDIA_CM8738B: u32 = 274;
pub const PCI_VENDOR_ID_ADVANTECH: u32 = 5118;
pub const PCI_VENDOR_ID_MEILHAUS: u32 = 5122;
pub const PCI_VENDOR_ID_LAVA: u32 = 5127;
pub const PCI_DEVICE_ID_LAVA_DSERIAL: u32 = 256;
pub const PCI_DEVICE_ID_LAVA_QUATRO_A: u32 = 257;
pub const PCI_DEVICE_ID_LAVA_QUATRO_B: u32 = 258;
pub const PCI_DEVICE_ID_LAVA_QUATTRO_A: u32 = 288;
pub const PCI_DEVICE_ID_LAVA_QUATTRO_B: u32 = 289;
pub const PCI_DEVICE_ID_LAVA_OCTO_A: u32 = 384;
pub const PCI_DEVICE_ID_LAVA_OCTO_B: u32 = 385;
pub const PCI_DEVICE_ID_LAVA_PORT_PLUS: u32 = 512;
pub const PCI_DEVICE_ID_LAVA_QUAD_A: u32 = 513;
pub const PCI_DEVICE_ID_LAVA_QUAD_B: u32 = 514;
pub const PCI_DEVICE_ID_LAVA_SSERIAL: u32 = 1280;
pub const PCI_DEVICE_ID_LAVA_PORT_650: u32 = 1536;
pub const PCI_DEVICE_ID_LAVA_PARALLEL: u32 = 32768;
pub const PCI_DEVICE_ID_LAVA_DUAL_PAR_A: u32 = 32770;
pub const PCI_DEVICE_ID_LAVA_DUAL_PAR_B: u32 = 32771;
pub const PCI_DEVICE_ID_LAVA_BOCA_IOPPAR: u32 = 34816;
pub const PCI_VENDOR_ID_TIMEDIA: u32 = 5129;
pub const PCI_DEVICE_ID_TIMEDIA_1889: u32 = 29032;
pub const PCI_VENDOR_ID_ICE: u32 = 5138;
pub const PCI_DEVICE_ID_ICE_1712: u32 = 5906;
pub const PCI_DEVICE_ID_VT1724: u32 = 5924;
pub const PCI_VENDOR_ID_MICROSOFT: u32 = 5140;
pub const PCI_DEVICE_ID_HYPERV_VIDEO: u32 = 21331;
pub const PCI_VENDOR_ID_OXSEMI: u32 = 5141;
pub const PCI_DEVICE_ID_OXSEMI_12PCI840: u32 = 33795;
pub const PCI_DEVICE_ID_OXSEMI_PCIe840: u32 = 49152;
pub const PCI_DEVICE_ID_OXSEMI_PCIe840_G: u32 = 49156;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_0: u32 = 49408;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_0_G: u32 = 49412;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_1: u32 = 49424;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_1_G: u32 = 49428;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_1_U: u32 = 49432;
pub const PCI_DEVICE_ID_OXSEMI_PCIe952_1_GU: u32 = 49436;
pub const PCI_DEVICE_ID_OXSEMI_16PCI954: u32 = 38145;
pub const PCI_DEVICE_ID_OXSEMI_C950: u32 = 38155;
pub const PCI_DEVICE_ID_OXSEMI_16PCI95N: u32 = 38161;
pub const PCI_DEVICE_ID_OXSEMI_16PCI954PP: u32 = 38163;
pub const PCI_DEVICE_ID_OXSEMI_16PCI952: u32 = 38177;
pub const PCI_DEVICE_ID_OXSEMI_16PCI952PP: u32 = 38179;
pub const PCI_SUBDEVICE_ID_OXSEMI_C950: u32 = 1;
pub const PCI_VENDOR_ID_CHELSIO: u32 = 5157;
pub const PCI_VENDOR_ID_EDIMAX: u32 = 5170;
pub const PCI_VENDOR_ID_ADLINK: u32 = 5194;
pub const PCI_VENDOR_ID_SAMSUNG: u32 = 5197;
pub const PCI_VENDOR_ID_GIGABYTE: u32 = 5208;
pub const PCI_VENDOR_ID_AMBIT: u32 = 5224;
pub const PCI_VENDOR_ID_MYRICOM: u32 = 5313;
pub const PCI_VENDOR_ID_MEDIATEK: u32 = 5315;
pub const PCI_DEVICE_ID_MEDIATEK_7629: u32 = 30249;
pub const PCI_VENDOR_ID_TITAN: u32 = 5330;
pub const PCI_DEVICE_ID_TITAN_010L: u32 = 32769;
pub const PCI_DEVICE_ID_TITAN_100L: u32 = 32784;
pub const PCI_DEVICE_ID_TITAN_110L: u32 = 32785;
pub const PCI_DEVICE_ID_TITAN_200L: u32 = 32800;
pub const PCI_DEVICE_ID_TITAN_210L: u32 = 32801;
pub const PCI_DEVICE_ID_TITAN_400L: u32 = 32832;
pub const PCI_DEVICE_ID_TITAN_800L: u32 = 32896;
pub const PCI_DEVICE_ID_TITAN_100: u32 = 40961;
pub const PCI_DEVICE_ID_TITAN_200: u32 = 40965;
pub const PCI_DEVICE_ID_TITAN_400: u32 = 40963;
pub const PCI_DEVICE_ID_TITAN_800B: u32 = 40964;
pub const PCI_VENDOR_ID_PANACOM: u32 = 5332;
pub const PCI_DEVICE_ID_PANACOM_QUADMODEM: u32 = 1024;
pub const PCI_DEVICE_ID_PANACOM_DUALMODEM: u32 = 1026;
pub const PCI_VENDOR_ID_SIPACKETS: u32 = 5337;
pub const PCI_DEVICE_ID_SP1011: u32 = 16;
pub const PCI_VENDOR_ID_AFAVLAB: u32 = 5339;
pub const PCI_DEVICE_ID_AFAVLAB_P028: u32 = 8576;
pub const PCI_DEVICE_ID_AFAVLAB_P030: u32 = 8578;
pub const PCI_SUBDEVICE_ID_AFAVLAB_P061: u32 = 8528;
pub const PCI_VENDOR_ID_AMPLICON: u32 = 5340;
pub const PCI_VENDOR_ID_BCM_GVC: u32 = 5284;
pub const PCI_VENDOR_ID_BROADCOM: u32 = 5348;
pub const PCI_DEVICE_ID_TIGON3_5752: u32 = 5632;
pub const PCI_DEVICE_ID_TIGON3_5752M: u32 = 5633;
pub const PCI_DEVICE_ID_NX2_5709: u32 = 5689;
pub const PCI_DEVICE_ID_NX2_5709S: u32 = 5690;
pub const PCI_DEVICE_ID_TIGON3_5700: u32 = 5700;
pub const PCI_DEVICE_ID_TIGON3_5701: u32 = 5701;
pub const PCI_DEVICE_ID_TIGON3_5702: u32 = 5702;
pub const PCI_DEVICE_ID_TIGON3_5703: u32 = 5703;
pub const PCI_DEVICE_ID_TIGON3_5704: u32 = 5704;
pub const PCI_DEVICE_ID_TIGON3_5704S_2: u32 = 5705;
pub const PCI_DEVICE_ID_NX2_5706: u32 = 5706;
pub const PCI_DEVICE_ID_NX2_5708: u32 = 5708;
pub const PCI_DEVICE_ID_TIGON3_5702FE: u32 = 5709;
pub const PCI_DEVICE_ID_NX2_57710: u32 = 5710;
pub const PCI_DEVICE_ID_NX2_57711: u32 = 5711;
pub const PCI_DEVICE_ID_NX2_57711E: u32 = 5712;
pub const PCI_DEVICE_ID_TIGON3_5705: u32 = 5715;
pub const PCI_DEVICE_ID_TIGON3_5705_2: u32 = 5716;
pub const PCI_DEVICE_ID_TIGON3_5719: u32 = 5719;
pub const PCI_DEVICE_ID_TIGON3_5721: u32 = 5721;
pub const PCI_DEVICE_ID_TIGON3_5722: u32 = 5722;
pub const PCI_DEVICE_ID_TIGON3_5723: u32 = 5723;
pub const PCI_DEVICE_ID_TIGON3_5705M: u32 = 5725;
pub const PCI_DEVICE_ID_TIGON3_5705M_2: u32 = 5726;
pub const PCI_DEVICE_ID_NX2_57712: u32 = 5730;
pub const PCI_DEVICE_ID_NX2_57712E: u32 = 5731;
pub const PCI_DEVICE_ID_NX2_57712_MF: u32 = 5731;
pub const PCI_DEVICE_ID_TIGON3_5714: u32 = 5736;
pub const PCI_DEVICE_ID_TIGON3_5714S: u32 = 5737;
pub const PCI_DEVICE_ID_TIGON3_5780: u32 = 5738;
pub const PCI_DEVICE_ID_TIGON3_5780S: u32 = 5739;
pub const PCI_DEVICE_ID_TIGON3_5705F: u32 = 5742;
pub const PCI_DEVICE_ID_NX2_57712_VF: u32 = 5743;
pub const PCI_DEVICE_ID_TIGON3_5754M: u32 = 5746;
pub const PCI_DEVICE_ID_TIGON3_5755M: u32 = 5747;
pub const PCI_DEVICE_ID_TIGON3_5756: u32 = 5748;
pub const PCI_DEVICE_ID_TIGON3_5750: u32 = 5750;
pub const PCI_DEVICE_ID_TIGON3_5751: u32 = 5751;
pub const PCI_DEVICE_ID_TIGON3_5715: u32 = 5752;
pub const PCI_DEVICE_ID_TIGON3_5715S: u32 = 5753;
pub const PCI_DEVICE_ID_TIGON3_5754: u32 = 5754;
pub const PCI_DEVICE_ID_TIGON3_5755: u32 = 5755;
pub const PCI_DEVICE_ID_TIGON3_5751M: u32 = 5757;
pub const PCI_DEVICE_ID_TIGON3_5751F: u32 = 5758;
pub const PCI_DEVICE_ID_TIGON3_5787F: u32 = 5759;
pub const PCI_DEVICE_ID_TIGON3_5761E: u32 = 5760;
pub const PCI_DEVICE_ID_TIGON3_5761: u32 = 5761;
pub const PCI_DEVICE_ID_TIGON3_5764: u32 = 5764;
pub const PCI_DEVICE_ID_NX2_57800: u32 = 5770;
pub const PCI_DEVICE_ID_NX2_57840: u32 = 5773;
pub const PCI_DEVICE_ID_NX2_57810: u32 = 5774;
pub const PCI_DEVICE_ID_TIGON3_5787M: u32 = 5779;
pub const PCI_DEVICE_ID_TIGON3_5782: u32 = 5782;
pub const PCI_DEVICE_ID_TIGON3_5784: u32 = 5784;
pub const PCI_DEVICE_ID_TIGON3_5786: u32 = 5786;
pub const PCI_DEVICE_ID_TIGON3_5787: u32 = 5787;
pub const PCI_DEVICE_ID_TIGON3_5788: u32 = 5788;
pub const PCI_DEVICE_ID_TIGON3_5789: u32 = 5789;
pub const PCI_DEVICE_ID_NX2_57840_4_10: u32 = 5793;
pub const PCI_DEVICE_ID_NX2_57840_2_20: u32 = 5794;
pub const PCI_DEVICE_ID_NX2_57840_MF: u32 = 5796;
pub const PCI_DEVICE_ID_NX2_57800_MF: u32 = 5797;
pub const PCI_DEVICE_ID_TIGON3_5702X: u32 = 5798;
pub const PCI_DEVICE_ID_TIGON3_5703X: u32 = 5799;
pub const PCI_DEVICE_ID_TIGON3_5704S: u32 = 5800;
pub const PCI_DEVICE_ID_NX2_57800_VF: u32 = 5801;
pub const PCI_DEVICE_ID_NX2_5706S: u32 = 5802;
pub const PCI_DEVICE_ID_NX2_5708S: u32 = 5804;
pub const PCI_DEVICE_ID_NX2_57840_VF: u32 = 5805;
pub const PCI_DEVICE_ID_NX2_57810_MF: u32 = 5806;
pub const PCI_DEVICE_ID_NX2_57810_VF: u32 = 5807;
pub const PCI_DEVICE_ID_TIGON3_5702A3: u32 = 5830;
pub const PCI_DEVICE_ID_TIGON3_5703A3: u32 = 5831;
pub const PCI_DEVICE_ID_TIGON3_5781: u32 = 5853;
pub const PCI_DEVICE_ID_TIGON3_5753: u32 = 5879;
pub const PCI_DEVICE_ID_TIGON3_5753M: u32 = 5885;
pub const PCI_DEVICE_ID_TIGON3_5753F: u32 = 5886;
pub const PCI_DEVICE_ID_TIGON3_5901: u32 = 5901;
pub const PCI_DEVICE_ID_BCM4401B1: u32 = 5900;
pub const PCI_DEVICE_ID_TIGON3_5901_2: u32 = 5902;
pub const PCI_DEVICE_ID_TIGON3_5906: u32 = 5906;
pub const PCI_DEVICE_ID_TIGON3_5906M: u32 = 5907;
pub const PCI_DEVICE_ID_BCM4401: u32 = 17409;
pub const PCI_DEVICE_ID_BCM4401B0: u32 = 17410;
pub const PCI_VENDOR_ID_TOPIC: u32 = 5407;
pub const PCI_DEVICE_ID_TOPIC_TP560: u32 = 0;
pub const PCI_VENDOR_ID_MAINPINE: u32 = 5410;
pub const PCI_DEVICE_ID_MAINPINE_PBRIDGE: u32 = 256;
pub const PCI_VENDOR_ID_ENE: u32 = 5412;
pub const PCI_DEVICE_ID_ENE_CB710_FLASH: u32 = 1296;
pub const PCI_DEVICE_ID_ENE_CB712_SD: u32 = 1360;
pub const PCI_DEVICE_ID_ENE_CB712_SD_2: u32 = 1361;
pub const PCI_DEVICE_ID_ENE_CB714_SD: u32 = 1872;
pub const PCI_DEVICE_ID_ENE_CB714_SD_2: u32 = 1873;
pub const PCI_DEVICE_ID_ENE_1211: u32 = 4625;
pub const PCI_DEVICE_ID_ENE_1225: u32 = 4645;
pub const PCI_DEVICE_ID_ENE_1410: u32 = 5136;
pub const PCI_DEVICE_ID_ENE_710: u32 = 5137;
pub const PCI_DEVICE_ID_ENE_712: u32 = 5138;
pub const PCI_DEVICE_ID_ENE_1420: u32 = 5152;
pub const PCI_DEVICE_ID_ENE_720: u32 = 5153;
pub const PCI_DEVICE_ID_ENE_722: u32 = 5154;
pub const PCI_SUBVENDOR_ID_PERLE: u32 = 5471;
pub const PCI_SUBDEVICE_ID_PCI_RAS4: u32 = 61441;
pub const PCI_SUBDEVICE_ID_PCI_RAS8: u32 = 61456;
pub const PCI_VENDOR_ID_SYBA: u32 = 5522;
pub const PCI_DEVICE_ID_SYBA_2P_EPP: u32 = 1922;
pub const PCI_DEVICE_ID_SYBA_1P_ECP: u32 = 1923;
pub const PCI_VENDOR_ID_MORETON: u32 = 5546;
pub const PCI_DEVICE_ID_RASTEL_2PORT: u32 = 8192;
pub const PCI_VENDOR_ID_VMWARE: u32 = 5549;
pub const PCI_DEVICE_ID_VMWARE_VMXNET3: u32 = 1968;
pub const PCI_VENDOR_ID_ZOLTRIX: u32 = 5552;
pub const PCI_DEVICE_ID_ZOLTRIX_2BD0: u32 = 11216;
pub const PCI_VENDOR_ID_MELLANOX: u32 = 5555;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX3: u32 = 4099;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX3_PRO: u32 = 4103;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTIB: u32 = 4113;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX4: u32 = 4115;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX4_LX: u32 = 4117;
pub const PCI_DEVICE_ID_MELLANOX_TAVOR: u32 = 23108;
pub const PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE: u32 = 23110;
pub const PCI_DEVICE_ID_MELLANOX_SINAI_OLD: u32 = 24204;
pub const PCI_DEVICE_ID_MELLANOX_SINAI: u32 = 25204;
pub const PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT: u32 = 25208;
pub const PCI_DEVICE_ID_MELLANOX_ARBEL: u32 = 25218;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_SDR: u32 = 25408;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_DDR: u32 = 25418;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_QDR: u32 = 25428;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_EN: u32 = 25448;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX_EN: u32 = 25458;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_DDR_GEN2: u32 = 26418;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_QDR_GEN2: u32 = 26428;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_5_GEN2: u32 = 26438;
pub const PCI_DEVICE_ID_MELLANOX_HERMON_EN_GEN2: u32 = 26448;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_T_GEN2: u32 = 26458;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_GEN2: u32 = 26468;
pub const PCI_DEVICE_ID_MELLANOX_CONNECTX2: u32 = 26478;
pub const PCI_VENDOR_ID_DFI: u32 = 5565;
pub const PCI_VENDOR_ID_QUICKNET: u32 = 5602;
pub const PCI_DEVICE_ID_QUICKNET_XJ: u32 = 1280;
pub const PCI_VENDOR_ID_ADDIDATA: u32 = 5560;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7500: u32 = 28672;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7420: u32 = 28673;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7300: u32 = 28674;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7500_2: u32 = 28681;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7420_2: u32 = 28682;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7300_2: u32 = 28683;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7500_3: u32 = 28684;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7420_3: u32 = 28685;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7300_3: u32 = 28686;
pub const PCI_DEVICE_ID_ADDIDATA_APCI7800_3: u32 = 28687;
pub const PCI_DEVICE_ID_ADDIDATA_APCIe7300: u32 = 28688;
pub const PCI_DEVICE_ID_ADDIDATA_APCIe7420: u32 = 28689;
pub const PCI_DEVICE_ID_ADDIDATA_APCIe7500: u32 = 28690;
pub const PCI_DEVICE_ID_ADDIDATA_APCIe7800: u32 = 28691;
pub const PCI_VENDOR_ID_PDC: u32 = 5609;
pub const PCI_VENDOR_ID_FARSITE: u32 = 5657;
pub const PCI_DEVICE_ID_FARSITE_T2P: u32 = 1024;
pub const PCI_DEVICE_ID_FARSITE_T4P: u32 = 1088;
pub const PCI_DEVICE_ID_FARSITE_T1U: u32 = 1552;
pub const PCI_DEVICE_ID_FARSITE_T2U: u32 = 1568;
pub const PCI_DEVICE_ID_FARSITE_T4U: u32 = 1600;
pub const PCI_DEVICE_ID_FARSITE_TE1: u32 = 5648;
pub const PCI_DEVICE_ID_FARSITE_TE1C: u32 = 5650;
pub const PCI_VENDOR_ID_ARIMA: u32 = 5663;
pub const PCI_VENDOR_ID_BROCADE: u32 = 5719;
pub const PCI_DEVICE_ID_BROCADE_CT: u32 = 20;
pub const PCI_DEVICE_ID_BROCADE_FC_8G1P: u32 = 23;
pub const PCI_DEVICE_ID_BROCADE_CT_FC: u32 = 33;
pub const PCI_VENDOR_ID_SIBYTE: u32 = 5741;
pub const PCI_DEVICE_ID_BCM1250_PCI: u32 = 1;
pub const PCI_DEVICE_ID_BCM1250_HT: u32 = 2;
pub const PCI_VENDOR_ID_ATHEROS: u32 = 5772;
pub const PCI_VENDOR_ID_NETCELL: u32 = 5788;
pub const PCI_DEVICE_ID_REVOLUTION: u32 = 68;
pub const PCI_VENDOR_ID_CENATEK: u32 = 5834;
pub const PCI_DEVICE_ID_CENATEK_IDE: u32 = 1;
pub const PCI_VENDOR_ID_SYNOPSYS: u32 = 5827;
pub const PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3: u32 = 43981;
pub const PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI: u32 = 43982;
pub const PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31: u32 = 43983;
pub const PCI_DEVICE_ID_SYNOPSYS_EDDA: u32 = 60890;
pub const PCI_VENDOR_ID_USR: u32 = 5868;
pub const PCI_VENDOR_ID_VITESSE: u32 = 5925;
pub const PCI_DEVICE_ID_VITESSE_VSC7174: u32 = 29044;
pub const PCI_VENDOR_ID_LINKSYS: u32 = 5943;
pub const PCI_DEVICE_ID_LINKSYS_EG1064: u32 = 4196;
pub const PCI_VENDOR_ID_ALTIMA: u32 = 5947;
pub const PCI_DEVICE_ID_ALTIMA_AC1000: u32 = 1000;
pub const PCI_DEVICE_ID_ALTIMA_AC1001: u32 = 1001;
pub const PCI_DEVICE_ID_ALTIMA_AC9100: u32 = 1002;
pub const PCI_DEVICE_ID_ALTIMA_AC1003: u32 = 1003;
pub const PCI_VENDOR_ID_CAVIUM: u32 = 6013;
pub const PCI_VENDOR_ID_TECHWELL: u32 = 6039;
pub const PCI_DEVICE_ID_TECHWELL_6800: u32 = 26624;
pub const PCI_DEVICE_ID_TECHWELL_6801: u32 = 26625;
pub const PCI_DEVICE_ID_TECHWELL_6804: u32 = 26628;
pub const PCI_DEVICE_ID_TECHWELL_6816_1: u32 = 26640;
pub const PCI_DEVICE_ID_TECHWELL_6816_2: u32 = 26641;
pub const PCI_DEVICE_ID_TECHWELL_6816_3: u32 = 26642;
pub const PCI_DEVICE_ID_TECHWELL_6816_4: u32 = 26643;
pub const PCI_VENDOR_ID_BELKIN: u32 = 6041;
pub const PCI_DEVICE_ID_BELKIN_F5D7010V7: u32 = 28703;
pub const PCI_VENDOR_ID_RDC: u32 = 6131;
pub const PCI_DEVICE_ID_RDC_R6020: u32 = 24608;
pub const PCI_DEVICE_ID_RDC_R6030: u32 = 24624;
pub const PCI_DEVICE_ID_RDC_R6040: u32 = 24640;
pub const PCI_DEVICE_ID_RDC_R6060: u32 = 24672;
pub const PCI_DEVICE_ID_RDC_R6061: u32 = 24673;
pub const PCI_DEVICE_ID_RDC_D1010: u32 = 4112;
pub const PCI_VENDOR_ID_GLI: u32 = 6048;
pub const PCI_VENDOR_ID_LENOVO: u32 = 6058;
pub const PCI_VENDOR_ID_QCOM: u32 = 6091;
pub const PCI_VENDOR_ID_CDNS: u32 = 6093;
pub const PCI_DEVICE_ID_CDNS_USBSS: u32 = 256;
pub const PCI_DEVICE_ID_CDNS_USB: u32 = 288;
pub const PCI_DEVICE_ID_CDNS_USBSSP: u32 = 512;
pub const PCI_VENDOR_ID_ARECA: u32 = 6099;
pub const PCI_DEVICE_ID_ARECA_1110: u32 = 4368;
pub const PCI_DEVICE_ID_ARECA_1120: u32 = 4384;
pub const PCI_DEVICE_ID_ARECA_1130: u32 = 4400;
pub const PCI_DEVICE_ID_ARECA_1160: u32 = 4448;
pub const PCI_DEVICE_ID_ARECA_1170: u32 = 4464;
pub const PCI_DEVICE_ID_ARECA_1200: u32 = 4608;
pub const PCI_DEVICE_ID_ARECA_1201: u32 = 4609;
pub const PCI_DEVICE_ID_ARECA_1202: u32 = 4610;
pub const PCI_DEVICE_ID_ARECA_1210: u32 = 4624;
pub const PCI_DEVICE_ID_ARECA_1220: u32 = 4640;
pub const PCI_DEVICE_ID_ARECA_1230: u32 = 4656;
pub const PCI_DEVICE_ID_ARECA_1260: u32 = 4704;
pub const PCI_DEVICE_ID_ARECA_1270: u32 = 4720;
pub const PCI_DEVICE_ID_ARECA_1280: u32 = 4736;
pub const PCI_DEVICE_ID_ARECA_1380: u32 = 4992;
pub const PCI_DEVICE_ID_ARECA_1381: u32 = 4993;
pub const PCI_DEVICE_ID_ARECA_1680: u32 = 5760;
pub const PCI_DEVICE_ID_ARECA_1681: u32 = 5761;
pub const PCI_VENDOR_ID_S2IO: u32 = 6101;
pub const PCI_DEVICE_ID_S2IO_WIN: u32 = 22321;
pub const PCI_DEVICE_ID_S2IO_UNI: u32 = 22577;
pub const PCI_DEVICE_ID_HERC_WIN: u32 = 22322;
pub const PCI_DEVICE_ID_HERC_UNI: u32 = 22578;
pub const PCI_VENDOR_ID_SITECOM: u32 = 6189;
pub const PCI_DEVICE_ID_SITECOM_DC105V2: u32 = 12393;
pub const PCI_VENDOR_ID_TOPSPIN: u32 = 6247;
pub const PCI_VENDOR_ID_COMMTECH: u32 = 6391;
pub const PCI_VENDOR_ID_SILAN: u32 = 6404;
pub const PCI_VENDOR_ID_RENESAS: u32 = 6418;
pub const PCI_DEVICE_ID_RENESAS_SH7781: u32 = 1;
pub const PCI_DEVICE_ID_RENESAS_SH7780: u32 = 2;
pub const PCI_DEVICE_ID_RENESAS_SH7763: u32 = 4;
pub const PCI_DEVICE_ID_RENESAS_SH7785: u32 = 7;
pub const PCI_DEVICE_ID_RENESAS_SH7786: u32 = 16;
pub const PCI_VENDOR_ID_SOLARFLARE: u32 = 6436;
pub const PCI_DEVICE_ID_SOLARFLARE_SFC4000A_0: u32 = 1795;
pub const PCI_DEVICE_ID_SOLARFLARE_SFC4000A_1: u32 = 26371;
pub const PCI_DEVICE_ID_SOLARFLARE_SFC4000B: u32 = 1808;
pub const PCI_VENDOR_ID_TDI: u32 = 6446;
pub const PCI_DEVICE_ID_TDI_EHCI: u32 = 257;
pub const PCI_VENDOR_ID_FREESCALE: u32 = 6487;
pub const PCI_VENDOR_ID_NXP: u32 = 6487;
pub const PCI_DEVICE_ID_MPC8308: u32 = 49158;
pub const PCI_DEVICE_ID_MPC8315E: u32 = 180;
pub const PCI_DEVICE_ID_MPC8315: u32 = 181;
pub const PCI_DEVICE_ID_MPC8314E: u32 = 182;
pub const PCI_DEVICE_ID_MPC8314: u32 = 183;
pub const PCI_DEVICE_ID_MPC8378E: u32 = 196;
pub const PCI_DEVICE_ID_MPC8378: u32 = 197;
pub const PCI_DEVICE_ID_MPC8377E: u32 = 198;
pub const PCI_DEVICE_ID_MPC8377: u32 = 199;
pub const PCI_DEVICE_ID_MPC8548E: u32 = 18;
pub const PCI_DEVICE_ID_MPC8548: u32 = 19;
pub const PCI_DEVICE_ID_MPC8543E: u32 = 20;
pub const PCI_DEVICE_ID_MPC8543: u32 = 21;
pub const PCI_DEVICE_ID_MPC8547E: u32 = 24;
pub const PCI_DEVICE_ID_MPC8545E: u32 = 25;
pub const PCI_DEVICE_ID_MPC8545: u32 = 26;
pub const PCI_DEVICE_ID_MPC8569E: u32 = 97;
pub const PCI_DEVICE_ID_MPC8569: u32 = 96;
pub const PCI_DEVICE_ID_MPC8568E: u32 = 32;
pub const PCI_DEVICE_ID_MPC8568: u32 = 33;
pub const PCI_DEVICE_ID_MPC8567E: u32 = 34;
pub const PCI_DEVICE_ID_MPC8567: u32 = 35;
pub const PCI_DEVICE_ID_MPC8533E: u32 = 48;
pub const PCI_DEVICE_ID_MPC8533: u32 = 49;
pub const PCI_DEVICE_ID_MPC8544E: u32 = 50;
pub const PCI_DEVICE_ID_MPC8544: u32 = 51;
pub const PCI_DEVICE_ID_MPC8572E: u32 = 64;
pub const PCI_DEVICE_ID_MPC8572: u32 = 65;
pub const PCI_DEVICE_ID_MPC8536E: u32 = 80;
pub const PCI_DEVICE_ID_MPC8536: u32 = 81;
pub const PCI_DEVICE_ID_P2020E: u32 = 112;
pub const PCI_DEVICE_ID_P2020: u32 = 113;
pub const PCI_DEVICE_ID_P2010E: u32 = 120;
pub const PCI_DEVICE_ID_P2010: u32 = 121;
pub const PCI_DEVICE_ID_P1020E: u32 = 256;
pub const PCI_DEVICE_ID_P1020: u32 = 257;
pub const PCI_DEVICE_ID_P1021E: u32 = 258;
pub const PCI_DEVICE_ID_P1021: u32 = 259;
pub const PCI_DEVICE_ID_P1011E: u32 = 264;
pub const PCI_DEVICE_ID_P1011: u32 = 265;
pub const PCI_DEVICE_ID_P1022E: u32 = 272;
pub const PCI_DEVICE_ID_P1022: u32 = 273;
pub const PCI_DEVICE_ID_P1013E: u32 = 280;
pub const PCI_DEVICE_ID_P1013: u32 = 281;
pub const PCI_DEVICE_ID_P4080E: u32 = 1024;
pub const PCI_DEVICE_ID_P4080: u32 = 1025;
pub const PCI_DEVICE_ID_P4040E: u32 = 1032;
pub const PCI_DEVICE_ID_P4040: u32 = 1033;
pub const PCI_DEVICE_ID_P2040E: u32 = 1040;
pub const PCI_DEVICE_ID_P2040: u32 = 1041;
pub const PCI_DEVICE_ID_P3041E: u32 = 1054;
pub const PCI_DEVICE_ID_P3041: u32 = 1055;
pub const PCI_DEVICE_ID_P5020E: u32 = 1056;
pub const PCI_DEVICE_ID_P5020: u32 = 1057;
pub const PCI_DEVICE_ID_P5010E: u32 = 1064;
pub const PCI_DEVICE_ID_P5010: u32 = 1065;
pub const PCI_DEVICE_ID_MPC8641: u32 = 28688;
pub const PCI_DEVICE_ID_MPC8641D: u32 = 28689;
pub const PCI_DEVICE_ID_MPC8610: u32 = 28696;
pub const PCI_VENDOR_ID_PASEMI: u32 = 6489;
pub const PCI_VENDOR_ID_ATTANSIC: u32 = 6505;
pub const PCI_DEVICE_ID_ATTANSIC_L1: u32 = 4168;
pub const PCI_DEVICE_ID_ATTANSIC_L2: u32 = 8264;
pub const PCI_VENDOR_ID_JMICRON: u32 = 6523;
pub const PCI_DEVICE_ID_JMICRON_JMB360: u32 = 9056;
pub const PCI_DEVICE_ID_JMICRON_JMB361: u32 = 9057;
pub const PCI_DEVICE_ID_JMICRON_JMB362: u32 = 9058;
pub const PCI_DEVICE_ID_JMICRON_JMB363: u32 = 9059;
pub const PCI_DEVICE_ID_JMICRON_JMB364: u32 = 9060;
pub const PCI_DEVICE_ID_JMICRON_JMB365: u32 = 9061;
pub const PCI_DEVICE_ID_JMICRON_JMB366: u32 = 9062;
pub const PCI_DEVICE_ID_JMICRON_JMB368: u32 = 9064;
pub const PCI_DEVICE_ID_JMICRON_JMB369: u32 = 9065;
pub const PCI_DEVICE_ID_JMICRON_JMB38X_SD: u32 = 9089;
pub const PCI_DEVICE_ID_JMICRON_JMB38X_MMC: u32 = 9090;
pub const PCI_DEVICE_ID_JMICRON_JMB38X_MS: u32 = 9091;
pub const PCI_DEVICE_ID_JMICRON_JMB385_MS: u32 = 9096;
pub const PCI_DEVICE_ID_JMICRON_JMB388_SD: u32 = 9105;
pub const PCI_DEVICE_ID_JMICRON_JMB388_ESD: u32 = 9106;
pub const PCI_DEVICE_ID_JMICRON_JMB390_MS: u32 = 9107;
pub const PCI_VENDOR_ID_KORENIX: u32 = 6530;
pub const PCI_DEVICE_ID_KORENIX_JETCARDF0: u32 = 5632;
pub const PCI_DEVICE_ID_KORENIX_JETCARDF1: u32 = 5887;
pub const PCI_DEVICE_ID_KORENIX_JETCARDF2: u32 = 5888;
pub const PCI_DEVICE_ID_KORENIX_JETCARDF3: u32 = 6143;
pub const PCI_VENDOR_ID_HUAWEI: u32 = 6629;
pub const PCI_DEVICE_ID_HUAWEI_ZIP_VF: u32 = 41553;
pub const PCI_DEVICE_ID_HUAWEI_SEC_VF: u32 = 41558;
pub const PCI_DEVICE_ID_HUAWEI_HPRE_VF: u32 = 41561;
pub const PCI_VENDOR_ID_NETRONOME: u32 = 6638;
pub const PCI_DEVICE_ID_NETRONOME_NFP3800: u32 = 14336;
pub const PCI_DEVICE_ID_NETRONOME_NFP4000: u32 = 16384;
pub const PCI_DEVICE_ID_NETRONOME_NFP5000: u32 = 20480;
pub const PCI_DEVICE_ID_NETRONOME_NFP6000: u32 = 24576;
pub const PCI_DEVICE_ID_NETRONOME_NFP3800_VF: u32 = 14339;
pub const PCI_DEVICE_ID_NETRONOME_NFP6000_VF: u32 = 24579;
pub const PCI_VENDOR_ID_QMI: u32 = 6706;
pub const PCI_VENDOR_ID_AZWAVE: u32 = 6715;
pub const PCI_VENDOR_ID_REDHAT_QUMRANET: u32 = 6900;
pub const PCI_SUBVENDOR_ID_REDHAT_QUMRANET: u32 = 6900;
pub const PCI_SUBDEVICE_ID_QEMU: u32 = 4352;
pub const PCI_VENDOR_ID_ASMEDIA: u32 = 6945;
pub const PCI_VENDOR_ID_REDHAT: u32 = 6966;
pub const PCI_VENDOR_ID_WCHIC: u32 = 7168;
pub const PCI_DEVICE_ID_WCHIC_CH382_0S1P: u32 = 12368;
pub const PCI_DEVICE_ID_WCHIC_CH382_2S1P: u32 = 12880;
pub const PCI_DEVICE_ID_WCHIC_CH382_2S: u32 = 12883;
pub const PCI_VENDOR_ID_SILICOM_DENMARK: u32 = 7212;
pub const PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS: u32 = 7222;
pub const PCI_VENDOR_ID_CIRCUITCO: u32 = 7368;
pub const PCI_SUBSYSTEM_ID_CIRCUITCO_MINNOWBOARD: u32 = 1;
pub const PCI_VENDOR_ID_AMAZON: u32 = 7439;
pub const PCI_VENDOR_ID_ZHAOXIN: u32 = 7447;
pub const PCI_VENDOR_ID_ROCKCHIP: u32 = 7559;
pub const PCI_VENDOR_ID_HYGON: u32 = 7572;
pub const PCI_VENDOR_ID_META: u32 = 7579;
pub const PCI_VENDOR_ID_FUNGIBLE: u32 = 7597;
pub const PCI_VENDOR_ID_HXT: u32 = 7615;
pub const PCI_VENDOR_ID_TEKRAM: u32 = 7649;
pub const PCI_DEVICE_ID_TEKRAM_DC290: u32 = 56361;
pub const PCI_VENDOR_ID_RPI: u32 = 7652;
pub const PCI_DEVICE_ID_RPI_RP1_C0: u32 = 1;
pub const PCI_VENDOR_ID_ALIBABA: u32 = 7661;
pub const PCI_VENDOR_ID_CXL: u32 = 7832;
pub const PCI_VENDOR_ID_TEHUTI: u32 = 8137;
pub const PCI_DEVICE_ID_TEHUTI_3009: u32 = 12297;
pub const PCI_DEVICE_ID_TEHUTI_3010: u32 = 12304;
pub const PCI_DEVICE_ID_TEHUTI_3014: u32 = 12308;
pub const PCI_VENDOR_ID_SUNIX: u32 = 8148;
pub const PCI_DEVICE_ID_SUNIX_1999: u32 = 6553;
pub const PCI_VENDOR_ID_HINT: u32 = 13192;
pub const PCI_DEVICE_ID_HINT_VXPROII_IDE: u32 = 32787;
pub const PCI_VENDOR_ID_3DLABS: u32 = 15677;
pub const PCI_DEVICE_ID_3DLABS_PERMEDIA2: u32 = 7;
pub const PCI_DEVICE_ID_3DLABS_PERMEDIA2V: u32 = 9;
pub const PCI_VENDOR_ID_NETXEN: u32 = 16448;
pub const PCI_DEVICE_ID_NX2031_10GXSR: u32 = 1;
pub const PCI_DEVICE_ID_NX2031_10GCX4: u32 = 2;
pub const PCI_DEVICE_ID_NX2031_4GCU: u32 = 3;
pub const PCI_DEVICE_ID_NX2031_IMEZ: u32 = 4;
pub const PCI_DEVICE_ID_NX2031_HMEZ: u32 = 5;
pub const PCI_DEVICE_ID_NX2031_XG_MGMT: u32 = 36;
pub const PCI_DEVICE_ID_NX2031_XG_MGMT2: u32 = 37;
pub const PCI_DEVICE_ID_NX3031: u32 = 256;
pub const PCI_VENDOR_ID_AKS: u32 = 16748;
pub const PCI_DEVICE_ID_AKS_ALADDINCARD: u32 = 256;
pub const PCI_VENDOR_ID_WCHCN: u32 = 17224;
pub const PCI_DEVICE_ID_WCHCN_CH353_4S: u32 = 13395;
pub const PCI_DEVICE_ID_WCHCN_CH353_2S1PF: u32 = 20550;
pub const PCI_DEVICE_ID_WCHCN_CH353_1S1P: u32 = 20563;
pub const PCI_DEVICE_ID_WCHCN_CH353_2S1P: u32 = 28755;
pub const PCI_VENDOR_ID_ACCESSIO: u32 = 18767;
pub const PCI_DEVICE_ID_ACCESSIO_WDG_CSM: u32 = 8896;
pub const PCI_VENDOR_ID_S3: u32 = 21299;
pub const PCI_DEVICE_ID_S3_TRIO: u32 = 34833;
pub const PCI_DEVICE_ID_S3_868: u32 = 34944;
pub const PCI_DEVICE_ID_S3_968: u32 = 35056;
pub const PCI_DEVICE_ID_S3_SAVAGE4: u32 = 35365;
pub const PCI_DEVICE_ID_S3_PROSAVAGE8: u32 = 36100;
pub const PCI_DEVICE_ID_S3_SONICVIBES: u32 = 51712;
pub const PCI_VENDOR_ID_DUNORD: u32 = 21828;
pub const PCI_DEVICE_ID_DUNORD_I3000: u32 = 1;
pub const PCI_VENDOR_ID_DCI: u32 = 26214;
pub const PCI_DEVICE_ID_DCI_PCCOM4: u32 = 1;
pub const PCI_DEVICE_ID_DCI_PCCOM8: u32 = 2;
pub const PCI_DEVICE_ID_DCI_PCCOM2: u32 = 4;
pub const PCI_VENDOR_ID_GLENFLY: u32 = 26470;
pub const PCI_VENDOR_ID_INTEL: u32 = 32902;
pub const PCI_DEVICE_ID_INTEL_EESSC: u32 = 8;
pub const PCI_DEVICE_ID_INTEL_HDA_CML_LP: u32 = 712;
pub const PCI_DEVICE_ID_INTEL_PXHD_0: u32 = 800;
pub const PCI_DEVICE_ID_INTEL_PXHD_1: u32 = 801;
pub const PCI_DEVICE_ID_INTEL_PXH_0: u32 = 809;
pub const PCI_DEVICE_ID_INTEL_PXH_1: u32 = 810;
pub const PCI_DEVICE_ID_INTEL_PXHV: u32 = 812;
pub const PCI_DEVICE_ID_INTEL_80332_0: u32 = 816;
pub const PCI_DEVICE_ID_INTEL_80332_1: u32 = 818;
pub const PCI_DEVICE_ID_INTEL_80333_0: u32 = 880;
pub const PCI_DEVICE_ID_INTEL_80333_1: u32 = 882;
pub const PCI_DEVICE_ID_INTEL_QAT_DH895XCC: u32 = 1077;
pub const PCI_DEVICE_ID_INTEL_QAT_DH895XCC_VF: u32 = 1091;
pub const PCI_DEVICE_ID_INTEL_82375: u32 = 1154;
pub const PCI_DEVICE_ID_INTEL_82424: u32 = 1155;
pub const PCI_DEVICE_ID_INTEL_82378: u32 = 1156;
pub const PCI_DEVICE_ID_INTEL_82425: u32 = 1158;
pub const PCI_DEVICE_ID_INTEL_HDA_CML_H: u32 = 1736;
pub const PCI_DEVICE_ID_INTEL_MRST_SD0: u32 = 2055;
pub const PCI_DEVICE_ID_INTEL_MRST_SD1: u32 = 2056;
pub const PCI_DEVICE_ID_INTEL_HDA_OAKTRAIL: u32 = 2058;
pub const PCI_DEVICE_ID_INTEL_MFD_SD: u32 = 2080;
pub const PCI_DEVICE_ID_INTEL_MFD_SDIO1: u32 = 2081;
pub const PCI_DEVICE_ID_INTEL_MFD_SDIO2: u32 = 2082;
pub const PCI_DEVICE_ID_INTEL_MFD_EMMC0: u32 = 2083;
pub const PCI_DEVICE_ID_INTEL_MFD_EMMC1: u32 = 2084;
pub const PCI_DEVICE_ID_INTEL_MRST_SD2: u32 = 2127;
pub const PCI_DEVICE_ID_INTEL_QUARK_X1000_ILB: u32 = 2398;
pub const PCI_DEVICE_ID_INTEL_I960: u32 = 2400;
pub const PCI_DEVICE_ID_INTEL_I960RM: u32 = 2402;
pub const PCI_DEVICE_ID_INTEL_HDA_HSW_0: u32 = 2572;
pub const PCI_DEVICE_ID_INTEL_DSA_SPR0: u32 = 2853;
pub const PCI_DEVICE_ID_INTEL_HDA_HSW_2: u32 = 3084;
pub const PCI_DEVICE_ID_INTEL_CENTERTON_ILB: u32 = 3168;
pub const PCI_DEVICE_ID_INTEL_IAX_SPR0: u32 = 3326;
pub const PCI_DEVICE_ID_INTEL_HDA_HSW_3: u32 = 3340;
pub const PCI_DEVICE_ID_INTEL_HDA_BYT: u32 = 3844;
pub const PCI_DEVICE_ID_INTEL_SST_BYT: u32 = 3880;
pub const PCI_DEVICE_ID_INTEL_8257X_SOL: u32 = 4194;
pub const PCI_DEVICE_ID_INTEL_82573E_SOL: u32 = 4229;
pub const PCI_DEVICE_ID_INTEL_82573L_SOL: u32 = 4239;
pub const PCI_DEVICE_ID_INTEL_82815_MC: u32 = 4400;
pub const PCI_DEVICE_ID_INTEL_82815_CGC: u32 = 4402;
pub const PCI_DEVICE_ID_INTEL_SST_TNG: u32 = 4506;
pub const PCI_DEVICE_ID_INTEL_82092AA_0: u32 = 4641;
pub const PCI_DEVICE_ID_INTEL_82437: u32 = 4653;
pub const PCI_DEVICE_ID_INTEL_82371FB_0: u32 = 4654;
pub const PCI_DEVICE_ID_INTEL_82371FB_1: u32 = 4656;
pub const PCI_DEVICE_ID_INTEL_82371MX: u32 = 4660;
pub const PCI_DEVICE_ID_INTEL_82441: u32 = 4663;
pub const PCI_DEVICE_ID_INTEL_82380FB: u32 = 4683;
pub const PCI_DEVICE_ID_INTEL_82439: u32 = 4688;
pub const PCI_DEVICE_ID_INTEL_LIGHT_RIDGE: u32 = 5395;
pub const PCI_DEVICE_ID_INTEL_EAGLE_RIDGE: u32 = 5402;
pub const PCI_DEVICE_ID_INTEL_LIGHT_PEAK: u32 = 5403;
pub const PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C: u32 = 5447;
pub const PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_2C: u32 = 5448;
pub const PCI_DEVICE_ID_INTEL_PORT_RIDGE: u32 = 5449;
pub const PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_2C_NHI: u32 = 5478;
pub const PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_2C_BRIDGE: u32 = 5479;
pub const PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_4C_NHI: u32 = 5480;
pub const PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_4C_BRIDGE: u32 = 5481;
pub const PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_NHI: u32 = 5482;
pub const PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_BRIDGE: u32 = 5483;
pub const PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI: u32 = 5484;
pub const PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_BRIDGE: u32 = 5485;
pub const PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_NHI: u32 = 5493;
pub const PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_BRIDGE: u32 = 5494;
pub const PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_NHI: u32 = 5495;
pub const PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_BRIDGE: u32 = 5496;
pub const PCI_DEVICE_ID_INTEL_HDA_BDW: u32 = 5644;
pub const PCI_DEVICE_ID_INTEL_80960_RP: u32 = 6496;
pub const PCI_DEVICE_ID_INTEL_QAT_C3XXX: u32 = 6626;
pub const PCI_DEVICE_ID_INTEL_QAT_C3XXX_VF: u32 = 6627;
pub const PCI_DEVICE_ID_INTEL_82840_HB: u32 = 6689;
pub const PCI_DEVICE_ID_INTEL_82845_HB: u32 = 6704;
pub const PCI_DEVICE_ID_INTEL_IOAT: u32 = 6712;
pub const PCI_DEVICE_ID_INTEL_HDA_CPT: u32 = 7200;
pub const PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MIN: u32 = 7233;
pub const PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MAX: u32 = 7263;
pub const PCI_DEVICE_ID_INTEL_HDA_PBG: u32 = 7456;
pub const PCI_DEVICE_ID_INTEL_PATSBURG_LPC_0: u32 = 7488;
pub const PCI_DEVICE_ID_INTEL_PATSBURG_LPC_1: u32 = 7489;
pub const PCI_DEVICE_ID_INTEL_HDA_PPT: u32 = 7712;
pub const PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI: u32 = 7729;
pub const PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MIN: u32 = 7744;
pub const PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MAX: u32 = 7775;
pub const PCI_DEVICE_ID_INTEL_VMD_201D: u32 = 8221;
pub const PCI_DEVICE_ID_INTEL_HDA_BSW: u32 = 8836;
pub const PCI_DEVICE_ID_INTEL_SST_BSW: u32 = 8872;
pub const PCI_DEVICE_ID_INTEL_DH89XXCC_LPC_MIN: u32 = 8976;
pub const PCI_DEVICE_ID_INTEL_DH89XXCC_LPC_MAX: u32 = 8991;
pub const PCI_DEVICE_ID_INTEL_82801AA_0: u32 = 9232;
pub const PCI_DEVICE_ID_INTEL_82801AA_1: u32 = 9233;
pub const PCI_DEVICE_ID_INTEL_82801AA_3: u32 = 9235;
pub const PCI_DEVICE_ID_INTEL_82801AA_5: u32 = 9237;
pub const PCI_DEVICE_ID_INTEL_82801AA_6: u32 = 9238;
pub const PCI_DEVICE_ID_INTEL_82801AA_8: u32 = 9240;
pub const PCI_DEVICE_ID_INTEL_82801AB_0: u32 = 9248;
pub const PCI_DEVICE_ID_INTEL_82801AB_1: u32 = 9249;
pub const PCI_DEVICE_ID_INTEL_82801AB_3: u32 = 9251;
pub const PCI_DEVICE_ID_INTEL_82801AB_5: u32 = 9253;
pub const PCI_DEVICE_ID_INTEL_82801AB_6: u32 = 9254;
pub const PCI_DEVICE_ID_INTEL_82801AB_8: u32 = 9256;
pub const PCI_DEVICE_ID_INTEL_82801BA_0: u32 = 9280;
pub const PCI_DEVICE_ID_INTEL_82801BA_2: u32 = 9283;
pub const PCI_DEVICE_ID_INTEL_82801BA_4: u32 = 9285;
pub const PCI_DEVICE_ID_INTEL_82801BA_6: u32 = 9288;
pub const PCI_DEVICE_ID_INTEL_82801BA_8: u32 = 9290;
pub const PCI_DEVICE_ID_INTEL_82801BA_9: u32 = 9291;
pub const PCI_DEVICE_ID_INTEL_82801BA_10: u32 = 9292;
pub const PCI_DEVICE_ID_INTEL_82801BA_11: u32 = 9294;
pub const PCI_DEVICE_ID_INTEL_82801E_0: u32 = 9296;
pub const PCI_DEVICE_ID_INTEL_82801E_11: u32 = 9307;
pub const PCI_DEVICE_ID_INTEL_82801CA_0: u32 = 9344;
pub const PCI_DEVICE_ID_INTEL_82801CA_3: u32 = 9347;
pub const PCI_DEVICE_ID_INTEL_82801CA_5: u32 = 9349;
pub const PCI_DEVICE_ID_INTEL_82801CA_6: u32 = 9350;
pub const PCI_DEVICE_ID_INTEL_82801CA_10: u32 = 9354;
pub const PCI_DEVICE_ID_INTEL_82801CA_11: u32 = 9355;
pub const PCI_DEVICE_ID_INTEL_82801CA_12: u32 = 9356;
pub const PCI_DEVICE_ID_INTEL_82801DB_0: u32 = 9408;
pub const PCI_DEVICE_ID_INTEL_82801DB_1: u32 = 9409;
pub const PCI_DEVICE_ID_INTEL_82801DB_2: u32 = 9410;
pub const PCI_DEVICE_ID_INTEL_82801DB_3: u32 = 9411;
pub const PCI_DEVICE_ID_INTEL_82801DB_5: u32 = 9413;
pub const PCI_DEVICE_ID_INTEL_82801DB_6: u32 = 9414;
pub const PCI_DEVICE_ID_INTEL_82801DB_9: u32 = 9417;
pub const PCI_DEVICE_ID_INTEL_82801DB_10: u32 = 9418;
pub const PCI_DEVICE_ID_INTEL_82801DB_11: u32 = 9419;
pub const PCI_DEVICE_ID_INTEL_82801DB_12: u32 = 9420;
pub const PCI_DEVICE_ID_INTEL_82801EB_0: u32 = 9424;
pub const PCI_DEVICE_ID_INTEL_82801EB_1: u32 = 9425;
pub const PCI_DEVICE_ID_INTEL_82801EB_3: u32 = 9427;
pub const PCI_DEVICE_ID_INTEL_82801EB_5: u32 = 9429;
pub const PCI_DEVICE_ID_INTEL_82801EB_6: u32 = 9430;
pub const PCI_DEVICE_ID_INTEL_82801EB_11: u32 = 9435;
pub const PCI_DEVICE_ID_INTEL_82801EB_12: u32 = 9436;
pub const PCI_DEVICE_ID_INTEL_82801EB_13: u32 = 9437;
pub const PCI_DEVICE_ID_INTEL_82820_HB: u32 = 9472;
pub const PCI_DEVICE_ID_INTEL_82820_UP_HB: u32 = 9473;
pub const PCI_DEVICE_ID_INTEL_82850_HB: u32 = 9520;
pub const PCI_DEVICE_ID_INTEL_82860_HB: u32 = 9521;
pub const PCI_DEVICE_ID_INTEL_E7501_MCH: u32 = 9548;
pub const PCI_DEVICE_ID_INTEL_7505_0: u32 = 9552;
pub const PCI_DEVICE_ID_INTEL_7205_0: u32 = 9565;
pub const PCI_DEVICE_ID_INTEL_82845G_HB: u32 = 9568;
pub const PCI_DEVICE_ID_INTEL_82845G_IG: u32 = 9570;
pub const PCI_DEVICE_ID_INTEL_82865_HB: u32 = 9584;
pub const PCI_DEVICE_ID_INTEL_82865_IG: u32 = 9586;
pub const PCI_DEVICE_ID_INTEL_82875_HB: u32 = 9592;
pub const PCI_DEVICE_ID_INTEL_82915G_HB: u32 = 9600;
pub const PCI_DEVICE_ID_INTEL_82915G_IG: u32 = 9602;
pub const PCI_DEVICE_ID_INTEL_82915GM_HB: u32 = 9616;
pub const PCI_DEVICE_ID_INTEL_82915GM_IG: u32 = 9618;
pub const PCI_DEVICE_ID_INTEL_ESB_1: u32 = 9633;
pub const PCI_DEVICE_ID_INTEL_ESB_2: u32 = 9634;
pub const PCI_DEVICE_ID_INTEL_ESB_4: u32 = 9636;
pub const PCI_DEVICE_ID_INTEL_ESB_5: u32 = 9638;
pub const PCI_DEVICE_ID_INTEL_ESB_9: u32 = 9643;
pub const PCI_DEVICE_ID_INTEL_ESB_10: u32 = 9644;
pub const PCI_DEVICE_ID_INTEL_5000_ERR: u32 = 9712;
pub const PCI_DEVICE_ID_INTEL_5000_FBD0: u32 = 9717;
pub const PCI_DEVICE_ID_INTEL_5000_FBD1: u32 = 9718;
pub const PCI_DEVICE_ID_INTEL_ICH6_0: u32 = 9792;
pub const PCI_DEVICE_ID_INTEL_ICH6_1: u32 = 9793;
pub const PCI_DEVICE_ID_INTEL_ICH6_2: u32 = 9794;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH6: u32 = 9832;
pub const PCI_DEVICE_ID_INTEL_ICH6_16: u32 = 9834;
pub const PCI_DEVICE_ID_INTEL_ICH6_17: u32 = 9837;
pub const PCI_DEVICE_ID_INTEL_ICH6_18: u32 = 9838;
pub const PCI_DEVICE_ID_INTEL_ICH6_19: u32 = 9839;
pub const PCI_DEVICE_ID_INTEL_ESB2_0: u32 = 9840;
pub const PCI_DEVICE_ID_INTEL_ESB2_14: u32 = 9880;
pub const PCI_DEVICE_ID_INTEL_HDA_ESB2: u32 = 9882;
pub const PCI_DEVICE_ID_INTEL_ESB2_17: u32 = 9883;
pub const PCI_DEVICE_ID_INTEL_ESB2_18: u32 = 9886;
pub const PCI_DEVICE_ID_INTEL_82945G_HB: u32 = 10096;
pub const PCI_DEVICE_ID_INTEL_82945G_IG: u32 = 10098;
pub const PCI_DEVICE_ID_INTEL_3000_HB: u32 = 10104;
pub const PCI_DEVICE_ID_INTEL_82945GM_HB: u32 = 10144;
pub const PCI_DEVICE_ID_INTEL_82945GM_IG: u32 = 10146;
pub const PCI_DEVICE_ID_INTEL_ICH7_30: u32 = 10160;
pub const PCI_DEVICE_ID_INTEL_ICH7_0: u32 = 10168;
pub const PCI_DEVICE_ID_INTEL_ICH7_1: u32 = 10169;
pub const PCI_DEVICE_ID_INTEL_TGP_LPC: u32 = 10172;
pub const PCI_DEVICE_ID_INTEL_ICH7_31: u32 = 10173;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH7: u32 = 10200;
pub const PCI_DEVICE_ID_INTEL_ICH7_17: u32 = 10202;
pub const PCI_DEVICE_ID_INTEL_ICH7_19: u32 = 10205;
pub const PCI_DEVICE_ID_INTEL_ICH7_20: u32 = 10206;
pub const PCI_DEVICE_ID_INTEL_ICH7_21: u32 = 10207;
pub const PCI_DEVICE_ID_INTEL_ICH8_0: u32 = 10256;
pub const PCI_DEVICE_ID_INTEL_ICH8_1: u32 = 10257;
pub const PCI_DEVICE_ID_INTEL_ICH8_2: u32 = 10258;
pub const PCI_DEVICE_ID_INTEL_ICH8_3: u32 = 10260;
pub const PCI_DEVICE_ID_INTEL_ICH8_4: u32 = 10261;
pub const PCI_DEVICE_ID_INTEL_ICH8_5: u32 = 10302;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH8: u32 = 10315;
pub const PCI_DEVICE_ID_INTEL_ICH8_6: u32 = 10320;
pub const PCI_DEVICE_ID_INTEL_VMD_28C0: u32 = 10432;
pub const PCI_DEVICE_ID_INTEL_ICH9_0: u32 = 10512;
pub const PCI_DEVICE_ID_INTEL_ICH9_2: u32 = 10514;
pub const PCI_DEVICE_ID_INTEL_ICH9_3: u32 = 10515;
pub const PCI_DEVICE_ID_INTEL_ICH9_4: u32 = 10516;
pub const PCI_DEVICE_ID_INTEL_ICH9_7: u32 = 10518;
pub const PCI_DEVICE_ID_INTEL_ICH9_1: u32 = 10519;
pub const PCI_DEVICE_ID_INTEL_ICH9_8: u32 = 10520;
pub const PCI_DEVICE_ID_INTEL_ICH9_5: u32 = 10521;
pub const PCI_DEVICE_ID_INTEL_ICH9_6: u32 = 10544;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH9_0: u32 = 10558;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH9_1: u32 = 10559;
pub const PCI_DEVICE_ID_INTEL_I7_MCR: u32 = 11288;
pub const PCI_DEVICE_ID_INTEL_I7_MC_TAD: u32 = 11289;
pub const PCI_DEVICE_ID_INTEL_I7_MC_RAS: u32 = 11290;
pub const PCI_DEVICE_ID_INTEL_I7_MC_TEST: u32 = 11292;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL: u32 = 11296;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR: u32 = 11297;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH0_RANK: u32 = 11298;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH0_TC: u32 = 11299;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH1_CTRL: u32 = 11304;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH1_ADDR: u32 = 11305;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH1_RANK: u32 = 11306;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH1_TC: u32 = 11307;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH2_CTRL: u32 = 11312;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR: u32 = 11313;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK: u32 = 11314;
pub const PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC: u32 = 11315;
pub const PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT: u32 = 11328;
pub const PCI_DEVICE_ID_INTEL_I7_NONCORE: u32 = 11329;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE: u32 = 11344;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT: u32 = 11345;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2: u32 = 11376;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_SAD: u32 = 11393;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0: u32 = 11408;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_PHY0: u32 = 11409;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR: u32 = 11416;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD: u32 = 11417;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST: u32 = 11420;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL: u32 = 11424;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR: u32 = 11425;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK: u32 = 11426;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC: u32 = 11427;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL: u32 = 11432;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR: u32 = 11433;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK: u32 = 11434;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC: u32 = 11435;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR_REV2: u32 = 11672;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD_REV2: u32 = 11673;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_RAS_REV2: u32 = 11674;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST_REV2: u32 = 11676;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL_REV2: u32 = 11680;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR_REV2: u32 = 11681;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK_REV2: u32 = 11682;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC_REV2: u32 = 11683;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL_REV2: u32 = 11688;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR_REV2: u32 = 11689;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK_REV2: u32 = 11690;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC_REV2: u32 = 11691;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_CTRL_REV2: u32 = 11696;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_ADDR_REV2: u32 = 11697;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_RANK_REV2: u32 = 11698;
pub const PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_TC_REV2: u32 = 11699;
pub const PCI_DEVICE_ID_INTEL_HDA_GML: u32 = 12696;
pub const PCI_DEVICE_ID_INTEL_82855PM_HB: u32 = 13120;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG4: u32 = 13353;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG5: u32 = 13354;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG6: u32 = 13355;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG7: u32 = 13356;
pub const PCI_DEVICE_ID_INTEL_X58_HUB_MGMT: u32 = 13358;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG0: u32 = 13360;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG1: u32 = 13361;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG2: u32 = 13362;
pub const PCI_DEVICE_ID_INTEL_IOAT_TBG3: u32 = 13363;
pub const PCI_DEVICE_ID_INTEL_HDA_ICL_LP: u32 = 13512;
pub const PCI_DEVICE_ID_INTEL_82830_HB: u32 = 13685;
pub const PCI_DEVICE_ID_INTEL_82830_CGC: u32 = 13687;
pub const PCI_DEVICE_ID_INTEL_82855GM_HB: u32 = 13696;
pub const PCI_DEVICE_ID_INTEL_82855GM_IG: u32 = 13698;
pub const PCI_DEVICE_ID_INTEL_82854_HB: u32 = 13708;
pub const PCI_DEVICE_ID_INTEL_82854_IG: u32 = 13710;
pub const PCI_DEVICE_ID_INTEL_E7520_MCH: u32 = 13712;
pub const PCI_DEVICE_ID_INTEL_E7320_MCH: u32 = 13714;
pub const PCI_DEVICE_ID_INTEL_MCH_PA: u32 = 13717;
pub const PCI_DEVICE_ID_INTEL_MCH_PA1: u32 = 13718;
pub const PCI_DEVICE_ID_INTEL_MCH_PB: u32 = 13719;
pub const PCI_DEVICE_ID_INTEL_MCH_PB1: u32 = 13720;
pub const PCI_DEVICE_ID_INTEL_MCH_PC: u32 = 13721;
pub const PCI_DEVICE_ID_INTEL_MCH_PC1: u32 = 13722;
pub const PCI_DEVICE_ID_INTEL_E7525_MCH: u32 = 13726;
pub const PCI_DEVICE_ID_INTEL_IOAT_CNB: u32 = 13835;
pub const PCI_DEVICE_ID_INTEL_FBD_CNB: u32 = 13836;
pub const PCI_DEVICE_ID_INTEL_I7300_MCH_ERR: u32 = 13836;
pub const PCI_DEVICE_ID_INTEL_I7300_MCH_FB0: u32 = 13839;
pub const PCI_DEVICE_ID_INTEL_I7300_MCH_FB1: u32 = 13840;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF0: u32 = 14096;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF1: u32 = 14097;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF2: u32 = 14098;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF3: u32 = 14099;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF4: u32 = 14100;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF5: u32 = 14101;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF6: u32 = 14102;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF7: u32 = 14103;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF8: u32 = 14104;
pub const PCI_DEVICE_ID_INTEL_IOAT_JSF9: u32 = 14105;
pub const PCI_DEVICE_ID_INTEL_QAT_C62X: u32 = 14280;
pub const PCI_DEVICE_ID_INTEL_QAT_C62X_VF: u32 = 14281;
pub const PCI_DEVICE_ID_INTEL_HDA_ICL_N: u32 = 14536;
pub const PCI_DEVICE_ID_INTEL_ICH10_0: u32 = 14868;
pub const PCI_DEVICE_ID_INTEL_ICH10_1: u32 = 14870;
pub const PCI_DEVICE_ID_INTEL_ICH10_2: u32 = 14872;
pub const PCI_DEVICE_ID_INTEL_ICH10_3: u32 = 14874;
pub const PCI_DEVICE_ID_INTEL_ICH10_4: u32 = 14896;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH10_0: u32 = 14910;
pub const PCI_DEVICE_ID_INTEL_ICH10_5: u32 = 14944;
pub const PCI_DEVICE_ID_INTEL_HDA_ICH10_1: u32 = 14958;
pub const PCI_DEVICE_ID_INTEL_5_3400_SERIES_LPC_MIN: u32 = 15104;
pub const PCI_DEVICE_ID_INTEL_5_3400_SERIES_LPC_MAX: u32 = 15135;
pub const PCI_DEVICE_ID_INTEL_HDA_5_3400_SERIES_0: u32 = 15190;
pub const PCI_DEVICE_ID_INTEL_HDA_5_3400_SERIES_1: u32 = 15191;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB0: u32 = 15392;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB1: u32 = 15393;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB2: u32 = 15394;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB3: u32 = 15395;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB4: u32 = 15396;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB5: u32 = 15397;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB6: u32 = 15398;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB7: u32 = 15399;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB8: u32 = 15406;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB9: u32 = 15407;
pub const PCI_DEVICE_ID_INTEL_UNC_QPI0: u32 = 15425;
pub const PCI_DEVICE_ID_INTEL_UNC_QPI1: u32 = 15426;
pub const PCI_DEVICE_ID_INTEL_UNC_R2PCIE: u32 = 15427;
pub const PCI_DEVICE_ID_INTEL_UNC_R3QPI0: u32 = 15428;
pub const PCI_DEVICE_ID_INTEL_UNC_R3QPI1: u32 = 15429;
pub const PCI_DEVICE_ID_INTEL_UNC_HA: u32 = 15430;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_RAS: u32 = 15473;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR0: u32 = 15474;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR1: u32 = 15475;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR2: u32 = 15478;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR3: u32 = 15479;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_HA0: u32 = 15520;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TA: u32 = 15528;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD0: u32 = 15530;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD1: u32 = 15531;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD2: u32 = 15532;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD3: u32 = 15533;
pub const PCI_DEVICE_ID_INTEL_UNC_IMC0: u32 = 15536;
pub const PCI_DEVICE_ID_INTEL_UNC_IMC1: u32 = 15537;
pub const PCI_DEVICE_ID_INTEL_UNC_IMC2: u32 = 15540;
pub const PCI_DEVICE_ID_INTEL_UNC_IMC3: u32 = 15541;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_DDRIO: u32 = 15544;
pub const PCI_DEVICE_ID_INTEL_JAKETOWN_UBOX: u32 = 15584;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_SAD0: u32 = 15604;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_BR: u32 = 15605;
pub const PCI_DEVICE_ID_INTEL_SBRIDGE_SAD1: u32 = 15606;
pub const PCI_DEVICE_ID_INTEL_HDA_ICL_H: u32 = 15816;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB: u32 = 16431;
pub const PCI_DEVICE_ID_INTEL_5400_ERR: u32 = 16432;
pub const PCI_DEVICE_ID_INTEL_5400_FBD0: u32 = 16437;
pub const PCI_DEVICE_ID_INTEL_5400_FBD1: u32 = 16438;
pub const PCI_DEVICE_ID_INTEL_HDA_TGL_H: u32 = 17352;
pub const PCI_DEVICE_ID_INTEL_HDA_DG1: u32 = 18701;
pub const PCI_DEVICE_ID_INTEL_HDA_EHL_0: u32 = 19285;
pub const PCI_DEVICE_ID_INTEL_HDA_EHL_3: u32 = 19288;
pub const PCI_DEVICE_ID_INTEL_HDA_WCL: u32 = 19752;
pub const PCI_DEVICE_ID_INTEL_HDA_JSL_N: u32 = 19912;
pub const PCI_DEVICE_ID_INTEL_HDA_DG2_0: u32 = 20368;
pub const PCI_DEVICE_ID_INTEL_HDA_DG2_1: u32 = 20369;
pub const PCI_DEVICE_ID_INTEL_HDA_DG2_2: u32 = 20370;
pub const PCI_DEVICE_ID_INTEL_EP80579_0: u32 = 20529;
pub const PCI_DEVICE_ID_INTEL_EP80579_1: u32 = 20530;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_P: u32 = 20936;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_PS: u32 = 20937;
pub const PCI_DEVICE_ID_INTEL_HDA_RPL_P_0: u32 = 20938;
pub const PCI_DEVICE_ID_INTEL_HDA_RPL_P_1: u32 = 20939;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_M: u32 = 20940;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_PX: u32 = 20941;
pub const PCI_DEVICE_ID_INTEL_HDA_RPL_M: u32 = 20942;
pub const PCI_DEVICE_ID_INTEL_HDA_RPL_PX: u32 = 20943;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_N: u32 = 21704;
pub const PCI_DEVICE_ID_INTEL_HDA_APL: u32 = 23192;
pub const PCI_DEVICE_ID_INTEL_5100_16: u32 = 26096;
pub const PCI_DEVICE_ID_INTEL_5100_19: u32 = 26099;
pub const PCI_DEVICE_ID_INTEL_5100_21: u32 = 26101;
pub const PCI_DEVICE_ID_INTEL_5100_22: u32 = 26102;
pub const PCI_DEVICE_ID_INTEL_IOAT_SCNB: u32 = 26111;
pub const PCI_DEVICE_ID_INTEL_HDA_FCL: u32 = 26536;
pub const PCI_DEVICE_ID_INTEL_82371SB_0: u32 = 28672;
pub const PCI_DEVICE_ID_INTEL_82371SB_1: u32 = 28688;
pub const PCI_DEVICE_ID_INTEL_82371SB_2: u32 = 28704;
pub const PCI_DEVICE_ID_INTEL_82437VX: u32 = 28720;
pub const PCI_DEVICE_ID_INTEL_82439TX: u32 = 28928;
pub const PCI_DEVICE_ID_INTEL_82371AB_0: u32 = 28944;
pub const PCI_DEVICE_ID_INTEL_82371AB: u32 = 28945;
pub const PCI_DEVICE_ID_INTEL_82371AB_2: u32 = 28946;
pub const PCI_DEVICE_ID_INTEL_82371AB_3: u32 = 28947;
pub const PCI_DEVICE_ID_INTEL_82810_MC1: u32 = 28960;
pub const PCI_DEVICE_ID_INTEL_82810_IG1: u32 = 28961;
pub const PCI_DEVICE_ID_INTEL_82810_MC3: u32 = 28962;
pub const PCI_DEVICE_ID_INTEL_82810_IG3: u32 = 28963;
pub const PCI_DEVICE_ID_INTEL_82810E_MC: u32 = 28964;
pub const PCI_DEVICE_ID_INTEL_82810E_IG: u32 = 28965;
pub const PCI_DEVICE_ID_INTEL_82443LX_0: u32 = 29056;
pub const PCI_DEVICE_ID_INTEL_82443LX_1: u32 = 29057;
pub const PCI_DEVICE_ID_INTEL_82443BX_0: u32 = 29072;
pub const PCI_DEVICE_ID_INTEL_82443BX_1: u32 = 29073;
pub const PCI_DEVICE_ID_INTEL_82443BX_2: u32 = 29074;
pub const PCI_DEVICE_ID_INTEL_440MX: u32 = 29077;
pub const PCI_DEVICE_ID_INTEL_440MX_6: u32 = 29078;
pub const PCI_DEVICE_ID_INTEL_82443MX_0: u32 = 29080;
pub const PCI_DEVICE_ID_INTEL_82443MX_1: u32 = 29081;
pub const PCI_DEVICE_ID_INTEL_82443MX_3: u32 = 29083;
pub const PCI_DEVICE_ID_INTEL_82443GX_0: u32 = 29088;
pub const PCI_DEVICE_ID_INTEL_82443GX_2: u32 = 29090;
pub const PCI_DEVICE_ID_INTEL_82372FB_1: u32 = 30209;
pub const PCI_DEVICE_ID_INTEL_HDA_ARL: u32 = 30504;
pub const PCI_DEVICE_ID_INTEL_HDA_RPL_S: u32 = 31312;
pub const PCI_DEVICE_ID_INTEL_HDA_ADL_S: u32 = 31440;
pub const PCI_DEVICE_ID_INTEL_HDA_MTL: u32 = 32296;
pub const PCI_DEVICE_ID_INTEL_HDA_ARL_S: u32 = 32592;
pub const PCI_DEVICE_ID_INTEL_SCH_LPC: u32 = 33049;
pub const PCI_DEVICE_ID_INTEL_SCH_IDE: u32 = 33050;
pub const PCI_DEVICE_ID_INTEL_HDA_POULSBO: u32 = 33051;
pub const PCI_DEVICE_ID_INTEL_E6XX_CU: u32 = 33155;
pub const PCI_DEVICE_ID_INTEL_ITC_LPC: u32 = 33158;
pub const PCI_DEVICE_ID_INTEL_82454GX: u32 = 33988;
pub const PCI_DEVICE_ID_INTEL_82450GX: u32 = 33989;
pub const PCI_DEVICE_ID_INTEL_82451NX: u32 = 33994;
pub const PCI_DEVICE_ID_INTEL_82454NX: u32 = 33995;
pub const PCI_DEVICE_ID_INTEL_84460GX: u32 = 34026;
pub const PCI_DEVICE_ID_INTEL_IXP4XX: u32 = 34048;
pub const PCI_DEVICE_ID_INTEL_HDA_LPT: u32 = 35872;
pub const PCI_DEVICE_ID_INTEL_HDA_9_SERIES: u32 = 36000;
pub const PCI_DEVICE_ID_INTEL_HDA_WBG_0: u32 = 36128;
pub const PCI_DEVICE_ID_INTEL_HDA_WBG_1: u32 = 36129;
pub const PCI_DEVICE_ID_INTEL_IXP2800: u32 = 36868;
pub const PCI_DEVICE_ID_INTEL_HDA_LKF: u32 = 39112;
pub const PCI_DEVICE_ID_INTEL_VMD_9A0B: u32 = 39435;
pub const PCI_DEVICE_ID_INTEL_HDA_LPT_LP_0: u32 = 39968;
pub const PCI_DEVICE_ID_INTEL_HDA_LPT_LP_1: u32 = 39969;
pub const PCI_DEVICE_ID_INTEL_HDA_WPT_LP: u32 = 40096;
pub const PCI_DEVICE_ID_INTEL_HDA_SKL_LP: u32 = 40304;
pub const PCI_DEVICE_ID_INTEL_HDA_KBL_LP: u32 = 40305;
pub const PCI_DEVICE_ID_INTEL_HDA_CNL_LP: u32 = 40392;
pub const PCI_DEVICE_ID_INTEL_HDA_TGL_LP: u32 = 41160;
pub const PCI_DEVICE_ID_INTEL_HDA_SKL: u32 = 41328;
pub const PCI_DEVICE_ID_INTEL_HDA_KBL: u32 = 41329;
pub const PCI_DEVICE_ID_INTEL_HDA_LBG_0: u32 = 41456;
pub const PCI_DEVICE_ID_INTEL_HDA_LBG_1: u32 = 41584;
pub const PCI_DEVICE_ID_INTEL_HDA_KBL_H: u32 = 41712;
pub const PCI_DEVICE_ID_INTEL_HDA_CNL_H: u32 = 41800;
pub const PCI_DEVICE_ID_INTEL_HDA_CML_S: u32 = 41968;
pub const PCI_DEVICE_ID_INTEL_HDA_LNL_P: u32 = 43048;
pub const PCI_DEVICE_ID_INTEL_S21152BB: u32 = 45394;
pub const PCI_DEVICE_ID_INTEL_HDA_BMG: u32 = 58103;
pub const PCI_DEVICE_ID_INTEL_HDA_PTL_H: u32 = 58152;
pub const PCI_DEVICE_ID_INTEL_HDA_PTL: u32 = 58408;
pub const PCI_DEVICE_ID_INTEL_HDA_CML_R: u32 = 61640;
pub const PCI_DEVICE_ID_INTEL_HDA_RKL_S: u32 = 61896;
pub const PCI_VENDOR_ID_WANGXUN: u32 = 32904;
pub const PCI_VENDOR_ID_SCALEMP: u32 = 34438;
pub const PCI_DEVICE_ID_SCALEMP_VSMP_CTL: u32 = 4112;
pub const PCI_VENDOR_ID_COMPUTONE: u32 = 36366;
pub const PCI_DEVICE_ID_COMPUTONE_PG: u32 = 770;
pub const PCI_SUBVENDOR_ID_COMPUTONE: u32 = 36366;
pub const PCI_SUBDEVICE_ID_COMPUTONE_PG4: u32 = 1;
pub const PCI_SUBDEVICE_ID_COMPUTONE_PG8: u32 = 2;
pub const PCI_SUBDEVICE_ID_COMPUTONE_PG6: u32 = 3;
pub const PCI_VENDOR_ID_KTI: u32 = 36398;
pub const PCI_VENDOR_ID_ADAPTEC: u32 = 36868;
pub const PCI_DEVICE_ID_ADAPTEC_7810: u32 = 4216;
pub const PCI_DEVICE_ID_ADAPTEC_7821: u32 = 8568;
pub const PCI_DEVICE_ID_ADAPTEC_38602: u32 = 14432;
pub const PCI_DEVICE_ID_ADAPTEC_7850: u32 = 20600;
pub const PCI_DEVICE_ID_ADAPTEC_7855: u32 = 21880;
pub const PCI_DEVICE_ID_ADAPTEC_3860: u32 = 24632;
pub const PCI_DEVICE_ID_ADAPTEC_1480A: u32 = 24693;
pub const PCI_DEVICE_ID_ADAPTEC_7860: u32 = 24696;
pub const PCI_DEVICE_ID_ADAPTEC_7861: u32 = 24952;
pub const PCI_DEVICE_ID_ADAPTEC_7870: u32 = 28792;
pub const PCI_DEVICE_ID_ADAPTEC_7871: u32 = 29048;
pub const PCI_DEVICE_ID_ADAPTEC_7872: u32 = 29304;
pub const PCI_DEVICE_ID_ADAPTEC_7873: u32 = 29560;
pub const PCI_DEVICE_ID_ADAPTEC_7874: u32 = 29816;
pub const PCI_DEVICE_ID_ADAPTEC_7895: u32 = 30869;
pub const PCI_DEVICE_ID_ADAPTEC_7880: u32 = 32888;
pub const PCI_DEVICE_ID_ADAPTEC_7881: u32 = 33144;
pub const PCI_DEVICE_ID_ADAPTEC_7882: u32 = 33400;
pub const PCI_DEVICE_ID_ADAPTEC_7883: u32 = 33656;
pub const PCI_DEVICE_ID_ADAPTEC_7884: u32 = 33912;
pub const PCI_DEVICE_ID_ADAPTEC_7885: u32 = 34168;
pub const PCI_DEVICE_ID_ADAPTEC_7886: u32 = 34424;
pub const PCI_DEVICE_ID_ADAPTEC_7887: u32 = 34680;
pub const PCI_DEVICE_ID_ADAPTEC_7888: u32 = 34936;
pub const PCI_VENDOR_ID_ADAPTEC2: u32 = 36869;
pub const PCI_DEVICE_ID_ADAPTEC2_2940U2: u32 = 16;
pub const PCI_DEVICE_ID_ADAPTEC2_2930U2: u32 = 17;
pub const PCI_DEVICE_ID_ADAPTEC2_7890B: u32 = 19;
pub const PCI_DEVICE_ID_ADAPTEC2_7890: u32 = 31;
pub const PCI_DEVICE_ID_ADAPTEC2_3940U2: u32 = 80;
pub const PCI_DEVICE_ID_ADAPTEC2_3950U2D: u32 = 81;
pub const PCI_DEVICE_ID_ADAPTEC2_7896: u32 = 95;
pub const PCI_DEVICE_ID_ADAPTEC2_7892A: u32 = 128;
pub const PCI_DEVICE_ID_ADAPTEC2_7892B: u32 = 129;
pub const PCI_DEVICE_ID_ADAPTEC2_7892D: u32 = 131;
pub const PCI_DEVICE_ID_ADAPTEC2_7892P: u32 = 143;
pub const PCI_DEVICE_ID_ADAPTEC2_7899A: u32 = 192;
pub const PCI_DEVICE_ID_ADAPTEC2_7899B: u32 = 193;
pub const PCI_DEVICE_ID_ADAPTEC2_7899D: u32 = 195;
pub const PCI_DEVICE_ID_ADAPTEC2_7899P: u32 = 207;
pub const PCI_DEVICE_ID_ADAPTEC2_OBSIDIAN: u32 = 1280;
pub const PCI_DEVICE_ID_ADAPTEC2_SCAMP: u32 = 1283;
pub const PCI_VENDOR_ID_HOLTEK: u32 = 37906;
pub const PCI_DEVICE_ID_HOLTEK_6565: u32 = 25957;
pub const PCI_VENDOR_ID_NETMOS: u32 = 38672;
pub const PCI_DEVICE_ID_NETMOS_9705: u32 = 38661;
pub const PCI_DEVICE_ID_NETMOS_9715: u32 = 38677;
pub const PCI_DEVICE_ID_NETMOS_9735: u32 = 38709;
pub const PCI_DEVICE_ID_NETMOS_9745: u32 = 38725;
pub const PCI_DEVICE_ID_NETMOS_9755: u32 = 38741;
pub const PCI_DEVICE_ID_NETMOS_9805: u32 = 38917;
pub const PCI_DEVICE_ID_NETMOS_9815: u32 = 38933;
pub const PCI_DEVICE_ID_NETMOS_9835: u32 = 38965;
pub const PCI_DEVICE_ID_NETMOS_9845: u32 = 38981;
pub const PCI_DEVICE_ID_NETMOS_9855: u32 = 38997;
pub const PCI_DEVICE_ID_NETMOS_9865: u32 = 39013;
pub const PCI_DEVICE_ID_NETMOS_9900: u32 = 39168;
pub const PCI_DEVICE_ID_NETMOS_9901: u32 = 39169;
pub const PCI_DEVICE_ID_NETMOS_9904: u32 = 39172;
pub const PCI_DEVICE_ID_NETMOS_9912: u32 = 39186;
pub const PCI_DEVICE_ID_NETMOS_9922: u32 = 39202;
pub const PCI_VENDOR_ID_3COM_2: u32 = 42791;
pub const PCI_VENDOR_ID_SOLIDRUN: u32 = 53347;
pub const PCI_VENDOR_ID_DIGIUM: u32 = 53601;
pub const PCI_DEVICE_ID_DIGIUM_HFC4S: u32 = 46096;
pub const PCI_SUBVENDOR_ID_EXSYS: u32 = 55373;
pub const PCI_SUBDEVICE_ID_EXSYS_4014: u32 = 16404;
pub const PCI_SUBDEVICE_ID_EXSYS_4055: u32 = 16469;
pub const PCI_VENDOR_ID_TIGERJET: u32 = 57689;
pub const PCI_DEVICE_ID_TIGERJET_300: u32 = 1;
pub const PCI_DEVICE_ID_TIGERJET_100: u32 = 2;
pub const PCI_VENDOR_ID_XILINX_RME: u32 = 60000;
pub const PCI_DEVICE_ID_RME_DIGI32: u32 = 39062;
pub const PCI_DEVICE_ID_RME_DIGI32_PRO: u32 = 39063;
pub const PCI_DEVICE_ID_RME_DIGI32_8: u32 = 39064;
pub const PCI_VENDOR_ID_XEN: u32 = 22611;
pub const PCI_DEVICE_ID_XEN_PLATFORM: u32 = 1;
pub const PCI_VENDOR_ID_OCZ: u32 = 7045;
pub const PCI_VENDOR_ID_NCUBE: u32 = 4351;
pub const PCI_STATUS_ERROR_BITS: u32 = 63744;
pub const PCI_NUM_RESET_METHODS: u32 = 8;
pub const PCI_BRIDGE_RESOURCE_NUM: u32 = 4;
pub const PCI_NUM_INTX: u32 = 4;
pub const PCI_ERROR_RESPONSE: i32 = -1;
pub const PCI_DOMAIN_NR_NOT_SET: i32 = -1;
pub const PCI_REGION_FLAG_MASK: u32 = 15;
pub const PCIBIOS_SUCCESSFUL: u32 = 0;
pub const PCIBIOS_FUNC_NOT_SUPPORTED: u32 = 129;
pub const PCIBIOS_BAD_VENDOR_ID: u32 = 131;
pub const PCIBIOS_DEVICE_NOT_FOUND: u32 = 134;
pub const PCIBIOS_BAD_REGISTER_NUMBER: u32 = 135;
pub const PCIBIOS_SET_FAILED: u32 = 136;
pub const PCIBIOS_BUFFER_TOO_SMALL: u32 = 137;
pub const PCI_IRQ_INTX: u32 = 1;
pub const PCI_IRQ_MSI: u32 = 2;
pub const PCI_IRQ_MSIX: u32 = 4;
pub const PCI_IRQ_AFFINITY: u32 = 8;
pub const HAVE_PCI_REQ_REGIONS: u32 = 2;
pub const PCI_VGA_STATE_CHANGE_BRIDGE: u32 = 1;
pub const PCI_VGA_STATE_CHANGE_DECODES: u32 = 2;
pub const PCI_IRQ_VIRTUAL: u32 = 16;
pub const PCI_IRQ_ALL_TYPES: u32 = 7;
pub const PCIE_PTM_CONTEXT_UPDATE_AUTO: u32 = 0;
pub const PCIE_PTM_CONTEXT_UPDATE_MANUAL: u32 = 1;
pub const PCIBIOS_MIN_IO: u32 = 4;
pub const PCIBIOS_MIN_MEM: u32 = 16;
pub const PCIPCI_FAIL: u32 = 1;
pub const PCIPCI_TRITON: u32 = 2;
pub const PCIPCI_NATOMA: u32 = 4;
pub const PCIPCI_VIAETBF: u32 = 8;
pub const PCIPCI_VSFX: u32 = 16;
pub const PCIPCI_ALIMAGIK: u32 = 32;
pub const PCIAGP_FAIL: u32 = 64;
pub const PCI_VPD_LRDT: u32 = 128;
pub const PCI_VPD_LTIN_ID_STRING: u32 = 2;
pub const PCI_VPD_LTIN_RO_DATA: u32 = 16;
pub const PCI_VPD_LTIN_RW_DATA: u32 = 17;
pub const PCI_VPD_RO_KEYWORD_PARTNO: &[u8; 3] = b"PN\0";
pub const PCI_VPD_RO_KEYWORD_SERIALNO: &[u8; 3] = b"SN\0";
pub const PCI_VPD_RO_KEYWORD_MFR_ID: &[u8; 3] = b"MN\0";
pub const PCI_VPD_RO_KEYWORD_VENDOR0: &[u8; 3] = b"V0\0";
pub const PCI_VPD_RO_KEYWORD_CHKSUM: &[u8; 3] = b"RV\0";
pub const LEDS_TRIG_TYPE_EDGE: u32 = 0;
pub const LEDS_TRIG_TYPE_LEVEL: u32 = 1;
pub const LEDS_BOOST_OFF: u32 = 0;
pub const LEDS_BOOST_ADAPTIVE: u32 = 1;
pub const LEDS_BOOST_FIXED: u32 = 2;
pub const LED_COLOR_ID_WHITE: u32 = 0;
pub const LED_COLOR_ID_RED: u32 = 1;
pub const LED_COLOR_ID_GREEN: u32 = 2;
pub const LED_COLOR_ID_BLUE: u32 = 3;
pub const LED_COLOR_ID_AMBER: u32 = 4;
pub const LED_COLOR_ID_VIOLET: u32 = 5;
pub const LED_COLOR_ID_YELLOW: u32 = 6;
pub const LED_COLOR_ID_IR: u32 = 7;
pub const LED_COLOR_ID_MULTI: u32 = 8;
pub const LED_COLOR_ID_RGB: u32 = 9;
pub const LED_COLOR_ID_PURPLE: u32 = 10;
pub const LED_COLOR_ID_ORANGE: u32 = 11;
pub const LED_COLOR_ID_PINK: u32 = 12;
pub const LED_COLOR_ID_CYAN: u32 = 13;
pub const LED_COLOR_ID_LIME: u32 = 14;
pub const LED_COLOR_ID_MAX: u32 = 15;
pub const LED_FUNCTION_CAPSLOCK: &[u8; 9] = b"capslock\0";
pub const LED_FUNCTION_SCROLLLOCK: &[u8; 11] = b"scrolllock\0";
pub const LED_FUNCTION_NUMLOCK: &[u8; 8] = b"numlock\0";
pub const LED_FUNCTION_FNLOCK: &[u8; 7] = b"fnlock\0";
pub const LED_FUNCTION_KBD_BACKLIGHT: &[u8; 14] = b"kbd_backlight\0";
pub const LED_FUNCTION_POWER: &[u8; 6] = b"power\0";
pub const LED_FUNCTION_DISK: &[u8; 5] = b"disk\0";
pub const LED_FUNCTION_CHARGING: &[u8; 9] = b"charging\0";
pub const LED_FUNCTION_STATUS: &[u8; 7] = b"status\0";
pub const LED_FUNCTION_MICMUTE: &[u8; 8] = b"micmute\0";
pub const LED_FUNCTION_MUTE: &[u8; 5] = b"mute\0";
pub const LED_FUNCTION_PLAYER1: &[u8; 9] = b"player-1\0";
pub const LED_FUNCTION_PLAYER2: &[u8; 9] = b"player-2\0";
pub const LED_FUNCTION_PLAYER3: &[u8; 9] = b"player-3\0";
pub const LED_FUNCTION_PLAYER4: &[u8; 9] = b"player-4\0";
pub const LED_FUNCTION_PLAYER5: &[u8; 9] = b"player-5\0";
pub const LED_FUNCTION_ACTIVITY: &[u8; 9] = b"activity\0";
pub const LED_FUNCTION_ALARM: &[u8; 6] = b"alarm\0";
pub const LED_FUNCTION_BACKLIGHT: &[u8; 10] = b"backlight\0";
pub const LED_FUNCTION_BLUETOOTH: &[u8; 10] = b"bluetooth\0";
pub const LED_FUNCTION_BOOT: &[u8; 5] = b"boot\0";
pub const LED_FUNCTION_CPU: &[u8; 4] = b"cpu\0";
pub const LED_FUNCTION_DEBUG: &[u8; 6] = b"debug\0";
pub const LED_FUNCTION_DISK_ACTIVITY: &[u8; 14] = b"disk-activity\0";
pub const LED_FUNCTION_DISK_ERR: &[u8; 9] = b"disk-err\0";
pub const LED_FUNCTION_DISK_READ: &[u8; 10] = b"disk-read\0";
pub const LED_FUNCTION_DISK_WRITE: &[u8; 11] = b"disk-write\0";
pub const LED_FUNCTION_FAULT: &[u8; 6] = b"fault\0";
pub const LED_FUNCTION_FLASH: &[u8; 6] = b"flash\0";
pub const LED_FUNCTION_HEARTBEAT: &[u8; 10] = b"heartbeat\0";
pub const LED_FUNCTION_INDICATOR: &[u8; 10] = b"indicator\0";
pub const LED_FUNCTION_LAN: &[u8; 4] = b"lan\0";
pub const LED_FUNCTION_MAIL: &[u8; 5] = b"mail\0";
pub const LED_FUNCTION_MOBILE: &[u8; 7] = b"mobile\0";
pub const LED_FUNCTION_MTD: &[u8; 4] = b"mtd\0";
pub const LED_FUNCTION_PANIC: &[u8; 6] = b"panic\0";
pub const LED_FUNCTION_PROGRAMMING: &[u8; 12] = b"programming\0";
pub const LED_FUNCTION_RX: &[u8; 3] = b"rx\0";
pub const LED_FUNCTION_SD: &[u8; 3] = b"sd\0";
pub const LED_FUNCTION_SPEED_LAN: &[u8; 10] = b"speed-lan\0";
pub const LED_FUNCTION_SPEED_WAN: &[u8; 10] = b"speed-wan\0";
pub const LED_FUNCTION_STANDBY: &[u8; 8] = b"standby\0";
pub const LED_FUNCTION_TORCH: &[u8; 6] = b"torch\0";
pub const LED_FUNCTION_TX: &[u8; 3] = b"tx\0";
pub const LED_FUNCTION_USB: &[u8; 4] = b"usb\0";
pub const LED_FUNCTION_WAN: &[u8; 4] = b"wan\0";
pub const LED_FUNCTION_WAN_ONLINE: &[u8; 11] = b"wan-online\0";
pub const LED_FUNCTION_WLAN: &[u8; 5] = b"wlan\0";
pub const LED_FUNCTION_WLAN_2GHZ: &[u8; 10] = b"wlan-2ghz\0";
pub const LED_FUNCTION_WLAN_5GHZ: &[u8; 10] = b"wlan-5ghz\0";
pub const LED_FUNCTION_WLAN_6GHZ: &[u8; 10] = b"wlan-6ghz\0";
pub const LED_FUNCTION_WPS: &[u8; 4] = b"wps\0";
pub const LED_BLINK_SW: u32 = 0;
pub const LED_BLINK_ONESHOT: u32 = 1;
pub const LED_BLINK_ONESHOT_STOP: u32 = 2;
pub const LED_BLINK_INVERT: u32 = 3;
pub const LED_BLINK_BRIGHTNESS_CHANGE: u32 = 4;
pub const LED_BLINK_DISABLE: u32 = 5;
pub const LED_SET_BRIGHTNESS_OFF: u32 = 6;
pub const LED_SET_BRIGHTNESS: u32 = 7;
pub const LED_SET_BLINK: u32 = 8;
pub const GPIO_LED_NO_BLINK_LOW: u32 = 0;
pub const GPIO_LED_NO_BLINK_HIGH: u32 = 1;
pub const GPIO_LED_BLINK: u32 = 2;
pub const MAX_UDELAY_MS: u32 = 5;
pub const PHY_POLL: i32 = -1;
pub const PHY_MAC_INTERRUPT: i32 = -2;
pub const PHY_IS_INTERNAL: u32 = 1;
pub const PHY_RST_AFTER_CLK_EN: u32 = 2;
pub const PHY_POLL_CABLE_TEST: u32 = 4;
pub const PHY_ALWAYS_CALL_SUSPEND: u32 = 8;
pub const MDIO_DEVICE_IS_PHY: u32 = 2147483648;
pub const PHY_MAX_ADDR: u32 = 32;
pub const PHY_ID_FMT: &[u8; 8] = b"%s:%02x\0";
pub const MII_BUS_ID_SIZE: u32 = 61;
pub const MDIO_MMD_NUM: u32 = 32;
pub const PHY_F_NO_IRQ: u32 = 2147483648;
pub const PHY_F_RXC_ALWAYS_ON: u32 = 1073741824;
pub const PHY_PAIR_ALL: i32 = -1;
pub const MAX_PID_NS_LEVEL: u32 = 32;
pub const MEMFD_NOEXEC_SCOPE_EXEC: u32 = 0;
pub const MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL: u32 = 1;
pub const MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED: u32 = 2;
pub const PIDNS_ADDING: u32 = 2147483648;
pub const PLATFORM_DEVID_NONE: i32 = -1;
pub const PLATFORM_DEVID_AUTO: i32 = -2;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLRDNORM: u32 = 64;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRNORM: u32 = 256;
pub const POLLWRBAND: u32 = 512;
pub const POLLMSG: u32 = 1024;
pub const POLLREMOVE: u32 = 4096;
pub const POLLRDHUP: u32 = 8192;
pub const EPOLL_CLOEXEC: u32 = 524288;
pub const EPOLL_CTL_ADD: u32 = 1;
pub const EPOLL_CTL_DEL: u32 = 2;
pub const EPOLL_CTL_MOD: u32 = 3;
pub const EPOLL_IOC_TYPE: u32 = 138;
pub const MAX_STACK_ALLOC: u32 = 832;
pub const FRONTEND_STACK_ALLOC: u32 = 256;
pub const SELECT_STACK_ALLOC: u32 = 256;
pub const POLL_STACK_ALLOC: u32 = 256;
pub const WQUEUES_STACK_ALLOC: u32 = 576;
pub const PREFERRED_MAX_PAGECACHE_ORDER: u32 = 8;
pub const MPOL_F_STATIC_NODES: u32 = 32768;
pub const MPOL_F_RELATIVE_NODES: u32 = 16384;
pub const MPOL_F_NUMA_BALANCING: u32 = 8192;
pub const MPOL_MODE_FLAGS: u32 = 57344;
pub const MPOL_F_NODE: u32 = 1;
pub const MPOL_F_ADDR: u32 = 2;
pub const MPOL_F_MEMS_ALLOWED: u32 = 4;
pub const MPOL_MF_STRICT: u32 = 1;
pub const MPOL_MF_MOVE: u32 = 2;
pub const MPOL_MF_MOVE_ALL: u32 = 4;
pub const MPOL_MF_LAZY: u32 = 8;
pub const MPOL_MF_INTERNAL: u32 = 16;
pub const MPOL_MF_VALID: u32 = 7;
pub const MPOL_F_SHARED: u32 = 1;
pub const MPOL_F_MOF: u32 = 8;
pub const MPOL_F_MORON: u32 = 16;
pub const RECLAIM_ZONE: u32 = 1;
pub const RECLAIM_WRITE: u32 = 2;
pub const RECLAIM_UNMAP: u32 = 4;
pub const SWAP_FLAG_PREFER: u32 = 32768;
pub const SWAP_FLAG_PRIO_MASK: u32 = 32767;
pub const SWAP_FLAG_DISCARD: u32 = 65536;
pub const SWAP_FLAG_DISCARD_ONCE: u32 = 131072;
pub const SWAP_FLAG_DISCARD_PAGES: u32 = 262144;
pub const SWAP_FLAGS_VALID: u32 = 524287;
pub const SWAP_BATCH: u32 = 64;
pub const MAX_SWAPFILES_SHIFT: u32 = 5;
pub const SWP_PTE_MARKER_NUM: u32 = 1;
pub const SWP_DEVICE_NUM: u32 = 0;
pub const SWP_MIGRATION_NUM: u32 = 3;
pub const SWP_HWPOISON_NUM: u32 = 0;
pub const MAX_SWAPFILES: u32 = 28;
pub const SWAP_CLUSTER_MAX: u32 = 32;
pub const SWAP_CLUSTER_MAX_SKIPPED: u32 = 32768;
pub const COMPACT_CLUSTER_MAX: u32 = 32;
pub const SWAP_HAS_CACHE: u32 = 64;
pub const COUNT_CONTINUED: u32 = 128;
pub const SWAP_MAP_MAX: u32 = 62;
pub const SWAP_MAP_BAD: u32 = 63;
pub const SWAP_MAP_SHMEM: u32 = 191;
pub const SWAP_CONT_MAX: u32 = 127;
pub const SWAP_ENTRY_INVALID: u32 = 0;
pub const SWAP_NR_ORDERS: u32 = 1;
pub const MEMCG_RECLAIM_MAY_SWAP: u32 = 2;
pub const MEMCG_RECLAIM_PROACTIVE: u32 = 4;
pub const MIN_SWAPPINESS: u32 = 0;
pub const MAX_SWAPPINESS: u32 = 200;
pub const SWAPPINESS_ANON_ONLY: u32 = 201;
pub const PM_HIBERNATION_PREPARE: u32 = 1;
pub const PM_POST_HIBERNATION: u32 = 2;
pub const PM_SUSPEND_PREPARE: u32 = 3;
pub const PM_POST_SUSPEND: u32 = 4;
pub const PM_RESTORE_PREPARE: u32 = 5;
pub const PM_POST_RESTORE: u32 = 6;
pub const REGULATOR_EVENT_UNDER_VOLTAGE: u32 = 1;
pub const REGULATOR_EVENT_OVER_CURRENT: u32 = 2;
pub const REGULATOR_EVENT_REGULATION_OUT: u32 = 4;
pub const REGULATOR_EVENT_FAIL: u32 = 8;
pub const REGULATOR_EVENT_OVER_TEMP: u32 = 16;
pub const REGULATOR_EVENT_FORCE_DISABLE: u32 = 32;
pub const REGULATOR_EVENT_VOLTAGE_CHANGE: u32 = 64;
pub const REGULATOR_EVENT_DISABLE: u32 = 128;
pub const REGULATOR_EVENT_PRE_VOLTAGE_CHANGE: u32 = 256;
pub const REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE: u32 = 512;
pub const REGULATOR_EVENT_PRE_DISABLE: u32 = 1024;
pub const REGULATOR_EVENT_ABORT_DISABLE: u32 = 2048;
pub const REGULATOR_EVENT_ENABLE: u32 = 4096;
pub const REGULATOR_EVENT_UNDER_VOLTAGE_WARN: u32 = 8192;
pub const REGULATOR_EVENT_OVER_CURRENT_WARN: u32 = 16384;
pub const REGULATOR_EVENT_OVER_VOLTAGE_WARN: u32 = 32768;
pub const REGULATOR_EVENT_OVER_TEMP_WARN: u32 = 65536;
pub const REGULATOR_EVENT_WARN_MASK: u32 = 122880;
pub const REG_GENL_FAMILY_NAME: &[u8; 10] = b"reg_event\0";
pub const REG_GENL_VERSION: u32 = 1;
pub const REG_GENL_MCAST_GROUP_NAME: &[u8; 13] = b"reg_mc_group\0";
pub const REGULATOR_MODE_INVALID: u32 = 0;
pub const REGULATOR_MODE_FAST: u32 = 1;
pub const REGULATOR_MODE_NORMAL: u32 = 2;
pub const REGULATOR_MODE_IDLE: u32 = 4;
pub const REGULATOR_MODE_STANDBY: u32 = 8;
pub const TRACEPOINT_DEFAULT_PRIO: u32 = 10;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const ffi::c_char,
    pub file: *const ffi::c_char,
    pub line: ffi::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [ffi::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: ffi::c_ulong,
    pub incorrect: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: ffi::c_ulong,
    pub hit: ffi::c_ulong,
}
impl Default for ftrace_branch_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ftrace_branch_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: ffi::c_ulong,
}
impl Default for ftrace_likely_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __s8 = ffi::c_schar;
pub type __u8 = ffi::c_uchar;
pub type __s16 = ffi::c_short;
pub type __u16 = ffi::c_ushort;
pub type __s32 = ffi::c_int;
pub type __u32 = ffi::c_uint;
pub type __s64 = ffi::c_longlong;
pub type __u64 = ffi::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub const false_: _bindgen_ty_1 = 0;
pub const true_: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [ffi::c_ulong; 16usize],
}
pub type __kernel_sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ffi::c_int)>;
pub type __kernel_key_t = ffi::c_int;
pub type __kernel_mqd_t = ffi::c_int;
pub type __kernel_long_t = ffi::c_long;
pub type __kernel_ulong_t = ffi::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ffi::c_uint;
pub type __kernel_pid_t = ffi::c_int;
pub type __kernel_ipc_pid_t = ffi::c_int;
pub type __kernel_uid_t = ffi::c_uint;
pub type __kernel_gid_t = ffi::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ffi::c_int;
pub type __kernel_uid32_t = ffi::c_uint;
pub type __kernel_gid32_t = ffi::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [ffi::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ffi::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time64_t = ffi::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ffi::c_int;
pub type __kernel_clockid_t = ffi::c_int;
pub type __kernel_caddr_t = *mut ffi::c_char;
pub type __kernel_uid16_t = ffi::c_ushort;
pub type __kernel_gid16_t = ffi::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ffi::c_uint;
pub type s128 = __s128;
pub type u128_ = __u128;
pub type __kernel_dev_t = u32_;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ffi::c_ushort;
pub type nlink_t = u32_;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type loff_t = __kernel_loff_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ffi::c_uchar;
pub type u_short = ffi::c_ushort;
pub type u_int = ffi::c_uint;
pub type u_long = ffi::c_ulong;
pub type unchar = ffi::c_uchar;
pub type ushort = ffi::c_ushort;
pub type uint = ffi::c_uint;
pub type ulong = ffi::c_ulong;
pub type ullong = ffi::c_ulonglong;
pub type u_int8_t = u8_;
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
pub type ktime_t = s64;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = ffi::c_uint;
pub type slab_flags_t = ffi::c_uint;
pub type fmode_t = ffi::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcuref_t {
    pub refcnt: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
impl Default for hlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
impl Default for hlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: ffi::c_ulong,
    pub f_fname: [ffi::c_char; 6usize],
    pub f_fpack: [ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
impl Default for callback_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rcu_callback_t = ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut ffi::c_void,
        b: *mut ffi::c_void,
        size: ffi::c_int,
        priv_: *const ffi::c_void,
    ),
>;
pub type swap_func_t = ::core::option::Option<
    unsafe extern "C" fn(a: *mut ffi::c_void, b: *mut ffi::c_void, size: ffi::c_int),
>;
pub type cmp_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const ffi::c_void,
        b: *const ffi::c_void,
        priv_: *const ffi::c_void,
    ) -> ffi::c_int,
>;
pub type cmp_func_t = ::core::option::Option<
    unsafe extern "C" fn(a: *const ffi::c_void, b: *const ffi::c_void) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
impl Default for rcuwait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ffi::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
impl Default for rb_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
impl Default for rb_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
impl Default for rb_root_cached {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
impl Default for timerqueue_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
impl Default for timerqueue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
impl Default for hrtimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kcsan_scoped_access {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const ffi::c_char,
    pub flags: ffi::c_ulong,
    pub desc: ffi::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
impl Default for resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IORES_DESC_NONE: _bindgen_ty_2 = 0;
pub const IORES_DESC_CRASH_KERNEL: _bindgen_ty_2 = 1;
pub const IORES_DESC_ACPI_TABLES: _bindgen_ty_2 = 2;
pub const IORES_DESC_ACPI_NV_STORAGE: _bindgen_ty_2 = 3;
pub const IORES_DESC_PERSISTENT_MEMORY: _bindgen_ty_2 = 4;
pub const IORES_DESC_PERSISTENT_MEMORY_LEGACY: _bindgen_ty_2 = 5;
pub const IORES_DESC_DEVICE_PRIVATE_MEMORY: _bindgen_ty_2 = 6;
pub const IORES_DESC_RESERVED: _bindgen_ty_2 = 7;
pub const IORES_DESC_SOFT_RESERVED: _bindgen_ty_2 = 8;
pub const IORES_DESC_CXL: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ffi::c_uint;
pub const IORES_MAP_SYSTEM_RAM: _bindgen_ty_3 = 1;
pub const IORES_MAP_ENCRYPTED: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ffi::c_uint;
pub type resource_alignf = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ffi::c_void,
        res: *const resource,
        size: resource_size_t,
        align: resource_size_t,
    ) -> resource_size_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource_constraint {
    pub min: resource_size_t,
    pub max: resource_size_t,
    pub align: resource_size_t,
    pub alignf: resource_alignf,
    pub alignf_data: *mut ffi::c_void,
}
impl Default for resource_constraint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type bug_insn_t = u32_;
pub type va_list = __builtin_va_list;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct taint_flag {
    pub c_true: ffi::c_char,
    pub c_false: ffi::c_char,
    pub module: bool_,
    pub desc: *const ffi::c_char,
}
impl Default for taint_flag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = ffi::c_uint;

pub type initcall_t = ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>;
pub type exitcall_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type initcall_entry_t = initcall_t;

pub type ctor_fn_t = ::core::option::Option<unsafe extern "C" fn()>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_system_type {
    pub name: *const ffi::c_char,
    pub fs_flags: ffi::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ffi::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: ffi::c_int,
            arg3: *const ffi::c_char,
            arg4: *mut ffi::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
impl Default for file_system_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [ffi::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const ffi::c_char,
    pub srcversion: *const ffi::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *mut kernel_symbol,
    pub crcs: *const u32_,
    pub num_syms: ffi::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: ffi::c_uint,
    pub num_gpl_syms: ffi::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const u32_,
    pub using_gplonly_symbols: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: ffi::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub mem: [module_memory; 7usize],
    pub arch: mod_arch_specific,
    pub taints: ffi::c_ulong,
    pub num_bugs: ffi::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut ffi::c_char,
    pub percpu: *mut ffi::c_void,
    pub percpu_size: ffi::c_uint,
    pub noinstr_text_start: *mut ffi::c_void,
    pub noinstr_text_size: ffi::c_uint,
    pub num_tracepoints: ffi::c_uint,
    pub tracepoints_ptrs: *const *mut tracepoint,
    pub num_srcu_structs: ffi::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: ffi::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: ffi::c_uint,
    pub num_trace_bprintk_fmt: ffi::c_uint,
    pub trace_bprintk_fmt_start: *mut *const ffi::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: ffi::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: ffi::c_uint,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
}
impl Default for module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qspinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qrwlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_rwlock_t = qrwlock;
pub const lockdep_wait_type_LD_WAIT_INV: lockdep_wait_type = 0;
pub const lockdep_wait_type_LD_WAIT_FREE: lockdep_wait_type = 1;
pub const lockdep_wait_type_LD_WAIT_SPIN: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_CONFIG: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_SLEEP: lockdep_wait_type = 3;
pub const lockdep_wait_type_LD_WAIT_MAX: lockdep_wait_type = 4;
pub type lockdep_wait_type = ffi::c_uint;
pub const lockdep_lock_type_LD_LOCK_NORMAL: lockdep_lock_type = 0;
pub const lockdep_lock_type_LD_LOCK_PERCPU: lockdep_lock_type = 1;
pub const lockdep_lock_type_LD_LOCK_WAIT_OVERRIDE: lockdep_lock_type = 2;
pub const lockdep_lock_type_LD_LOCK_MAX: lockdep_lock_type = 3;
pub type lockdep_lock_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pin_cookie {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
impl Default for raw_spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ffi::c_int,
    pub burst: ffi::c_int,
    pub rs_n_left: atomic_t,
    pub missed: atomic_t,
    pub flags: ffi::c_uint,
    pub begin: ffi::c_ulong,
}
impl Default for ratelimit_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct console {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct va_format {
    pub fmt: *const ffi::c_char,
    pub va: *mut va_list,
}
impl Default for va_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub fop_flags: fop_flags_t,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ffi::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_uint, arg3: ffi::c_ulong) -> ffi::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_uint, arg3: ffi::c_ulong) -> ffi::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ffi::c_int,
    >,
    pub flush:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> ffi::c_int>,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ffi::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(arg1: ffi::c_int, arg2: *mut file, arg3: ffi::c_int) -> ffi::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_int, arg3: *mut file_lock) -> ffi::c_int,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ffi::c_ulong,
            arg3: ffi::c_ulong,
            arg4: ffi::c_ulong,
            arg5: ffi::c_ulong,
        ) -> ffi::c_ulong,
    >,
    pub check_flags: ::core::option::Option<unsafe extern "C" fn(arg1: ffi::c_int) -> ffi::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_int, arg3: *mut file_lock) -> ffi::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: ffi::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ffi::c_int,
            arg3: *mut *mut file_lease,
            arg4: *mut *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: ffi::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> ffi::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: ffi::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: ffi::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(ioucmd: *mut io_uring_cmd, issue_flags: ffi::c_uint) -> ffi::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub mmap_prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_desc) -> ffi::c_int>,
}
impl Default for file_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const DUMP_PREFIX_NONE: _bindgen_ty_4 = 0;
pub const DUMP_PREFIX_ADDRESS: _bindgen_ty_4 = 1;
pub const DUMP_PREFIX_OFFSET: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ffi::c_int,
    pub file_disp: ffi::c_int,
    pub line: ffi::c_ushort,
    pub flags: ffi::c_ushort,
}

pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = ffi::c_uint;

#[repr(C)]
#[derive(Default)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<ffi::c_char>,
}

#[repr(C)]
#[repr(align(64))]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<ffi::c_char>,
}
impl Default for cacheline_padding {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prctl_mm_map {
    pub start_code: __u64,
    pub end_code: __u64,
    pub start_data: __u64,
    pub end_data: __u64,
    pub start_brk: __u64,
    pub brk: __u64,
    pub start_stack: __u64,
    pub arg_start: __u64,
    pub arg_end: __u64,
    pub env_start: __u64,
    pub env_end: __u64,
    pub auxv: *mut __u64,
    pub auxv_size: __u32,
    pub exe_fd: __u32,
}
impl Default for prctl_mm_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_regs_struct {
    pub pc: ffi::c_ulong,
    pub ra: ffi::c_ulong,
    pub sp: ffi::c_ulong,
    pub gp: ffi::c_ulong,
    pub tp: ffi::c_ulong,
    pub t0: ffi::c_ulong,
    pub t1: ffi::c_ulong,
    pub t2: ffi::c_ulong,
    pub s0: ffi::c_ulong,
    pub s1: ffi::c_ulong,
    pub a0: ffi::c_ulong,
    pub a1: ffi::c_ulong,
    pub a2: ffi::c_ulong,
    pub a3: ffi::c_ulong,
    pub a4: ffi::c_ulong,
    pub a5: ffi::c_ulong,
    pub a6: ffi::c_ulong,
    pub a7: ffi::c_ulong,
    pub s2: ffi::c_ulong,
    pub s3: ffi::c_ulong,
    pub s4: ffi::c_ulong,
    pub s5: ffi::c_ulong,
    pub s6: ffi::c_ulong,
    pub s7: ffi::c_ulong,
    pub s8: ffi::c_ulong,
    pub s9: ffi::c_ulong,
    pub s10: ffi::c_ulong,
    pub s11: ffi::c_ulong,
    pub t3: ffi::c_ulong,
    pub t4: ffi::c_ulong,
    pub t5: ffi::c_ulong,
    pub t6: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __riscv_f_ext_state {
    pub f: [__u32; 32usize],
    pub fcsr: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __riscv_d_ext_state {
    pub f: [__u64; 32usize],
    pub fcsr: __u32,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __riscv_q_ext_state {
    pub f: [__u64; 64usize],
    pub fcsr: __u32,
    pub reserved: [__u32; 3usize],
}
impl Default for __riscv_q_ext_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __riscv_ctx_hdr {
    pub magic: __u32,
    pub size: __u32,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __riscv_extra_ext_header {
    pub __padding: [__u32; 129usize],
    pub reserved: __u32,
    pub hdr: __riscv_ctx_hdr,
}
impl Default for __riscv_extra_ext_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __riscv_fp_state {
    pub f: __riscv_f_ext_state,
    pub d: __riscv_d_ext_state,
    pub q: __riscv_q_ext_state,
}
impl Default for __riscv_fp_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __riscv_v_ext_state {
    pub vstart: ffi::c_ulong,
    pub vl: ffi::c_ulong,
    pub vtype: ffi::c_ulong,
    pub vcsr: ffi::c_ulong,
    pub vlenb: ffi::c_ulong,
    pub datap: *mut ffi::c_void,
}
impl Default for __riscv_v_ext_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __riscv_v_regset_state {
    pub vstart: ffi::c_ulong,
    pub vl: ffi::c_ulong,
    pub vtype: ffi::c_ulong,
    pub vcsr: ffi::c_ulong,
    pub vlenb: ffi::c_ulong,
    pub vreg: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_regs {
    pub epc: ffi::c_ulong,
    pub ra: ffi::c_ulong,
    pub sp: ffi::c_ulong,
    pub gp: ffi::c_ulong,
    pub tp: ffi::c_ulong,
    pub t0: ffi::c_ulong,
    pub t1: ffi::c_ulong,
    pub t2: ffi::c_ulong,
    pub s0: ffi::c_ulong,
    pub s1: ffi::c_ulong,
    pub __bindgen_anon_1: pt_regs__bindgen_ty_1,
    pub s2: ffi::c_ulong,
    pub s3: ffi::c_ulong,
    pub s4: ffi::c_ulong,
    pub s5: ffi::c_ulong,
    pub s6: ffi::c_ulong,
    pub s7: ffi::c_ulong,
    pub s8: ffi::c_ulong,
    pub s9: ffi::c_ulong,
    pub s10: ffi::c_ulong,
    pub s11: ffi::c_ulong,
    pub t3: ffi::c_ulong,
    pub t4: ffi::c_ulong,
    pub t5: ffi::c_ulong,
    pub t6: ffi::c_ulong,
    pub status: ffi::c_ulong,
    pub badaddr: ffi::c_ulong,
    pub cause: ffi::c_ulong,
    pub orig_a0: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_regs__bindgen_ty_1 {
    pub __bindgen_anon_1: pt_regs__bindgen_ty_1__bindgen_ty_1,
    pub a_regs: pt_regs__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_regs__bindgen_ty_1__bindgen_ty_1 {
    pub a0: ffi::c_ulong,
    pub a1: ffi::c_ulong,
    pub a2: ffi::c_ulong,
    pub a3: ffi::c_ulong,
    pub a4: ffi::c_ulong,
    pub a5: ffi::c_ulong,
    pub a6: ffi::c_ulong,
    pub a7: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_regs__bindgen_ty_1__bindgen_ty_2 {
    pub a0: ffi::c_ulong,
    pub a1: ffi::c_ulong,
    pub a2: ffi::c_ulong,
    pub a3: ffi::c_ulong,
    pub a4: ffi::c_ulong,
    pub a5: ffi::c_ulong,
    pub a6: ffi::c_ulong,
    pub a7: ffi::c_ulong,
}
impl Default for pt_regs__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pt_regs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct thread_struct {
    pub ra: ffi::c_ulong,
    pub sp: ffi::c_ulong,
    pub s: [ffi::c_ulong; 12usize],
    pub fstate: __riscv_d_ext_state,
    pub bad_cause: ffi::c_ulong,
    pub envcfg: ffi::c_ulong,
    pub sum: ffi::c_ulong,
    pub riscv_v_flags: u32_,
    pub vstate_ctrl: u32_,
    pub vstate: __riscv_v_ext_state,
    pub align_ctl: ffi::c_ulong,
    pub kernel_vstate: __riscv_v_ext_state,
    pub force_icache_flush: bool_,
    pub prev_cpu: ffi::c_uint,
}
impl Default for thread_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const ___GFP_DMA_BIT: _bindgen_ty_5 = 0;
pub const ___GFP_HIGHMEM_BIT: _bindgen_ty_5 = 1;
pub const ___GFP_DMA32_BIT: _bindgen_ty_5 = 2;
pub const ___GFP_MOVABLE_BIT: _bindgen_ty_5 = 3;
pub const ___GFP_RECLAIMABLE_BIT: _bindgen_ty_5 = 4;
pub const ___GFP_HIGH_BIT: _bindgen_ty_5 = 5;
pub const ___GFP_IO_BIT: _bindgen_ty_5 = 6;
pub const ___GFP_FS_BIT: _bindgen_ty_5 = 7;
pub const ___GFP_ZERO_BIT: _bindgen_ty_5 = 8;
pub const ___GFP_UNUSED_BIT: _bindgen_ty_5 = 9;
pub const ___GFP_DIRECT_RECLAIM_BIT: _bindgen_ty_5 = 10;
pub const ___GFP_KSWAPD_RECLAIM_BIT: _bindgen_ty_5 = 11;
pub const ___GFP_WRITE_BIT: _bindgen_ty_5 = 12;
pub const ___GFP_NOWARN_BIT: _bindgen_ty_5 = 13;
pub const ___GFP_RETRY_MAYFAIL_BIT: _bindgen_ty_5 = 14;
pub const ___GFP_NOFAIL_BIT: _bindgen_ty_5 = 15;
pub const ___GFP_NORETRY_BIT: _bindgen_ty_5 = 16;
pub const ___GFP_MEMALLOC_BIT: _bindgen_ty_5 = 17;
pub const ___GFP_COMP_BIT: _bindgen_ty_5 = 18;
pub const ___GFP_NOMEMALLOC_BIT: _bindgen_ty_5 = 19;
pub const ___GFP_HARDWALL_BIT: _bindgen_ty_5 = 20;
pub const ___GFP_THISNODE_BIT: _bindgen_ty_5 = 21;
pub const ___GFP_ACCOUNT_BIT: _bindgen_ty_5 = 22;
pub const ___GFP_ZEROTAGS_BIT: _bindgen_ty_5 = 23;
pub const ___GFP_NO_OBJ_EXT_BIT: _bindgen_ty_5 = 24;
pub const ___GFP_LAST_BIT: _bindgen_ty_5 = 25;
pub type _bindgen_ty_5 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: ffi::c_ulong,
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> ffi::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ffi::c_int,
    pub has_timeout: ffi::c_int,
    pub tv_sec: ffi::c_ulong,
    pub tv_nsec: ffi::c_ulong,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_irq_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_irqsave_t {
    pub lock: *mut ffi::c_void,
    pub flags: ffi::c_ulong,
}
impl Default for class_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BAD_STACK: _bindgen_ty_6 = -1;
pub const NOT_STACK: _bindgen_ty_6 = 0;
pub const GOOD_FRAME: _bindgen_ty_6 = 1;
pub const GOOD_STACK: _bindgen_ty_6 = 2;
pub type _bindgen_ty_6 = ffi::c_int;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SECCOMP: syscall_work_bit = 0;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT: syscall_work_bit = 1;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACE: syscall_work_bit = 2;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EMU: syscall_work_bit = 3;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_AUDIT: syscall_work_bit = 4;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH: syscall_work_bit = 5;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP: syscall_work_bit = 6;
pub type syscall_work_bit = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pte_t {
    pub pte: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgprot_t {
    pub pgprot: ffi::c_ulong,
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_mapping {
    pub virt_addr: ffi::c_ulong,
    pub virt_offset: ffi::c_ulong,
    pub phys_addr: usize,
    pub size: usize,
    pub va_pa_offset: ffi::c_ulong,
    pub page_offset: ffi::c_ulong,
    pub va_kernel_pa_offset: ffi::c_ulong,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_info {
    pub flags: ffi::c_ulong,
    pub preempt_count: ffi::c_int,
    pub kernel_sp: ffi::c_long,
    pub user_sp: ffi::c_long,
    pub cpu: ffi::c_int,
    pub syscall_work: ffi::c_ulong,
    pub a0: ffi::c_ulong,
    pub a1: ffi::c_ulong,
    pub a2: ffi::c_ulong,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct preempt_ops {
    pub sched_in: ::core::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, cpu: ffi::c_int),
    >,
    pub sched_out: ::core::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, next: *mut task_struct),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct preempt_notifier {
    pub link: hlist_node,
    pub ops: *mut preempt_ops,
}
impl Default for preempt_notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_preempt_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_preempt_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_preempt_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_preempt_notrace_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_preempt_notrace_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_preempt_notrace_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_migrate_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_migrate_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_migrate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s8_fract {
    pub numerator: __s8,
    pub denominator: __s8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u8_fract {
    pub numerator: __u8,
    pub denominator: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s16_fract {
    pub numerator: __s16,
    pub denominator: __s16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u16_fract {
    pub numerator: __u16,
    pub denominator: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s32_fract {
    pub numerator: __s32,
    pub denominator: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u32_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut ffi::c_void,
}
impl Default for static_call_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}

pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_FREEING_INITMEM: system_states = 2;
pub const system_states_SYSTEM_RUNNING: system_states = 3;
pub const system_states_SYSTEM_HALT: system_states = 4;
pub const system_states_SYSTEM_POWER_OFF: system_states = 5;
pub const system_states_SYSTEM_RESTART: system_states = 6;
pub const system_states_SYSTEM_SUSPEND: system_states = 7;
pub type system_states = ffi::c_uint;

pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub const ftrace_dump_mode_DUMP_PARAM: ftrace_dump_mode = 3;
pub type ftrace_dump_mode = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpumask {
    pub bits: [ffi::c_ulong; 1usize],
}
pub type cpumask_t = cpumask;
pub type cpumask_var_t = [cpumask; 1usize];

pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [ffi::c_ulong; 1usize],
}

#[repr(C)]
#[derive(Default)]
pub struct rand_pool_info {
    pub entropy_count: ffi::c_int,
    pub buf_size: ffi::c_int,
    pub buf: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vgetrandom_opaque_params {
    pub size_of_opaque_state: __u32,
    pub mmap_prot: __u32,
    pub mmap_flags: __u32,
    pub reserved: [__u32; 13usize],
}

pub const node_states_N_POSSIBLE: node_states = 0;
pub const node_states_N_ONLINE: node_states = 1;
pub const node_states_N_NORMAL_MEMORY: node_states = 2;
pub const node_states_N_HIGH_MEMORY: node_states = 2;
pub const node_states_N_MEMORY: node_states = 3;
pub const node_states_N_CPU: node_states = 4;
pub const node_states_N_GENERIC_INITIATOR: node_states = 5;
pub const node_states_NR_NODE_STATES: node_states = 6;
pub type node_states = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
impl Default for llist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
impl Default for llist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const CSD_FLAG_LOCK: _bindgen_ty_7 = 1;
pub const IRQ_WORK_PENDING: _bindgen_ty_7 = 1;
pub const IRQ_WORK_BUSY: _bindgen_ty_7 = 2;
pub const IRQ_WORK_LAZY: _bindgen_ty_7 = 4;
pub const IRQ_WORK_HARD_IRQ: _bindgen_ty_7 = 8;
pub const IRQ_WORK_CLAIMED: _bindgen_ty_7 = 3;
pub const CSD_TYPE_ASYNC: _bindgen_ty_7 = 0;
pub const CSD_TYPE_SYNC: _bindgen_ty_7 = 16;
pub const CSD_TYPE_IRQ_WORK: _bindgen_ty_7 = 32;
pub const CSD_TYPE_TTWU: _bindgen_ty_7 = 48;
pub const CSD_FLAG_TYPE_MASK: _bindgen_ty_7 = 240;
pub type _bindgen_ty_7 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ffi::c_uint,
    pub a_flags: atomic_t,
}
impl Default for __call_single_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __call_single_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type smp_call_func_t = ::core::option::Option<unsafe extern "C" fn(info: *mut ffi::c_void)>;
pub type smp_cond_func_t =
    ::core::option::Option<unsafe extern "C" fn(cpu: ffi::c_int, info: *mut ffi::c_void) -> bool_>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ffi::c_void,
}
impl Default for __call_single_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type call_single_data_t = __call_single_data;

pub const irqreturn_IRQ_NONE: irqreturn = 0;
pub const irqreturn_IRQ_HANDLED: irqreturn = 1;
pub const irqreturn_IRQ_WAKE_THREAD: irqreturn = 2;
pub type irqreturn = ffi::c_uint;
pub use self::irqreturn as irqreturn_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: ffi::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for static_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ffi::c_long,
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = ffi::c_uint;

pub const class_jump_label_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_jump_label_lock_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_jump_label_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
impl Default for static_key_true {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
impl Default for static_key_false {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mmiowb_state {
    pub nesting_count: u16_,
    pub mmiowb_pending: u16_,
}

#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct spinlock {
    pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
impl Default for rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_raw_spinlock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_raw_spinlock_try_is_conditional: bool_ = true;
pub type class_raw_spinlock_try_t = class_raw_spinlock_t;
pub const class_raw_spinlock_nested_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_nested_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_nested_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_raw_spinlock_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_irq_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_raw_spinlock_irq_try_is_conditional: bool_ = true;
pub type class_raw_spinlock_irq_try_t = class_raw_spinlock_irq_t;
pub const class_raw_spinlock_bh_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_bh_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_bh_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_raw_spinlock_bh_try_is_conditional: bool_ = true;
pub type class_raw_spinlock_bh_try_t = class_raw_spinlock_bh_t;
pub const class_raw_spinlock_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_irqsave_t {
    pub lock: *mut raw_spinlock_t,
    pub flags: ffi::c_ulong,
}
impl Default for class_raw_spinlock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_raw_spinlock_irqsave_try_is_conditional: bool_ = true;
pub type class_raw_spinlock_irqsave_try_t = class_raw_spinlock_irqsave_t;
pub const class_spinlock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_t {
    pub lock: *mut spinlock_t,
}
impl Default for class_spinlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_spinlock_try_is_conditional: bool_ = true;
pub type class_spinlock_try_t = class_spinlock_t;
pub const class_spinlock_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_irq_t {
    pub lock: *mut spinlock_t,
}
impl Default for class_spinlock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_spinlock_irq_try_is_conditional: bool_ = true;
pub type class_spinlock_irq_try_t = class_spinlock_irq_t;
pub const class_spinlock_bh_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_bh_t {
    pub lock: *mut spinlock_t,
}
impl Default for class_spinlock_bh_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_spinlock_bh_try_is_conditional: bool_ = true;
pub type class_spinlock_bh_try_t = class_spinlock_bh_t;
pub const class_spinlock_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_irqsave_t {
    pub lock: *mut spinlock_t,
    pub flags: ffi::c_ulong,
}
impl Default for class_spinlock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_spinlock_irqsave_try_is_conditional: bool_ = true;
pub type class_spinlock_irqsave_try_t = class_spinlock_irqsave_t;
pub const class_read_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_read_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_read_lock_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_irq_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_read_lock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_read_lock_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_irqsave_t {
    pub lock: *mut rwlock_t,
    pub flags: ffi::c_ulong,
}
impl Default for class_read_lock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_write_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_write_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_write_lock_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_irq_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_write_lock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_write_lock_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_irqsave_t {
    pub lock: *mut rwlock_t,
    pub flags: ffi::c_ulong,
}
impl Default for class_write_lock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
impl Default for hlist_nulls_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
impl Default for hlist_nulls_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: ffi::c_uint,
        flags: ffi::c_int,
        key: *mut ffi::c_void,
    ) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: ffi::c_uint,
    pub private: *mut ffi::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
impl Default for wait_queue_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
impl Default for wait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_head_t = wait_queue_head;

pub type task_call_f = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, arg: *mut ffi::c_void) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
impl Default for mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type class_mutex_t = *mut mutex;
pub const class_mutex_is_conditional: bool_ = false;
pub const class_mutex_try_is_conditional: bool_ = true;
pub type class_mutex_try_t = class_mutex_t;
pub const class_mutex_intr_is_conditional: bool_ = true;
pub type class_mutex_intr_t = class_mutex_t;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: ffi::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_rwlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_rwlock_t = seqcount_rwlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_mutex {
    pub seqcount: seqcount_t,
}
pub type seqcount_mutex_t = seqcount_mutex;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_latch_t {
    pub seqcount: seqcount_t,
}
pub const pageblock_bits_PB_migrate: pageblock_bits = 0;
pub const pageblock_bits_PB_migrate_end: pageblock_bits = 2;
pub const pageblock_bits_PB_compact_skip: pageblock_bits = 3;
pub const pageblock_bits___NR_PAGEBLOCK_BITS: pageblock_bits = 4;
pub type pageblock_bits = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
pub const MM_FILEPAGES: _bindgen_ty_8 = 0;
pub const MM_ANONPAGES: _bindgen_ty_8 = 1;
pub const MM_SWAPENTS: _bindgen_ty_8 = 2;
pub const MM_SHMEMPAGES: _bindgen_ty_8 = 3;
pub const NR_MM_COUNTERS: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
impl Default for page_frag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_frag_cache {
    pub encoded_page: ffi::c_ulong,
    pub offset: __u32,
    pub pagecnt_bias: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
pub const refcount_saturation_type_REFCOUNT_ADD_NOT_ZERO_OVF: refcount_saturation_type = 0;
pub const refcount_saturation_type_REFCOUNT_ADD_OVF: refcount_saturation_type = 1;
pub const refcount_saturation_type_REFCOUNT_ADD_UAF: refcount_saturation_type = 2;
pub const refcount_saturation_type_REFCOUNT_SUB_UAF: refcount_saturation_type = 3;
pub const refcount_saturation_type_REFCOUNT_DEC_LEAK: refcount_saturation_type = 4;
pub type refcount_saturation_type = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_gp_oldstate {
    pub rgos_norm: ffi::c_ulong,
    pub rgos_exp: ffi::c_ulong,
}

pub const class_rcu_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_rcu_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_rcu_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_metadata {
    pub end: ffi::c_uchar,
    pub gap: ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [ffi::c_ulong; 15usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_range_64__bindgen_ty_1 {
    pub slot: [*mut ffi::c_void; 16usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [*mut ffi::c_void; 15usize],
    pub meta: maple_metadata,
}
impl Default for maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_range_64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_range_64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_arange_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [ffi::c_ulong; 9usize],
    pub slot: [*mut ffi::c_void; 10usize],
    pub gap: [ffi::c_ulong; 10usize],
    pub meta: maple_metadata,
}
impl Default for maple_arange_64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_alloc {
    pub total: ffi::c_ulong,
    pub node_count: ffi::c_uchar,
    pub request_count: ffi::c_uint,
    pub slot: [*mut maple_alloc; 30usize],
}
impl Default for maple_alloc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_topiary {
    pub parent: *mut maple_pnode,
    pub next: *mut maple_enode,
}
impl Default for maple_topiary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const maple_type_maple_dense: maple_type = 0;
pub const maple_type_maple_leaf_64: maple_type = 1;
pub const maple_type_maple_range_64: maple_type = 2;
pub const maple_type_maple_arange_64: maple_type = 3;
pub type maple_type = ffi::c_uint;
pub const store_type_wr_invalid: store_type = 0;
pub const store_type_wr_new_root: store_type = 1;
pub const store_type_wr_store_root: store_type = 2;
pub const store_type_wr_exact_fit: store_type = 3;
pub const store_type_wr_spanning_store: store_type = 4;
pub const store_type_wr_split_store: store_type = 5;
pub const store_type_wr_rebalance: store_type = 6;
pub const store_type_wr_append: store_type = 7;
pub const store_type_wr_node_store: store_type = 8;
pub const store_type_wr_slot_store: store_type = 9;
pub type store_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map_p {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_flags: ffi::c_uint,
    pub ma_root: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
}
impl Default for maple_tree__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_node__bindgen_ty_1 {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: maple_node__bindgen_ty_1__bindgen_ty_2,
    pub mr64: maple_range_64,
    pub ma64: maple_arange_64,
    pub alloc: maple_alloc,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_1 {
    pub parent: *mut maple_pnode,
    pub slot: [*mut ffi::c_void; 31usize],
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_2 {
    pub pad: *mut ffi::c_void,
    pub rcu: callback_head,
    pub piv_parent: *mut maple_enode,
    pub parent_slot: ffi::c_uchar,
    pub type_: maple_type,
    pub slot_len: ffi::c_uchar,
    pub ma_flags: ffi::c_uint,
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_topiary {
    pub head: *mut maple_enode,
    pub tail: *mut maple_enode,
    pub mtree: *mut maple_tree,
}
impl Default for ma_topiary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const maple_status_ma_active: maple_status = 0;
pub const maple_status_ma_start: maple_status = 1;
pub const maple_status_ma_root: maple_status = 2;
pub const maple_status_ma_none: maple_status = 3;
pub const maple_status_ma_pause: maple_status = 4;
pub const maple_status_ma_overflow: maple_status = 5;
pub const maple_status_ma_underflow: maple_status = 6;
pub const maple_status_ma_error: maple_status = 7;
pub type maple_status = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_state {
    pub tree: *mut maple_tree,
    pub index: ffi::c_ulong,
    pub last: ffi::c_ulong,
    pub node: *mut maple_enode,
    pub min: ffi::c_ulong,
    pub max: ffi::c_ulong,
    pub alloc: *mut maple_alloc,
    pub status: maple_status,
    pub depth: ffi::c_uchar,
    pub offset: ffi::c_uchar,
    pub mas_flags: ffi::c_uchar,
    pub end: ffi::c_uchar,
    pub store_type: store_type,
}
impl Default for ma_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_wr_state {
    pub mas: *mut ma_state,
    pub node: *mut maple_node,
    pub r_min: ffi::c_ulong,
    pub r_max: ffi::c_ulong,
    pub type_: maple_type,
    pub offset_end: ffi::c_uchar,
    pub pivots: *mut ffi::c_ulong,
    pub end_piv: ffi::c_ulong,
    pub slots: *mut *mut ffi::c_void,
    pub entry: *mut ffi::c_void,
    pub content: *mut ffi::c_void,
    pub vacant_height: ffi::c_uchar,
    pub sufficient_height: ffi::c_uchar,
}
impl Default for ma_wr_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
impl Default for rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type class_rwsem_read_t = *mut rw_semaphore;
pub const class_rwsem_read_is_conditional: bool_ = false;
pub const class_rwsem_read_try_is_conditional: bool_ = true;
pub type class_rwsem_read_try_t = class_rwsem_read_t;
pub const class_rwsem_read_intr_is_conditional: bool_ = true;
pub type class_rwsem_read_intr_t = class_rwsem_read_t;
pub type class_rwsem_write_t = *mut rw_semaphore;
pub const class_rwsem_write_is_conditional: bool_ = false;
pub const class_rwsem_write_try_is_conditional: bool_ = true;
pub type class_rwsem_write_try_t = class_rwsem_write_t;
pub const class_rwsem_write_kill_is_conditional: bool_ = true;
pub type class_rwsem_write_kill_t = class_rwsem_write_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
impl Default for swait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue {
    pub task: *mut task_struct,
    pub task_list: list_head,
}
impl Default for swait_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ffi::c_uint,
    pub wait: swait_queue_head,
}
impl Default for completion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type time64_t = __s64;
pub type timeu64_t = __u64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ffi::c_longlong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_itimerval {
    pub it_interval: __kernel_old_timeval,
    pub it_value: __kernel_old_timeval,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ffi::c_int,
    pub tz_dsttime: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ffi::c_int,
    pub tm_min: ffi::c_int,
    pub tm_hour: ffi::c_int,
    pub tm_mday: ffi::c_int,
    pub tm_mon: ffi::c_int,
    pub tm_year: ffi::c_long,
    pub tm_wday: ffi::c_int,
    pub tm_yday: ffi::c_int,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timex_timeval {
    pub tv_sec: __kernel_time64_t,
    pub tv_usec: ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_timex {
    pub modes: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub offset: ffi::c_longlong,
    pub freq: ffi::c_longlong,
    pub maxerror: ffi::c_longlong,
    pub esterror: ffi::c_longlong,
    pub status: ffi::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub constant: ffi::c_longlong,
    pub precision: ffi::c_longlong,
    pub tolerance: ffi::c_longlong,
    pub time: __kernel_timex_timeval,
    pub tick: ffi::c_longlong,
    pub ppsfreq: ffi::c_longlong,
    pub jitter: ffi::c_longlong,
    pub shift: ffi::c_int,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub stabil: ffi::c_longlong,
    pub jitcnt: ffi::c_longlong,
    pub calcnt: ffi::c_longlong,
    pub errcnt: ffi::c_longlong,
    pub stbcnt: ffi::c_longlong,
    pub tai: ffi::c_int,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 44usize]>,
}
impl Default for __kernel_timex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl __kernel_timex {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}

pub type cycles_t = ffi::c_ulong;

pub type old_time32_t = s32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timeval32 {
    pub tv_sec: old_time32_t,
    pub tv_usec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_itimerspec32 {
    pub it_interval: old_timespec32,
    pub it_value: old_timespec32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_utimbuf32 {
    pub actime: old_time32_t,
    pub modtime: old_time32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_timex32 {
    pub modes: u32_,
    pub offset: s32,
    pub freq: s32,
    pub maxerror: s32,
    pub esterror: s32,
    pub status: s32,
    pub constant: s32,
    pub precision: s32,
    pub tolerance: s32,
    pub time: old_timeval32,
    pub tick: s32,
    pub ppsfreq: s32,
    pub jitter: s32,
    pub shift: s32,
    pub stabil: s32,
    pub jitcnt: s32,
    pub calcnt: s32,
    pub errcnt: s32,
    pub stbcnt: s32,
    pub tai: s32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
impl Default for old_timex32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timens_offset {
    pub sec: s64,
    pub nsec: u64_,
}

pub const clocksource_ids_CSID_GENERIC: clocksource_ids = 0;
pub const clocksource_ids_CSID_ARM_ARCH_COUNTER: clocksource_ids = 1;
pub const clocksource_ids_CSID_S390_TOD: clocksource_ids = 2;
pub const clocksource_ids_CSID_X86_TSC_EARLY: clocksource_ids = 3;
pub const clocksource_ids_CSID_X86_TSC: clocksource_ids = 4;
pub const clocksource_ids_CSID_X86_KVM_CLK: clocksource_ids = 5;
pub const clocksource_ids_CSID_X86_ART: clocksource_ids = 6;
pub const clocksource_ids_CSID_MAX: clocksource_ids = 7;
pub type clocksource_ids = ffi::c_uint;

pub const tk_offsets_TK_OFFS_REAL: tk_offsets = 0;
pub const tk_offsets_TK_OFFS_BOOT: tk_offsets = 1;
pub const tk_offsets_TK_OFFS_TAI: tk_offsets = 2;
pub const tk_offsets_TK_OFFS_MAX: tk_offsets = 3;
pub type tk_offsets = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_time_snapshot {
    pub cycles: u64_,
    pub real: ktime_t,
    pub boot: ktime_t,
    pub raw: ktime_t,
    pub cs_id: clocksource_ids,
    pub clock_was_set_seq: ffi::c_uint,
    pub cs_was_changed_seq: u8_,
}
impl Default for system_time_snapshot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct system_device_crosststamp {
    pub device: ktime_t,
    pub sys_realtime: ktime_t,
    pub sys_monoraw: ktime_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_counterval_t {
    pub cycles: u64_,
    pub cs_id: clocksource_ids,
    pub use_nsecs: bool_,
}
impl Default for system_counterval_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const debug_obj_state_ODEBUG_STATE_NONE: debug_obj_state = 0;
pub const debug_obj_state_ODEBUG_STATE_INIT: debug_obj_state = 1;
pub const debug_obj_state_ODEBUG_STATE_INACTIVE: debug_obj_state = 2;
pub const debug_obj_state_ODEBUG_STATE_ACTIVE: debug_obj_state = 3;
pub const debug_obj_state_ODEBUG_STATE_DESTROYED: debug_obj_state = 4;
pub const debug_obj_state_ODEBUG_STATE_NOTAVAILABLE: debug_obj_state = 5;
pub const debug_obj_state_ODEBUG_STATE_MAX: debug_obj_state = 6;
pub type debug_obj_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: ffi::c_uint,
    pub __bindgen_anon_1: debug_obj__bindgen_ty_1,
    pub descr: *const debug_obj_descr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union debug_obj__bindgen_ty_1 {
    pub object: *mut ffi::c_void,
    pub batch_last: *mut hlist_node,
}
impl Default for debug_obj__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for debug_obj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj_descr {
    pub name: *const ffi::c_char,
    pub debug_hint:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut ffi::c_void) -> *mut ffi::c_void>,
    pub is_static_object:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut ffi::c_void) -> bool_>,
    pub fixup_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_activate: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_destroy: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_free: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_assert_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ffi::c_void, state: debug_obj_state) -> bool_,
    >,
}
impl Default for debug_obj_descr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ffi::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
impl Default for timer_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            regs: *mut pt_regs,
            data: *mut __u64,
        ) -> ffi::c_int,
    >,
    pub ret_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            func: ffi::c_ulong,
            regs: *mut pt_regs,
            data: *mut __u64,
        ) -> ffi::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut uprobe_consumer, mm: *mut mm_struct) -> bool_,
    >,
    pub cons_node: list_head,
    pub id: __u64,
}
impl Default for uprobe_consumer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type probe_opcode_t = u32_;
pub type probes_handler_t = ::core::option::Option<
    unsafe extern "C" fn(opcode: u32_, addr: ffi::c_ulong, arg1: *mut pt_regs) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_probe_insn {
    pub insn: *mut probe_opcode_t,
    pub handler: probes_handler_t,
    pub restore: ffi::c_ulong,
}
impl Default for arch_probe_insn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type uprobe_opcode_t = u32_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_cause: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub api: arch_probe_insn,
    pub insn_size: ffi::c_ulong,
    pub simulate: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 8usize],
    pub ixol: [u8_; 8usize],
}
impl Default for arch_uprobe__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for arch_uprobe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = ffi::c_uint;
pub const hprobe_state_HPROBE_LEASED: hprobe_state = 0;
pub const hprobe_state_HPROBE_STABLE: hprobe_state = 1;
pub const hprobe_state_HPROBE_GONE: hprobe_state = 2;
pub const hprobe_state_HPROBE_CONSUMED: hprobe_state = 3;
pub type hprobe_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hprobe {
    pub state: hprobe_state,
    pub srcu_idx: ffi::c_int,
    pub uprobe: *mut uprobe,
}
impl Default for hprobe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub depth: ffi::c_uint,
    pub return_instances: *mut return_instance,
    pub ri_pool: *mut return_instance,
    pub ri_timer: timer_list,
    pub ri_seqcount: seqcount_t,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: ffi::c_ulong,
    pub signal_denied: bool_,
    pub auprobe: *mut arch_uprobe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: ffi::c_ulong,
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct return_consumer {
    pub cookie: __u64,
    pub id: __u64,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct return_instance {
    pub hprobe: hprobe,
    pub func: ffi::c_ulong,
    pub stack: ffi::c_ulong,
    pub orig_ret_vaddr: ffi::c_ulong,
    pub chained: bool_,
    pub cons_cnt: ffi::c_int,
    pub next: *mut return_instance,
    pub rcu: callback_head,
    pub consumer: return_consumer,
    pub extra_consumers: *mut return_consumer,
}
impl Default for return_instance {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const rp_check_RP_CHECK_CALL: rp_check = 0;
pub const rp_check_RP_CHECK_CHAIN_CALL: rp_check = 1;
pub const rp_check_RP_CHECK_RET: rp_check = 2;
pub type rp_check = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
impl Default for uprobes_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct codetag_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct codetag_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct codetag {
    pub flags: ffi::c_uint,
    pub lineno: ffi::c_uint,
    pub modname: *const ffi::c_char,
    pub function: *const ffi::c_char,
    pub filename: *const ffi::c_char,
}
impl Default for codetag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union codetag_ref {
    pub ct: *mut codetag,
}
impl Default for codetag_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct codetag_type_desc {
    pub section: *const ffi::c_char,
    pub tag_size: usize,
    pub module_load: ::core::option::Option<
        unsafe extern "C" fn(
            mod_: *mut module,
            start: *mut codetag,
            end: *mut codetag,
        ) -> ffi::c_int,
    >,
    pub module_unload: ::core::option::Option<
        unsafe extern "C" fn(mod_: *mut module, start: *mut codetag, end: *mut codetag),
    >,
    pub module_replaced:
        ::core::option::Option<unsafe extern "C" fn(mod_: *mut module, new_mod: *mut module)>,
    pub needs_section_mem: ::core::option::Option<
        unsafe extern "C" fn(mod_: *mut module, size: ffi::c_ulong) -> bool_,
    >,
    pub alloc_section_mem: ::core::option::Option<
        unsafe extern "C" fn(
            mod_: *mut module,
            size: ffi::c_ulong,
            prepend: ffi::c_uint,
            align: ffi::c_ulong,
        ) -> *mut ffi::c_void,
    >,
    pub free_section_mem:
        ::core::option::Option<unsafe extern "C" fn(mod_: *mut module, used: bool_)>,
}
impl Default for codetag_type_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct codetag_iterator {
    pub cttype: *mut codetag_type,
    pub cmod: *mut codetag_module,
    pub mod_id: ffi::c_ulong,
    pub ct: *mut codetag,
    pub mod_seq: ffi::c_ulong,
}
impl Default for codetag_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct alloc_tag_counters {
    pub bytes: u64_,
    pub calls: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alloc_tag {
    pub ct: codetag,
    pub counters: *mut alloc_tag_counters,
}
impl Default for alloc_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alloc_tag_kernel_section {
    pub first_tag: *mut alloc_tag,
    pub count: ffi::c_ulong,
}
impl Default for alloc_tag_kernel_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alloc_tag_module_section {
    pub __bindgen_anon_1: alloc_tag_module_section__bindgen_ty_1,
    pub end_addr: ffi::c_ulong,
    pub size: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union alloc_tag_module_section__bindgen_ty_1 {
    pub start_addr: ffi::c_ulong,
    pub first_tag: *mut alloc_tag,
}
impl Default for alloc_tag_module_section__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for alloc_tag_module_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
impl Default for work_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const work_bits_WORK_STRUCT_PENDING_BIT: work_bits = 0;
pub const work_bits_WORK_STRUCT_INACTIVE_BIT: work_bits = 1;
pub const work_bits_WORK_STRUCT_PWQ_BIT: work_bits = 2;
pub const work_bits_WORK_STRUCT_LINKED_BIT: work_bits = 3;
pub const work_bits_WORK_STRUCT_FLAG_BITS: work_bits = 4;
pub const work_bits_WORK_STRUCT_COLOR_SHIFT: work_bits = 4;
pub const work_bits_WORK_STRUCT_COLOR_BITS: work_bits = 4;
pub const work_bits_WORK_STRUCT_PWQ_SHIFT: work_bits = 8;
pub const work_bits_WORK_OFFQ_FLAG_SHIFT: work_bits = 4;
pub const work_bits_WORK_OFFQ_BH_BIT: work_bits = 4;
pub const work_bits_WORK_OFFQ_FLAG_END: work_bits = 5;
pub const work_bits_WORK_OFFQ_FLAG_BITS: work_bits = 1;
pub const work_bits_WORK_OFFQ_DISABLE_SHIFT: work_bits = 5;
pub const work_bits_WORK_OFFQ_DISABLE_BITS: work_bits = 16;
pub const work_bits_WORK_OFFQ_POOL_SHIFT: work_bits = 21;
pub const work_bits_WORK_OFFQ_LEFT: work_bits = 43;
pub const work_bits_WORK_OFFQ_POOL_BITS: work_bits = 31;
pub type work_bits = ffi::c_uint;
pub const work_flags_WORK_STRUCT_PENDING: work_flags = 1;
pub const work_flags_WORK_STRUCT_INACTIVE: work_flags = 2;
pub const work_flags_WORK_STRUCT_PWQ: work_flags = 4;
pub const work_flags_WORK_STRUCT_LINKED: work_flags = 8;
pub const work_flags_WORK_STRUCT_STATIC: work_flags = 0;
pub type work_flags = ffi::c_uint;
pub const wq_misc_consts_WORK_NR_COLORS: wq_misc_consts = 16;
pub const wq_misc_consts_WORK_CPU_UNBOUND: wq_misc_consts = 64;
pub const wq_misc_consts_WORK_BUSY_PENDING: wq_misc_consts = 1;
pub const wq_misc_consts_WORK_BUSY_RUNNING: wq_misc_consts = 2;
pub const wq_misc_consts_WORKER_DESC_LEN: wq_misc_consts = 32;
pub type wq_misc_consts = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ffi::c_int,
}
impl Default for delayed_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
impl Default for rcu_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const wq_affn_scope_WQ_AFFN_DFL: wq_affn_scope = 0;
pub const wq_affn_scope_WQ_AFFN_CPU: wq_affn_scope = 1;
pub const wq_affn_scope_WQ_AFFN_SMT: wq_affn_scope = 2;
pub const wq_affn_scope_WQ_AFFN_CACHE: wq_affn_scope = 3;
pub const wq_affn_scope_WQ_AFFN_NUMA: wq_affn_scope = 4;
pub const wq_affn_scope_WQ_AFFN_SYSTEM: wq_affn_scope = 5;
pub const wq_affn_scope_WQ_AFFN_NR_TYPES: wq_affn_scope = 6;
pub type wq_affn_scope = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_attrs {
    pub nice: ffi::c_int,
    pub cpumask: cpumask_var_t,
    pub __pod_cpumask: cpumask_var_t,
    pub affn_strict: bool_,
    pub affn_scope: wq_affn_scope,
    pub ordered: bool_,
}
impl Default for workqueue_attrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct execute_work {
    pub work: work_struct,
}
impl Default for execute_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const wq_flags_WQ_BH: wq_flags = 1;
pub const wq_flags_WQ_UNBOUND: wq_flags = 2;
pub const wq_flags_WQ_FREEZABLE: wq_flags = 4;
pub const wq_flags_WQ_MEM_RECLAIM: wq_flags = 8;
pub const wq_flags_WQ_HIGHPRI: wq_flags = 16;
pub const wq_flags_WQ_CPU_INTENSIVE: wq_flags = 32;
pub const wq_flags_WQ_SYSFS: wq_flags = 64;
pub const wq_flags_WQ_POWER_EFFICIENT: wq_flags = 128;
pub const wq_flags_WQ_PERCPU: wq_flags = 256;
pub const wq_flags___WQ_DESTROYING: wq_flags = 32768;
pub const wq_flags___WQ_DRAINING: wq_flags = 65536;
pub const wq_flags___WQ_ORDERED: wq_flags = 131072;
pub const wq_flags___WQ_LEGACY: wq_flags = 262144;
pub const wq_flags___WQ_BH_ALLOWS: wq_flags = 17;
pub type wq_flags = ffi::c_uint;
pub const wq_consts_WQ_MAX_ACTIVE: wq_consts = 2048;
pub const wq_consts_WQ_UNBOUND_MAX_ACTIVE: wq_consts = 2048;
pub const wq_consts_WQ_DFL_ACTIVE: wq_consts = 1024;
pub const wq_consts_WQ_DFL_MIN_ACTIVE: wq_consts = 8;
pub type wq_consts = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_merge_struct {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct clone_args {
    pub flags: __u64,
    pub pidfd: __u64,
    pub child_tid: __u64,
    pub parent_tid: __u64,
    pub exit_signal: __u64,
    pub stack: __u64,
    pub stack_size: __u64,
    pub tls: __u64,
    pub set_tid: __u64,
    pub set_tid_size: __u64,
    pub cgroup: __u64,
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    pub idr: idr,
    pub rcu: callback_head,
    pub pid_allocated: ffi::c_uint,
    pub child_reaper: *mut task_struct,
    pub pid_cachep: *mut kmem_cache,
    pub level: ffi::c_uint,
    pub pid_max: ffi::c_int,
    pub parent: *mut pid_namespace,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub reboot: ffi::c_int,
    pub ns: ns_common,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub memfd_noexec_scope: ffi::c_int,
}
impl Default for pid_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
impl Default for sysv_sem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
impl Default for sysv_shm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_context_state {
    pub param_tls: [ffi::c_char; 800usize],
    pub retval_tls: [ffi::c_char; 800usize],
    pub va_arg_tls: [ffi::c_char; 800usize],
    pub va_arg_origin_tls: [ffi::c_char; 800usize],
    pub va_arg_overflow_size_tls: u64_,
    pub param_origin_tls: [ffi::c_char; 800usize],
    pub retval_origin_tls: u32_,
}
impl Default for kmsan_context_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_ctx {
    pub cstate: kmsan_context_state,
    pub kmsan_in_runtime: ffi::c_int,
    pub depth: ffi::c_uint,
}
impl Default for kmsan_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
impl Default for plist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_node {
    pub prio: ffi::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
impl Default for plist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp {
    pub mode: ffi::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
impl Default for seccomp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rusage {
    pub ru_utime: __kernel_old_timeval,
    pub ru_stime: __kernel_old_timeval,
    pub ru_maxrss: __kernel_long_t,
    pub ru_ixrss: __kernel_long_t,
    pub ru_idrss: __kernel_long_t,
    pub ru_isrss: __kernel_long_t,
    pub ru_minflt: __kernel_long_t,
    pub ru_majflt: __kernel_long_t,
    pub ru_nswap: __kernel_long_t,
    pub ru_inblock: __kernel_long_t,
    pub ru_oublock: __kernel_long_t,
    pub ru_msgsnd: __kernel_long_t,
    pub ru_msgrcv: __kernel_long_t,
    pub ru_nsignals: __kernel_long_t,
    pub ru_nvcsw: __kernel_long_t,
    pub ru_nivcsw: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: __u64,
    pub rlim_max: __u64,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [ffi::c_ulong; 1usize],
}
pub type old_sigset_t = ffi::c_ulong;
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: ffi::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
pub struct sigaltstack {
    pub ss_sp: *mut ffi::c_void,
    pub ss_flags: ffi::c_int,
    pub ss_size: __kernel_size_t,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __sc_riscv_v_state {
    pub v_state: __riscv_v_ext_state,
}
impl Default for __sc_riscv_v_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub sc_regs: user_regs_struct,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub sc_fpregs: __riscv_fp_state,
    pub sc_extdesc: __riscv_extra_ext_header,
}
impl Default for sigcontext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigcontext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ffi::c_int,
    pub sival_ptr: *mut ffi::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ffi::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ffi::c_int,
}
impl Default for __sifields__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
impl Default for __sifields__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ffi::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ffi::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ffi::c_int,
    pub _addr_lsb: ffi::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [ffi::c_char; 8usize],
    pub _lower: *mut ffi::c_void,
    pub _upper: *mut ffi::c_void,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [ffi::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ffi::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ffi::c_long,
    pub _fd: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ffi::c_void,
    pub _syscall: ffi::c_int,
    pub _arch: ffi::c_uint,
}
impl Default for __sifields__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [ffi::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ffi::c_int,
    pub si_errno: ffi::c_int,
    pub si_code: ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ffi::c_int,
    pub sigev_notify: ffi::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [ffi::c_int; 12usize],
    pub _tid: ffi::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ffi::c_void,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: ffi::c_int,
    pub si_errno: ffi::c_int,
    pub si_code: ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for kernel_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigqueue {
    pub list: list_head,
    pub flags: ffi::c_int,
    pub info: kernel_siginfo_t,
    pub ucounts: *mut ucounts,
}
impl Default for sigqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
impl Default for sigpending {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ffi::c_ulong,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ksignal {
    pub ka: k_sigaction,
    pub info: kernel_siginfo_t,
    pub sig: ffi::c_int,
}
impl Default for ksignal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut ffi::c_char,
    pub offset: ffi::c_ulong,
    pub len: ffi::c_ulong,
    pub on_dispatch: bool_,
}
impl Default for syscall_user_dispatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_xmit {
    pub recursion: u16_,
    pub more: u8_,
    pub skip_txqueue: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_io_accounting {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
impl Default for posix_cputimer_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: ffi::c_uint,
    pub expiry_active: ffi::c_uint,
}
impl Default for posix_cputimers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub mutex: mutex,
    pub scheduled: ffi::c_uint,
}
impl Default for posix_cputimers_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const rseq_cpu_id_state_RSEQ_CPU_ID_UNINITIALIZED: rseq_cpu_id_state = -1;
pub const rseq_cpu_id_state_RSEQ_CPU_ID_REGISTRATION_FAILED: rseq_cpu_id_state = -2;
pub type rseq_cpu_id_state = ffi::c_int;
pub const rseq_flags_RSEQ_FLAG_UNREGISTER: rseq_flags = 1;
pub type rseq_flags = ffi::c_uint;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT: rseq_cs_flags_bit = 0;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT: rseq_cs_flags_bit = 1;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT: rseq_cs_flags_bit = 2;
pub type rseq_cs_flags_bit = ffi::c_uint;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT: rseq_cs_flags = 1;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL: rseq_cs_flags = 2;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE: rseq_cs_flags = 4;
pub type rseq_cs_flags = ffi::c_uint;
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct rseq_cs {
    pub version: __u32,
    pub flags: __u32,
    pub start_ip: __u64,
    pub post_commit_offset: __u64,
    pub abort_ip: __u64,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Default)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
    pub node_id: __u32,
    pub mm_cid: __u32,
    pub end: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags {
    pub mask: ffi::c_ulong,
    pub name: *const ffi::c_char,
}
impl Default for trace_print_flags {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: ffi::c_ulonglong,
    pub name: *const ffi::c_char,
}
impl Default for trace_print_flags_u64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ffi::c_void,
    pub data: *mut ffi::c_void,
    pub prio: ffi::c_int,
}
impl Default for tracepoint_func {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tracepoint_ext {
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl tracepoint_ext {
    #[inline]
    pub fn faultable(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_faultable(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn faultable_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_faultable_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(faultable: ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let faultable: u32 = unsafe { ::core::mem::transmute(faultable) };
            faultable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ffi::c_char,
    pub key: static_key_false,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut ffi::c_void,
    pub iterator: *mut ffi::c_void,
    pub probestub: *mut ffi::c_void,
    pub funcs: *mut tracepoint_func,
    pub ext: *mut tracepoint_ext,
}
impl Default for tracepoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type tracepoint_ptr_t = *mut tracepoint;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut ffi::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
impl Default for bpf_raw_event_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct unwind_cache {
    pub unwind_completed: ffi::c_ulong,
    pub nr_entries: ffi::c_uint,
    pub entries: __IncompleteArrayField<ffi::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union unwind_task_id {
    pub __bindgen_anon_1: unwind_task_id__bindgen_ty_1,
    pub id: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct unwind_task_id__bindgen_ty_1 {
    pub cpu: u32_,
    pub cnt: u32_,
}
impl Default for unwind_task_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct unwind_task_info {
    pub unwind_mask: ffi::c_ulong,
    pub cache: *mut unwind_cache,
    pub work: callback_head,
    pub id: unwind_task_id,
}
impl Default for unwind_task_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_net_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_ctx_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct root_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_event_mm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scx_task_group {}
pub const TASK_COMM_LEN: _bindgen_ty_9 = 16;
pub type _bindgen_ty_9 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
impl Default for prev_cputime {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vtime_state_VTIME_INACTIVE: vtime_state = 0;
pub const vtime_state_VTIME_IDLE: vtime_state = 1;
pub const vtime_state_VTIME_SYS: vtime_state = 2;
pub const vtime_state_VTIME_USER: vtime_state = 3;
pub const vtime_state_VTIME_GUEST: vtime_state = 4;
pub type vtime_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vtime {
    pub seqcount: seqcount_t,
    pub starttime: ffi::c_ulonglong,
    pub state: vtime_state,
    pub cpu: ffi::c_uint,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
}
impl Default for vtime {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const uclamp_id_UCLAMP_MIN: uclamp_id = 0;
pub const uclamp_id_UCLAMP_MAX: uclamp_id = 1;
pub const uclamp_id_UCLAMP_CNT: uclamp_id = 2;
pub type uclamp_id = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: ffi::c_ulong,
    pub run_delay: ffi::c_ulonglong,
    pub max_run_delay: ffi::c_ulonglong,
    pub min_run_delay: ffi::c_ulonglong,
    pub last_arrival: ffi::c_ulonglong,
    pub last_queued: ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct load_weight {
    pub weight: ffi::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: ffi::c_ulong,
    pub runnable_avg: ffi::c_ulong,
    pub util_avg: ffi::c_ulong,
    pub util_est: ffi::c_uint,
}
impl Default for sched_avg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_statistics {}
impl Default for sched_statistics {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub deadline: u64_,
    pub min_vruntime: u64_,
    pub min_slice: u64_,
    pub group_node: list_head,
    pub on_rq: ffi::c_uchar,
    pub sched_delayed: ffi::c_uchar,
    pub rel_deadline: ffi::c_uchar,
    pub custom_slice: ffi::c_uchar,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub __bindgen_anon_1: sched_entity__bindgen_ty_1,
    pub slice: u64_,
    pub nr_migrations: u64_,
    pub depth: ffi::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: ffi::c_ulong,
    pub __bindgen_padding_0: u64,
    pub avg: sched_avg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_entity__bindgen_ty_1 {
    pub vlag: s64,
    pub vprot: u64_,
}
impl Default for sched_entity__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sched_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: ffi::c_ulong,
    pub watchdog_stamp: ffi::c_ulong,
    pub time_slice: ffi::c_uint,
    pub on_rq: ffi::c_ushort,
    pub on_list: ffi::c_ushort,
    pub back: *mut sched_rt_entity,
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type dl_server_has_tasks_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sched_dl_entity) -> bool_>;
pub type dl_server_pick_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sched_dl_entity) -> *mut task_struct>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub rq: *mut rq,
    pub server_pick_task: dl_server_pick_f,
    pub pi_se: *mut sched_dl_entity,
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_throttled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_throttled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_yielded_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_yielded_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_non_contending_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_non_contending_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_overrun_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_overrun_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_server(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_server(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_server_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_server_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_server_active(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_server_active(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_server_active_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_server_active_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer_armed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer_armed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_armed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_armed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer_running(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer_running(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_running_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_running_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: ffi::c_uint,
        dl_yielded: ffi::c_uint,
        dl_non_contending: ffi::c_uint,
        dl_overrun: ffi::c_uint,
        dl_server: ffi::c_uint,
        dl_server_active: ffi::c_uint,
        dl_defer: ffi::c_uint,
        dl_defer_armed: ffi::c_uint,
        dl_defer_running: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dl_server: u32 = unsafe { ::core::mem::transmute(dl_server) };
            dl_server as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dl_server_active: u32 = unsafe { ::core::mem::transmute(dl_server_active) };
            dl_server_active as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dl_defer: u32 = unsafe { ::core::mem::transmute(dl_defer) };
            dl_defer as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dl_defer_armed: u32 = unsafe { ::core::mem::transmute(dl_defer_armed) };
            dl_defer_armed as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dl_defer_running: u32 = unsafe { ::core::mem::transmute(dl_defer_running) };
            dl_defer_running as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
impl Default for rcu_special {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const perf_event_task_context_perf_invalid_context: perf_event_task_context = -1;
pub const perf_event_task_context_perf_hw_context: perf_event_task_context = 0;
pub const perf_event_task_context_perf_sw_context: perf_event_task_context = 1;
pub const perf_event_task_context_perf_nr_task_contexts: perf_event_task_context = 2;
pub type perf_event_task_context = ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
impl Default for wake_q_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: ffi::c_uint,
    pub saved_state: ffi::c_uint,
    pub stack: *mut ffi::c_void,
    pub usage: refcount_t,
    pub flags: ffi::c_uint,
    pub ptrace: ffi::c_uint,
    pub on_cpu: ffi::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: ffi::c_uint,
    pub wakee_flip_decay_ts: ffi::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: ffi::c_int,
    pub wake_cpu: ffi::c_int,
    pub on_rq: ffi::c_int,
    pub prio: ffi::c_int,
    pub static_prio: ffi::c_int,
    pub normal_prio: ffi::c_int,
    pub rt_priority: ffi::c_uint,
    pub __bindgen_padding_0: [u64; 2usize],
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub dl_server: *mut sched_dl_entity,
    pub sched_class: *mut sched_class,
    pub sched_task_group: *mut task_group,
    pub __bindgen_padding_1: u64,
    pub stats: sched_statistics,
    pub preempt_notifiers: hlist_head,
    pub policy: ffi::c_uint,
    pub max_allowed_capacity: ffi::c_ulong,
    pub nr_cpus_allowed: ffi::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut ffi::c_void,
    pub migration_disabled: ffi::c_ushort,
    pub migration_flags: ffi::c_ushort,
    pub trc_reader_nesting: ffi::c_int,
    pub trc_ipi_to_cpu: ffi::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_holdout_list: list_head,
    pub trc_blkd_node: list_head,
    pub trc_blkd_cpu: ffi::c_int,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub faults_disabled_mapping: *mut address_space,
    pub exit_state: ffi::c_int,
    pub exit_code: ffi::c_int,
    pub exit_signal: ffi::c_int,
    pub pdeath_signal: ffi::c_int,
    pub jobctl: ffi::c_ulong,
    pub personality: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub atomic_flags: ffi::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: ffi::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut ffi::c_int,
    pub clear_child_tid: *mut ffi::c_int,
    pub worker_private: *mut ffi::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ffi::c_ulong,
    pub nivcsw: ffi::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: ffi::c_ulong,
    pub maj_flt: ffi::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [ffi::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: ffi::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: ffi::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: ffi::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub blocked_on: *mut mutex,
    pub journal_info: *mut ffi::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: ffi::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: ffi::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: ffi::c_uint,
    pub perf_recursion: [u8_; 4usize],
    pub perf_event_ctxp: *mut perf_event_context,
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub perf_ctx_data: *mut perf_ctx_data,
    pub rseq: *mut rseq,
    pub rseq_len: u32_,
    pub rseq_sig: u32_,
    pub rseq_event_mask: ffi::c_ulong,
    pub mm_cid: ffi::c_int,
    pub last_mm_cid: ffi::c_int,
    pub migrate_from_cpu: ffi::c_int,
    pub mm_cid_active: ffi::c_int,
    pub cid_work: callback_head,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub nr_dirtied: ffi::c_int,
    pub nr_dirtied_pause: ffi::c_int,
    pub dirty_paused_when: ffi::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub trace_recursion: ffi::c_ulong,
    pub memcg_nr_pages_over_high: ffi::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub objcg: *mut obj_cgroup,
    pub throttle_disk: *mut gendisk,
    pub utask: *mut uprobe_task,
    pub kmap_ctrl: kmap_ctrl,
    pub rcu: callback_head,
    pub rcu_users: refcount_t,
    pub pagefault_disabled: ffi::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub security: *mut ffi::c_void,
    pub bpf_storage: *mut bpf_local_storage,
    pub bpf_ctx: *mut bpf_run_ctx,
    pub bpf_net_context: *mut bpf_net_context,
    pub thread: thread_struct,
}
impl Default for task_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_reset_on_fork_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_reset_on_fork_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_contributes_to_load_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_contributes_to_load_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_migrated_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_migrated_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_task_hot(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_task_hot(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_task_hot_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_task_hot_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_remote_wakeup_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_remote_wakeup_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_rt_mutex(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_rt_mutex(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_rt_mutex_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_rt_mutex_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_execve(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_execve_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_execve_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_iowait_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_iowait_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn brk_randomized(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_randomized(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn brk_randomized_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_brk_randomized_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_cgroup_migration_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_cgroup_migration_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frozen(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frozen_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_frozen_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_memdelay_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_memdelay_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_eventfd_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_eventfd_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_nf_duplicate(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_nf_duplicate(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_nf_duplicate_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_nf_duplicate_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: ffi::c_uint,
        sched_contributes_to_load: ffi::c_uint,
        sched_migrated: ffi::c_uint,
        sched_task_hot: ffi::c_uint,
        sched_remote_wakeup: ffi::c_uint,
        sched_rt_mutex: ffi::c_uint,
        in_execve: ffi::c_uint,
        in_iowait: ffi::c_uint,
        brk_randomized: ffi::c_uint,
        no_cgroup_migration: ffi::c_uint,
        frozen: ffi::c_uint,
        use_memdelay: ffi::c_uint,
        in_eventfd: ffi::c_uint,
        in_nf_duplicate: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_task_hot: u32 = unsafe { ::core::mem::transmute(sched_task_hot) };
            sched_task_hot as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let sched_rt_mutex: u32 = unsafe { ::core::mem::transmute(sched_rt_mutex) };
            sched_rt_mutex as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let brk_randomized: u32 = unsafe { ::core::mem::transmute(brk_randomized) };
            brk_randomized as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let in_nf_duplicate: u32 = unsafe { ::core::mem::transmute(in_nf_duplicate) };
            in_nf_duplicate as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union thread_union {
    pub task: task_struct,
    pub stack: [ffi::c_ulong; 2048usize],
}
impl Default for thread_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_group_info {
    pub nr_units: ffi::c_int,
    pub base_offset: ffi::c_ulong,
    pub cpu_map: *mut ffi::c_uint,
}
impl Default for pcpu_group_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pcpu_alloc_info {
    pub static_size: usize,
    pub reserved_size: usize,
    pub dyn_size: usize,
    pub unit_size: usize,
    pub atom_size: usize,
    pub alloc_size: usize,
    pub __ai_size: usize,
    pub nr_groups: ffi::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
impl Default for pcpu_alloc_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pcpu_fc_PCPU_FC_AUTO: pcpu_fc = 0;
pub const pcpu_fc_PCPU_FC_EMBED: pcpu_fc = 1;
pub const pcpu_fc_PCPU_FC_PAGE: pcpu_fc = 2;
pub const pcpu_fc_PCPU_FC_NR: pcpu_fc = 3;
pub type pcpu_fc = ffi::c_uint;

pub type pcpu_fc_cpu_to_node_fn_t =
    ::core::option::Option<unsafe extern "C" fn(cpu: ffi::c_int) -> ffi::c_int>;
pub type pcpu_fc_cpu_distance_fn_t =
    ::core::option::Option<unsafe extern "C" fn(from: ffi::c_uint, to: ffi::c_uint) -> ffi::c_int>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
impl Default for percpu_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub id: atomic_long_t,
    pub vdso: *mut ffi::c_void,
    pub icache_stale_mask: cpumask_t,
    pub force_icache_flush: bool_,
    pub flags: ffi::c_ulong,
    pub pmlen: u8_,
}
impl Default for mm_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_private_hash {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub private: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ffi::c_void,
    pub mlock_count: ffi::c_uint,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub pcp_llist: llist_node,
    pub order: ffi::c_uint,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub __folio_index: ffi::c_ulong,
    pub share: ffi::c_ulong,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub pp_magic: ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ffi::c_ulong,
    pub dma_addr: ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _unused_pgmap_compound_head: *mut ffi::c_void,
    pub zone_device_data: *mut ffi::c_void,
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub page_type: ffi::c_uint,
    pub _mapcount: atomic_t,
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct encoded_page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swp_entry_t {
    pub val: ffi::c_ulong,
}
pub type mm_id_mapcount_t = ffi::c_int;
pub type mm_id_t = ffi::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_3,
    pub __bindgen_anon_4: folio__bindgen_ty_4,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
    pub memcg_data: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub pgmap: *mut dev_pagemap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ffi::c_void,
    pub mlock_count: ffi::c_uint,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub index: ffi::c_ulong,
    pub share: ffi::c_ulong,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub private: *mut ffi::c_void,
    pub swap: swp_entry_t,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
    pub __page_1: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1 {
    pub _flags_1: ffi::c_ulong,
    pub _head_1: ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub _mapcount_1: atomic_t,
    pub _refcount_1: atomic_t,
    pub _nr_pages: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _usable_1: [ffi::c_ulong; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _large_mapcount: atomic_t,
    pub _nr_pages_mapped: atomic_t,
    pub _entire_mapcount: atomic_t,
    pub _pincount: atomic_t,
    pub _mm_id_mapcount: [mm_id_mapcount_t; 2usize],
    pub __bindgen_anon_1:
        folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _mm_id: [mm_id_t; 2usize],
    pub _mm_ids: ffi::c_ulong,
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_3 {
    pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
    pub __page_2: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_1 {
    pub _flags_2: ffi::c_ulong,
    pub _head_2: ffi::c_ulong,
    pub _deferred_list: list_head,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_4 {
    pub __bindgen_anon_1: folio__bindgen_ty_4__bindgen_ty_1,
    pub __page_3: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_4__bindgen_ty_1 {
    pub _flags_3: ffi::c_ulong,
    pub _head_3: ffi::c_ulong,
    pub _hugetlb_subpool: *mut ffi::c_void,
    pub _hugetlb_cgroup: *mut ffi::c_void,
    pub _hugetlb_cgroup_rsvd: *mut ffi::c_void,
    pub _hugetlb_hwpoison: *mut ffi::c_void,
}
impl Default for folio__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ptdesc {
    pub __page_flags: ffi::c_ulong,
    pub __bindgen_anon_1: ptdesc__bindgen_ty_1,
    pub __page_mapping: ffi::c_ulong,
    pub __bindgen_anon_2: ptdesc__bindgen_ty_2,
    pub __bindgen_anon_3: ptdesc__bindgen_ty_3,
    pub __page_type: ffi::c_uint,
    pub __page_refcount: atomic_t,
    pub pt_memcg_data: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_1 {
    pub pt_rcu_head: callback_head,
    pub pt_list: list_head,
    pub __bindgen_anon_1: ptdesc__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ptdesc__bindgen_ty_1__bindgen_ty_1 {
    pub _pt_pad_1: ffi::c_ulong,
    pub pmd_huge_pte: pgtable_t,
}
impl Default for ptdesc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ptdesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_2 {
    pub pt_index: ffi::c_ulong,
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
    pub pt_share_count: atomic_t,
}
impl Default for ptdesc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_3 {
    pub _pt_pad_2: ffi::c_ulong,
    pub ptl: spinlock_t,
}
impl Default for ptdesc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ptdesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_flags_t = ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct freeptr_t {
    pub v: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_region {
    pub vm_rb: rb_node,
    pub vm_flags: vm_flags_t,
    pub vm_start: ffi::c_ulong,
    pub vm_end: ffi::c_ulong,
    pub vm_top: ffi::c_ulong,
    pub vm_pgoff: ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_usage: ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vm_region {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vm_region {
    #[inline]
    pub fn vm_icache_flushed(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vm_icache_flushed(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vm_icache_flushed_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_vm_icache_flushed_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(vm_icache_flushed: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vm_icache_flushed: u8 = unsafe { ::core::mem::transmute(vm_icache_flushed) };
            vm_icache_flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_userfaultfd_ctx {}
#[repr(C)]
#[derive(Default)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vma_numab_state {
    pub next_scan: ffi::c_ulong,
    pub pids_active_reset: ffi::c_ulong,
    pub pids_active: [ffi::c_ulong; 2usize],
    pub start_scan_seq: ffi::c_int,
    pub prev_scan_seq: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_desc {
    pub mm: *mut mm_struct,
    pub start: ffi::c_ulong,
    pub end: ffi::c_ulong,
    pub pgoff: ffi::c_ulong,
    pub file: *mut file,
    pub vm_flags: vm_flags_t,
    pub page_prot: pgprot_t,
    pub vm_ops: *const vm_operations_struct,
    pub private_data: *mut ffi::c_void,
}
impl Default for vm_area_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub __bindgen_anon_2: vm_area_struct__bindgen_ty_2,
    pub vm_lock_seq: ffi::c_uint,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut ffi::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub __bindgen_padding_0: [u32; 4usize],
    pub vm_refcnt: refcount_t,
    pub shared: vm_area_struct__bindgen_ty_3,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub vm_freeptr: freeptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub vm_start: ffi::c_ulong,
    pub vm_end: ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_2 {
    pub vm_flags: vm_flags_t,
    pub __vm_flags: vm_flags_t,
}
impl Default for vm_area_struct__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_3 {
    pub rb: rb_node,
    pub rb_subtree_last: ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_area_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mm_cid {
    pub time: u64_,
    pub cid: ffi::c_int,
    pub recent_cid: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_mm_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<ffi::c_ulong>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1__bindgen_ty_1,
    pub mm_mt: maple_tree,
    pub mmap_base: ffi::c_ulong,
    pub mmap_legacy_base: ffi::c_ulong,
    pub task_size: ffi::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub pcpu_cid: *mut mm_cid,
    pub mm_cid_next_scan: ffi::c_ulong,
    pub nr_cpus_allowed: ffi::c_uint,
    pub max_nr_cid: atomic_t,
    pub cpus_allowed_lock: raw_spinlock_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: ffi::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub vma_writer_wait: rcuwait,
    pub mm_lock_seq: seqcount_t,
    pub futex_hash_lock: mutex,
    pub futex_phash: *mut futex_private_hash,
    pub futex_phash_new: *mut futex_private_hash,
    pub futex_batches: ffi::c_ulong,
    pub futex_rcu: callback_head,
    pub futex_atomic: atomic_long_t,
    pub futex_ref: *mut ffi::c_uint,
    pub hiwater_rss: ffi::c_ulong,
    pub hiwater_vm: ffi::c_ulong,
    pub total_vm: ffi::c_ulong,
    pub locked_vm: ffi::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: ffi::c_ulong,
    pub exec_vm: ffi::c_ulong,
    pub stack_vm: ffi::c_ulong,
    pub def_flags: vm_flags_t,
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: ffi::c_ulong,
    pub end_code: ffi::c_ulong,
    pub start_data: ffi::c_ulong,
    pub end_data: ffi::c_ulong,
    pub start_brk: ffi::c_ulong,
    pub brk: ffi::c_ulong,
    pub start_stack: ffi::c_ulong,
    pub arg_start: ffi::c_ulong,
    pub arg_end: ffi::c_ulong,
    pub env_start: ffi::c_ulong,
    pub env_end: ffi::c_ulong,
    pub saved_auxv: [ffi::c_ulong; 66usize],
    pub rss_stat: [percpu_counter; 4usize],
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: ffi::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
    pub mm_count: atomic_t,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_iterator {
    pub mas: ma_state,
}
impl Default for vma_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mm_cid_state_MM_CID_UNSET: mm_cid_state = 4294967295;
pub const mm_cid_state_MM_CID_LAZY_PUT: mm_cid_state = 2147483648;
pub type mm_cid_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_gather {
    _unused: [u8; 0],
}

pub type vm_fault_t = ffi::c_uint;
pub const vm_fault_reason_VM_FAULT_OOM: vm_fault_reason = 1;
pub const vm_fault_reason_VM_FAULT_SIGBUS: vm_fault_reason = 2;
pub const vm_fault_reason_VM_FAULT_MAJOR: vm_fault_reason = 4;
pub const vm_fault_reason_VM_FAULT_HWPOISON: vm_fault_reason = 16;
pub const vm_fault_reason_VM_FAULT_HWPOISON_LARGE: vm_fault_reason = 32;
pub const vm_fault_reason_VM_FAULT_SIGSEGV: vm_fault_reason = 64;
pub const vm_fault_reason_VM_FAULT_NOPAGE: vm_fault_reason = 256;
pub const vm_fault_reason_VM_FAULT_LOCKED: vm_fault_reason = 512;
pub const vm_fault_reason_VM_FAULT_RETRY: vm_fault_reason = 1024;
pub const vm_fault_reason_VM_FAULT_FALLBACK: vm_fault_reason = 2048;
pub const vm_fault_reason_VM_FAULT_DONE_COW: vm_fault_reason = 4096;
pub const vm_fault_reason_VM_FAULT_NEEDDSYNC: vm_fault_reason = 8192;
pub const vm_fault_reason_VM_FAULT_COMPLETED: vm_fault_reason = 16384;
pub const vm_fault_reason_VM_FAULT_HINDEX_MASK: vm_fault_reason = 983040;
pub type vm_fault_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const ffi::c_char,
    pub pages: *mut *mut page,
    pub fault: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            vma: *mut vm_area_struct,
            vmf: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            new_vma: *mut vm_area_struct,
        ) -> ffi::c_int,
    >,
    pub close: ::core::option::Option<
        unsafe extern "C" fn(sm: *const vm_special_mapping, vma: *mut vm_area_struct),
    >,
}
impl Default for vm_special_mapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tlb_flush_reason_TLB_FLUSH_ON_TASK_SWITCH: tlb_flush_reason = 0;
pub const tlb_flush_reason_TLB_REMOTE_SHOOTDOWN: tlb_flush_reason = 1;
pub const tlb_flush_reason_TLB_LOCAL_SHOOTDOWN: tlb_flush_reason = 2;
pub const tlb_flush_reason_TLB_LOCAL_MM_SHOOTDOWN: tlb_flush_reason = 3;
pub const tlb_flush_reason_TLB_REMOTE_SEND_IPI: tlb_flush_reason = 4;
pub const tlb_flush_reason_TLB_REMOTE_WRONG_CPU: tlb_flush_reason = 5;
pub const tlb_flush_reason_NR_TLB_FLUSH_REASONS: tlb_flush_reason = 6;
pub type tlb_flush_reason = ffi::c_uint;
pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
pub const fault_flag_FAULT_FLAG_VMA_LOCK: fault_flag = 4096;
pub type fault_flag = ffi::c_uint;
pub type zap_flags_t = ffi::c_uint;
pub type cydp_t = ffi::c_int;
pub const FOLL_WRITE: _bindgen_ty_10 = 1;
pub const FOLL_GET: _bindgen_ty_10 = 2;
pub const FOLL_DUMP: _bindgen_ty_10 = 4;
pub const FOLL_FORCE: _bindgen_ty_10 = 8;
pub const FOLL_NOWAIT: _bindgen_ty_10 = 16;
pub const FOLL_NOFAULT: _bindgen_ty_10 = 32;
pub const FOLL_HWPOISON: _bindgen_ty_10 = 64;
pub const FOLL_ANON: _bindgen_ty_10 = 128;
pub const FOLL_LONGTERM: _bindgen_ty_10 = 256;
pub const FOLL_SPLIT_PMD: _bindgen_ty_10 = 512;
pub const FOLL_PCI_P2PDMA: _bindgen_ty_10 = 1024;
pub const FOLL_INTERRUPTIBLE: _bindgen_ty_10 = 2048;
pub const FOLL_HONOR_NUMA_FAULT: _bindgen_ty_10 = 4096;
pub type _bindgen_ty_10 = ffi::c_uint;
pub const pageflags_PG_locked: pageflags = 0;
pub const pageflags_PG_writeback: pageflags = 1;
pub const pageflags_PG_referenced: pageflags = 2;
pub const pageflags_PG_uptodate: pageflags = 3;
pub const pageflags_PG_dirty: pageflags = 4;
pub const pageflags_PG_lru: pageflags = 5;
pub const pageflags_PG_head: pageflags = 6;
pub const pageflags_PG_waiters: pageflags = 7;
pub const pageflags_PG_active: pageflags = 8;
pub const pageflags_PG_workingset: pageflags = 9;
pub const pageflags_PG_owner_priv_1: pageflags = 10;
pub const pageflags_PG_owner_2: pageflags = 11;
pub const pageflags_PG_arch_1: pageflags = 12;
pub const pageflags_PG_reserved: pageflags = 13;
pub const pageflags_PG_private: pageflags = 14;
pub const pageflags_PG_private_2: pageflags = 15;
pub const pageflags_PG_reclaim: pageflags = 16;
pub const pageflags_PG_swapbacked: pageflags = 17;
pub const pageflags_PG_unevictable: pageflags = 18;
pub const pageflags_PG_dropbehind: pageflags = 19;
pub const pageflags_PG_mlocked: pageflags = 20;
pub const pageflags___NR_PAGEFLAGS: pageflags = 21;
pub const pageflags_PG_readahead: pageflags = 16;
pub const pageflags_PG_swapcache: pageflags = 10;
pub const pageflags_PG_checked: pageflags = 10;
pub const pageflags_PG_anon_exclusive: pageflags = 11;
pub const pageflags_PG_mappedtodisk: pageflags = 11;
pub const pageflags_PG_fscache: pageflags = 15;
pub const pageflags_PG_pinned: pageflags = 10;
pub const pageflags_PG_savepinned: pageflags = 4;
pub const pageflags_PG_foreign: pageflags = 10;
pub const pageflags_PG_xen_remapped: pageflags = 10;
pub const pageflags_PG_movable_ops_isolated: pageflags = 16;
pub const pageflags_PG_movable_ops: pageflags = 3;
pub const pageflags_PG_reported: pageflags = 3;
pub const pageflags_PG_has_hwpoisoned: pageflags = 8;
pub const pageflags_PG_large_rmappable: pageflags = 9;
pub const pageflags_PG_partially_mapped: pageflags = 16;
pub type pageflags = ffi::c_uint;

pub const pagetype_PGTY_buddy: pagetype = 240;
pub const pagetype_PGTY_offline: pagetype = 241;
pub const pagetype_PGTY_table: pagetype = 242;
pub const pagetype_PGTY_guard: pagetype = 243;
pub const pagetype_PGTY_hugetlb: pagetype = 244;
pub const pagetype_PGTY_slab: pagetype = 245;
pub const pagetype_PGTY_zsmalloc: pagetype = 246;
pub const pagetype_PGTY_unaccepted: pagetype = 247;
pub const pagetype_PGTY_large_kmalloc: pagetype = 248;
pub const pagetype_PGTY_mapcount_underflow: pagetype = 255;
pub type pagetype = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_lock_t {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_trylock_t {
    pub llock: local_lock_t,
    pub acquired: u8_,
}
pub type class_local_lock_t = *mut local_lock_t;
pub const class_local_lock_is_conditional: bool_ = false;
pub type class_local_lock_irq_t = *mut local_lock_t;
pub const class_local_lock_irq_is_conditional: bool_ = false;
pub const class_local_lock_irqsave_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_local_lock_irqsave_t {
    pub lock: *mut local_lock_t,
    pub flags: ffi::c_ulong,
}
impl Default for class_local_lock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_local_lock_nested_bh_t = *mut local_lock_t;
pub const class_local_lock_nested_bh_is_conditional: bool_ = false;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct zswap_lruvec_state {}
pub const migratetype_MIGRATE_UNMOVABLE: migratetype = 0;
pub const migratetype_MIGRATE_MOVABLE: migratetype = 1;
pub const migratetype_MIGRATE_RECLAIMABLE: migratetype = 2;
pub const migratetype_MIGRATE_PCPTYPES: migratetype = 3;
pub const migratetype_MIGRATE_HIGHATOMIC: migratetype = 3;
pub const migratetype___MIGRATE_TYPE_END: migratetype = 3;
pub const migratetype_MIGRATE_TYPES: migratetype = 4;
pub type migratetype = i32;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 4usize],
    pub nr_free: ffi::c_ulong,
}
impl Default for free_area {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const zone_stat_item_NR_FREE_PAGES: zone_stat_item = 0;
pub const zone_stat_item_NR_FREE_PAGES_BLOCKS: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_LRU_BASE: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_INACTIVE_ANON: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_ACTIVE_ANON: zone_stat_item = 3;
pub const zone_stat_item_NR_ZONE_INACTIVE_FILE: zone_stat_item = 4;
pub const zone_stat_item_NR_ZONE_ACTIVE_FILE: zone_stat_item = 5;
pub const zone_stat_item_NR_ZONE_UNEVICTABLE: zone_stat_item = 6;
pub const zone_stat_item_NR_ZONE_WRITE_PENDING: zone_stat_item = 7;
pub const zone_stat_item_NR_MLOCK: zone_stat_item = 8;
pub const zone_stat_item_NR_FREE_CMA_PAGES: zone_stat_item = 9;
pub const zone_stat_item_NR_VM_ZONE_STAT_ITEMS: zone_stat_item = 10;
pub type zone_stat_item = ffi::c_uint;
pub const node_stat_item_NR_LRU_BASE: node_stat_item = 0;
pub const node_stat_item_NR_INACTIVE_ANON: node_stat_item = 0;
pub const node_stat_item_NR_ACTIVE_ANON: node_stat_item = 1;
pub const node_stat_item_NR_INACTIVE_FILE: node_stat_item = 2;
pub const node_stat_item_NR_ACTIVE_FILE: node_stat_item = 3;
pub const node_stat_item_NR_UNEVICTABLE: node_stat_item = 4;
pub const node_stat_item_NR_SLAB_RECLAIMABLE_B: node_stat_item = 5;
pub const node_stat_item_NR_SLAB_UNRECLAIMABLE_B: node_stat_item = 6;
pub const node_stat_item_NR_ISOLATED_ANON: node_stat_item = 7;
pub const node_stat_item_NR_ISOLATED_FILE: node_stat_item = 8;
pub const node_stat_item_WORKINGSET_NODES: node_stat_item = 9;
pub const node_stat_item_WORKINGSET_REFAULT_BASE: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_ANON: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_FILE: node_stat_item = 11;
pub const node_stat_item_WORKINGSET_ACTIVATE_BASE: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_ANON: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_FILE: node_stat_item = 13;
pub const node_stat_item_WORKINGSET_RESTORE_BASE: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_ANON: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_FILE: node_stat_item = 15;
pub const node_stat_item_WORKINGSET_NODERECLAIM: node_stat_item = 16;
pub const node_stat_item_NR_ANON_MAPPED: node_stat_item = 17;
pub const node_stat_item_NR_FILE_MAPPED: node_stat_item = 18;
pub const node_stat_item_NR_FILE_PAGES: node_stat_item = 19;
pub const node_stat_item_NR_FILE_DIRTY: node_stat_item = 20;
pub const node_stat_item_NR_WRITEBACK: node_stat_item = 21;
pub const node_stat_item_NR_SHMEM: node_stat_item = 22;
pub const node_stat_item_NR_SHMEM_THPS: node_stat_item = 23;
pub const node_stat_item_NR_SHMEM_PMDMAPPED: node_stat_item = 24;
pub const node_stat_item_NR_FILE_THPS: node_stat_item = 25;
pub const node_stat_item_NR_FILE_PMDMAPPED: node_stat_item = 26;
pub const node_stat_item_NR_ANON_THPS: node_stat_item = 27;
pub const node_stat_item_NR_VMSCAN_WRITE: node_stat_item = 28;
pub const node_stat_item_NR_VMSCAN_IMMEDIATE: node_stat_item = 29;
pub const node_stat_item_NR_DIRTIED: node_stat_item = 30;
pub const node_stat_item_NR_WRITTEN: node_stat_item = 31;
pub const node_stat_item_NR_THROTTLED_WRITTEN: node_stat_item = 32;
pub const node_stat_item_NR_KERNEL_MISC_RECLAIMABLE: node_stat_item = 33;
pub const node_stat_item_NR_FOLL_PIN_ACQUIRED: node_stat_item = 34;
pub const node_stat_item_NR_FOLL_PIN_RELEASED: node_stat_item = 35;
pub const node_stat_item_NR_KERNEL_STACK_KB: node_stat_item = 36;
pub const node_stat_item_NR_PAGETABLE: node_stat_item = 37;
pub const node_stat_item_NR_SECONDARY_PAGETABLE: node_stat_item = 38;
pub const node_stat_item_NR_IOMMU_PAGES: node_stat_item = 39;
pub const node_stat_item_NR_SWAPCACHE: node_stat_item = 40;
pub const node_stat_item_PGDEMOTE_KSWAPD: node_stat_item = 41;
pub const node_stat_item_PGDEMOTE_DIRECT: node_stat_item = 42;
pub const node_stat_item_PGDEMOTE_KHUGEPAGED: node_stat_item = 43;
pub const node_stat_item_PGDEMOTE_PROACTIVE: node_stat_item = 44;
pub const node_stat_item_NR_HUGETLB: node_stat_item = 45;
pub const node_stat_item_NR_BALLOON_PAGES: node_stat_item = 46;
pub const node_stat_item_NR_VM_NODE_STAT_ITEMS: node_stat_item = 47;
pub type node_stat_item = ffi::c_uint;
pub const lru_list_LRU_INACTIVE_ANON: lru_list = 0;
pub const lru_list_LRU_ACTIVE_ANON: lru_list = 1;
pub const lru_list_LRU_INACTIVE_FILE: lru_list = 2;
pub const lru_list_LRU_ACTIVE_FILE: lru_list = 3;
pub const lru_list_LRU_UNEVICTABLE: lru_list = 4;
pub const lru_list_NR_LRU_LISTS: lru_list = 5;
pub type lru_list = ffi::c_uint;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_WRITEBACK: vmscan_throttle_state = 0;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_ISOLATED: vmscan_throttle_state = 1;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_NOPROGRESS: vmscan_throttle_state = 2;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_CONGESTED: vmscan_throttle_state = 3;
pub const vmscan_throttle_state_NR_VMSCAN_THROTTLE: vmscan_throttle_state = 4;
pub type vmscan_throttle_state = ffi::c_uint;
pub const lruvec_flags_LRUVEC_CGROUP_CONGESTED: lruvec_flags = 0;
pub const lruvec_flags_LRUVEC_NODE_CONGESTED: lruvec_flags = 1;
pub type lruvec_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_vma_mapped_walk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: ffi::c_ulong,
    pub file_cost: ffi::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [ffi::c_ulong; 2usize],
    pub flags: ffi::c_ulong,
    pub pgdat: *mut pglist_data,
    pub zswap_lruvec_state: zswap_lruvec_state,
}
impl Default for lruvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type isolate_mode_t = ffi::c_uint;
pub const zone_watermarks_WMARK_MIN: zone_watermarks = 0;
pub const zone_watermarks_WMARK_LOW: zone_watermarks = 1;
pub const zone_watermarks_WMARK_HIGH: zone_watermarks = 2;
pub const zone_watermarks_WMARK_PROMO: zone_watermarks = 3;
pub const zone_watermarks_NR_WMARK: zone_watermarks = 4;
pub type zone_watermarks = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub lock: spinlock_t,
    pub count: ffi::c_int,
    pub high: ffi::c_int,
    pub high_min: ffi::c_int,
    pub high_max: ffi::c_int,
    pub batch: ffi::c_int,
    pub flags: u8_,
    pub alloc_factor: u8_,
    pub free_count: ffi::c_short,
    pub lists: [list_head; 12usize],
}
impl Default for per_cpu_pages {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct per_cpu_zonestat {
    pub vm_stat_diff: [s8; 10usize],
    pub stat_threshold: s8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 47usize],
}
impl Default for per_cpu_nodestat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const zone_type_ZONE_DMA32: zone_type = 0;
pub const zone_type_ZONE_NORMAL: zone_type = 1;
pub const zone_type_ZONE_MOVABLE: zone_type = 2;
pub const zone_type___MAX_NR_ZONES: zone_type = 3;
pub type zone_type = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct zone {
    pub _watermark: [ffi::c_ulong; 4usize],
    pub watermark_boost: ffi::c_ulong,
    pub nr_reserved_highatomic: ffi::c_ulong,
    pub nr_free_highatomic: ffi::c_ulong,
    pub lowmem_reserve: [ffi::c_long; 3usize],
    pub zone_pgdat: *mut pglist_data,
    pub per_cpu_pageset: *mut per_cpu_pages,
    pub per_cpu_zonestats: *mut per_cpu_zonestat,
    pub pageset_high_min: ffi::c_int,
    pub pageset_high_max: ffi::c_int,
    pub pageset_batch: ffi::c_int,
    pub zone_start_pfn: ffi::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: ffi::c_ulong,
    pub present_pages: ffi::c_ulong,
    pub name: *const ffi::c_char,
    pub initialized: ffi::c_int,
    pub __bindgen_padding_0: [u64; 3usize],
    pub _pad1_: cacheline_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ffi::c_ulong,
    pub lock: spinlock_t,
    pub trylock_free_pages: llist_head,
    pub __bindgen_padding_1: [u64; 2usize],
    pub _pad2_: cacheline_padding,
    pub percpu_drift_mark: ffi::c_ulong,
    pub compact_cached_free_pfn: ffi::c_ulong,
    pub compact_cached_migrate_pfn: [ffi::c_ulong; 2usize],
    pub compact_init_migrate_pfn: ffi::c_ulong,
    pub compact_init_free_pfn: ffi::c_ulong,
    pub compact_considered: ffi::c_uint,
    pub compact_defer_shift: ffi::c_uint,
    pub compact_order_failed: ffi::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 0usize],
    pub _pad3_: cacheline_padding,
    pub vm_stat: [atomic_long_t; 10usize],
    pub vm_numa_event: __IncompleteArrayField<atomic_long_t>,
}
impl Default for zone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pgdat_flags_PGDAT_DIRTY: pgdat_flags = 0;
pub const pgdat_flags_PGDAT_WRITEBACK: pgdat_flags = 1;
pub const pgdat_flags_PGDAT_RECLAIM_LOCKED: pgdat_flags = 2;
pub type pgdat_flags = ffi::c_uint;
pub const zone_flags_ZONE_BOOSTED_WATERMARK: zone_flags = 0;
pub const zone_flags_ZONE_RECLAIM_ACTIVE: zone_flags = 1;
pub const zone_flags_ZONE_BELOW_HIGH: zone_flags = 2;
pub type zone_flags = ffi::c_uint;
pub const ZONELIST_FALLBACK: _bindgen_ty_11 = 0;
pub const MAX_ZONELISTS: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ffi::c_int,
}
impl Default for zoneref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 4usize],
}
impl Default for zonelist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[repr(align(64))]
pub struct pglist_data {
    pub node_zones: [zone; 3usize],
    pub node_zonelists: [zonelist; 1usize],
    pub nr_zones: ffi::c_int,
    pub node_start_pfn: ffi::c_ulong,
    pub node_present_pages: ffi::c_ulong,
    pub node_spanned_pages: ffi::c_ulong,
    pub node_id: ffi::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub reclaim_wait: [wait_queue_head_t; 4usize],
    pub nr_writeback_throttled: atomic_t,
    pub nr_reclaim_start: ffi::c_ulong,
    pub kswapd: *mut task_struct,
    pub kswapd_order: ffi::c_int,
    pub kswapd_highest_zoneidx: zone_type,
    pub kswapd_failures: ffi::c_int,
    pub kcompactd_max_order: ffi::c_int,
    pub kcompactd_highest_zoneidx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub proactive_compact_trigger: bool_,
    pub totalreserve_pages: ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 5usize],
    pub _pad1_: cacheline_padding,
    pub __lruvec: lruvec,
    pub flags: ffi::c_ulong,
    pub __bindgen_padding_1: [u64; 5usize],
    pub _pad2_: cacheline_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 47usize],
}
impl Default for pglist_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_cblist {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
    pub len: ffi::c_long,
}
impl Default for rcu_cblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [ffi::c_ulong; 4usize],
    pub len: ffi::c_long,
    pub seglen: [ffi::c_long; 4usize],
    pub flags: u8_,
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct srcu_ctr {
    pub srcu_locks: atomic_long_t,
    pub srcu_unlocks: atomic_long_t,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_ctrs: [srcu_ctr; 2usize],
    pub srcu_reader_flavor: ffi::c_int,
    pub __bindgen_padding_0: [u32; 7usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ffi::c_ulong,
    pub cpu: ffi::c_int,
    pub ssp: *mut srcu_struct,
}
impl Default for srcu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [ffi::c_ulong; 4usize],
    pub srcu_data_have_cbs: [ffi::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ffi::c_int,
    pub grphi: ffi::c_int,
}
impl Default for srcu_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_usage {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 3usize],
    pub srcu_size_state: ffi::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_gp_seq: ffi::c_ulong,
    pub srcu_gp_seq_needed: ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_gp_start: ffi::c_ulong,
    pub srcu_last_gp_end: ffi::c_ulong,
    pub srcu_size_jiffies: ffi::c_ulong,
    pub srcu_n_lock_retries: ffi::c_ulong,
    pub srcu_n_exp_nodelay: ffi::c_ulong,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: ffi::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: ffi::c_ulong,
    pub reschedule_count: ffi::c_ulong,
    pub work: delayed_work,
    pub srcu_ssp: *mut srcu_struct,
}
impl Default for srcu_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub srcu_ctrp: *mut srcu_ctr,
    pub sda: *mut srcu_data,
    pub dep_map: lockdep_map,
    pub srcu_sup: *mut srcu_usage,
}
impl Default for srcu_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_srcu_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_srcu_t {
    pub lock: *mut srcu_struct,
    pub idx: ffi::c_int,
}
impl Default for class_srcu_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const class_srcu_fast_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_srcu_fast_t {
    pub lock: *mut srcu_struct,
    pub scp: *mut srcu_ctr,
}
impl Default for class_srcu_fast_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: ffi::c_ulong,
        data: *mut ffi::c_void,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ffi::c_int,
}
impl Default for notifier_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
impl Default for atomic_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
impl Default for blocking_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
impl Default for raw_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcuu: srcu_usage,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
impl Default for srcu_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_group {
    _unused: [u8; 0],
}

pub const meminit_context_MEMINIT_EARLY: meminit_context = 0;
pub const meminit_context_MEMINIT_HOTPLUG: meminit_context = 1;
pub type meminit_context = ffi::c_uint;

#[repr(C)]
pub struct mem_section_usage {
    pub rcu: callback_head,
    pub subsection_map: [ffi::c_ulong; 1usize],
    pub pageblock_flags: __IncompleteArrayField<ffi::c_ulong>,
}
impl Default for mem_section_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_section {
    pub section_mem_map: ffi::c_ulong,
    pub usage: *mut mem_section_usage,
}
impl Default for mem_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const SECTION_MARKED_PRESENT_BIT: _bindgen_ty_12 = 0;
pub const SECTION_HAS_MEM_MAP_BIT: _bindgen_ty_12 = 1;
pub const SECTION_IS_ONLINE_BIT: _bindgen_ty_12 = 2;
pub const SECTION_IS_EARLY_BIT: _bindgen_ty_12 = 3;
pub const SECTION_MAP_LAST_BIT: _bindgen_ty_12 = 4;
pub type _bindgen_ty_12 = ffi::c_uint;

pub const scale_freq_source_SCALE_FREQ_SOURCE_CPUFREQ: scale_freq_source = 0;
pub const scale_freq_source_SCALE_FREQ_SOURCE_ARCH: scale_freq_source = 1;
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPPC: scale_freq_source = 2;
pub const scale_freq_source_SCALE_FREQ_SOURCE_VIRT: scale_freq_source = 3;
pub type scale_freq_source = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scale_freq_data {
    pub source: scale_freq_source,
    pub set_freq_scale: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for scale_freq_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_topology {
    pub thread_id: ffi::c_int,
    pub core_id: ffi::c_int,
    pub cluster_id: ffi::c_int,
    pub package_id: ffi::c_int,
    pub thread_sibling: cpumask_t,
    pub core_sibling: cpumask_t,
    pub cluster_sibling: cpumask_t,
    pub llc_sibling: cpumask_t,
}

pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
pub const __PERCPU_REF_ATOMIC: _bindgen_ty_13 = 1;
pub const __PERCPU_REF_DEAD: _bindgen_ty_13 = 2;
pub const __PERCPU_REF_ATOMIC_DEAD: _bindgen_ty_13 = 3;
pub const __PERCPU_REF_FLAG_BITS: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ffi::c_uint;
pub const PERCPU_REF_INIT_ATOMIC: _bindgen_ty_14 = 1;
pub const PERCPU_REF_INIT_DEAD: _bindgen_ty_14 = 2;
pub const PERCPU_REF_ALLOW_REINIT: _bindgen_ty_14 = 4;
pub type _bindgen_ty_14 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl Default for percpu_ref_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_atomic_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_force_atomic_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_reinit_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_allow_reinit_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: ffi::c_ulong,
    pub data: *mut percpu_ref_data,
}
impl Default for percpu_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const _slab_flag_bits__SLAB_CONSISTENCY_CHECKS: _slab_flag_bits = 0;
pub const _slab_flag_bits__SLAB_RED_ZONE: _slab_flag_bits = 1;
pub const _slab_flag_bits__SLAB_POISON: _slab_flag_bits = 2;
pub const _slab_flag_bits__SLAB_KMALLOC: _slab_flag_bits = 3;
pub const _slab_flag_bits__SLAB_HWCACHE_ALIGN: _slab_flag_bits = 4;
pub const _slab_flag_bits__SLAB_CACHE_DMA: _slab_flag_bits = 5;
pub const _slab_flag_bits__SLAB_CACHE_DMA32: _slab_flag_bits = 6;
pub const _slab_flag_bits__SLAB_STORE_USER: _slab_flag_bits = 7;
pub const _slab_flag_bits__SLAB_PANIC: _slab_flag_bits = 8;
pub const _slab_flag_bits__SLAB_TYPESAFE_BY_RCU: _slab_flag_bits = 9;
pub const _slab_flag_bits__SLAB_TRACE: _slab_flag_bits = 10;
pub const _slab_flag_bits__SLAB_NOLEAKTRACE: _slab_flag_bits = 11;
pub const _slab_flag_bits__SLAB_NO_MERGE: _slab_flag_bits = 12;
pub const _slab_flag_bits__SLAB_ACCOUNT: _slab_flag_bits = 13;
pub const _slab_flag_bits__SLAB_NO_USER_FLAGS: _slab_flag_bits = 14;
pub const _slab_flag_bits__SLAB_RECLAIM_ACCOUNT: _slab_flag_bits = 15;
pub const _slab_flag_bits__SLAB_OBJECT_POISON: _slab_flag_bits = 16;
pub const _slab_flag_bits__SLAB_CMPXCHG_DOUBLE: _slab_flag_bits = 17;
pub const _slab_flag_bits__SLAB_NO_OBJ_EXT: _slab_flag_bits = 18;
pub const _slab_flag_bits__SLAB_FLAGS_LAST_BIT: _slab_flag_bits = 19;
pub type _slab_flag_bits = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_struct {
    _unused: [u8; 0],
}
pub type kasan_vmalloc_flags_t = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kmem_cache_args {
    pub align: ffi::c_uint,
    pub useroffset: ffi::c_uint,
    pub usersize: ffi::c_uint,
    pub freeptr_offset: ffi::c_uint,
    pub use_freeptr_offset: bool_,
    pub ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>,
}

pub const kmalloc_cache_type_KMALLOC_NORMAL: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_DMA: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RANDOM_START: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RANDOM_END: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RECLAIM: kmalloc_cache_type = 1;
pub const kmalloc_cache_type_KMALLOC_CGROUP: kmalloc_cache_type = 2;
pub const kmalloc_cache_type_NR_KMALLOC_TYPES: kmalloc_cache_type = 3;
pub type kmalloc_cache_type = ffi::c_uint;
pub type kmem_buckets = [*mut kmem_cache; 14usize];

#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource_win {
    pub res: resource,
    pub offset: resource_size_t,
}
impl Default for resource_win {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource_entry {
    pub node: list_head,
    pub res: *mut resource,
    pub offset: resource_size_t,
    pub __res: resource,
}
impl Default for resource_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_printk_info {
    pub subsystem: [ffi::c_char; 16usize],
    pub device: [ffi::c_char; 48usize],
}
impl Default for dev_printk_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY: _bindgen_ty_15 = 1;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED: _bindgen_ty_15 = 2;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY: _bindgen_ty_15 = 4;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED: _bindgen_ty_15 = 8;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY: _bindgen_ty_15 = 16;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE: _bindgen_ty_15 = 32;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY: _bindgen_ty_15 = 64;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ: _bindgen_ty_15 = 128;
pub type _bindgen_ty_15 = ffi::c_uint;
pub const MEMBARRIER_FLAG_SYNC_CORE: _bindgen_ty_16 = 1;
pub const MEMBARRIER_FLAG_RSEQ: _bindgen_ty_16 = 2;
pub type _bindgen_ty_16 = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xa_limit {
    pub max: u32_,
    pub min: u32_,
}
pub type xa_mark_t = ffi::c_uint;
pub const xa_lock_type_XA_LOCK_IRQ: xa_lock_type = 1;
pub const xa_lock_type_XA_LOCK_BH: xa_lock_type = 2;
pub type xa_lock_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut ffi::c_void,
}
impl Default for xarray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_node {
    pub shift: ffi::c_uchar,
    pub offset: ffi::c_uchar,
    pub count: ffi::c_uchar,
    pub nr_values: ffi::c_uchar,
    pub parent: *mut xa_node,
    pub array: *mut xarray,
    pub __bindgen_anon_1: xa_node__bindgen_ty_1,
    pub slots: [*mut ffi::c_void; 64usize],
    pub __bindgen_anon_2: xa_node__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
}
impl Default for xa_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_2 {
    pub tags: [[ffi::c_ulong; 1usize]; 3usize],
    pub marks: [[ffi::c_ulong; 1usize]; 3usize],
}
impl Default for xa_node__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for xa_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type xa_update_node_t = ::core::option::Option<unsafe extern "C" fn(node: *mut xa_node)>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_state {
    pub xa: *mut xarray,
    pub xa_index: ffi::c_ulong,
    pub xa_shift: ffi::c_uchar,
    pub xa_sibs: ffi::c_uchar,
    pub xa_offset: ffi::c_uchar,
    pub xa_pad: ffi::c_uchar,
    pub xa_node: *mut xa_node,
    pub xa_alloc: *mut xa_node,
    pub xa_update: xa_update_node_t,
    pub xa_lru: *mut list_lru,
}
impl Default for xa_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const XA_CHECK_SCHED: _bindgen_ty_17 = 4096;
pub type _bindgen_ty_17 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_preload {
    pub lock: local_lock_t,
    pub nr: ffi::c_uint,
    pub nodes: *mut xa_node,
}
impl Default for radix_tree_preload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_iter {
    pub index: ffi::c_ulong,
    pub next_index: ffi::c_ulong,
    pub tags: ffi::c_ulong,
    pub node: *mut xa_node,
}
impl Default for radix_tree_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const RADIX_TREE_ITER_TAG_MASK: _bindgen_ty_18 = 15;
pub const RADIX_TREE_ITER_TAGGED: _bindgen_ty_18 = 16;
pub const RADIX_TREE_ITER_CONTIG: _bindgen_ty_18 = 32;
pub type _bindgen_ty_18 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: ffi::c_uint,
    pub idr_next: ffi::c_uint,
}
impl Default for idr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __class_idr {
    pub idr: *mut idr,
    pub id: ffi::c_int,
}
impl Default for __class_idr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_idr_alloc_t = __class_idr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ida_bitmap {
    pub bitmap: [ffi::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ida {
    pub xa: xarray,
}
impl Default for ida {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub parent: *mut user_namespace,
    pub level: ffi::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: ffi::c_ulong,
    pub parent_could_setfcap: bool_,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [ffi::c_long; 10usize],
    pub rlimit_max: [ffi::c_long; 4usize],
}
impl Default for user_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_global_locks {
    pub open_file_mutex: [mutex; 1024usize],
}
impl Default for kernfs_global_locks {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const kernfs_node_type_KERNFS_DIR: kernfs_node_type = 1;
pub const kernfs_node_type_KERNFS_FILE: kernfs_node_type = 2;
pub const kernfs_node_type_KERNFS_LINK: kernfs_node_type = 4;
pub type kernfs_node_type = ffi::c_uint;
pub const kernfs_node_flag_KERNFS_ACTIVATED: kernfs_node_flag = 16;
pub const kernfs_node_flag_KERNFS_NS: kernfs_node_flag = 32;
pub const kernfs_node_flag_KERNFS_HAS_SEQ_SHOW: kernfs_node_flag = 64;
pub const kernfs_node_flag_KERNFS_HAS_MMAP: kernfs_node_flag = 128;
pub const kernfs_node_flag_KERNFS_LOCKDEP: kernfs_node_flag = 256;
pub const kernfs_node_flag_KERNFS_HIDDEN: kernfs_node_flag = 512;
pub const kernfs_node_flag_KERNFS_SUICIDAL: kernfs_node_flag = 1024;
pub const kernfs_node_flag_KERNFS_SUICIDED: kernfs_node_flag = 2048;
pub const kernfs_node_flag_KERNFS_EMPTY_DIR: kernfs_node_flag = 4096;
pub const kernfs_node_flag_KERNFS_HAS_RELEASE: kernfs_node_flag = 8192;
pub const kernfs_node_flag_KERNFS_REMOVING: kernfs_node_flag = 16384;
pub type kernfs_node_flag = ffi::c_uint;
pub const kernfs_root_flag_KERNFS_ROOT_CREATE_DEACTIVATED: kernfs_root_flag = 1;
pub const kernfs_root_flag_KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK: kernfs_root_flag = 2;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_EXPORTOP: kernfs_root_flag = 4;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_USER_XATTR: kernfs_root_flag = 8;
pub const kernfs_root_flag_KERNFS_ROOT_INVARIANT_PARENT: kernfs_root_flag = 16;
pub type kernfs_root_flag = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: ffi::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: ffi::c_ulong,
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub __parent: *mut kernfs_node,
    pub name: *const ffi::c_char,
    pub rb: rb_node,
    pub ns: *const ffi::c_void,
    pub hash: ffi::c_uint,
    pub flags: ffi::c_ushort,
    pub mode: umode_t,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub id: u64_,
    pub priv_: *mut ffi::c_void,
    pub iattr: *mut kernfs_iattrs,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernfs_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const ffi::c_char,
            mode: umode_t,
        ) -> ffi::c_int,
    >,
    pub rmdir: ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> ffi::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const ffi::c_char,
        ) -> ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> ffi::c_int,
    >,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut ffi::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: ffi::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut ffi::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmapped_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mmapped_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn released_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_released_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, vma: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            offset: loff_t,
            whence: ffi::c_int,
        ) -> loff_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_fs_context {
    pub root: *mut kernfs_root,
    pub ns_tag: *mut ffi::c_void,
    pub magic: ffi::c_ulong,
    pub new_sb_created: bool_,
}
impl Default for kernfs_fs_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut ffi::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const ffi::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const ffi::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>,
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct stat {
    pub st_dev: ffi::c_ulong,
    pub st_ino: ffi::c_ulong,
    pub st_mode: ffi::c_uint,
    pub st_nlink: ffi::c_uint,
    pub st_uid: ffi::c_uint,
    pub st_gid: ffi::c_uint,
    pub st_rdev: ffi::c_ulong,
    pub __pad1: ffi::c_ulong,
    pub st_size: ffi::c_long,
    pub st_blksize: ffi::c_int,
    pub __pad2: ffi::c_int,
    pub st_blocks: ffi::c_long,
    pub st_atime: ffi::c_long,
    pub st_atime_nsec: ffi::c_ulong,
    pub st_mtime: ffi::c_long,
    pub st_mtime_nsec: ffi::c_ulong,
    pub st_ctime: ffi::c_long,
    pub st_ctime_nsec: ffi::c_ulong,
    pub __unused4: ffi::c_uint,
    pub __unused5: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub stx_subvol: __u64,
    pub stx_atomic_write_unit_min: __u32,
    pub stx_atomic_write_unit_max: __u32,
    pub stx_atomic_write_segments_max: __u32,
    pub stx_dio_read_offset_align: __u32,
    pub stx_atomic_write_unit_max_opt: __u32,
    pub __spare2: [__u32; 1usize],
    pub __spare3: [__u64; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: ffi::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub change_cookie: u64_,
    pub subvol: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
    pub dio_read_offset_align: u32_,
    pub atomic_write_unit_min: u32_,
    pub atomic_write_unit_max: u32_,
    pub atomic_write_unit_max_opt: u32_,
    pub atomic_write_segments_max: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute {
    pub name: *const ffi::c_char,
    pub mode: umode_t,
}
impl Default for attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute_group {
    pub name: *const ffi::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kobject, arg2: *mut attribute, arg3: ffi::c_int) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *const bin_attribute,
            arg3: ffi::c_int,
        ) -> umode_t,
    >,
    pub bin_size: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *const bin_attribute,
            arg3: ffi::c_int,
        ) -> usize,
    >,
    pub attrs: *mut *mut attribute,
    pub __bindgen_anon_1: attribute_group__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union attribute_group__bindgen_ty_1 {
    pub bin_attrs: *const *const bin_attribute,
    pub bin_attrs_new: *const *const bin_attribute,
}
impl Default for attribute_group__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for attribute_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut ffi::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub read_new: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write_new: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: loff_t,
            arg5: ffi::c_int,
        ) -> loff_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *const bin_attribute,
            vma: *mut vm_area_struct,
        ) -> ffi::c_int,
    >,
}
impl Default for bin_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const ffi::c_char,
            arg4: usize,
        ) -> isize,
    >,
}

pub const kobject_action_KOBJ_ADD: kobject_action = 0;
pub const kobject_action_KOBJ_REMOVE: kobject_action = 1;
pub const kobject_action_KOBJ_CHANGE: kobject_action = 2;
pub const kobject_action_KOBJ_MOVE: kobject_action = 3;
pub const kobject_action_KOBJ_ONLINE: kobject_action = 4;
pub const kobject_action_KOBJ_OFFLINE: kobject_action = 5;
pub const kobject_action_KOBJ_BIND: kobject_action = 6;
pub const kobject_action_KOBJ_UNBIND: kobject_action = 7;
pub type kobject_action = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobject {
    pub name: *const ffi::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_initialized_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_initialized_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_in_sysfs_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_in_sysfs_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_add_uevent_sent_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_add_uevent_sent_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_remove_uevent_sent_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_remove_uevent_sent_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uevent_suppress_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uevent_suppress_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: ffi::c_uint,
        state_in_sysfs: ffi::c_uint,
        state_add_uevent_sent: ffi::c_uint,
        state_remove_uevent_sent: ffi::c_uint,
        uevent_suppress: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> *const ffi::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
impl Default for kobj_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut ffi::c_char; 3usize],
    pub envp: [*mut ffi::c_char; 64usize],
    pub envp_idx: ffi::c_int,
    pub buf: [ffi::c_char; 2048usize],
    pub buflen: ffi::c_int,
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> ffi::c_int>,
    pub name:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> *const ffi::c_char>,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for kobj_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
impl Default for kset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct update_util_data {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(data: *mut update_util_data, time: u64_, flags: ffi::c_uint),
    >,
}

pub const cpu_idle_type___CPU_NOT_IDLE: cpu_idle_type = 0;
pub const cpu_idle_type_CPU_IDLE: cpu_idle_type = 1;
pub const cpu_idle_type_CPU_NEWLY_IDLE: cpu_idle_type = 2;
pub const cpu_idle_type_CPU_MAX_IDLE_TYPES: cpu_idle_type = 3;
pub type cpu_idle_type = ffi::c_uint;

pub const __SD_BALANCE_NEWIDLE: _bindgen_ty_19 = 0;
pub const __SD_BALANCE_EXEC: _bindgen_ty_19 = 1;
pub const __SD_BALANCE_FORK: _bindgen_ty_19 = 2;
pub const __SD_BALANCE_WAKE: _bindgen_ty_19 = 3;
pub const __SD_WAKE_AFFINE: _bindgen_ty_19 = 4;
pub const __SD_ASYM_CPUCAPACITY: _bindgen_ty_19 = 5;
pub const __SD_ASYM_CPUCAPACITY_FULL: _bindgen_ty_19 = 6;
pub const __SD_SHARE_CPUCAPACITY: _bindgen_ty_19 = 7;
pub const __SD_CLUSTER: _bindgen_ty_19 = 8;
pub const __SD_SHARE_LLC: _bindgen_ty_19 = 9;
pub const __SD_SERIALIZE: _bindgen_ty_19 = 10;
pub const __SD_ASYM_PACKING: _bindgen_ty_19 = 11;
pub const __SD_PREFER_SIBLING: _bindgen_ty_19 = 12;
pub const __SD_NUMA: _bindgen_ty_19 = 13;
pub const __SD_FLAG_CNT: _bindgen_ty_19 = 14;
pub type _bindgen_ty_19 = ffi::c_uint;
pub const SD_BALANCE_NEWIDLE: _bindgen_ty_20 = 1;
pub const SD_BALANCE_EXEC: _bindgen_ty_20 = 2;
pub const SD_BALANCE_FORK: _bindgen_ty_20 = 4;
pub const SD_BALANCE_WAKE: _bindgen_ty_20 = 8;
pub const SD_WAKE_AFFINE: _bindgen_ty_20 = 16;
pub const SD_ASYM_CPUCAPACITY: _bindgen_ty_20 = 32;
pub const SD_ASYM_CPUCAPACITY_FULL: _bindgen_ty_20 = 64;
pub const SD_SHARE_CPUCAPACITY: _bindgen_ty_20 = 128;
pub const SD_CLUSTER: _bindgen_ty_20 = 256;
pub const SD_SHARE_LLC: _bindgen_ty_20 = 512;
pub const SD_SERIALIZE: _bindgen_ty_20 = 1024;
pub const SD_ASYM_PACKING: _bindgen_ty_20 = 2048;
pub const SD_PREFER_SIBLING: _bindgen_ty_20 = 4096;
pub const SD_NUMA: _bindgen_ty_20 = 8192;
pub type _bindgen_ty_20 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_flag_debug {
    pub meta_flags: ffi::c_uint,
    pub name: *mut ffi::c_char,
}
impl Default for sd_flag_debug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_attr {
    pub relax_domain_level: ffi::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_shared {
    pub ref_: atomic_t,
    pub nr_busy_cpus: atomic_t,
    pub has_idle_cores: ffi::c_int,
    pub nr_idle_scan: ffi::c_int,
}
#[repr(C)]
pub struct sched_domain {
    pub parent: *mut sched_domain,
    pub child: *mut sched_domain,
    pub groups: *mut sched_group,
    pub min_interval: ffi::c_ulong,
    pub max_interval: ffi::c_ulong,
    pub busy_factor: ffi::c_uint,
    pub imbalance_pct: ffi::c_uint,
    pub cache_nice_tries: ffi::c_uint,
    pub imb_numa_nr: ffi::c_uint,
    pub nohz_idle: ffi::c_int,
    pub flags: ffi::c_int,
    pub level: ffi::c_int,
    pub last_balance: ffi::c_ulong,
    pub balance_interval: ffi::c_uint,
    pub nr_balance_failed: ffi::c_uint,
    pub max_newidle_lb_cost: u64_,
    pub last_decay_max_lb_cost: ffi::c_ulong,
    pub name: *mut ffi::c_char,
    pub __bindgen_anon_1: sched_domain__bindgen_ty_1,
    pub shared: *mut sched_domain_shared,
    pub span_weight: ffi::c_uint,
    pub span: __IncompleteArrayField<ffi::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_domain__bindgen_ty_1 {
    pub private: *mut ffi::c_void,
    pub rcu: callback_head,
}
impl Default for sched_domain__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sched_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type sched_domain_mask_f =
    ::core::option::Option<unsafe extern "C" fn(cpu: ffi::c_int) -> *const cpumask>;
pub type sched_domain_flags_f = ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_data {
    pub sd: *mut *mut sched_domain,
    pub sds: *mut *mut sched_domain_shared,
    pub sg: *mut *mut sched_group,
    pub sgc: *mut *mut sched_group_capacity,
}
impl Default for sd_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_domain_topology_level {
    pub mask: sched_domain_mask_f,
    pub sd_flags: sched_domain_flags_f,
    pub numa_level: ffi::c_int,
    pub data: sd_data,
    pub name: *mut ffi::c_char,
}
impl Default for sched_domain_topology_level {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_perf_state {
    pub performance: ffi::c_ulong,
    pub frequency: ffi::c_ulong,
    pub power: ffi::c_ulong,
    pub cost: ffi::c_ulong,
    pub flags: ffi::c_ulong,
}
#[repr(C)]
pub struct em_perf_table {
    pub rcu: callback_head,
    pub kref: kref,
    pub state: __IncompleteArrayField<em_perf_state>,
}
impl Default for em_perf_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct em_perf_domain {
    pub em_table: *mut em_perf_table,
    pub nr_perf_states: ffi::c_int,
    pub min_perf_state: ffi::c_int,
    pub max_perf_state: ffi::c_int,
    pub flags: ffi::c_ulong,
    pub cpus: __IncompleteArrayField<ffi::c_ulong>,
}
impl Default for em_perf_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_data_callback {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist {
    pub k_lock: spinlock_t,
    pub k_list: list_head,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
}
impl Default for klist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut ffi::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
impl Default for klist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_iter {
    pub i_klist: *mut klist,
    pub i_cur: *mut klist_node,
}
impl Default for klist_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_message {
    pub event: ffi::c_int,
}
pub type pm_message_t = pm_message;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_idle: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
}
pub const rpm_status_RPM_INVALID: rpm_status = -1;
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub const rpm_status_RPM_BLOCKED: rpm_status = 4;
pub type rpm_status = ffi::c_int;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: ffi::c_uint,
    pub clock_op_might_sleep: ffi::c_uint,
    pub clock_mutex: mutex,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: ffi::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub last_status: rpm_status,
    pub runtime_error: ffi::c_int,
    pub autosuspend_delay: ffi::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for dev_pm_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn can_wakeup_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_can_wakeup_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn async_suspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_async_suspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_dpm_list_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_in_dpm_list_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_prepared_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_prepared_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_noirq_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_noirq_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_late_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_late_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_pm_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_pm_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn early_init_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_early_init_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direct_complete_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_direct_complete_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: bool_,
        async_suspend: bool_,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u8 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u8 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wakeup_path_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wakeup_path_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn syscore_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_syscore_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_pm_callbacks_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_pm_callbacks_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn work_in_progress(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_work_in_progress(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn work_in_progress_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_work_in_progress_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smart_suspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smart_suspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smart_suspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_smart_suspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn must_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn must_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_must_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn may_skip_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_may_skip_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strict_midlayer(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strict_midlayer(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strict_midlayer_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_strict_midlayer_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        work_in_progress: bool_,
        smart_suspend: bool_,
        must_resume: bool_,
        may_skip_resume: bool_,
        strict_midlayer: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let work_in_progress: u8 = unsafe { ::core::mem::transmute(work_in_progress) };
            work_in_progress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let smart_suspend: u8 = unsafe { ::core::mem::transmute(smart_suspend) };
            smart_suspend as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let must_resume: u8 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let may_skip_resume: u8 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let strict_midlayer: u8 = unsafe { ::core::mem::transmute(strict_midlayer) };
            strict_midlayer as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_depth_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disable_depth_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idle_notification_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_idle_notification_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn request_pending(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn request_pending_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_request_pending_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn deferred_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_deferred_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn needs_force_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_needs_force_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn runtime_auto_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_runtime_auto_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_children_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_children_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_callbacks_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_callbacks_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_safe_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_irq_safe_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_autosuspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_autosuspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timer_autosuspends_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_timer_autosuspends_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn memalloc_noio_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_memalloc_noio_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: ffi::c_uint,
        idle_notification: bool_,
        request_pending: bool_,
        deferred_resume: bool_,
        needs_force_resume: bool_,
        runtime_auto: bool_,
        ignore_children: bool_,
        no_callbacks: bool_,
        irq_safe: bool_,
        use_autosuspend: bool_,
        timer_autosuspends: bool_,
        memalloc_noio: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u8 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u8 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u8 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u8 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u8 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u8 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u8 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u8 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u8 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u8 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn detach_power_off(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_detach_power_off(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn detach_power_off_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_detach_power_off_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(detach_power_off: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let detach_power_off: u8 = unsafe { ::core::mem::transmute(detach_power_off) };
            detach_power_off as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub set_performance_state: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: ffi::c_uint) -> ffi::c_int,
    >,
}

pub const dpm_order_DPM_ORDER_NONE: dpm_order = 0;
pub const dpm_order_DPM_ORDER_DEV_AFTER_PARENT: dpm_order = 1;
pub const dpm_order_DPM_ORDER_PARENT_BEFORE_DEV: dpm_order = 2;
pub const dpm_order_DPM_ORDER_DEV_LAST: dpm_order = 3;
pub type dpm_order = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_type {
    pub name: *const ffi::c_char,
    pub dev_name: *const ffi::c_char,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *const device_driver) -> ffi::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub irq_get_affinity: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, irq_vec: ffi::c_uint) -> *const cpumask,
    >,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub dma_configure: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub need_parent_lock: bool_,
}
impl Default for bus_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(bus: *const bus_type, buf: *mut ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(bus: *const bus_type, buf: *const ffi::c_char, count: usize) -> isize,
    >,
}
impl Default for bus_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type device_match_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut device, data: *const ffi::c_void) -> ffi::c_int,
>;

pub type device_iter_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut device, data: *mut ffi::c_void) -> ffi::c_int,
>;

pub const bus_notifier_event_BUS_NOTIFY_ADD_DEVICE: bus_notifier_event = 0;
pub const bus_notifier_event_BUS_NOTIFY_DEL_DEVICE: bus_notifier_event = 1;
pub const bus_notifier_event_BUS_NOTIFY_REMOVED_DEVICE: bus_notifier_event = 2;
pub const bus_notifier_event_BUS_NOTIFY_BIND_DRIVER: bus_notifier_event = 3;
pub const bus_notifier_event_BUS_NOTIFY_BOUND_DRIVER: bus_notifier_event = 4;
pub const bus_notifier_event_BUS_NOTIFY_UNBIND_DRIVER: bus_notifier_event = 5;
pub const bus_notifier_event_BUS_NOTIFY_UNBOUND_DRIVER: bus_notifier_event = 6;
pub const bus_notifier_event_BUS_NOTIFY_DRIVER_NOT_BOUND: bus_notifier_event = 7;
pub type bus_notifier_event = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct class {
    pub name: *const ffi::c_char,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, mode: *mut umode_t) -> *mut ffi::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *const class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(dev: *const device) -> *const ffi::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
}
impl Default for class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_dev_iter {
    pub ki: klist_iter,
    pub type_: *const device_type,
    pub sp: *mut subsys_private,
}
impl Default for class_dev_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_compat {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            class: *const class,
            attr: *const class_attribute,
            buf: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            class: *const class,
            attr: *const class_attribute,
            buf: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for class_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute_string {
    pub attr: class_attribute,
    pub str_: *mut ffi::c_char,
}
impl Default for class_attribute_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_interface {
    pub node: list_head,
    pub class: *const class,
    pub add_dev: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub remove_dev: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
}
impl Default for class_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type dr_release_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut device, res: *mut ffi::c_void)>;
pub type dr_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut device,
        res: *mut ffi::c_void,
        match_data: *mut ffi::c_void,
    ) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sysctl_args {
    pub name: *mut ffi::c_int,
    pub nlen: ffi::c_int,
    pub oldval: *mut ffi::c_void,
    pub oldlenp: *mut usize,
    pub newval: *mut ffi::c_void,
    pub newlen: usize,
    pub __unused: [ffi::c_ulong; 4usize],
}
impl Default for __sysctl_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CTL_KERN: _bindgen_ty_21 = 1;
pub const CTL_VM: _bindgen_ty_21 = 2;
pub const CTL_NET: _bindgen_ty_21 = 3;
pub const CTL_PROC: _bindgen_ty_21 = 4;
pub const CTL_FS: _bindgen_ty_21 = 5;
pub const CTL_DEBUG: _bindgen_ty_21 = 6;
pub const CTL_DEV: _bindgen_ty_21 = 7;
pub const CTL_BUS: _bindgen_ty_21 = 8;
pub const CTL_ABI: _bindgen_ty_21 = 9;
pub const CTL_CPU: _bindgen_ty_21 = 10;
pub const CTL_ARLAN: _bindgen_ty_21 = 254;
pub const CTL_S390DBF: _bindgen_ty_21 = 5677;
pub const CTL_SUNRPC: _bindgen_ty_21 = 7249;
pub const CTL_PM: _bindgen_ty_21 = 9899;
pub const CTL_FRV: _bindgen_ty_21 = 9898;
pub type _bindgen_ty_21 = ffi::c_uint;
pub const CTL_BUS_ISA: _bindgen_ty_22 = 1;
pub type _bindgen_ty_22 = ffi::c_uint;
pub const INOTIFY_MAX_USER_INSTANCES: _bindgen_ty_23 = 1;
pub const INOTIFY_MAX_USER_WATCHES: _bindgen_ty_23 = 2;
pub const INOTIFY_MAX_QUEUED_EVENTS: _bindgen_ty_23 = 3;
pub type _bindgen_ty_23 = ffi::c_uint;
pub const KERN_OSTYPE: _bindgen_ty_24 = 1;
pub const KERN_OSRELEASE: _bindgen_ty_24 = 2;
pub const KERN_OSREV: _bindgen_ty_24 = 3;
pub const KERN_VERSION: _bindgen_ty_24 = 4;
pub const KERN_SECUREMASK: _bindgen_ty_24 = 5;
pub const KERN_PROF: _bindgen_ty_24 = 6;
pub const KERN_NODENAME: _bindgen_ty_24 = 7;
pub const KERN_DOMAINNAME: _bindgen_ty_24 = 8;
pub const KERN_PANIC: _bindgen_ty_24 = 15;
pub const KERN_REALROOTDEV: _bindgen_ty_24 = 16;
pub const KERN_SPARC_REBOOT: _bindgen_ty_24 = 21;
pub const KERN_CTLALTDEL: _bindgen_ty_24 = 22;
pub const KERN_PRINTK: _bindgen_ty_24 = 23;
pub const KERN_NAMETRANS: _bindgen_ty_24 = 24;
pub const KERN_PPC_HTABRECLAIM: _bindgen_ty_24 = 25;
pub const KERN_PPC_ZEROPAGED: _bindgen_ty_24 = 26;
pub const KERN_PPC_POWERSAVE_NAP: _bindgen_ty_24 = 27;
pub const KERN_MODPROBE: _bindgen_ty_24 = 28;
pub const KERN_SG_BIG_BUFF: _bindgen_ty_24 = 29;
pub const KERN_ACCT: _bindgen_ty_24 = 30;
pub const KERN_PPC_L2CR: _bindgen_ty_24 = 31;
pub const KERN_RTSIGNR: _bindgen_ty_24 = 32;
pub const KERN_RTSIGMAX: _bindgen_ty_24 = 33;
pub const KERN_SHMMAX: _bindgen_ty_24 = 34;
pub const KERN_MSGMAX: _bindgen_ty_24 = 35;
pub const KERN_MSGMNB: _bindgen_ty_24 = 36;
pub const KERN_MSGPOOL: _bindgen_ty_24 = 37;
pub const KERN_SYSRQ: _bindgen_ty_24 = 38;
pub const KERN_MAX_THREADS: _bindgen_ty_24 = 39;
pub const KERN_RANDOM: _bindgen_ty_24 = 40;
pub const KERN_SHMALL: _bindgen_ty_24 = 41;
pub const KERN_MSGMNI: _bindgen_ty_24 = 42;
pub const KERN_SEM: _bindgen_ty_24 = 43;
pub const KERN_SPARC_STOP_A: _bindgen_ty_24 = 44;
pub const KERN_SHMMNI: _bindgen_ty_24 = 45;
pub const KERN_OVERFLOWUID: _bindgen_ty_24 = 46;
pub const KERN_OVERFLOWGID: _bindgen_ty_24 = 47;
pub const KERN_SHMPATH: _bindgen_ty_24 = 48;
pub const KERN_HOTPLUG: _bindgen_ty_24 = 49;
pub const KERN_IEEE_EMULATION_WARNINGS: _bindgen_ty_24 = 50;
pub const KERN_S390_USER_DEBUG_LOGGING: _bindgen_ty_24 = 51;
pub const KERN_CORE_USES_PID: _bindgen_ty_24 = 52;
pub const KERN_TAINTED: _bindgen_ty_24 = 53;
pub const KERN_CADPID: _bindgen_ty_24 = 54;
pub const KERN_PIDMAX: _bindgen_ty_24 = 55;
pub const KERN_CORE_PATTERN: _bindgen_ty_24 = 56;
pub const KERN_PANIC_ON_OOPS: _bindgen_ty_24 = 57;
pub const KERN_HPPA_PWRSW: _bindgen_ty_24 = 58;
pub const KERN_HPPA_UNALIGNED: _bindgen_ty_24 = 59;
pub const KERN_PRINTK_RATELIMIT: _bindgen_ty_24 = 60;
pub const KERN_PRINTK_RATELIMIT_BURST: _bindgen_ty_24 = 61;
pub const KERN_PTY: _bindgen_ty_24 = 62;
pub const KERN_NGROUPS_MAX: _bindgen_ty_24 = 63;
pub const KERN_SPARC_SCONS_PWROFF: _bindgen_ty_24 = 64;
pub const KERN_HZ_TIMER: _bindgen_ty_24 = 65;
pub const KERN_UNKNOWN_NMI_PANIC: _bindgen_ty_24 = 66;
pub const KERN_BOOTLOADER_TYPE: _bindgen_ty_24 = 67;
pub const KERN_RANDOMIZE: _bindgen_ty_24 = 68;
pub const KERN_SETUID_DUMPABLE: _bindgen_ty_24 = 69;
pub const KERN_SPIN_RETRY: _bindgen_ty_24 = 70;
pub const KERN_ACPI_VIDEO_FLAGS: _bindgen_ty_24 = 71;
pub const KERN_IA64_UNALIGNED: _bindgen_ty_24 = 72;
pub const KERN_COMPAT_LOG: _bindgen_ty_24 = 73;
pub const KERN_MAX_LOCK_DEPTH: _bindgen_ty_24 = 74;
pub const KERN_NMI_WATCHDOG: _bindgen_ty_24 = 75;
pub const KERN_PANIC_ON_NMI: _bindgen_ty_24 = 76;
pub const KERN_PANIC_ON_WARN: _bindgen_ty_24 = 77;
pub const KERN_PANIC_PRINT: _bindgen_ty_24 = 78;
pub type _bindgen_ty_24 = ffi::c_uint;
pub const VM_UNUSED1: _bindgen_ty_25 = 1;
pub const VM_UNUSED2: _bindgen_ty_25 = 2;
pub const VM_UNUSED3: _bindgen_ty_25 = 3;
pub const VM_UNUSED4: _bindgen_ty_25 = 4;
pub const VM_OVERCOMMIT_MEMORY: _bindgen_ty_25 = 5;
pub const VM_UNUSED5: _bindgen_ty_25 = 6;
pub const VM_UNUSED7: _bindgen_ty_25 = 7;
pub const VM_UNUSED8: _bindgen_ty_25 = 8;
pub const VM_UNUSED9: _bindgen_ty_25 = 9;
pub const VM_PAGE_CLUSTER: _bindgen_ty_25 = 10;
pub const VM_DIRTY_BACKGROUND: _bindgen_ty_25 = 11;
pub const VM_DIRTY_RATIO: _bindgen_ty_25 = 12;
pub const VM_DIRTY_WB_CS: _bindgen_ty_25 = 13;
pub const VM_DIRTY_EXPIRE_CS: _bindgen_ty_25 = 14;
pub const VM_NR_PDFLUSH_THREADS: _bindgen_ty_25 = 15;
pub const VM_OVERCOMMIT_RATIO: _bindgen_ty_25 = 16;
pub const VM_PAGEBUF: _bindgen_ty_25 = 17;
pub const VM_HUGETLB_PAGES: _bindgen_ty_25 = 18;
pub const VM_SWAPPINESS: _bindgen_ty_25 = 19;
pub const VM_LOWMEM_RESERVE_RATIO: _bindgen_ty_25 = 20;
pub const VM_MIN_FREE_KBYTES: _bindgen_ty_25 = 21;
pub const VM_MAX_MAP_COUNT: _bindgen_ty_25 = 22;
pub const VM_LAPTOP_MODE: _bindgen_ty_25 = 23;
pub const VM_BLOCK_DUMP: _bindgen_ty_25 = 24;
pub const VM_HUGETLB_GROUP: _bindgen_ty_25 = 25;
pub const VM_VFS_CACHE_PRESSURE: _bindgen_ty_25 = 26;
pub const VM_LEGACY_VA_LAYOUT: _bindgen_ty_25 = 27;
pub const VM_SWAP_TOKEN_TIMEOUT: _bindgen_ty_25 = 28;
pub const VM_DROP_PAGECACHE: _bindgen_ty_25 = 29;
pub const VM_PERCPU_PAGELIST_FRACTION: _bindgen_ty_25 = 30;
pub const VM_ZONE_RECLAIM_MODE: _bindgen_ty_25 = 31;
pub const VM_MIN_UNMAPPED: _bindgen_ty_25 = 32;
pub const VM_PANIC_ON_OOM: _bindgen_ty_25 = 33;
pub const VM_VDSO_ENABLED: _bindgen_ty_25 = 34;
pub const VM_MIN_SLAB: _bindgen_ty_25 = 35;
pub type _bindgen_ty_25 = ffi::c_uint;
pub const NET_CORE: _bindgen_ty_26 = 1;
pub const NET_ETHER: _bindgen_ty_26 = 2;
pub const NET_802: _bindgen_ty_26 = 3;
pub const NET_UNIX: _bindgen_ty_26 = 4;
pub const NET_IPV4: _bindgen_ty_26 = 5;
pub const NET_IPX: _bindgen_ty_26 = 6;
pub const NET_ATALK: _bindgen_ty_26 = 7;
pub const NET_NETROM: _bindgen_ty_26 = 8;
pub const NET_AX25: _bindgen_ty_26 = 9;
pub const NET_BRIDGE: _bindgen_ty_26 = 10;
pub const NET_ROSE: _bindgen_ty_26 = 11;
pub const NET_IPV6: _bindgen_ty_26 = 12;
pub const NET_X25: _bindgen_ty_26 = 13;
pub const NET_TR: _bindgen_ty_26 = 14;
pub const NET_DECNET: _bindgen_ty_26 = 15;
pub const NET_ECONET: _bindgen_ty_26 = 16;
pub const NET_SCTP: _bindgen_ty_26 = 17;
pub const NET_LLC: _bindgen_ty_26 = 18;
pub const NET_NETFILTER: _bindgen_ty_26 = 19;
pub const NET_DCCP: _bindgen_ty_26 = 20;
pub const NET_IRDA: _bindgen_ty_26 = 412;
pub type _bindgen_ty_26 = ffi::c_uint;
pub const RANDOM_POOLSIZE: _bindgen_ty_27 = 1;
pub const RANDOM_ENTROPY_COUNT: _bindgen_ty_27 = 2;
pub const RANDOM_READ_THRESH: _bindgen_ty_27 = 3;
pub const RANDOM_WRITE_THRESH: _bindgen_ty_27 = 4;
pub const RANDOM_BOOT_ID: _bindgen_ty_27 = 5;
pub const RANDOM_UUID: _bindgen_ty_27 = 6;
pub type _bindgen_ty_27 = ffi::c_uint;
pub const PTY_MAX: _bindgen_ty_28 = 1;
pub const PTY_NR: _bindgen_ty_28 = 2;
pub type _bindgen_ty_28 = ffi::c_uint;
pub const BUS_ISA_MEM_BASE: _bindgen_ty_29 = 1;
pub const BUS_ISA_PORT_BASE: _bindgen_ty_29 = 2;
pub const BUS_ISA_PORT_SHIFT: _bindgen_ty_29 = 3;
pub type _bindgen_ty_29 = ffi::c_uint;
pub const NET_CORE_WMEM_MAX: _bindgen_ty_30 = 1;
pub const NET_CORE_RMEM_MAX: _bindgen_ty_30 = 2;
pub const NET_CORE_WMEM_DEFAULT: _bindgen_ty_30 = 3;
pub const NET_CORE_RMEM_DEFAULT: _bindgen_ty_30 = 4;
pub const NET_CORE_MAX_BACKLOG: _bindgen_ty_30 = 6;
pub const NET_CORE_FASTROUTE: _bindgen_ty_30 = 7;
pub const NET_CORE_MSG_COST: _bindgen_ty_30 = 8;
pub const NET_CORE_MSG_BURST: _bindgen_ty_30 = 9;
pub const NET_CORE_OPTMEM_MAX: _bindgen_ty_30 = 10;
pub const NET_CORE_HOT_LIST_LENGTH: _bindgen_ty_30 = 11;
pub const NET_CORE_DIVERT_VERSION: _bindgen_ty_30 = 12;
pub const NET_CORE_NO_CONG_THRESH: _bindgen_ty_30 = 13;
pub const NET_CORE_NO_CONG: _bindgen_ty_30 = 14;
pub const NET_CORE_LO_CONG: _bindgen_ty_30 = 15;
pub const NET_CORE_MOD_CONG: _bindgen_ty_30 = 16;
pub const NET_CORE_DEV_WEIGHT: _bindgen_ty_30 = 17;
pub const NET_CORE_SOMAXCONN: _bindgen_ty_30 = 18;
pub const NET_CORE_BUDGET: _bindgen_ty_30 = 19;
pub const NET_CORE_AEVENT_ETIME: _bindgen_ty_30 = 20;
pub const NET_CORE_AEVENT_RSEQTH: _bindgen_ty_30 = 21;
pub const NET_CORE_WARNINGS: _bindgen_ty_30 = 22;
pub type _bindgen_ty_30 = ffi::c_uint;
pub const NET_UNIX_DESTROY_DELAY: _bindgen_ty_31 = 1;
pub const NET_UNIX_DELETE_DELAY: _bindgen_ty_31 = 2;
pub const NET_UNIX_MAX_DGRAM_QLEN: _bindgen_ty_31 = 3;
pub type _bindgen_ty_31 = ffi::c_uint;
pub const NET_NF_CONNTRACK_MAX: _bindgen_ty_32 = 1;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_32 = 2;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_32 = 3;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_32 = 4;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_32 = 5;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_32 = 6;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_32 = 7;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_32 = 8;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_32 = 9;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_32 = 10;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_32 = 11;
pub const NET_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_32 = 12;
pub const NET_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_32 = 13;
pub const NET_NF_CONNTRACK_BUCKETS: _bindgen_ty_32 = 14;
pub const NET_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_32 = 15;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_32 = 16;
pub const NET_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_32 = 17;
pub const NET_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_32 = 18;
pub const NET_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_32 = 19;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_32 = 20;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_32 = 21;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_32 = 22;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_32 = 23;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_32 = 24;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_32 = 25;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_32 = 26;
pub const NET_NF_CONNTRACK_COUNT: _bindgen_ty_32 = 27;
pub const NET_NF_CONNTRACK_ICMPV6_TIMEOUT: _bindgen_ty_32 = 28;
pub const NET_NF_CONNTRACK_FRAG6_TIMEOUT: _bindgen_ty_32 = 29;
pub const NET_NF_CONNTRACK_FRAG6_LOW_THRESH: _bindgen_ty_32 = 30;
pub const NET_NF_CONNTRACK_FRAG6_HIGH_THRESH: _bindgen_ty_32 = 31;
pub const NET_NF_CONNTRACK_CHECKSUM: _bindgen_ty_32 = 32;
pub type _bindgen_ty_32 = ffi::c_uint;
pub const NET_IPV4_FORWARD: _bindgen_ty_33 = 8;
pub const NET_IPV4_DYNADDR: _bindgen_ty_33 = 9;
pub const NET_IPV4_CONF: _bindgen_ty_33 = 16;
pub const NET_IPV4_NEIGH: _bindgen_ty_33 = 17;
pub const NET_IPV4_ROUTE: _bindgen_ty_33 = 18;
pub const NET_IPV4_FIB_HASH: _bindgen_ty_33 = 19;
pub const NET_IPV4_NETFILTER: _bindgen_ty_33 = 20;
pub const NET_IPV4_TCP_TIMESTAMPS: _bindgen_ty_33 = 33;
pub const NET_IPV4_TCP_WINDOW_SCALING: _bindgen_ty_33 = 34;
pub const NET_IPV4_TCP_SACK: _bindgen_ty_33 = 35;
pub const NET_IPV4_TCP_RETRANS_COLLAPSE: _bindgen_ty_33 = 36;
pub const NET_IPV4_DEFAULT_TTL: _bindgen_ty_33 = 37;
pub const NET_IPV4_AUTOCONFIG: _bindgen_ty_33 = 38;
pub const NET_IPV4_NO_PMTU_DISC: _bindgen_ty_33 = 39;
pub const NET_IPV4_TCP_SYN_RETRIES: _bindgen_ty_33 = 40;
pub const NET_IPV4_IPFRAG_HIGH_THRESH: _bindgen_ty_33 = 41;
pub const NET_IPV4_IPFRAG_LOW_THRESH: _bindgen_ty_33 = 42;
pub const NET_IPV4_IPFRAG_TIME: _bindgen_ty_33 = 43;
pub const NET_IPV4_TCP_MAX_KA_PROBES: _bindgen_ty_33 = 44;
pub const NET_IPV4_TCP_KEEPALIVE_TIME: _bindgen_ty_33 = 45;
pub const NET_IPV4_TCP_KEEPALIVE_PROBES: _bindgen_ty_33 = 46;
pub const NET_IPV4_TCP_RETRIES1: _bindgen_ty_33 = 47;
pub const NET_IPV4_TCP_RETRIES2: _bindgen_ty_33 = 48;
pub const NET_IPV4_TCP_FIN_TIMEOUT: _bindgen_ty_33 = 49;
pub const NET_IPV4_IP_MASQ_DEBUG: _bindgen_ty_33 = 50;
pub const NET_TCP_SYNCOOKIES: _bindgen_ty_33 = 51;
pub const NET_TCP_STDURG: _bindgen_ty_33 = 52;
pub const NET_TCP_RFC1337: _bindgen_ty_33 = 53;
pub const NET_TCP_SYN_TAILDROP: _bindgen_ty_33 = 54;
pub const NET_TCP_MAX_SYN_BACKLOG: _bindgen_ty_33 = 55;
pub const NET_IPV4_LOCAL_PORT_RANGE: _bindgen_ty_33 = 56;
pub const NET_IPV4_ICMP_ECHO_IGNORE_ALL: _bindgen_ty_33 = 57;
pub const NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS: _bindgen_ty_33 = 58;
pub const NET_IPV4_ICMP_SOURCEQUENCH_RATE: _bindgen_ty_33 = 59;
pub const NET_IPV4_ICMP_DESTUNREACH_RATE: _bindgen_ty_33 = 60;
pub const NET_IPV4_ICMP_TIMEEXCEED_RATE: _bindgen_ty_33 = 61;
pub const NET_IPV4_ICMP_PARAMPROB_RATE: _bindgen_ty_33 = 62;
pub const NET_IPV4_ICMP_ECHOREPLY_RATE: _bindgen_ty_33 = 63;
pub const NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES: _bindgen_ty_33 = 64;
pub const NET_IPV4_IGMP_MAX_MEMBERSHIPS: _bindgen_ty_33 = 65;
pub const NET_TCP_TW_RECYCLE: _bindgen_ty_33 = 66;
pub const NET_IPV4_ALWAYS_DEFRAG: _bindgen_ty_33 = 67;
pub const NET_IPV4_TCP_KEEPALIVE_INTVL: _bindgen_ty_33 = 68;
pub const NET_IPV4_INET_PEER_THRESHOLD: _bindgen_ty_33 = 69;
pub const NET_IPV4_INET_PEER_MINTTL: _bindgen_ty_33 = 70;
pub const NET_IPV4_INET_PEER_MAXTTL: _bindgen_ty_33 = 71;
pub const NET_IPV4_INET_PEER_GC_MINTIME: _bindgen_ty_33 = 72;
pub const NET_IPV4_INET_PEER_GC_MAXTIME: _bindgen_ty_33 = 73;
pub const NET_TCP_ORPHAN_RETRIES: _bindgen_ty_33 = 74;
pub const NET_TCP_ABORT_ON_OVERFLOW: _bindgen_ty_33 = 75;
pub const NET_TCP_SYNACK_RETRIES: _bindgen_ty_33 = 76;
pub const NET_TCP_MAX_ORPHANS: _bindgen_ty_33 = 77;
pub const NET_TCP_MAX_TW_BUCKETS: _bindgen_ty_33 = 78;
pub const NET_TCP_FACK: _bindgen_ty_33 = 79;
pub const NET_TCP_REORDERING: _bindgen_ty_33 = 80;
pub const NET_TCP_ECN: _bindgen_ty_33 = 81;
pub const NET_TCP_DSACK: _bindgen_ty_33 = 82;
pub const NET_TCP_MEM: _bindgen_ty_33 = 83;
pub const NET_TCP_WMEM: _bindgen_ty_33 = 84;
pub const NET_TCP_RMEM: _bindgen_ty_33 = 85;
pub const NET_TCP_APP_WIN: _bindgen_ty_33 = 86;
pub const NET_TCP_ADV_WIN_SCALE: _bindgen_ty_33 = 87;
pub const NET_IPV4_NONLOCAL_BIND: _bindgen_ty_33 = 88;
pub const NET_IPV4_ICMP_RATELIMIT: _bindgen_ty_33 = 89;
pub const NET_IPV4_ICMP_RATEMASK: _bindgen_ty_33 = 90;
pub const NET_TCP_TW_REUSE: _bindgen_ty_33 = 91;
pub const NET_TCP_FRTO: _bindgen_ty_33 = 92;
pub const NET_TCP_LOW_LATENCY: _bindgen_ty_33 = 93;
pub const NET_IPV4_IPFRAG_SECRET_INTERVAL: _bindgen_ty_33 = 94;
pub const NET_IPV4_IGMP_MAX_MSF: _bindgen_ty_33 = 96;
pub const NET_TCP_NO_METRICS_SAVE: _bindgen_ty_33 = 97;
pub const NET_TCP_DEFAULT_WIN_SCALE: _bindgen_ty_33 = 105;
pub const NET_TCP_MODERATE_RCVBUF: _bindgen_ty_33 = 106;
pub const NET_TCP_TSO_WIN_DIVISOR: _bindgen_ty_33 = 107;
pub const NET_TCP_BIC_BETA: _bindgen_ty_33 = 108;
pub const NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR: _bindgen_ty_33 = 109;
pub const NET_TCP_CONG_CONTROL: _bindgen_ty_33 = 110;
pub const NET_TCP_ABC: _bindgen_ty_33 = 111;
pub const NET_IPV4_IPFRAG_MAX_DIST: _bindgen_ty_33 = 112;
pub const NET_TCP_MTU_PROBING: _bindgen_ty_33 = 113;
pub const NET_TCP_BASE_MSS: _bindgen_ty_33 = 114;
pub const NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS: _bindgen_ty_33 = 115;
pub const NET_TCP_DMA_COPYBREAK: _bindgen_ty_33 = 116;
pub const NET_TCP_SLOW_START_AFTER_IDLE: _bindgen_ty_33 = 117;
pub const NET_CIPSOV4_CACHE_ENABLE: _bindgen_ty_33 = 118;
pub const NET_CIPSOV4_CACHE_BUCKET_SIZE: _bindgen_ty_33 = 119;
pub const NET_CIPSOV4_RBM_OPTFMT: _bindgen_ty_33 = 120;
pub const NET_CIPSOV4_RBM_STRICTVALID: _bindgen_ty_33 = 121;
pub const NET_TCP_AVAIL_CONG_CONTROL: _bindgen_ty_33 = 122;
pub const NET_TCP_ALLOWED_CONG_CONTROL: _bindgen_ty_33 = 123;
pub const NET_TCP_MAX_SSTHRESH: _bindgen_ty_33 = 124;
pub const NET_TCP_FRTO_RESPONSE: _bindgen_ty_33 = 125;
pub type _bindgen_ty_33 = ffi::c_uint;
pub const NET_IPV4_ROUTE_FLUSH: _bindgen_ty_34 = 1;
pub const NET_IPV4_ROUTE_MIN_DELAY: _bindgen_ty_34 = 2;
pub const NET_IPV4_ROUTE_MAX_DELAY: _bindgen_ty_34 = 3;
pub const NET_IPV4_ROUTE_GC_THRESH: _bindgen_ty_34 = 4;
pub const NET_IPV4_ROUTE_MAX_SIZE: _bindgen_ty_34 = 5;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_34 = 6;
pub const NET_IPV4_ROUTE_GC_TIMEOUT: _bindgen_ty_34 = 7;
pub const NET_IPV4_ROUTE_GC_INTERVAL: _bindgen_ty_34 = 8;
pub const NET_IPV4_ROUTE_REDIRECT_LOAD: _bindgen_ty_34 = 9;
pub const NET_IPV4_ROUTE_REDIRECT_NUMBER: _bindgen_ty_34 = 10;
pub const NET_IPV4_ROUTE_REDIRECT_SILENCE: _bindgen_ty_34 = 11;
pub const NET_IPV4_ROUTE_ERROR_COST: _bindgen_ty_34 = 12;
pub const NET_IPV4_ROUTE_ERROR_BURST: _bindgen_ty_34 = 13;
pub const NET_IPV4_ROUTE_GC_ELASTICITY: _bindgen_ty_34 = 14;
pub const NET_IPV4_ROUTE_MTU_EXPIRES: _bindgen_ty_34 = 15;
pub const NET_IPV4_ROUTE_MIN_PMTU: _bindgen_ty_34 = 16;
pub const NET_IPV4_ROUTE_MIN_ADVMSS: _bindgen_ty_34 = 17;
pub const NET_IPV4_ROUTE_SECRET_INTERVAL: _bindgen_ty_34 = 18;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_34 = 19;
pub type _bindgen_ty_34 = ffi::c_uint;
pub const NET_PROTO_CONF_ALL: _bindgen_ty_35 = -2;
pub const NET_PROTO_CONF_DEFAULT: _bindgen_ty_35 = -3;
pub type _bindgen_ty_35 = ffi::c_int;
pub const NET_IPV4_CONF_FORWARDING: _bindgen_ty_36 = 1;
pub const NET_IPV4_CONF_MC_FORWARDING: _bindgen_ty_36 = 2;
pub const NET_IPV4_CONF_PROXY_ARP: _bindgen_ty_36 = 3;
pub const NET_IPV4_CONF_ACCEPT_REDIRECTS: _bindgen_ty_36 = 4;
pub const NET_IPV4_CONF_SECURE_REDIRECTS: _bindgen_ty_36 = 5;
pub const NET_IPV4_CONF_SEND_REDIRECTS: _bindgen_ty_36 = 6;
pub const NET_IPV4_CONF_SHARED_MEDIA: _bindgen_ty_36 = 7;
pub const NET_IPV4_CONF_RP_FILTER: _bindgen_ty_36 = 8;
pub const NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE: _bindgen_ty_36 = 9;
pub const NET_IPV4_CONF_BOOTP_RELAY: _bindgen_ty_36 = 10;
pub const NET_IPV4_CONF_LOG_MARTIANS: _bindgen_ty_36 = 11;
pub const NET_IPV4_CONF_TAG: _bindgen_ty_36 = 12;
pub const NET_IPV4_CONF_ARPFILTER: _bindgen_ty_36 = 13;
pub const NET_IPV4_CONF_MEDIUM_ID: _bindgen_ty_36 = 14;
pub const NET_IPV4_CONF_NOXFRM: _bindgen_ty_36 = 15;
pub const NET_IPV4_CONF_NOPOLICY: _bindgen_ty_36 = 16;
pub const NET_IPV4_CONF_FORCE_IGMP_VERSION: _bindgen_ty_36 = 17;
pub const NET_IPV4_CONF_ARP_ANNOUNCE: _bindgen_ty_36 = 18;
pub const NET_IPV4_CONF_ARP_IGNORE: _bindgen_ty_36 = 19;
pub const NET_IPV4_CONF_PROMOTE_SECONDARIES: _bindgen_ty_36 = 20;
pub const NET_IPV4_CONF_ARP_ACCEPT: _bindgen_ty_36 = 21;
pub const NET_IPV4_CONF_ARP_NOTIFY: _bindgen_ty_36 = 22;
pub const NET_IPV4_CONF_ARP_EVICT_NOCARRIER: _bindgen_ty_36 = 23;
pub type _bindgen_ty_36 = ffi::c_uint;
pub const NET_IPV4_NF_CONNTRACK_MAX: _bindgen_ty_37 = 1;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_37 = 2;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_37 = 3;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_37 = 4;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_37 = 5;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_37 = 6;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_37 = 7;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_37 = 8;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_37 = 9;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_37 = 10;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_37 = 11;
pub const NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_37 = 12;
pub const NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_37 = 13;
pub const NET_IPV4_NF_CONNTRACK_BUCKETS: _bindgen_ty_37 = 14;
pub const NET_IPV4_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_37 = 15;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_37 = 16;
pub const NET_IPV4_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_37 = 17;
pub const NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_37 = 18;
pub const NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_37 = 19;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_37 = 20;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_37 = 21;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_37 = 22;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_37 = 23;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_37 = 24;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_37 = 25;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_37 = 26;
pub const NET_IPV4_NF_CONNTRACK_COUNT: _bindgen_ty_37 = 27;
pub const NET_IPV4_NF_CONNTRACK_CHECKSUM: _bindgen_ty_37 = 28;
pub type _bindgen_ty_37 = ffi::c_uint;
pub const NET_IPV6_CONF: _bindgen_ty_38 = 16;
pub const NET_IPV6_NEIGH: _bindgen_ty_38 = 17;
pub const NET_IPV6_ROUTE: _bindgen_ty_38 = 18;
pub const NET_IPV6_ICMP: _bindgen_ty_38 = 19;
pub const NET_IPV6_BINDV6ONLY: _bindgen_ty_38 = 20;
pub const NET_IPV6_IP6FRAG_HIGH_THRESH: _bindgen_ty_38 = 21;
pub const NET_IPV6_IP6FRAG_LOW_THRESH: _bindgen_ty_38 = 22;
pub const NET_IPV6_IP6FRAG_TIME: _bindgen_ty_38 = 23;
pub const NET_IPV6_IP6FRAG_SECRET_INTERVAL: _bindgen_ty_38 = 24;
pub const NET_IPV6_MLD_MAX_MSF: _bindgen_ty_38 = 25;
pub type _bindgen_ty_38 = ffi::c_uint;
pub const NET_IPV6_ROUTE_FLUSH: _bindgen_ty_39 = 1;
pub const NET_IPV6_ROUTE_GC_THRESH: _bindgen_ty_39 = 2;
pub const NET_IPV6_ROUTE_MAX_SIZE: _bindgen_ty_39 = 3;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_39 = 4;
pub const NET_IPV6_ROUTE_GC_TIMEOUT: _bindgen_ty_39 = 5;
pub const NET_IPV6_ROUTE_GC_INTERVAL: _bindgen_ty_39 = 6;
pub const NET_IPV6_ROUTE_GC_ELASTICITY: _bindgen_ty_39 = 7;
pub const NET_IPV6_ROUTE_MTU_EXPIRES: _bindgen_ty_39 = 8;
pub const NET_IPV6_ROUTE_MIN_ADVMSS: _bindgen_ty_39 = 9;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_39 = 10;
pub type _bindgen_ty_39 = ffi::c_uint;
pub const NET_IPV6_FORWARDING: _bindgen_ty_40 = 1;
pub const NET_IPV6_HOP_LIMIT: _bindgen_ty_40 = 2;
pub const NET_IPV6_MTU: _bindgen_ty_40 = 3;
pub const NET_IPV6_ACCEPT_RA: _bindgen_ty_40 = 4;
pub const NET_IPV6_ACCEPT_REDIRECTS: _bindgen_ty_40 = 5;
pub const NET_IPV6_AUTOCONF: _bindgen_ty_40 = 6;
pub const NET_IPV6_DAD_TRANSMITS: _bindgen_ty_40 = 7;
pub const NET_IPV6_RTR_SOLICITS: _bindgen_ty_40 = 8;
pub const NET_IPV6_RTR_SOLICIT_INTERVAL: _bindgen_ty_40 = 9;
pub const NET_IPV6_RTR_SOLICIT_DELAY: _bindgen_ty_40 = 10;
pub const NET_IPV6_USE_TEMPADDR: _bindgen_ty_40 = 11;
pub const NET_IPV6_TEMP_VALID_LFT: _bindgen_ty_40 = 12;
pub const NET_IPV6_TEMP_PREFERED_LFT: _bindgen_ty_40 = 13;
pub const NET_IPV6_REGEN_MAX_RETRY: _bindgen_ty_40 = 14;
pub const NET_IPV6_MAX_DESYNC_FACTOR: _bindgen_ty_40 = 15;
pub const NET_IPV6_MAX_ADDRESSES: _bindgen_ty_40 = 16;
pub const NET_IPV6_FORCE_MLD_VERSION: _bindgen_ty_40 = 17;
pub const NET_IPV6_ACCEPT_RA_DEFRTR: _bindgen_ty_40 = 18;
pub const NET_IPV6_ACCEPT_RA_PINFO: _bindgen_ty_40 = 19;
pub const NET_IPV6_ACCEPT_RA_RTR_PREF: _bindgen_ty_40 = 20;
pub const NET_IPV6_RTR_PROBE_INTERVAL: _bindgen_ty_40 = 21;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN: _bindgen_ty_40 = 22;
pub const NET_IPV6_PROXY_NDP: _bindgen_ty_40 = 23;
pub const NET_IPV6_ACCEPT_SOURCE_ROUTE: _bindgen_ty_40 = 25;
pub const NET_IPV6_ACCEPT_RA_FROM_LOCAL: _bindgen_ty_40 = 26;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN: _bindgen_ty_40 = 27;
pub const NET_IPV6_RA_DEFRTR_METRIC: _bindgen_ty_40 = 28;
pub const NET_IPV6_FORCE_FORWARDING: _bindgen_ty_40 = 29;
pub const __NET_IPV6_MAX: _bindgen_ty_40 = 30;
pub type _bindgen_ty_40 = ffi::c_uint;
pub const NET_IPV6_ICMP_RATELIMIT: _bindgen_ty_41 = 1;
pub const NET_IPV6_ICMP_ECHO_IGNORE_ALL: _bindgen_ty_41 = 2;
pub type _bindgen_ty_41 = ffi::c_uint;
pub const NET_NEIGH_MCAST_SOLICIT: _bindgen_ty_42 = 1;
pub const NET_NEIGH_UCAST_SOLICIT: _bindgen_ty_42 = 2;
pub const NET_NEIGH_APP_SOLICIT: _bindgen_ty_42 = 3;
pub const NET_NEIGH_RETRANS_TIME: _bindgen_ty_42 = 4;
pub const NET_NEIGH_REACHABLE_TIME: _bindgen_ty_42 = 5;
pub const NET_NEIGH_DELAY_PROBE_TIME: _bindgen_ty_42 = 6;
pub const NET_NEIGH_GC_STALE_TIME: _bindgen_ty_42 = 7;
pub const NET_NEIGH_UNRES_QLEN: _bindgen_ty_42 = 8;
pub const NET_NEIGH_PROXY_QLEN: _bindgen_ty_42 = 9;
pub const NET_NEIGH_ANYCAST_DELAY: _bindgen_ty_42 = 10;
pub const NET_NEIGH_PROXY_DELAY: _bindgen_ty_42 = 11;
pub const NET_NEIGH_LOCKTIME: _bindgen_ty_42 = 12;
pub const NET_NEIGH_GC_INTERVAL: _bindgen_ty_42 = 13;
pub const NET_NEIGH_GC_THRESH1: _bindgen_ty_42 = 14;
pub const NET_NEIGH_GC_THRESH2: _bindgen_ty_42 = 15;
pub const NET_NEIGH_GC_THRESH3: _bindgen_ty_42 = 16;
pub const NET_NEIGH_RETRANS_TIME_MS: _bindgen_ty_42 = 17;
pub const NET_NEIGH_REACHABLE_TIME_MS: _bindgen_ty_42 = 18;
pub const NET_NEIGH_INTERVAL_PROBE_TIME_MS: _bindgen_ty_42 = 19;
pub type _bindgen_ty_42 = ffi::c_uint;
pub const NET_DCCP_DEFAULT: _bindgen_ty_43 = 1;
pub type _bindgen_ty_43 = ffi::c_uint;
pub const NET_IPX_PPROP_BROADCASTING: _bindgen_ty_44 = 1;
pub const NET_IPX_FORWARDING: _bindgen_ty_44 = 2;
pub type _bindgen_ty_44 = ffi::c_uint;
pub const NET_LLC2: _bindgen_ty_45 = 1;
pub const NET_LLC_STATION: _bindgen_ty_45 = 2;
pub type _bindgen_ty_45 = ffi::c_uint;
pub const NET_LLC2_TIMEOUT: _bindgen_ty_46 = 1;
pub type _bindgen_ty_46 = ffi::c_uint;
pub const NET_LLC_STATION_ACK_TIMEOUT: _bindgen_ty_47 = 1;
pub type _bindgen_ty_47 = ffi::c_uint;
pub const NET_LLC2_ACK_TIMEOUT: _bindgen_ty_48 = 1;
pub const NET_LLC2_P_TIMEOUT: _bindgen_ty_48 = 2;
pub const NET_LLC2_REJ_TIMEOUT: _bindgen_ty_48 = 3;
pub const NET_LLC2_BUSY_TIMEOUT: _bindgen_ty_48 = 4;
pub type _bindgen_ty_48 = ffi::c_uint;
pub const NET_ATALK_AARP_EXPIRY_TIME: _bindgen_ty_49 = 1;
pub const NET_ATALK_AARP_TICK_TIME: _bindgen_ty_49 = 2;
pub const NET_ATALK_AARP_RETRANSMIT_LIMIT: _bindgen_ty_49 = 3;
pub const NET_ATALK_AARP_RESOLVE_TIME: _bindgen_ty_49 = 4;
pub type _bindgen_ty_49 = ffi::c_uint;
pub const NET_NETROM_DEFAULT_PATH_QUALITY: _bindgen_ty_50 = 1;
pub const NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER: _bindgen_ty_50 = 2;
pub const NET_NETROM_NETWORK_TTL_INITIALISER: _bindgen_ty_50 = 3;
pub const NET_NETROM_TRANSPORT_TIMEOUT: _bindgen_ty_50 = 4;
pub const NET_NETROM_TRANSPORT_MAXIMUM_TRIES: _bindgen_ty_50 = 5;
pub const NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY: _bindgen_ty_50 = 6;
pub const NET_NETROM_TRANSPORT_BUSY_DELAY: _bindgen_ty_50 = 7;
pub const NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE: _bindgen_ty_50 = 8;
pub const NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT: _bindgen_ty_50 = 9;
pub const NET_NETROM_ROUTING_CONTROL: _bindgen_ty_50 = 10;
pub const NET_NETROM_LINK_FAILS_COUNT: _bindgen_ty_50 = 11;
pub const NET_NETROM_RESET: _bindgen_ty_50 = 12;
pub type _bindgen_ty_50 = ffi::c_uint;
pub const NET_AX25_IP_DEFAULT_MODE: _bindgen_ty_51 = 1;
pub const NET_AX25_DEFAULT_MODE: _bindgen_ty_51 = 2;
pub const NET_AX25_BACKOFF_TYPE: _bindgen_ty_51 = 3;
pub const NET_AX25_CONNECT_MODE: _bindgen_ty_51 = 4;
pub const NET_AX25_STANDARD_WINDOW: _bindgen_ty_51 = 5;
pub const NET_AX25_EXTENDED_WINDOW: _bindgen_ty_51 = 6;
pub const NET_AX25_T1_TIMEOUT: _bindgen_ty_51 = 7;
pub const NET_AX25_T2_TIMEOUT: _bindgen_ty_51 = 8;
pub const NET_AX25_T3_TIMEOUT: _bindgen_ty_51 = 9;
pub const NET_AX25_IDLE_TIMEOUT: _bindgen_ty_51 = 10;
pub const NET_AX25_N2: _bindgen_ty_51 = 11;
pub const NET_AX25_PACLEN: _bindgen_ty_51 = 12;
pub const NET_AX25_PROTOCOL: _bindgen_ty_51 = 13;
pub const NET_AX25_DAMA_SLAVE_TIMEOUT: _bindgen_ty_51 = 14;
pub type _bindgen_ty_51 = ffi::c_uint;
pub const NET_ROSE_RESTART_REQUEST_TIMEOUT: _bindgen_ty_52 = 1;
pub const NET_ROSE_CALL_REQUEST_TIMEOUT: _bindgen_ty_52 = 2;
pub const NET_ROSE_RESET_REQUEST_TIMEOUT: _bindgen_ty_52 = 3;
pub const NET_ROSE_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_52 = 4;
pub const NET_ROSE_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_52 = 5;
pub const NET_ROSE_ROUTING_CONTROL: _bindgen_ty_52 = 6;
pub const NET_ROSE_LINK_FAIL_TIMEOUT: _bindgen_ty_52 = 7;
pub const NET_ROSE_MAX_VCS: _bindgen_ty_52 = 8;
pub const NET_ROSE_WINDOW_SIZE: _bindgen_ty_52 = 9;
pub const NET_ROSE_NO_ACTIVITY_TIMEOUT: _bindgen_ty_52 = 10;
pub type _bindgen_ty_52 = ffi::c_uint;
pub const NET_X25_RESTART_REQUEST_TIMEOUT: _bindgen_ty_53 = 1;
pub const NET_X25_CALL_REQUEST_TIMEOUT: _bindgen_ty_53 = 2;
pub const NET_X25_RESET_REQUEST_TIMEOUT: _bindgen_ty_53 = 3;
pub const NET_X25_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_53 = 4;
pub const NET_X25_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_53 = 5;
pub const NET_X25_FORWARD: _bindgen_ty_53 = 6;
pub type _bindgen_ty_53 = ffi::c_uint;
pub const NET_TR_RIF_TIMEOUT: _bindgen_ty_54 = 1;
pub type _bindgen_ty_54 = ffi::c_uint;
pub const NET_DECNET_NODE_TYPE: _bindgen_ty_55 = 1;
pub const NET_DECNET_NODE_ADDRESS: _bindgen_ty_55 = 2;
pub const NET_DECNET_NODE_NAME: _bindgen_ty_55 = 3;
pub const NET_DECNET_DEFAULT_DEVICE: _bindgen_ty_55 = 4;
pub const NET_DECNET_TIME_WAIT: _bindgen_ty_55 = 5;
pub const NET_DECNET_DN_COUNT: _bindgen_ty_55 = 6;
pub const NET_DECNET_DI_COUNT: _bindgen_ty_55 = 7;
pub const NET_DECNET_DR_COUNT: _bindgen_ty_55 = 8;
pub const NET_DECNET_DST_GC_INTERVAL: _bindgen_ty_55 = 9;
pub const NET_DECNET_CONF: _bindgen_ty_55 = 10;
pub const NET_DECNET_NO_FC_MAX_CWND: _bindgen_ty_55 = 11;
pub const NET_DECNET_MEM: _bindgen_ty_55 = 12;
pub const NET_DECNET_RMEM: _bindgen_ty_55 = 13;
pub const NET_DECNET_WMEM: _bindgen_ty_55 = 14;
pub const NET_DECNET_DEBUG_LEVEL: _bindgen_ty_55 = 255;
pub type _bindgen_ty_55 = ffi::c_uint;
pub const NET_DECNET_CONF_LOOPBACK: _bindgen_ty_56 = -2;
pub const NET_DECNET_CONF_DDCMP: _bindgen_ty_56 = -3;
pub const NET_DECNET_CONF_PPP: _bindgen_ty_56 = -4;
pub const NET_DECNET_CONF_X25: _bindgen_ty_56 = -5;
pub const NET_DECNET_CONF_GRE: _bindgen_ty_56 = -6;
pub const NET_DECNET_CONF_ETHER: _bindgen_ty_56 = -7;
pub type _bindgen_ty_56 = ffi::c_int;
pub const NET_DECNET_CONF_DEV_PRIORITY: _bindgen_ty_57 = 1;
pub const NET_DECNET_CONF_DEV_T1: _bindgen_ty_57 = 2;
pub const NET_DECNET_CONF_DEV_T2: _bindgen_ty_57 = 3;
pub const NET_DECNET_CONF_DEV_T3: _bindgen_ty_57 = 4;
pub const NET_DECNET_CONF_DEV_FORWARDING: _bindgen_ty_57 = 5;
pub const NET_DECNET_CONF_DEV_BLKSIZE: _bindgen_ty_57 = 6;
pub const NET_DECNET_CONF_DEV_STATE: _bindgen_ty_57 = 7;
pub type _bindgen_ty_57 = ffi::c_uint;
pub const NET_SCTP_RTO_INITIAL: _bindgen_ty_58 = 1;
pub const NET_SCTP_RTO_MIN: _bindgen_ty_58 = 2;
pub const NET_SCTP_RTO_MAX: _bindgen_ty_58 = 3;
pub const NET_SCTP_RTO_ALPHA: _bindgen_ty_58 = 4;
pub const NET_SCTP_RTO_BETA: _bindgen_ty_58 = 5;
pub const NET_SCTP_VALID_COOKIE_LIFE: _bindgen_ty_58 = 6;
pub const NET_SCTP_ASSOCIATION_MAX_RETRANS: _bindgen_ty_58 = 7;
pub const NET_SCTP_PATH_MAX_RETRANS: _bindgen_ty_58 = 8;
pub const NET_SCTP_MAX_INIT_RETRANSMITS: _bindgen_ty_58 = 9;
pub const NET_SCTP_HB_INTERVAL: _bindgen_ty_58 = 10;
pub const NET_SCTP_PRESERVE_ENABLE: _bindgen_ty_58 = 11;
pub const NET_SCTP_MAX_BURST: _bindgen_ty_58 = 12;
pub const NET_SCTP_ADDIP_ENABLE: _bindgen_ty_58 = 13;
pub const NET_SCTP_PRSCTP_ENABLE: _bindgen_ty_58 = 14;
pub const NET_SCTP_SNDBUF_POLICY: _bindgen_ty_58 = 15;
pub const NET_SCTP_SACK_TIMEOUT: _bindgen_ty_58 = 16;
pub const NET_SCTP_RCVBUF_POLICY: _bindgen_ty_58 = 17;
pub type _bindgen_ty_58 = ffi::c_uint;
pub const NET_BRIDGE_NF_CALL_ARPTABLES: _bindgen_ty_59 = 1;
pub const NET_BRIDGE_NF_CALL_IPTABLES: _bindgen_ty_59 = 2;
pub const NET_BRIDGE_NF_CALL_IP6TABLES: _bindgen_ty_59 = 3;
pub const NET_BRIDGE_NF_FILTER_VLAN_TAGGED: _bindgen_ty_59 = 4;
pub const NET_BRIDGE_NF_FILTER_PPPOE_TAGGED: _bindgen_ty_59 = 5;
pub type _bindgen_ty_59 = ffi::c_uint;
pub const FS_NRINODE: _bindgen_ty_60 = 1;
pub const FS_STATINODE: _bindgen_ty_60 = 2;
pub const FS_MAXINODE: _bindgen_ty_60 = 3;
pub const FS_NRDQUOT: _bindgen_ty_60 = 4;
pub const FS_MAXDQUOT: _bindgen_ty_60 = 5;
pub const FS_NRFILE: _bindgen_ty_60 = 6;
pub const FS_MAXFILE: _bindgen_ty_60 = 7;
pub const FS_DENTRY: _bindgen_ty_60 = 8;
pub const FS_NRSUPER: _bindgen_ty_60 = 9;
pub const FS_MAXSUPER: _bindgen_ty_60 = 10;
pub const FS_OVERFLOWUID: _bindgen_ty_60 = 11;
pub const FS_OVERFLOWGID: _bindgen_ty_60 = 12;
pub const FS_LEASES: _bindgen_ty_60 = 13;
pub const FS_DIR_NOTIFY: _bindgen_ty_60 = 14;
pub const FS_LEASE_TIME: _bindgen_ty_60 = 15;
pub const FS_DQSTATS: _bindgen_ty_60 = 16;
pub const FS_XFS: _bindgen_ty_60 = 17;
pub const FS_AIO_NR: _bindgen_ty_60 = 18;
pub const FS_AIO_MAX_NR: _bindgen_ty_60 = 19;
pub const FS_INOTIFY: _bindgen_ty_60 = 20;
pub const FS_OCFS2: _bindgen_ty_60 = 988;
pub type _bindgen_ty_60 = ffi::c_uint;
pub const FS_DQ_LOOKUPS: _bindgen_ty_61 = 1;
pub const FS_DQ_DROPS: _bindgen_ty_61 = 2;
pub const FS_DQ_READS: _bindgen_ty_61 = 3;
pub const FS_DQ_WRITES: _bindgen_ty_61 = 4;
pub const FS_DQ_CACHE_HITS: _bindgen_ty_61 = 5;
pub const FS_DQ_ALLOCATED: _bindgen_ty_61 = 6;
pub const FS_DQ_FREE: _bindgen_ty_61 = 7;
pub const FS_DQ_SYNCS: _bindgen_ty_61 = 8;
pub const FS_DQ_WARNINGS: _bindgen_ty_61 = 9;
pub type _bindgen_ty_61 = ffi::c_uint;
pub const DEV_CDROM: _bindgen_ty_62 = 1;
pub const DEV_HWMON: _bindgen_ty_62 = 2;
pub const DEV_PARPORT: _bindgen_ty_62 = 3;
pub const DEV_RAID: _bindgen_ty_62 = 4;
pub const DEV_MAC_HID: _bindgen_ty_62 = 5;
pub const DEV_SCSI: _bindgen_ty_62 = 6;
pub const DEV_IPMI: _bindgen_ty_62 = 7;
pub type _bindgen_ty_62 = ffi::c_uint;
pub const DEV_CDROM_INFO: _bindgen_ty_63 = 1;
pub const DEV_CDROM_AUTOCLOSE: _bindgen_ty_63 = 2;
pub const DEV_CDROM_AUTOEJECT: _bindgen_ty_63 = 3;
pub const DEV_CDROM_DEBUG: _bindgen_ty_63 = 4;
pub const DEV_CDROM_LOCK: _bindgen_ty_63 = 5;
pub const DEV_CDROM_CHECK_MEDIA: _bindgen_ty_63 = 6;
pub type _bindgen_ty_63 = ffi::c_uint;
pub const DEV_PARPORT_DEFAULT: _bindgen_ty_64 = -3;
pub type _bindgen_ty_64 = ffi::c_int;
pub const DEV_RAID_SPEED_LIMIT_MIN: _bindgen_ty_65 = 1;
pub const DEV_RAID_SPEED_LIMIT_MAX: _bindgen_ty_65 = 2;
pub type _bindgen_ty_65 = ffi::c_uint;
pub const DEV_PARPORT_DEFAULT_TIMESLICE: _bindgen_ty_66 = 1;
pub const DEV_PARPORT_DEFAULT_SPINTIME: _bindgen_ty_66 = 2;
pub type _bindgen_ty_66 = ffi::c_uint;
pub const DEV_PARPORT_SPINTIME: _bindgen_ty_67 = 1;
pub const DEV_PARPORT_BASE_ADDR: _bindgen_ty_67 = 2;
pub const DEV_PARPORT_IRQ: _bindgen_ty_67 = 3;
pub const DEV_PARPORT_DMA: _bindgen_ty_67 = 4;
pub const DEV_PARPORT_MODES: _bindgen_ty_67 = 5;
pub const DEV_PARPORT_DEVICES: _bindgen_ty_67 = 6;
pub const DEV_PARPORT_AUTOPROBE: _bindgen_ty_67 = 16;
pub type _bindgen_ty_67 = ffi::c_uint;
pub const DEV_PARPORT_DEVICES_ACTIVE: _bindgen_ty_68 = -3;
pub type _bindgen_ty_68 = ffi::c_int;
pub const DEV_PARPORT_DEVICE_TIMESLICE: _bindgen_ty_69 = 1;
pub type _bindgen_ty_69 = ffi::c_uint;
pub const DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES: _bindgen_ty_70 = 1;
pub const DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES: _bindgen_ty_70 = 2;
pub const DEV_MAC_HID_MOUSE_BUTTON_EMULATION: _bindgen_ty_70 = 3;
pub const DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE: _bindgen_ty_70 = 4;
pub const DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE: _bindgen_ty_70 = 5;
pub const DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES: _bindgen_ty_70 = 6;
pub type _bindgen_ty_70 = ffi::c_uint;
pub const DEV_SCSI_LOGGING_LEVEL: _bindgen_ty_71 = 1;
pub type _bindgen_ty_71 = ffi::c_uint;
pub const DEV_IPMI_POWEROFF_POWERCYCLE: _bindgen_ty_72 = 1;
pub type _bindgen_ty_72 = ffi::c_uint;
pub const ABI_DEFHANDLER_COFF: _bindgen_ty_73 = 1;
pub const ABI_DEFHANDLER_ELF: _bindgen_ty_73 = 2;
pub const ABI_DEFHANDLER_LCALL7: _bindgen_ty_73 = 3;
pub const ABI_DEFHANDLER_LIBCSO: _bindgen_ty_73 = 4;
pub const ABI_TRACE: _bindgen_ty_73 = 5;
pub const ABI_FAKE_UTSNAME: _bindgen_ty_73 = 6;
pub type _bindgen_ty_73 = ffi::c_uint;

pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *const ctl_table,
        write: ffi::c_int,
        buffer: *mut ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table {
    pub procname: *const ffi::c_char,
    pub data: *mut ffi::c_void,
    pub maxlen: ffi::c_int,
    pub mode: umode_t,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ffi::c_void,
    pub extra2: *mut ffi::c_void,
}
impl Default for ctl_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
impl Default for ctl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *const ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
    pub type_: ctl_table_header__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *const ctl_table,
    pub ctl_table_size: ffi::c_int,
    pub used: ffi::c_int,
    pub count: ffi::c_int,
    pub nreg: ffi::c_int,
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ctl_table_header_SYSCTL_TABLE_TYPE_DEFAULT: ctl_table_header__bindgen_ty_2 = 0;
pub const ctl_table_header_SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY: ctl_table_header__bindgen_ty_2 = 1;
pub type ctl_table_header__bindgen_ty_2 = ffi::c_uint;
impl Default for ctl_table_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
impl Default for ctl_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ffi::c_int>,
    pub dir: ctl_dir,
}
impl Default for ctl_table_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, table: *const ctl_table) -> ffi::c_int,
    >,
}
impl Default for ctl_table_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct subprocess_info {
    pub work: work_struct,
    pub complete: *mut completion,
    pub path: *const ffi::c_char,
    pub argv: *mut *mut ffi::c_char,
    pub envp: *mut *mut ffi::c_char,
    pub wait: ffi::c_int,
    pub retval: ffi::c_int,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(info: *mut subprocess_info, new: *mut cred) -> ffi::c_int,
    >,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(info: *mut subprocess_info)>,
    pub data: *mut ffi::c_void,
}
impl Default for subprocess_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const umh_disable_depth_UMH_ENABLED: umh_disable_depth = 0;
pub const umh_disable_depth_UMH_FREEZING: umh_disable_depth = 1;
pub const umh_disable_depth_UMH_DISABLED: umh_disable_depth = 2;
pub type umh_disable_depth = ffi::c_uint;

pub type Elf32_Addr = __u32;
pub type Elf32_Half = __u16;
pub type Elf32_Off = __u32;
pub type Elf32_Sword = __s32;
pub type Elf32_Word = __u32;
pub type Elf32_Versym = __u16;
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_SHalf = __s16;
pub type Elf64_Off = __u64;
pub type Elf64_Sword = __s32;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
pub type Elf64_Sxword = __s64;
pub type Elf64_Versym = __u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf32_Dyn {
    pub d_tag: Elf32_Sword,
    pub d_un: Elf32_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf32_Dyn__bindgen_ty_1 {
    pub d_val: Elf32_Sword,
    pub d_ptr: Elf32_Addr,
}
impl Default for Elf32_Dyn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for Elf32_Dyn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf64_Dyn__bindgen_ty_1 {
    pub d_val: Elf64_Xword,
    pub d_ptr: Elf64_Addr,
}
impl Default for Elf64_Dyn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for Elf64_Dyn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rel {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
}
pub type Elf32_Rel = elf32_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rel {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
}
pub type Elf64_Rel = elf64_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    pub r_addend: Elf32_Sword,
}
pub type Elf32_Rela = elf32_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
pub type Elf64_Rela = elf64_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_sym {
    pub st_name: Elf32_Word,
    pub st_value: Elf32_Addr,
    pub st_size: Elf32_Word,
    pub st_info: ffi::c_uchar,
    pub st_other: ffi::c_uchar,
    pub st_shndx: Elf32_Half,
}
pub type Elf32_Sym = elf32_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: ffi::c_uchar,
    pub st_other: ffi::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_hdr {
    pub e_ident: [ffi::c_uchar; 16usize],
    pub e_type: Elf32_Half,
    pub e_machine: Elf32_Half,
    pub e_version: Elf32_Word,
    pub e_entry: Elf32_Addr,
    pub e_phoff: Elf32_Off,
    pub e_shoff: Elf32_Off,
    pub e_flags: Elf32_Word,
    pub e_ehsize: Elf32_Half,
    pub e_phentsize: Elf32_Half,
    pub e_phnum: Elf32_Half,
    pub e_shentsize: Elf32_Half,
    pub e_shnum: Elf32_Half,
    pub e_shstrndx: Elf32_Half,
}
pub type Elf32_Ehdr = elf32_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [ffi::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_phdr {
    pub p_type: Elf32_Word,
    pub p_offset: Elf32_Off,
    pub p_vaddr: Elf32_Addr,
    pub p_paddr: Elf32_Addr,
    pub p_filesz: Elf32_Word,
    pub p_memsz: Elf32_Word,
    pub p_flags: Elf32_Word,
    pub p_align: Elf32_Word,
}
pub type Elf32_Phdr = elf32_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
pub type Elf64_Phdr = elf64_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_shdr {
    pub sh_name: Elf32_Word,
    pub sh_type: Elf32_Word,
    pub sh_flags: Elf32_Word,
    pub sh_addr: Elf32_Addr,
    pub sh_offset: Elf32_Off,
    pub sh_size: Elf32_Word,
    pub sh_link: Elf32_Word,
    pub sh_info: Elf32_Word,
    pub sh_addralign: Elf32_Word,
    pub sh_entsize: Elf32_Word,
}
pub type Elf32_Shdr = elf32_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_note {
    pub n_namesz: Elf32_Word,
    pub n_descsz: Elf32_Word,
    pub n_type: Elf32_Word,
}
pub type Elf32_Nhdr = elf32_note;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_note {
    pub n_namesz: Elf64_Word,
    pub n_descsz: Elf64_Word,
    pub n_type: Elf64_Word,
}
pub type Elf64_Nhdr = elf64_note;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct Elf32_Verdef {
    pub vd_version: Elf32_Half,
    pub vd_flags: Elf32_Half,
    pub vd_ndx: Elf32_Half,
    pub vd_cnt: Elf32_Half,
    pub vd_hash: Elf32_Word,
    pub vd_aux: Elf32_Word,
    pub vd_next: Elf32_Word,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct Elf64_Verdef {
    pub vd_version: Elf64_Half,
    pub vd_flags: Elf64_Half,
    pub vd_ndx: Elf64_Half,
    pub vd_cnt: Elf64_Half,
    pub vd_hash: Elf64_Word,
    pub vd_aux: Elf64_Word,
    pub vd_next: Elf64_Word,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct Elf32_Verdaux {
    pub vda_name: Elf32_Word,
    pub vda_next: Elf32_Word,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct Elf64_Verdaux {
    pub vda_name: Elf64_Word,
    pub vda_next: Elf64_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
impl Default for rhash_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhlist_head {
    pub rhead: rhash_head,
    pub next: *mut rhlist_head,
}
impl Default for rhlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bucket_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const ffi::c_void,
}
impl Default for rhashtable_compare_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut rhashtable_compare_arg, obj: *const ffi::c_void) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: ffi::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: ffi::c_uint,
    pub max_elems: ffi::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
impl Default for rhashtable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhltable {
    pub ht: rhashtable,
}
impl Default for rhltable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_walker {
    pub list: list_head,
    pub tbl: *mut bucket_table,
}
impl Default for rhashtable_walker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_iter {
    pub ht: *mut rhashtable,
    pub p: *mut rhash_head,
    pub list: *mut rhlist_head,
    pub walker: rhashtable_walker,
    pub slot: ffi::c_uint,
    pub skip: ffi::c_uint,
    pub end_of_table: bool_,
}
impl Default for rhashtable_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipc_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid_t,
    pub gid: __kernel_gid_t,
    pub cuid: __kernel_uid_t,
    pub cgid: __kernel_gid_t,
    pub mode: __kernel_mode_t,
    pub seq: ffi::c_ushort,
}
#[repr(C)]
#[derive(Default)]
pub struct ipc64_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid32_t,
    pub gid: __kernel_gid32_t,
    pub cuid: __kernel_uid32_t,
    pub cgid: __kernel_gid32_t,
    pub mode: __kernel_mode_t,
    pub __pad1: __IncompleteArrayField<ffi::c_uchar>,
    pub seq: ffi::c_ushort,
    pub __pad2: ffi::c_ushort,
    pub __unused1: __kernel_ulong_t,
    pub __unused2: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_kludge {
    pub msgp: *mut msgbuf,
    pub msgtyp: ffi::c_long,
}
impl Default for ipc_kludge {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct kern_ipc_perm {
    pub lock: spinlock_t,
    pub deleted: bool_,
    pub id: ffi::c_int,
    pub key: key_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub cuid: kuid_t,
    pub cgid: kgid_t,
    pub mode: umode_t,
    pub seq: ffi::c_ulong,
    pub security: *mut ffi::c_void,
    pub khtnode: rhash_head,
    pub rcu: callback_head,
    pub refcount: refcount_t,
}
impl Default for kern_ipc_perm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semid_ds {
    pub sem_perm: ipc_perm,
    pub sem_otime: __kernel_old_time_t,
    pub sem_ctime: __kernel_old_time_t,
    pub sem_base: *mut sem,
    pub sem_pending: *mut sem_queue,
    pub sem_pending_last: *mut *mut sem_queue,
    pub undo: *mut sem_undo,
    pub sem_nsems: ffi::c_ushort,
}
impl Default for semid_ds {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct semid64_ds {
    pub sem_perm: ipc64_perm,
    pub sem_otime: ffi::c_long,
    pub sem_ctime: ffi::c_long,
    pub sem_nsems: ffi::c_ulong,
    pub __unused3: ffi::c_ulong,
    pub __unused4: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sembuf {
    pub sem_num: ffi::c_ushort,
    pub sem_op: ffi::c_short,
    pub sem_flg: ffi::c_short,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union semun {
    pub val: ffi::c_int,
    pub buf: *mut semid_ds,
    pub array: *mut ffi::c_ushort,
    pub __buf: *mut seminfo,
    pub __pad: *mut ffi::c_void,
}
impl Default for semun {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seminfo {
    pub semmap: ffi::c_int,
    pub semmni: ffi::c_int,
    pub semmns: ffi::c_int,
    pub semmnu: ffi::c_int,
    pub semmsl: ffi::c_int,
    pub semopm: ffi::c_int,
    pub semume: ffi::c_int,
    pub semusz: ffi::c_int,
    pub semvmx: ffi::c_int,
    pub semaem: ffi::c_int,
}

#[repr(C)]
pub struct iovec {
    pub iov_base: *mut ffi::c_void,
    pub iov_len: __kernel_size_t,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dmabuf_cmsg {
    pub frag_offset: __u64,
    pub frag_size: __u32,
    pub frag_token: __u32,
    pub dmabuf_id: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dmabuf_token {
    pub token_start: __u32,
    pub token_count: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio_queue {
    _unused: [u8; 0],
}
pub type iov_iter_extraction_t = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut ffi::c_void,
    pub iov_len: usize,
}
impl Default for kvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const iter_type_ITER_UBUF: iter_type = 0;
pub const iter_type_ITER_IOVEC: iter_type = 1;
pub const iter_type_ITER_BVEC: iter_type = 2;
pub const iter_type_ITER_KVEC: iter_type = 3;
pub const iter_type_ITER_FOLIOQ: iter_type = 4;
pub const iter_type_ITER_XARRAY: iter_type = 5;
pub const iter_type_ITER_DISCARD: iter_type = 6;
pub type iter_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iov_iter_state {
    pub iov_offset: usize,
    pub count: usize,
    pub nr_segs: ffi::c_ulong,
}
#[repr(C)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub iov_offset: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
pub struct iov_iter__bindgen_ty_1 {
    pub __ubuf_iovec: __BindgenUnionField<iovec>,
    pub __bindgen_anon_1: __BindgenUnionField<iov_iter__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub count: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub folioq: *const folio_queue,
    pub xarray: *mut xarray,
    pub ubuf: *mut ffi::c_void,
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: ffi::c_ulong,
    pub folioq_slot: u8_,
    pub xarray_start: loff_t,
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type uio_meta_flags_t = __u16;
#[repr(C)]
pub struct uio_meta {
    pub flags: uio_meta_flags_t,
    pub app_tag: u16_,
    pub seed: u64_,
    pub iter: iov_iter,
}
impl Default for uio_meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type __kernel_sa_family_t = ffi::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [ffi::c_char; 126usize],
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __kernel_sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto_accept_arg {
    _unused: [u8; 0],
}

pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub __bindgen_anon_1: sockaddr__bindgen_ty_1,
}
#[repr(C)]
pub struct sockaddr__bindgen_ty_1 {
    pub sa_data_min: __BindgenUnionField<[ffi::c_char; 14usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<sockaddr__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 14usize],
}
#[repr(C)]
#[derive(Default)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_sa_data: sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub sa_data: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for sockaddr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sockaddr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ffi::c_int,
    pub l_linger: ffi::c_int,
}
#[repr(C)]
pub struct msghdr {
    pub msg_name: *mut ffi::c_void,
    pub msg_namelen: ffi::c_int,
    pub msg_inq: ffi::c_int,
    pub msg_iter: iov_iter,
    pub __bindgen_anon_1: msghdr__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub msg_flags: ffi::c_uint,
    pub msg_controllen: __kernel_size_t,
    pub msg_iocb: *mut kiocb,
    pub msg_ubuf: *mut ubuf_info,
    pub sg_from_iter: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, from: *mut iov_iter, length: usize) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msghdr__bindgen_ty_1 {
    pub msg_control: *mut ffi::c_void,
    pub msg_control_user: *mut ffi::c_void,
}
impl Default for msghdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl msghdr {
    #[inline]
    pub fn msg_control_is_user(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_control_is_user(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msg_control_is_user_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_msg_control_is_user_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msg_get_inq(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_get_inq(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msg_get_inq_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_msg_get_inq_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_control_is_user: bool_,
        msg_get_inq: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_control_is_user: u8 = unsafe { ::core::mem::transmute(msg_control_is_user) };
            msg_control_is_user as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let msg_get_inq: u8 = unsafe { ::core::mem::transmute(msg_get_inq) };
            msg_get_inq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct user_msghdr {
    pub msg_name: *mut ffi::c_void,
    pub msg_namelen: ffi::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: __kernel_size_t,
    pub msg_control: *mut ffi::c_void,
    pub msg_controllen: __kernel_size_t,
    pub msg_flags: ffi::c_uint,
}
impl Default for user_msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct mmsghdr {
    pub msg_hdr: user_msghdr,
    pub msg_len: ffi::c_uint,
}
impl Default for mmsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct cmsghdr {
    pub cmsg_len: __kernel_size_t,
    pub cmsg_level: ffi::c_int,
    pub cmsg_type: ffi::c_int,
}
impl Default for cmsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ucred {
    pub pid: __u32,
    pub uid: __u32,
    pub gid: __u32,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_timestamping_internal {
    pub ts: [timespec64; 3usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: ffi::c_uint,
    pub clock_type: ffi::c_uint,
    pub loopback: ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: ffi::c_uint,
    pub clock_type: ffi::c_uint,
    pub loopback: ffi::c_ushort,
    pub slot_map: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: ffi::c_ushort,
    pub parity: ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto {
    pub t391: ffi::c_uint,
    pub t392: ffi::c_uint,
    pub n391: ffi::c_uint,
    pub n392: ffi::c_uint,
    pub n393: ffi::c_uint,
    pub lmi: ffi::c_ushort,
    pub dce: ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: ffi::c_uint,
    pub master: [ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cisco_proto {
    pub interval: ffi::c_uint,
    pub timeout: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: ffi::c_ushort,
    pub modulo: ffi::c_uint,
    pub window: ffi::c_uint,
    pub t1: ffi::c_uint,
    pub t2: ffi::c_uint,
    pub n2: ffi::c_uint,
}
pub const net_device_flags_IFF_UP: net_device_flags = 1;
pub const net_device_flags_IFF_BROADCAST: net_device_flags = 2;
pub const net_device_flags_IFF_DEBUG: net_device_flags = 4;
pub const net_device_flags_IFF_LOOPBACK: net_device_flags = 8;
pub const net_device_flags_IFF_POINTOPOINT: net_device_flags = 16;
pub const net_device_flags_IFF_NOTRAILERS: net_device_flags = 32;
pub const net_device_flags_IFF_RUNNING: net_device_flags = 64;
pub const net_device_flags_IFF_NOARP: net_device_flags = 128;
pub const net_device_flags_IFF_PROMISC: net_device_flags = 256;
pub const net_device_flags_IFF_ALLMULTI: net_device_flags = 512;
pub const net_device_flags_IFF_MASTER: net_device_flags = 1024;
pub const net_device_flags_IFF_SLAVE: net_device_flags = 2048;
pub const net_device_flags_IFF_MULTICAST: net_device_flags = 4096;
pub const net_device_flags_IFF_PORTSEL: net_device_flags = 8192;
pub const net_device_flags_IFF_AUTOMEDIA: net_device_flags = 16384;
pub const net_device_flags_IFF_DYNAMIC: net_device_flags = 32768;
pub const net_device_flags_IFF_LOWER_UP: net_device_flags = 65536;
pub const net_device_flags_IFF_DORMANT: net_device_flags = 131072;
pub const net_device_flags_IFF_ECHO: net_device_flags = 262144;
pub type net_device_flags = ffi::c_uint;
pub const IF_OPER_UNKNOWN: _bindgen_ty_74 = 0;
pub const IF_OPER_NOTPRESENT: _bindgen_ty_74 = 1;
pub const IF_OPER_DOWN: _bindgen_ty_74 = 2;
pub const IF_OPER_LOWERLAYERDOWN: _bindgen_ty_74 = 3;
pub const IF_OPER_TESTING: _bindgen_ty_74 = 4;
pub const IF_OPER_DORMANT: _bindgen_ty_74 = 5;
pub const IF_OPER_UP: _bindgen_ty_74 = 6;
pub type _bindgen_ty_74 = ffi::c_uint;
pub const IF_LINK_MODE_DEFAULT: _bindgen_ty_75 = 0;
pub const IF_LINK_MODE_DORMANT: _bindgen_ty_75 = 1;
pub const IF_LINK_MODE_TESTING: _bindgen_ty_75 = 2;
pub type _bindgen_ty_75 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifmap {
    pub mem_start: ffi::c_ulong,
    pub mem_end: ffi::c_ulong,
    pub base_addr: ffi::c_ushort,
    pub irq: ffi::c_uchar,
    pub dma: ffi::c_uchar,
    pub port: ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: ffi::c_uint,
    pub size: ffi::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
}
impl Default for if_settings__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for if_settings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [ffi::c_char; 16usize],
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifreq__bindgen_ty_2 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_netmask: __BindgenUnionField<sockaddr>,
    pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
    pub ifru_flags: __BindgenUnionField<ffi::c_short>,
    pub ifru_ivalue: __BindgenUnionField<ffi::c_int>,
    pub ifru_mtu: __BindgenUnionField<ffi::c_int>,
    pub ifru_map: __BindgenUnionField<ifmap>,
    pub ifru_slave: __BindgenUnionField<[ffi::c_char; 16usize]>,
    pub ifru_newname: __BindgenUnionField<[ffi::c_char; 16usize]>,
    pub ifru_data: __BindgenUnionField<*mut ffi::c_void>,
    pub ifru_settings: __BindgenUnionField<if_settings>,
    pub bindgen_union_field: [u64; 3usize],
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: ffi::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: *mut ffi::c_char,
    pub ifcu_req: *mut ifreq,
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifconf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_key {
    pub flags: *mut ffi::c_ulong,
    pub bit_nr: ffi::c_int,
    pub timeout: ffi::c_ulong,
}
impl Default for wait_bit_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_queue_entry {
    pub key: wait_bit_key,
    pub wq_entry: wait_queue_entry,
}
impl Default for wait_bit_queue_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_bit_action_f = ::core::option::Option<
    unsafe extern "C" fn(key: *mut wait_bit_key, mode: ffi::c_int) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ffi::c_int,
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qstr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union shortname_store {
    pub string: [ffi::c_uchar; 40usize],
    pub words: [ffi::c_ulong; 5usize],
}
impl Default for shortname_store {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: ffi::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_shortname: shortname_store,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: ffi::c_ulong,
    pub d_fsdata: *mut ffi::c_void,
    pub d_lockref: lockref,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_sib: hlist_node,
    pub d_children: hlist_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const dentry_d_lock_class_DENTRY_D_LOCK_NORMAL: dentry_d_lock_class = 0;
pub const dentry_d_lock_class_DENTRY_D_LOCK_NESTED: dentry_d_lock_class = 1;
pub type dentry_d_lock_class = ffi::c_uint;
pub const d_real_type_D_REAL_DATA: d_real_type = 0;
pub const d_real_type_D_REAL_METADATA: d_real_type = 1;
pub type d_real_type = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const qstr,
            arg3: *mut dentry,
            arg4: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ffi::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: ffi::c_uint,
            arg3: *const ffi::c_char,
            arg4: *const qstr,
        ) -> ffi::c_int,
    >,
    pub d_delete: ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ffi::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ffi::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ffi::c_char,
            arg3: ffi::c_int,
        ) -> *mut ffi::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ffi::c_int>,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, type_: d_real_type) -> *mut dentry,
    >,
    pub d_unalias_trylock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> bool_>,
    pub d_unalias_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry)>,
}
impl Default for dentry_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const dentry_flags_DCACHE_OP_HASH: dentry_flags = 1;
pub const dentry_flags_DCACHE_OP_COMPARE: dentry_flags = 2;
pub const dentry_flags_DCACHE_OP_REVALIDATE: dentry_flags = 4;
pub const dentry_flags_DCACHE_OP_DELETE: dentry_flags = 8;
pub const dentry_flags_DCACHE_OP_PRUNE: dentry_flags = 16;
pub const dentry_flags_DCACHE_DISCONNECTED: dentry_flags = 32;
pub const dentry_flags_DCACHE_REFERENCED: dentry_flags = 64;
pub const dentry_flags_DCACHE_DONTCACHE: dentry_flags = 128;
pub const dentry_flags_DCACHE_CANT_MOUNT: dentry_flags = 256;
pub const dentry_flags_DCACHE_GENOCIDE: dentry_flags = 512;
pub const dentry_flags_DCACHE_SHRINK_LIST: dentry_flags = 1024;
pub const dentry_flags_DCACHE_OP_WEAK_REVALIDATE: dentry_flags = 2048;
pub const dentry_flags_DCACHE_NFSFS_RENAMED: dentry_flags = 4096;
pub const dentry_flags_DCACHE_FSNOTIFY_PARENT_WATCHED: dentry_flags = 8192;
pub const dentry_flags_DCACHE_DENTRY_KILLED: dentry_flags = 16384;
pub const dentry_flags_DCACHE_MOUNTED: dentry_flags = 32768;
pub const dentry_flags_DCACHE_NEED_AUTOMOUNT: dentry_flags = 65536;
pub const dentry_flags_DCACHE_MANAGE_TRANSIT: dentry_flags = 131072;
pub const dentry_flags_DCACHE_LRU_LIST: dentry_flags = 262144;
pub const dentry_flags_DCACHE_ENTRY_TYPE: dentry_flags = 3670016;
pub const dentry_flags_DCACHE_MISS_TYPE: dentry_flags = 0;
pub const dentry_flags_DCACHE_WHITEOUT_TYPE: dentry_flags = 524288;
pub const dentry_flags_DCACHE_DIRECTORY_TYPE: dentry_flags = 1048576;
pub const dentry_flags_DCACHE_AUTODIR_TYPE: dentry_flags = 1572864;
pub const dentry_flags_DCACHE_REGULAR_TYPE: dentry_flags = 2097152;
pub const dentry_flags_DCACHE_SPECIAL_TYPE: dentry_flags = 2621440;
pub const dentry_flags_DCACHE_SYMLINK_TYPE: dentry_flags = 3145728;
pub const dentry_flags_DCACHE_NOKEY_NAME: dentry_flags = 4194304;
pub const dentry_flags_DCACHE_OP_REAL: dentry_flags = 8388608;
pub const dentry_flags_DCACHE_PAR_LOOKUP: dentry_flags = 16777216;
pub const dentry_flags_DCACHE_DENTRY_CURSOR: dentry_flags = 33554432;
pub const dentry_flags_DCACHE_NORCU: dentry_flags = 67108864;
pub type dentry_flags = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct name_snapshot {
    pub name: qstr,
    pub inline_name: shortname_store,
}
impl Default for name_snapshot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
impl Default for path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker_info_unit {
    pub nr_deferred: [atomic_long_t; 64usize],
    pub map: [ffi::c_ulong; 1usize],
}
impl Default for shrinker_info_unit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct shrinker_info {
    pub rcu: callback_head,
    pub map_nr_max: ffi::c_int,
    pub unit: __IncompleteArrayField<*mut shrinker_info_unit>,
}
impl Default for shrinker_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: ffi::c_int,
    pub nr_to_scan: ffi::c_ulong,
    pub nr_scanned: ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for shrink_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ffi::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ffi::c_ulong,
    >,
    pub batch: ffi::c_long,
    pub seeks: ffi::c_int,
    pub flags: ffi::c_uint,
    pub refcount: refcount_t,
    pub done: completion,
    pub rcu: callback_head,
    pub private_data: *mut ffi::c_void,
    pub list: list_head,
    pub id: ffi::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
impl Default for shrinker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const lru_status_LRU_REMOVED: lru_status = 0;
pub const lru_status_LRU_REMOVED_RETRY: lru_status = 1;
pub const lru_status_LRU_ROTATE: lru_status = 2;
pub const lru_status_LRU_SKIP: lru_status = 3;
pub const lru_status_LRU_RETRY: lru_status = 4;
pub const lru_status_LRU_STOP: lru_status = 5;
pub type lru_status = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: ffi::c_long,
    pub lock: spinlock_t,
}
impl Default for list_lru_one {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub node: __IncompleteArrayField<list_lru_one>,
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lru: list_lru_one,
    pub nr_items: atomic_long_t,
}
impl Default for list_lru_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: ffi::c_int,
    pub memcg_aware: bool_,
    pub xa: xarray,
}
impl Default for list_lru {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type list_lru_walk_cb = ::core::option::Option<
    unsafe extern "C" fn(
        item: *mut list_head,
        list: *mut list_lru_one,
        cb_arg: *mut ffi::c_void,
    ) -> lru_status,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pidfs_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct upid {
    pub nr: ffi::c_int,
    pub ns: *mut pid_namespace,
}
impl Default for upid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pid {
    pub count: refcount_t,
    pub level: ffi::c_uint,
    pub lock: spinlock_t,
    pub __bindgen_anon_1: pid__bindgen_ty_1,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: __IncompleteArrayField<upid>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid__bindgen_ty_1 {
    pub ino: u64_,
    pub pidfs_node: rb_node,
    pub stashed: *mut dentry,
    pub attr: *mut pidfs_attr,
}
impl Default for pid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: ffi::c_int,
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cap_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_vfs_cap_data {
    pub magic_etc: __u32,
    pub rootid: kuid_t,
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_idmap {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: ffi::c_uint,
    pub wait_list: list_head,
}
impl Default for semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: ffi::c_int,
    pub pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock {
    pub l_type: ffi::c_short,
    pub l_whence: ffi::c_short,
    pub l_start: __kernel_off_t,
    pub l_len: __kernel_off_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock64 {
    pub l_type: ffi::c_short,
    pub l_whence: ffi::c_short,
    pub l_start: __kernel_loff_t,
    pub l_len: __kernel_loff_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub type migrate_mode = ffi::c_uint;
pub const migrate_reason_MR_COMPACTION: migrate_reason = 0;
pub const migrate_reason_MR_MEMORY_FAILURE: migrate_reason = 1;
pub const migrate_reason_MR_MEMORY_HOTPLUG: migrate_reason = 2;
pub const migrate_reason_MR_SYSCALL: migrate_reason = 3;
pub const migrate_reason_MR_MEMPOLICY_MBIND: migrate_reason = 4;
pub const migrate_reason_MR_NUMA_MISPLACED: migrate_reason = 5;
pub const migrate_reason_MR_CONTIG_RANGE: migrate_reason = 6;
pub const migrate_reason_MR_LONGTERM_PIN: migrate_reason = 7;
pub const migrate_reason_MR_DEMOTION: migrate_reason = 8;
pub const migrate_reason_MR_DAMON: migrate_reason = 9;
pub const migrate_reason_MR_TYPES: migrate_reason = 10;
pub type migrate_reason = ffi::c_uint;

pub const siginfo_layout_SIL_KILL: siginfo_layout = 0;
pub const siginfo_layout_SIL_TIMER: siginfo_layout = 1;
pub const siginfo_layout_SIL_POLL: siginfo_layout = 2;
pub const siginfo_layout_SIL_FAULT: siginfo_layout = 3;
pub const siginfo_layout_SIL_FAULT_TRAPNO: siginfo_layout = 4;
pub const siginfo_layout_SIL_FAULT_MCEERR: siginfo_layout = 5;
pub const siginfo_layout_SIL_FAULT_BNDERR: siginfo_layout = 6;
pub const siginfo_layout_SIL_FAULT_PKUERR: siginfo_layout = 7;
pub const siginfo_layout_SIL_FAULT_PERF_EVENT: siginfo_layout = 8;
pub const siginfo_layout_SIL_CHLD: siginfo_layout = 9;
pub const siginfo_layout_SIL_RT: siginfo_layout = 10;
pub const siginfo_layout_SIL_SYS: siginfo_layout = 11;
pub type siginfo_layout = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_cpuinfo {
    pub mvendorid: ffi::c_ulong,
    pub marchid: ffi::c_ulong,
    pub mimpid: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_isainfo {
    pub isa: [ffi::c_ulong; 2usize],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct riscv_isa_ext_data {
    pub id: ffi::c_uint,
    pub name: *const ffi::c_char,
    pub property: *const ffi::c_char,
    pub subset_ext_ids: *const ffi::c_uint,
    pub subset_ext_size: ffi::c_uint,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            data: *const riscv_isa_ext_data,
            isa_bitmap: *const ffi::c_ulong,
        ) -> ffi::c_int,
    >,
}
impl Default for riscv_isa_ext_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct alt_entry {
    pub old_offset: s32,
    pub alt_offset: s32,
    pub vendor_id: u16_,
    pub alt_len: u16_,
    pub patch_id: u32_,
}

pub type compat_size_t = u32_;
pub type compat_ssize_t = s32;
pub type compat_clock_t = s32;
pub type compat_pid_t = s32;
pub type compat_ino_t = u32_;
pub type compat_off_t = s32;
pub type compat_loff_t = s64;
pub type compat_daddr_t = s32;
pub type compat_timer_t = s32;
pub type compat_key_t = s32;
pub type compat_short_t = s16;
pub type compat_int_t = s32;
pub type compat_long_t = s32;
pub type compat_ushort_t = u16_;
pub type compat_uint_t = u32_;
pub type compat_ulong_t = u32_;
pub type compat_uptr_t = u32_;
pub type compat_caddr_t = u32_;
pub type compat_aio_context_t = u32_;
pub type compat_old_sigset_t = u32_;
pub type __compat_uid_t = u32_;
pub type __compat_gid_t = u32_;
pub type __compat_uid32_t = u32_;
pub type __compat_gid32_t = u32_;
pub type compat_mode_t = u32_;
pub type compat_s64 = s64;
pub type compat_u64 = u64_;
pub type compat_sigset_word = u32_;
pub type compat_dev_t = u32_;
pub type compat_ipc_pid_t = s32;
pub type compat_fsid_t = __kernel_fsid_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_statfs {
    pub f_type: compat_int_t,
    pub f_bsize: compat_int_t,
    pub f_blocks: compat_int_t,
    pub f_bfree: compat_int_t,
    pub f_bavail: compat_int_t,
    pub f_files: compat_int_t,
    pub f_ffree: compat_int_t,
    pub f_fsid: compat_fsid_t,
    pub f_namelen: compat_int_t,
    pub f_frsize: compat_int_t,
    pub f_flags: compat_int_t,
    pub f_spare: [compat_int_t; 4usize],
}
#[repr(C)]
#[derive(Default)]
pub struct compat_ipc64_perm {
    pub key: compat_key_t,
    pub uid: __compat_uid32_t,
    pub gid: __compat_gid32_t,
    pub cuid: __compat_uid32_t,
    pub cgid: __compat_gid32_t,
    pub mode: compat_mode_t,
    pub __pad1: __IncompleteArrayField<ffi::c_uchar>,
    pub seq: compat_ushort_t,
    pub __pad2: compat_ushort_t,
    pub unused1: compat_ulong_t,
    pub unused2: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_semid64_ds {
    pub sem_perm: compat_ipc64_perm,
    pub sem_otime: compat_ulong_t,
    pub sem_otime_high: compat_ulong_t,
    pub sem_ctime: compat_ulong_t,
    pub sem_ctime_high: compat_ulong_t,
    pub sem_nsems: compat_ulong_t,
    pub __unused3: compat_ulong_t,
    pub __unused4: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_msqid64_ds {
    pub msg_perm: compat_ipc64_perm,
    pub msg_stime: compat_ulong_t,
    pub msg_stime_high: compat_ulong_t,
    pub msg_rtime: compat_ulong_t,
    pub msg_rtime_high: compat_ulong_t,
    pub msg_ctime: compat_ulong_t,
    pub msg_ctime_high: compat_ulong_t,
    pub msg_cbytes: compat_ulong_t,
    pub msg_qnum: compat_ulong_t,
    pub msg_qbytes: compat_ulong_t,
    pub msg_lspid: compat_pid_t,
    pub msg_lrpid: compat_pid_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_shmid64_ds {
    pub shm_perm: compat_ipc64_perm,
    pub shm_segsz: compat_size_t,
    pub shm_atime: compat_ulong_t,
    pub shm_atime_high: compat_ulong_t,
    pub shm_dtime: compat_ulong_t,
    pub shm_dtime_high: compat_ulong_t,
    pub shm_ctime: compat_ulong_t,
    pub shm_ctime_high: compat_ulong_t,
    pub shm_cpid: compat_pid_t,
    pub shm_lpid: compat_pid_t,
    pub shm_nattch: compat_ulong_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_user_regs_struct {
    pub pc: compat_ulong_t,
    pub ra: compat_ulong_t,
    pub sp: compat_ulong_t,
    pub gp: compat_ulong_t,
    pub tp: compat_ulong_t,
    pub t0: compat_ulong_t,
    pub t1: compat_ulong_t,
    pub t2: compat_ulong_t,
    pub s0: compat_ulong_t,
    pub s1: compat_ulong_t,
    pub a0: compat_ulong_t,
    pub a1: compat_ulong_t,
    pub a2: compat_ulong_t,
    pub a3: compat_ulong_t,
    pub a4: compat_ulong_t,
    pub a5: compat_ulong_t,
    pub a6: compat_ulong_t,
    pub a7: compat_ulong_t,
    pub s2: compat_ulong_t,
    pub s3: compat_ulong_t,
    pub s4: compat_ulong_t,
    pub s5: compat_ulong_t,
    pub s6: compat_ulong_t,
    pub s7: compat_ulong_t,
    pub s8: compat_ulong_t,
    pub s9: compat_ulong_t,
    pub s10: compat_ulong_t,
    pub s11: compat_ulong_t,
    pub t3: compat_ulong_t,
    pub t4: compat_ulong_t,
    pub t5: compat_ulong_t,
    pub t6: compat_ulong_t,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct p4d_t {
    pub p4d: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pud_t {
    pub pud: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: ffi::c_ulong,
}
pub const napot_cont_order_NAPOT_CONT64KB_ORDER: napot_cont_order = 4;
pub const napot_cont_order_NAPOT_ORDER_MAX: napot_cont_order = 5;
pub type napot_cont_order = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_alloc_ops {
    pub get_pte_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pte_t>,
    pub alloc_pte: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_pmd_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pmd_t>,
    pub alloc_pmd: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_pud_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pud_t>,
    pub alloc_pud: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_p4d_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut p4d_t>,
    pub alloc_p4d: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: ffi::c_int,
    pub fixup: ffi::c_int,
    pub type_: ffi::c_short,
    pub data: ffi::c_short,
}

pub const class_pagefault_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_pagefault_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_pagefault_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_clone_args {
    pub flags: u64_,
    pub pidfd: *mut ffi::c_int,
    pub child_tid: *mut ffi::c_int,
    pub parent_tid: *mut ffi::c_int,
    pub name: *const ffi::c_char,
    pub exit_signal: ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub stack: ffi::c_ulong,
    pub stack_size: ffi::c_ulong,
    pub tls: ffi::c_ulong,
    pub set_tid: *mut pid_t,
    pub set_tid_size: usize,
    pub cgroup: ffi::c_int,
    pub idle: ffi::c_int,
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void) -> ffi::c_int>,
    pub fn_arg: *mut ffi::c_void,
    pub cgrp: *mut cgroup,
    pub cset: *mut css_set,
    pub kill_seq: ffi::c_uint,
}
impl Default for kernel_clone_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernel_clone_args {
    #[inline]
    pub fn kthread(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_kthread(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn kthread_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_kthread_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_thread(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_thread(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_thread_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_io_thread_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_worker(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user_worker(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_worker_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_user_worker_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_files(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_files(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_files_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_files_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        kthread: u32_,
        io_thread: u32_,
        user_worker: u32_,
        no_files: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let kthread: u32 = unsafe { ::core::mem::transmute(kthread) };
            kthread as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_thread: u32 = unsafe { ::core::mem::transmute(io_thread) };
            io_thread as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let user_worker: u32 = unsafe { ::core::mem::transmute(user_worker) };
            user_worker as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_files: u32 = unsafe { ::core::mem::transmute(no_files) };
            no_files as u64
        });
        __bindgen_bitfield_unit
    }
}

pub type class_task_lock_t = *mut task_struct;
pub const class_task_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: ffi::c_ulong,
}
impl Default for assoc_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ops {
    pub get_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(index_key: *const ffi::c_void, level: ffi::c_int) -> ffi::c_ulong,
    >,
    pub get_object_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(object: *const ffi::c_void, level: ffi::c_int) -> ffi::c_ulong,
    >,
    pub compare_object: ::core::option::Option<
        unsafe extern "C" fn(object: *const ffi::c_void, index_key: *const ffi::c_void) -> bool_,
    >,
    pub diff_objects: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const ffi::c_void,
            index_key: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub free_object: ::core::option::Option<unsafe extern "C" fn(object: *mut ffi::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array_edit {
    _unused: [u8; 0],
}

pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net {
    _unused: [u8; 0],
}
pub const key_need_perm_KEY_NEED_UNSPECIFIED: key_need_perm = 0;
pub const key_need_perm_KEY_NEED_VIEW: key_need_perm = 1;
pub const key_need_perm_KEY_NEED_READ: key_need_perm = 2;
pub const key_need_perm_KEY_NEED_WRITE: key_need_perm = 3;
pub const key_need_perm_KEY_NEED_SEARCH: key_need_perm = 4;
pub const key_need_perm_KEY_NEED_LINK: key_need_perm = 5;
pub const key_need_perm_KEY_NEED_SETATTR: key_need_perm = 6;
pub const key_need_perm_KEY_NEED_UNLINK: key_need_perm = 7;
pub const key_need_perm_KEY_SYSADMIN_OVERRIDE: key_need_perm = 8;
pub const key_need_perm_KEY_AUTHTOKEN_OVERRIDE: key_need_perm = 9;
pub const key_need_perm_KEY_DEFER_PERM_CHECK: key_need_perm = 10;
pub type key_need_perm = ffi::c_uint;
pub const key_lookup_flag_KEY_LOOKUP_CREATE: key_lookup_flag = 1;
pub const key_lookup_flag_KEY_LOOKUP_PARTIAL: key_lookup_flag = 2;
pub const key_lookup_flag_KEY_LOOKUP_ALL: key_lookup_flag = 3;
pub type key_lookup_flag = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_owner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_name {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
impl Default for key_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: ffi::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [ffi::c_char; 6usize],
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for keyring_index_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut ffi::c_void,
    pub data: [*mut ffi::c_void; 4usize],
}
impl Default for key_payload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __key_reference_with_attributes {
    _unused: [u8; 0],
}
pub type key_ref_t = *mut __key_reference_with_attributes;
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
impl Default for key_restriction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const key_state_KEY_IS_UNINSTANTIATED: key_state = 0;
pub const key_state_KEY_IS_POSITIVE: key_state = 1;
pub type key_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut ffi::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: ffi::c_ushort,
    pub datalen: ffi::c_ushort,
    pub state: ffi::c_short,
    pub flags: ffi::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: ffi::c_ulong,
    pub len_desc: ffi::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut ffi::c_char,
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: ffi::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub ratelimit: ratelimit_state,
}
impl Default for user_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct group_info {
    pub usage: refcount_t,
    pub ngroups: ffi::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_long_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: ffi::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: ffi::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut ffi::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: ffi::c_int,
    pub rcu: callback_head,
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ffi::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC: hrtimer_base_type = 0;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME: hrtimer_base_type = 1;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME: hrtimer_base_type = 2;
pub const hrtimer_base_type_HRTIMER_BASE_TAI: hrtimer_base_type = 3;
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC_SOFT: hrtimer_base_type = 4;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME_SOFT: hrtimer_base_type = 5;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME_SOFT: hrtimer_base_type = 6;
pub const hrtimer_base_type_HRTIMER_BASE_TAI_SOFT: hrtimer_base_type = 7;
pub const hrtimer_base_type_HRTIMER_MAX_CLOCK_BASES: hrtimer_base_type = 8;
pub type hrtimer_base_type = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: ffi::c_uint,
    pub active_bases: ffi::c_uint,
    pub clock_was_set_seq: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: ffi::c_uint,
    pub nr_retries: ffi::c_ushort,
    pub nr_hangs: ffi::c_ushort,
    pub max_hang_time: ffi::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
    pub csd: call_single_data_t,
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hres_active_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hres_active_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_hrtirq_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_hrtirq_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hang_detected_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hang_detected_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn softirq_activated_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_softirq_activated_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn online(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn online_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_online_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: ffi::c_uint,
        in_hrtirq: ffi::c_uint,
        hang_detected: ffi::c_uint,
        softirq_activated: ffi::c_uint,
        online: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let online: u32 = unsafe { ::core::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const hrtimer_mode_HRTIMER_MODE_ABS: hrtimer_mode = 0;
pub const hrtimer_mode_HRTIMER_MODE_REL: hrtimer_mode = 1;
pub const hrtimer_mode_HRTIMER_MODE_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED: hrtimer_mode = 3;
pub const hrtimer_mode_HRTIMER_MODE_ABS_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_REL_SOFT: hrtimer_mode = 5;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_SOFT: hrtimer_mode = 6;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_SOFT: hrtimer_mode = 7;
pub const hrtimer_mode_HRTIMER_MODE_ABS_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_REL_HARD: hrtimer_mode = 9;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_HARD: hrtimer_mode = 10;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_HARD: hrtimer_mode = 11;
pub type hrtimer_mode = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
impl Default for hrtimer_sleeper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_device {
    _unused: [u8; 0],
}
pub const alarmtimer_type_ALARM_REALTIME: alarmtimer_type = 0;
pub const alarmtimer_type_ALARM_BOOTTIME: alarmtimer_type = 1;
pub const alarmtimer_type_ALARM_NUMTYPE: alarmtimer_type = 2;
pub const alarmtimer_type_ALARM_REALTIME_FREEZER: alarmtimer_type = 3;
pub const alarmtimer_type_ALARM_BOOTTIME_FREEZER: alarmtimer_type = 4;
pub type alarmtimer_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alarm {
    pub node: timerqueue_node,
    pub timer: hrtimer,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut alarm, now: ktime_t)>,
    pub type_: alarmtimer_type,
    pub state: ffi::c_int,
    pub data: *mut ffi::c_void,
}
impl Default for alarm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_timer {
    pub node: timerqueue_node,
    pub head: *mut timerqueue_head,
    pub pid: *mut pid,
    pub elist: list_head,
    pub firing: bool_,
    pub nanosleep: bool_,
    pub handling: *mut task_struct,
}
impl Default for cpu_timer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct k_itimer {
    pub t_hash: hlist_node,
    pub list: hlist_node,
    pub it_id: timer_t,
    pub it_clock: clockid_t,
    pub it_sigev_notify: ffi::c_int,
    pub it_pid_type: pid_type,
    pub it_signal: *mut signal_struct,
    pub kclock: *mut k_clock,
    pub it_lock: spinlock_t,
    pub it_status: ffi::c_int,
    pub it_sig_periodic: bool_,
    pub it_overrun: s64,
    pub it_overrun_last: s64,
    pub it_signal_seq: ffi::c_uint,
    pub it_sigqueue_seq: ffi::c_uint,
    pub it_interval: ktime_t,
    pub ignored_list: hlist_node,
    pub __bindgen_anon_1: k_itimer__bindgen_ty_1,
    pub sigq: sigqueue,
    pub rcuref: rcuref_t,
    pub it: k_itimer__bindgen_ty_2,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_1 {
    pub it_pid: *mut pid,
    pub it_process: *mut task_struct,
}
impl Default for k_itimer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_2 {
    pub real: k_itimer__bindgen_ty_2__bindgen_ty_1,
    pub cpu: cpu_timer,
    pub alarm: k_itimer__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_1 {
    pub timer: hrtimer,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_2 {
    pub alarmtimer: alarm,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for k_itimer__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for k_itimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
impl Default for sighand_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: ffi::c_int,
    pub ac_exitcode: ffi::c_long,
    pub ac_mem: ffi::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: ffi::c_ulong,
    pub ac_majflt: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiprocess_signals {
    pub signal: sigset_t,
    pub node: hlist_node,
}
impl Default for multiprocess_signals {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
impl Default for core_thread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
impl Default for core_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: ffi::c_int,
    pub quick_threads: ffi::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: ffi::c_int,
    pub notify_count: ffi::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: ffi::c_int,
    pub flags: ffi::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub next_posix_timer_id: atomic_t,
    pub posix_timers: hlist_head,
    pub ignored_posix_timers: hlist_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: ffi::c_int,
    pub tty: *mut tty_struct,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ffi::c_ulong,
    pub nivcsw: ffi::c_ulong,
    pub cnvcsw: ffi::c_ulong,
    pub cnivcsw: ffi::c_ulong,
    pub min_flt: ffi::c_ulong,
    pub maj_flt: ffi::c_ulong,
    pub cmin_flt: ffi::c_ulong,
    pub cmaj_flt: ffi::c_ulong,
    pub inblock: ffi::c_ulong,
    pub oublock: ffi::c_ulong,
    pub cinblock: ffi::c_ulong,
    pub coublock: ffi::c_ulong,
    pub maxrss: ffi::c_ulong,
    pub cmaxrss: ffi::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: ffi::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub audit_tty: ffi::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: ffi::c_short,
    pub oom_score_adj_min: ffi::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl Default for signal_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_child_subreaper_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_child_subreaper_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_child_subreaper_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_child_subreaper_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timer_create_restore_ids(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_create_restore_ids(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timer_create_restore_ids_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timer_create_restore_ids_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: ffi::c_uint,
        has_child_subreaper: ffi::c_uint,
        timer_create_restore_ids: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let timer_create_restore_ids: u32 =
                unsafe { ::core::mem::transmute(timer_create_restore_ids) };
            timer_create_restore_ids as u64
        });
        __bindgen_bitfield_unit
    }
}

pub type proc_visitor = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, data: *mut ffi::c_void) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: ffi::c_int,
    pub gp_count: ffi::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
impl Default for rcu_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut ffi::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type class_percpu_read_t = *mut percpu_rw_semaphore;
pub const class_percpu_read_is_conditional: bool_ = false;
pub const class_percpu_read_try_is_conditional: bool_ = true;
pub type class_percpu_read_try_t = class_percpu_read_t;
pub type class_percpu_write_t = *mut percpu_rw_semaphore;
pub const class_percpu_write_is_conditional: bool_ = false;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>,
    pub arg: *mut ffi::c_void,
}
impl Default for delayed_call {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct guid_t {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}

pub type errseq_t = u32_;

pub const ICQ_EXITED: _bindgen_ty_76 = 4;
pub const ICQ_DESTROYED: _bindgen_ty_76 = 8;
pub type _bindgen_ty_76 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for io_cq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: ffi::c_ushort,
    pub lock: spinlock_t,
    pub icq_tree: xarray,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
impl Default for io_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const IOPRIO_CLASS_NONE: _bindgen_ty_77 = 0;
pub const IOPRIO_CLASS_RT: _bindgen_ty_77 = 1;
pub const IOPRIO_CLASS_BE: _bindgen_ty_77 = 2;
pub const IOPRIO_CLASS_IDLE: _bindgen_ty_77 = 3;
pub const IOPRIO_CLASS_INVALID: _bindgen_ty_77 = 7;
pub type _bindgen_ty_77 = ffi::c_uint;
pub const IOPRIO_WHO_PROCESS: _bindgen_ty_78 = 1;
pub const IOPRIO_WHO_PGRP: _bindgen_ty_78 = 2;
pub const IOPRIO_WHO_USER: _bindgen_ty_78 = 3;
pub type _bindgen_ty_78 = ffi::c_uint;
pub const IOPRIO_HINT_NONE: _bindgen_ty_79 = 0;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_1: _bindgen_ty_79 = 1;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_2: _bindgen_ty_79 = 2;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_3: _bindgen_ty_79 = 3;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_4: _bindgen_ty_79 = 4;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_5: _bindgen_ty_79 = 5;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_6: _bindgen_ty_79 = 6;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_7: _bindgen_ty_79 = 7;
pub type _bindgen_ty_79 = ffi::c_uint;

pub const mount_flags_MNT_NOSUID: mount_flags = 1;
pub const mount_flags_MNT_NODEV: mount_flags = 2;
pub const mount_flags_MNT_NOEXEC: mount_flags = 4;
pub const mount_flags_MNT_NOATIME: mount_flags = 8;
pub const mount_flags_MNT_NODIRATIME: mount_flags = 16;
pub const mount_flags_MNT_RELATIME: mount_flags = 32;
pub const mount_flags_MNT_READONLY: mount_flags = 64;
pub const mount_flags_MNT_NOSYMFOLLOW: mount_flags = 128;
pub const mount_flags_MNT_SHRINKABLE: mount_flags = 256;
pub const mount_flags_MNT_WRITE_HOLD: mount_flags = 512;
pub const mount_flags_MNT_INTERNAL: mount_flags = 16384;
pub const mount_flags_MNT_LOCK_ATIME: mount_flags = 262144;
pub const mount_flags_MNT_LOCK_NOEXEC: mount_flags = 524288;
pub const mount_flags_MNT_LOCK_NOSUID: mount_flags = 1048576;
pub const mount_flags_MNT_LOCK_NODEV: mount_flags = 2097152;
pub const mount_flags_MNT_LOCK_READONLY: mount_flags = 4194304;
pub const mount_flags_MNT_LOCKED: mount_flags = 8388608;
pub const mount_flags_MNT_DOOMED: mount_flags = 16777216;
pub const mount_flags_MNT_SYNC_UMOUNT: mount_flags = 33554432;
pub const mount_flags_MNT_UMOUNT: mount_flags = 134217728;
pub const mount_flags_MNT_USER_SETTABLE_MASK: mount_flags = 255;
pub const mount_flags_MNT_ATIME_MASK: mount_flags = 56;
pub const mount_flags_MNT_INTERNAL_FLAGS: mount_flags = 58737152;
pub type mount_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: ffi::c_int,
    pub mnt_idmap: *mut mnt_idmap,
}
impl Default for vfsmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}

pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = ffi::c_uchar;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_ref_t {
    pub refcnt: atomic64_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct utf8data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct utf8data_table {
    _unused: [u8; 0],
}
pub const utf8_normalization_UTF8_NFDI: utf8_normalization = 0;
pub const utf8_normalization_UTF8_NFDICF: utf8_normalization = 1;
pub const utf8_normalization_UTF8_NMAX: utf8_normalization = 2;
pub type utf8_normalization = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct unicode_map {
    pub version: ffi::c_uint,
    pub ntab: [*const utf8data; 2usize],
    pub tables: *const utf8data_table,
}
impl Default for unicode_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const procfs_ino_PROCFS_ROOT_INO: procfs_ino = 1;
pub type procfs_ino = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsuuid2 {
    pub len: __u8,
    pub uuid: [__u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_sysfs_path {
    pub len: __u8,
    pub name: [__u8; 128usize],
}
impl Default for fs_sysfs_path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct logical_block_metadata_cap {
    pub lbmd_flags: __u32,
    pub lbmd_interval: __u16,
    pub lbmd_size: __u8,
    pub lbmd_opaque_size: __u8,
    pub lbmd_opaque_offset: __u8,
    pub lbmd_pi_size: __u8,
    pub lbmd_pi_offset: __u8,
    pub lbmd_guard_tag_type: __u8,
    pub lbmd_app_tag_size: __u8,
    pub lbmd_ref_tag_size: __u8,
    pub lbmd_storage_tag_size: __u8,
    pub pad: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: ffi::c_ulong,
    pub nr_free_files: ffi::c_ulong,
    pub max_files: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: ffi::c_long,
    pub nr_unused: ffi::c_long,
    pub dummy: [ffi::c_long; 5usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_attr {
    pub fa_xflags: __u64,
    pub fa_extsize: __u32,
    pub fa_nextents: __u32,
    pub fa_projid: __u32,
    pub fa_cowextsize: __u32,
}
pub type __kernel_rwf_t = ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_region {
    pub start: __u64,
    pub end: __u64,
    pub categories: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_scan_arg {
    pub size: __u64,
    pub flags: __u64,
    pub start: __u64,
    pub end: __u64,
    pub walk_end: __u64,
    pub vec: __u64,
    pub vec_len: __u64,
    pub max_pages: __u64,
    pub category_inverted: __u64,
    pub category_mask: __u64,
    pub category_anyof_mask: __u64,
    pub return_mask: __u64,
}
pub const procmap_query_flags_PROCMAP_QUERY_VMA_READABLE: procmap_query_flags = 1;
pub const procmap_query_flags_PROCMAP_QUERY_VMA_WRITABLE: procmap_query_flags = 2;
pub const procmap_query_flags_PROCMAP_QUERY_VMA_EXECUTABLE: procmap_query_flags = 4;
pub const procmap_query_flags_PROCMAP_QUERY_VMA_SHARED: procmap_query_flags = 8;
pub const procmap_query_flags_PROCMAP_QUERY_COVERING_OR_NEXT_VMA: procmap_query_flags = 16;
pub const procmap_query_flags_PROCMAP_QUERY_FILE_BACKED_VMA: procmap_query_flags = 32;
pub type procmap_query_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct procmap_query {
    pub size: __u64,
    pub query_flags: __u64,
    pub query_addr: __u64,
    pub vma_start: __u64,
    pub vma_end: __u64,
    pub vma_flags: __u64,
    pub vma_page_size: __u64,
    pub vma_offset: __u64,
    pub inode: __u64,
    pub dev_major: __u32,
    pub dev_minor: __u32,
    pub vma_name_size: __u32,
    pub build_id_size: __u32,
    pub vma_name_addr: __u64,
    pub build_id_addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_sb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter_spec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_kattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iomap_ops {
    _unused: [u8; 0],
}

pub type rwf_t = __kernel_rwf_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct buffer_head {
    _unused: [u8; 0],
}
pub type get_block_t = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        iblock: sector_t,
        bh_result: *mut buffer_head,
        create: ffi::c_int,
    ) -> ffi::c_int,
>;
pub type dio_iodone_t = ::core::option::Option<
    unsafe extern "C" fn(
        iocb: *mut kiocb,
        offset: loff_t,
        bytes: isize,
        private: *mut ffi::c_void,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: ffi::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
}
impl Default for iattr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
}
impl Default for iattr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iattr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_disk_quota {
    pub d_version: __s8,
    pub d_flags: __s8,
    pub d_fieldmask: __u16,
    pub d_id: __u32,
    pub d_blk_hardlimit: __u64,
    pub d_blk_softlimit: __u64,
    pub d_ino_hardlimit: __u64,
    pub d_ino_softlimit: __u64,
    pub d_bcount: __u64,
    pub d_icount: __u64,
    pub d_itimer: __s32,
    pub d_btimer: __s32,
    pub d_iwarns: __u16,
    pub d_bwarns: __u16,
    pub d_itimer_hi: __s8,
    pub d_btimer_hi: __s8,
    pub d_rtbtimer_hi: __s8,
    pub d_padding2: __s8,
    pub d_rtb_hardlimit: __u64,
    pub d_rtb_softlimit: __u64,
    pub d_rtbcount: __u64,
    pub d_rtbtimer: __s32,
    pub d_rtbwarns: __u16,
    pub d_padding3: __s16,
    pub d_padding4: [ffi::c_char; 8usize],
}
pub type fs_disk_quota_t = fs_disk_quota;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestat {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
}
pub type fs_qfilestat_t = fs_qfilestat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_stat {
    pub qs_version: __s8,
    pub qs_flags: __u16,
    pub qs_pad: __s8,
    pub qs_uquota: fs_qfilestat_t,
    pub qs_gquota: fs_qfilestat_t,
    pub qs_incoredqs: __u32,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
}
pub type fs_quota_stat_t = fs_quota_stat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestatv {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
    pub qfs_pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_statv {
    pub qs_version: __s8,
    pub qs_pad1: __u8,
    pub qs_flags: __u16,
    pub qs_incoredqs: __u32,
    pub qs_uquota: fs_qfilestatv,
    pub qs_gquota: fs_qfilestatv,
    pub qs_pquota: fs_qfilestatv,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
    pub qs_rtbwarnlimit: __u16,
    pub qs_pad3: __u16,
    pub qs_pad4: __u32,
    pub qs_pad2: [__u64; 7usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qtree_fmt_operations {
    pub mem2disk_dqblk:
        ::core::option::Option<unsafe extern "C" fn(disk: *mut ffi::c_void, dquot: *mut dquot)>,
    pub disk2mem_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot, disk: *mut ffi::c_void)>,
    pub is_id: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut ffi::c_void, dquot: *mut dquot) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qtree_mem_dqinfo {
    pub dqi_sb: *mut super_block,
    pub dqi_type: ffi::c_int,
    pub dqi_blocks: ffi::c_uint,
    pub dqi_free_blk: ffi::c_uint,
    pub dqi_free_entry: ffi::c_uint,
    pub dqi_blocksize_bits: ffi::c_uint,
    pub dqi_entry_size: ffi::c_uint,
    pub dqi_usable_bs: ffi::c_uint,
    pub dqi_qtree_depth: ffi::c_uint,
    pub dqi_ops: *const qtree_fmt_operations,
}
impl Default for qtree_mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}

pub const QIF_BLIMITS_B: _bindgen_ty_80 = 0;
pub const QIF_SPACE_B: _bindgen_ty_80 = 1;
pub const QIF_ILIMITS_B: _bindgen_ty_80 = 2;
pub const QIF_INODES_B: _bindgen_ty_80 = 3;
pub const QIF_BTIME_B: _bindgen_ty_80 = 4;
pub const QIF_ITIME_B: _bindgen_ty_80 = 5;
pub type _bindgen_ty_80 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_nextdqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
    pub dqb_id: __u32,
}
pub const DQF_ROOT_SQUASH_B: _bindgen_ty_81 = 0;
pub const DQF_SYS_FILE_B: _bindgen_ty_81 = 16;
pub const DQF_PRIVATE: _bindgen_ty_81 = 17;
pub type _bindgen_ty_81 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqinfo {
    pub dqi_bgrace: __u64,
    pub dqi_igrace: __u64,
    pub dqi_flags: __u32,
    pub dqi_valid: __u32,
}
pub const QUOTA_NL_C_UNSPEC: _bindgen_ty_82 = 0;
pub const QUOTA_NL_C_WARNING: _bindgen_ty_82 = 1;
pub const __QUOTA_NL_C_MAX: _bindgen_ty_82 = 2;
pub type _bindgen_ty_82 = ffi::c_uint;
pub const QUOTA_NL_A_UNSPEC: _bindgen_ty_83 = 0;
pub const QUOTA_NL_A_QTYPE: _bindgen_ty_83 = 1;
pub const QUOTA_NL_A_EXCESS_ID: _bindgen_ty_83 = 2;
pub const QUOTA_NL_A_WARNING: _bindgen_ty_83 = 3;
pub const QUOTA_NL_A_DEV_MAJOR: _bindgen_ty_83 = 4;
pub const QUOTA_NL_A_DEV_MINOR: _bindgen_ty_83 = 5;
pub const QUOTA_NL_A_CAUSED_ID: _bindgen_ty_83 = 6;
pub const QUOTA_NL_A_PAD: _bindgen_ty_83 = 7;
pub const __QUOTA_NL_A_MAX: _bindgen_ty_83 = 8;
pub type _bindgen_ty_83 = ffi::c_uint;
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = ffi::c_uint;
pub type qid_t = __kernel_uid32_t;
pub type qsize_t = ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kqid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: ffi::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: ffi::c_ulong,
    pub dqi_bgrace: ffi::c_uint,
    pub dqi_igrace: ffi::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut ffi::c_void,
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DQF_INFO_DIRTY_B: _bindgen_ty_84 = 17;
pub type _bindgen_ty_84 = ffi::c_uint;

pub const DQST_LOOKUPS: _bindgen_ty_85 = 0;
pub const DQST_DROPS: _bindgen_ty_85 = 1;
pub const DQST_READS: _bindgen_ty_85 = 2;
pub const DQST_WRITES: _bindgen_ty_85 = 3;
pub const DQST_CACHE_HITS: _bindgen_ty_85 = 4;
pub const DQST_ALLOC_DQUOTS: _bindgen_ty_85 = 5;
pub const DQST_FREE_DQUOTS: _bindgen_ty_85 = 6;
pub const DQST_SYNCS: _bindgen_ty_85 = 7;
pub const _DQST_DQSTAT_LAST: _bindgen_ty_85 = 8;
pub type _bindgen_ty_85 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dqstats {
    pub stat: [ffi::c_ulong; 8usize],
    pub counter: [percpu_counter; 8usize],
}
impl Default for dqstats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: ffi::c_ulong,
    pub dq_dqb: mem_dqblk,
}
impl Default for dquot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub read_dqblk: ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub commit_dqblk: ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub release_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub mark_dirty: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ffi::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ffi::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: ffi::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: ffi::c_int,
    pub d_spc_warns: ffi::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: ffi::c_uint,
    pub spc_timelimit: ffi::c_uint,
    pub ino_timelimit: ffi::c_uint,
    pub rt_spc_timelimit: ffi::c_uint,
    pub spc_warnlimit: ffi::c_uint,
    pub ino_warnlimit: ffi::c_uint,
    pub rt_spc_warnlimit: ffi::c_uint,
    pub ino: ffi::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: ffi::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: ffi::c_int,
    pub i_flags: ffi::c_uint,
    pub i_spc_timelimit: ffi::c_uint,
    pub i_ino_timelimit: ffi::c_uint,
    pub i_rt_spc_timelimit: ffi::c_uint,
    pub i_spc_warnlimit: ffi::c_uint,
    pub i_ino_warnlimit: ffi::c_uint,
    pub i_rt_spc_warnlimit: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: ffi::c_int,
            arg4: *const path,
        ) -> ffi::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: *mut qc_info,
        ) -> ffi::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: kqid, arg3: *mut qc_dqblk) -> ffi::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> ffi::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: kqid, arg3: *mut qc_dqblk) -> ffi::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ffi::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: ffi::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
impl Default for quota_format_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _DQUOT_USAGE_ENABLED: _bindgen_ty_86 = 0;
pub const _DQUOT_LIMITS_ENABLED: _bindgen_ty_86 = 1;
pub const _DQUOT_SUSPENDED: _bindgen_ty_86 = 2;
pub const _DQUOT_STATE_FLAGS: _bindgen_ty_86 = 3;
pub type _bindgen_ty_86 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: ffi::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
impl Default for quota_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_module_name {
    pub qm_fmt_id: ffi::c_int,
    pub qm_mod_name: *mut ffi::c_char,
}
impl Default for quota_module_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const positive_aop_returns_AOP_WRITEPAGE_ACTIVATE: positive_aop_returns = 524288;
pub const positive_aop_returns_AOP_TRUNCATED_PAGE: positive_aop_returns = 524289;
pub type positive_aop_returns = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: ffi::c_long)>,
    pub private: *mut ffi::c_void,
    pub ki_flags: ffi::c_int,
    pub ki_ioprio: u16_,
    pub ki_write_stream: u8_,
    pub __bindgen_anon_1: kiocb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kiocb__bindgen_ty_1 {
    pub ki_waitq: *mut wait_page_queue,
    pub dio_complete: ::core::option::Option<unsafe extern "C" fn(data: *mut ffi::c_void) -> isize>,
}
impl Default for kiocb__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kiocb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct address_space_operations {
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ffi::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut writeback_control) -> ffi::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kiocb,
            mapping: *mut address_space,
            pos: loff_t,
            len: ffi::c_uint,
            foliop: *mut *mut folio,
            fsdata: *mut *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kiocb,
            mapping: *mut address_space,
            pos: loff_t,
            len: ffi::c_uint,
            copied: ffi::c_uint,
            folio: *mut folio,
            fsdata: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: usize, len: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> ffi::c_int,
    >,
    pub launder_folio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> ffi::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: usize, count: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> ffi::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> ffi::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> ffi::c_int,
    >,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub nrpages: ffi::c_ulong,
    pub writeback_index: ffi::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: ffi::c_ulong,
    pub wb_err: errseq_t,
    pub i_private_lock: spinlock_t,
    pub i_private_list: list_head,
    pub i_mmap_rwsem: rw_semaphore,
    pub i_private_data: *mut ffi::c_void,
}
impl Default for address_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: ffi::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: ffi::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut ffi::c_void,
    pub i_ino: ffi::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime_sec: time64_t,
    pub i_mtime_sec: time64_t,
    pub i_ctime_sec: time64_t,
    pub i_atime_nsec: u32_,
    pub i_mtime_nsec: u32_,
    pub i_ctime_nsec: u32_,
    pub i_generation: u32_,
    pub i_lock: spinlock_t,
    pub i_bytes: ffi::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: rw_hint,
    pub i_blocks: blkcnt_t,
    pub i_state: u32_,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: ffi::c_ulong,
    pub dirtied_time_when: ffi::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: ffi::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub __bindgen_anon_5: inode__bindgen_ty_5,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_private: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: ffi::c_uint,
    pub __i_nlink: ffi::c_uint,
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_devices: list_head,
    pub i_linklen: ffi::c_int,
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_5 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut ffi::c_char,
    pub i_dir_seq: ffi::c_uint,
}
impl Default for inode__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for inode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const inode_i_mutex_lock_class_I_MUTEX_NORMAL: inode_i_mutex_lock_class = 0;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT: inode_i_mutex_lock_class = 1;
pub const inode_i_mutex_lock_class_I_MUTEX_CHILD: inode_i_mutex_lock_class = 2;
pub const inode_i_mutex_lock_class_I_MUTEX_XATTR: inode_i_mutex_lock_class = 3;
pub const inode_i_mutex_lock_class_I_MUTEX_NONDIR2: inode_i_mutex_lock_class = 4;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT2: inode_i_mutex_lock_class = 5;
pub type inode_i_mutex_lock_class = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub file: *mut file,
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: ffi::c_int,
}
impl Default for fown_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: ffi::c_ulong,
    pub size: ffi::c_uint,
    pub async_size: ffi::c_uint,
    pub ra_pages: ffi::c_uint,
    pub order: ffi::c_ushort,
    pub mmap_miss: ffi::c_ushort,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_lock: spinlock_t,
    pub f_mode: fmode_t,
    pub f_op: *const file_operations,
    pub f_mapping: *mut address_space,
    pub private_data: *mut ffi::c_void,
    pub f_inode: *mut inode,
    pub f_flags: ffi::c_uint,
    pub f_iocb_flags: ffi::c_uint,
    pub f_cred: *const cred,
    pub f_owner: *mut fown_struct,
    pub f_path: path,
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_pos: loff_t,
    pub f_security: *mut ffi::c_void,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
    pub f_ep: *mut hlist_head,
    pub __bindgen_anon_2: file__bindgen_ty_2,
    pub f_ref: file_ref_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_pos_lock: mutex,
    pub f_pipe: u64_,
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_2 {
    pub f_task_work: callback_head,
    pub f_llist: llist_node,
    pub f_ra: file_ra_state,
    pub f_freeptr: freeptr_t,
}
impl Default for file__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct file_handle {
    pub handle_bytes: __u32,
    pub handle_type: ffi::c_int,
    pub f_handle: __IncompleteArrayField<ffi::c_uchar>,
}

pub type fl_owner_t = *mut ffi::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lease {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: ffi::c_int,
    pub fa_fd: ffi::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
impl Default for fasync_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const SB_UNFROZEN: _bindgen_ty_87 = 0;
pub const SB_FREEZE_WRITE: _bindgen_ty_87 = 1;
pub const SB_FREEZE_PAGEFAULT: _bindgen_ty_87 = 2;
pub const SB_FREEZE_FS: _bindgen_ty_87 = 3;
pub const SB_FREEZE_COMPLETE: _bindgen_ty_87 = 4;
pub type _bindgen_ty_87 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: ffi::c_ushort,
    pub freeze_kcount: ffi::c_int,
    pub freeze_ucount: ffi::c_int,
    pub freeze_owner: *const ffi::c_void,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
impl Default for sb_writers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: ffi::c_uchar,
    pub s_blocksize: ffi::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: ffi::c_ulong,
    pub s_iflags: ffi::c_ulong,
    pub s_magic: ffi::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: ffi::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut ffi::c_void,
    pub s_xattr: *const *mut xattr_handler,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdev_file: *mut file,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: ffi::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut ffi::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: u32_,
    pub s_fsnotify_info: *mut fsnotify_sb_info,
    pub s_id: [ffi::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_uuid_len: u8_,
    pub s_sysfs_name: [ffi::c_char; 37usize],
    pub s_max_links: ffi::c_uint,
    pub s_d_flags: ffi::c_uint,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const ffi::c_char,
    pub __s_d_op: *const dentry_operations,
    pub s_shrink: *mut shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_readonly_remount: ffi::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: ffi::c_int,
    pub __bindgen_padding_0: [u32; 11usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
impl Default for super_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct renamedata {
    pub old_mnt_idmap: *mut mnt_idmap,
    pub old_parent: *mut dentry,
    pub old_dentry: *mut dentry,
    pub new_mnt_idmap: *mut mnt_idmap,
    pub new_parent: *mut dentry,
    pub new_dentry: *mut dentry,
    pub delegated_inode: *mut *mut inode,
    pub flags: ffi::c_uint,
}
impl Default for renamedata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const ffi::c_char,
        arg3: ffi::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: ffi::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
    pub count: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
pub type fop_flags_t = ffi::c_uint;

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: ffi::c_uint) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const ffi::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub get_inode_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ffi::c_int, arg3: bool_) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ffi::c_char,
            arg3: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> ffi::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode, arg3: *mut dentry) -> ffi::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const ffi::c_char,
        ) -> ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> *mut dentry,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> ffi::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> ffi::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut ffi::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> ffi::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: ffi::c_uint,
            create_mode: umode_t,
        ) -> ffi::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> ffi::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: ffi::c_int,
        ) -> *mut posix_acl,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut posix_acl,
            arg4: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            idmap: *mut mnt_idmap,
            dentry: *mut dentry,
            fa: *mut file_kattr,
        ) -> ffi::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut file_kattr) -> ffi::c_int,
    >,
    pub get_offset_ctx:
        ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> *mut offset_ctx>,
}
impl Default for inode_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const freeze_holder_FREEZE_HOLDER_KERNEL: freeze_holder = 1;
pub const freeze_holder_FREEZE_HOLDER_USERSPACE: freeze_holder = 2;
pub const freeze_holder_FREEZE_MAY_NEST: freeze_holder = 4;
pub const freeze_holder_FREEZE_EXCL: freeze_holder = 8;
pub type freeze_holder = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: ffi::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> ffi::c_int,
    >,
    pub drop_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ffi::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: ffi::c_int) -> ffi::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            who: freeze_holder,
            owner: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ffi::c_int>,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            who: freeze_holder,
            owner: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ffi::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ffi::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ffi::c_int,
            arg3: *mut ffi::c_char,
        ) -> ffi::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> ffi::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> ffi::c_long,
    >,
    pub remove_bdev: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, bdev: *mut block_device) -> ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block)>,
}

pub const file_time_flags_S_ATIME: file_time_flags = 1;
pub const file_time_flags_S_MTIME: file_time_flags = 2;
pub const file_time_flags_S_CTIME: file_time_flags = 4;
pub const file_time_flags_S_VERSION: file_time_flags = 8;
pub type file_time_flags = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_names {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct filename {
    pub name: *const ffi::c_char,
    pub uptr: *const ffi::c_char,
    pub refcnt: atomic_t,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<ffi::c_char>,
}
impl Default for filename {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type dio_submit_t = ::core::option::Option<
    unsafe extern "C" fn(bio: *mut bio, inode: *mut inode, file_offset: loff_t),
>;
pub const DIO_LOCKING: _bindgen_ty_88 = 1;
pub const DIO_SKIP_HOLES: _bindgen_ty_88 = 2;
pub type _bindgen_ty_88 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct tree_descr {
    pub name: *const ffi::c_char,
    pub ops: *const file_operations,
    pub mode: ffi::c_int,
}
impl Default for tree_descr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct offset_ctx {
    pub mt: maple_tree,
    pub next_offset: ffi::c_ulong,
}
impl Default for offset_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct simple_transaction_argresp {
    pub size: isize,
    pub data: __IncompleteArrayField<ffi::c_char>,
}

pub type aio_context_t = __kernel_ulong_t;
pub const IOCB_CMD_PREAD: _bindgen_ty_89 = 0;
pub const IOCB_CMD_PWRITE: _bindgen_ty_89 = 1;
pub const IOCB_CMD_FSYNC: _bindgen_ty_89 = 2;
pub const IOCB_CMD_FDSYNC: _bindgen_ty_89 = 3;
pub const IOCB_CMD_POLL: _bindgen_ty_89 = 5;
pub const IOCB_CMD_NOOP: _bindgen_ty_89 = 6;
pub const IOCB_CMD_PREADV: _bindgen_ty_89 = 7;
pub const IOCB_CMD_PWRITEV: _bindgen_ty_89 = 8;
pub type _bindgen_ty_89 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_event {
    pub data: __u64,
    pub obj: __u64,
    pub res: __s64,
    pub res2: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iocb {
    pub aio_data: __u64,
    pub aio_key: __u32,
    pub aio_rw_flags: __kernel_rwf_t,
    pub aio_lio_opcode: __u16,
    pub aio_reqprio: __s16,
    pub aio_fildes: __u32,
    pub aio_buf: __u64,
    pub aio_nbytes: __u64,
    pub aio_offset: __s64,
    pub aio_reserved2: __u64,
    pub aio_flags: __u32,
    pub aio_resfd: __u32,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_iovec {
    pub iov_base: compat_uptr_t,
    pub iov_len: compat_size_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaltstack {
    pub ss_sp: compat_uptr_t,
    pub ss_flags: ffi::c_int,
    pub ss_size: compat_size_t,
}
pub type compat_stack_t = compat_sigaltstack;
pub type compat_uid_t = __compat_uid32_t;
pub type compat_gid_t = __compat_gid32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sel_arg_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_itimerval32 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_tms {
    pub tms_utime: compat_clock_t,
    pub tms_stime: compat_clock_t,
    pub tms_cutime: compat_clock_t,
    pub tms_cstime: compat_clock_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigset_t {
    pub sig: [compat_sigset_word; 2usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaction {
    pub sa_handler: compat_uptr_t,
    pub sa_flags: compat_ulong_t,
    pub sa_mask: compat_sigset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigval {
    pub sival_int: compat_int_t,
    pub sival_ptr: compat_uptr_t,
}
impl Default for compat_sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_sigval_t = compat_sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo {
    pub si_signo: ffi::c_int,
    pub si_errno: ffi::c_int,
    pub si_code: ffi::c_int,
    pub _sifields: compat_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1 {
    pub _pad: [ffi::c_int; 29usize],
    pub _kill: compat_siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: compat_siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _rt: compat_siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: compat_siginfo__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: compat_siginfo__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: compat_siginfo__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: compat_siginfo__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _tid: compat_timer_t,
    pub _overrun: ffi::c_int,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _status: ffi::c_int,
    pub _utime: compat_clock_t,
    pub _stime: compat_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _addr: compat_uptr_t,
    pub __bindgen_anon_1: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ffi::c_int,
    pub _addr_lsb: ffi::c_short,
    pub _addr_bnd: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [ffi::c_char; 4usize],
    pub _lower: compat_uptr_t,
    pub _upper: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [ffi::c_char; 4usize],
    pub _pkey: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: compat_ulong_t,
    pub _type: u32_,
    pub _flags: u32_,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub _band: compat_long_t,
    pub _fd: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: compat_uptr_t,
    pub _syscall: ffi::c_int,
    pub _arch: ffi::c_uint,
}
impl Default for compat_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_siginfo_t = compat_siginfo;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rlimit {
    pub rlim_cur: compat_ulong_t,
    pub rlim_max: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock {
    pub l_type: ffi::c_short,
    pub l_whence: ffi::c_short,
    pub l_start: compat_off_t,
    pub l_len: compat_off_t,
    pub l_pid: compat_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock64 {
    pub l_type: ffi::c_short,
    pub l_whence: ffi::c_short,
    pub l_start: compat_loff_t,
    pub l_len: compat_loff_t,
    pub l_pid: compat_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rusage {
    pub ru_utime: old_timeval32,
    pub ru_stime: old_timeval32,
    pub ru_maxrss: compat_long_t,
    pub ru_ixrss: compat_long_t,
    pub ru_idrss: compat_long_t,
    pub ru_isrss: compat_long_t,
    pub ru_minflt: compat_long_t,
    pub ru_majflt: compat_long_t,
    pub ru_nswap: compat_long_t,
    pub ru_inblock: compat_long_t,
    pub ru_oublock: compat_long_t,
    pub ru_msgsnd: compat_long_t,
    pub ru_msgrcv: compat_long_t,
    pub ru_nsignals: compat_long_t,
    pub ru_nvcsw: compat_long_t,
    pub ru_nivcsw: compat_long_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __compat_aio_sigset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_dirent {
    pub d_ino: u32_,
    pub d_off: compat_off_t,
    pub d_reclen: u16_,
    pub d_name: [ffi::c_char; 256usize],
}
impl Default for compat_dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ustat {
    pub f_tfree: compat_daddr_t,
    pub f_tinode: compat_ino_t,
    pub f_fname: [ffi::c_char; 6usize],
    pub f_fpack: [ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sigevent {
    pub sigev_value: compat_sigval_t,
    pub sigev_signo: compat_int_t,
    pub sigev_notify: compat_int_t,
    pub _sigev_un: compat_sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigevent__bindgen_ty_1 {
    pub _pad: [compat_int_t; 13usize],
    pub _tid: compat_int_t,
    pub _sigev_thread: compat_sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: compat_uptr_t,
    pub _attribute: compat_uptr_t,
}
impl Default for compat_sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_sigevent_t = compat_sigevent;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifmap {
    pub mem_start: compat_ulong_t,
    pub mem_end: compat_ulong_t,
    pub base_addr: ffi::c_ushort,
    pub irq: ffi::c_uchar,
    pub dma: ffi::c_uchar,
    pub port: ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_if_settings {
    pub type_: ffi::c_uint,
    pub size: ffi::c_uint,
    pub ifs_ifsu: compat_uptr_t,
}
#[repr(C)]
pub struct compat_ifreq {
    pub ifr_ifrn: compat_ifreq__bindgen_ty_1,
    pub ifr_ifru: compat_ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_ifreq__bindgen_ty_1 {
    pub ifrn_name: [ffi::c_char; 16usize],
}
impl Default for compat_ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct compat_ifreq__bindgen_ty_2 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_netmask: __BindgenUnionField<sockaddr>,
    pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
    pub ifru_flags: __BindgenUnionField<ffi::c_short>,
    pub ifru_ivalue: __BindgenUnionField<compat_int_t>,
    pub ifru_mtu: __BindgenUnionField<compat_int_t>,
    pub ifru_map: __BindgenUnionField<compat_ifmap>,
    pub ifru_slave: __BindgenUnionField<[ffi::c_char; 16usize]>,
    pub ifru_newname: __BindgenUnionField<[ffi::c_char; 16usize]>,
    pub ifru_data: __BindgenUnionField<compat_caddr_t>,
    pub ifru_settings: __BindgenUnionField<compat_if_settings>,
    pub bindgen_union_field: [u32; 4usize],
}
impl Default for compat_ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_ifreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifconf {
    pub ifc_len: compat_int_t,
    pub ifcbuf: compat_caddr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_keyctl_kdf_params {
    pub hashname: compat_uptr_t,
    pub otherinfo: compat_uptr_t,
    pub otherinfolen: __u32,
    pub __spare: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_stat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_statfs64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_old_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_dirent64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysctl_args {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_kexec_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_mq_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_msgbuf {
    _unused: [u8; 0],
}

pub type elf_greg_t = ffi::c_ulong;
pub type elf_gregset_t = user_regs_struct;
pub type elf_fpreg_t = __u64;
pub type elf_fpregset_t = __riscv_fp_state;

pub const class_cpus_read_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_cpus_read_lock_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_cpus_read_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const cache_type_CACHE_TYPE_NOCACHE: cache_type = 0;
pub const cache_type_CACHE_TYPE_INST: cache_type = 1;
pub const cache_type_CACHE_TYPE_DATA: cache_type = 2;
pub const cache_type_CACHE_TYPE_SEPARATE: cache_type = 3;
pub const cache_type_CACHE_TYPE_UNIFIED: cache_type = 4;
pub type cache_type = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cacheinfo {
    pub id: ffi::c_uint,
    pub type_: cache_type,
    pub level: ffi::c_uint,
    pub coherency_line_size: ffi::c_uint,
    pub number_of_sets: ffi::c_uint,
    pub ways_of_associativity: ffi::c_uint,
    pub physical_line_partition: ffi::c_uint,
    pub size: ffi::c_uint,
    pub shared_cpu_map: cpumask_t,
    pub attributes: ffi::c_uint,
    pub fw_token: *mut ffi::c_void,
    pub disable_sysfs: bool_,
    pub priv_: *mut ffi::c_void,
}
impl Default for cacheinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_cacheinfo {
    pub info_list: *mut cacheinfo,
    pub per_cpu_data_slice_size: ffi::c_uint,
    pub num_levels: ffi::c_uint,
    pub num_leaves: ffi::c_uint,
    pub cpu_map_populated: bool_,
    pub early_ci_levels: bool_,
}
impl Default for cpu_cacheinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_cacheinfo_ops {
    pub get_priv_group: ::core::option::Option<
        unsafe extern "C" fn(this_leaf: *mut cacheinfo) -> *const attribute_group,
    >,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_binprm {
    _unused: [u8; 0],
}

pub type compat_elf_greg_t = compat_ulong_t;
pub type compat_elf_gregset_t = [compat_elf_greg_t; 32usize];

#[repr(C)]
#[derive(Copy, Clone)]
pub struct coredump_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnu_property {
    pub pr_type: u32_,
    pub pr_datasz: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_elf_state {
    _unused: [u8; 0],
}
pub const KERNEL_PARAM_OPS_FL_NOARG: _bindgen_ty_90 = 1;
pub type _bindgen_ty_90 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: ffi::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(val: *const ffi::c_char, kp: *const kernel_param) -> ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(buffer: *mut ffi::c_char, kp: *const kernel_param) -> ffi::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut ffi::c_void)>,
}
pub const KERNEL_PARAM_FL_UNSAFE: _bindgen_ty_91 = 1;
pub const KERNEL_PARAM_FL_HWPARAM: _bindgen_ty_91 = 2;
pub type _bindgen_ty_91 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const ffi::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut ffi::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_string {
    pub maxlen: ffi::c_uint,
    pub string: *mut ffi::c_char,
}
impl Default for kparam_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_array {
    pub max: ffi::c_uint,
    pub elemsize: ffi::c_uint,
    pub num: *mut ffi::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut ffi::c_void,
}
impl Default for kparam_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type parse_unknown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        param: *mut ffi::c_char,
        val: *mut ffi::c_char,
        doing: *const ffi::c_char,
        arg: *mut ffi::c_void,
    ) -> ffi::c_int,
>;

pub const hwparam_type_hwparam_ioport: hwparam_type = 0;
pub const hwparam_type_hwparam_iomem: hwparam_type = 1;
pub const hwparam_type_hwparam_ioport_or_iomem: hwparam_type = 2;
pub const hwparam_type_hwparam_irq: hwparam_type = 3;
pub const hwparam_type_hwparam_dma: hwparam_type = 4;
pub const hwparam_type_hwparam_dma_addr: hwparam_type = 5;
pub const hwparam_type_hwparam_other: hwparam_type = 6;
pub type hwparam_type = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
impl Default for latch_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_root {
    pub seq: seqcount_latch_t,
    pub tree: [rb_root; 2usize],
}
impl Default for latch_tree_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct latch_tree_ops {
    pub less: ::core::option::Option<
        unsafe extern "C" fn(a: *mut latch_tree_node, b: *mut latch_tree_node) -> bool_,
    >,
    pub comp: ::core::option::Option<
        unsafe extern "C" fn(key: *mut ffi::c_void, b: *mut latch_tree_node) -> ffi::c_int,
    >,
}
pub const EI_ETYPE_NULL: _bindgen_ty_92 = 0;
pub const EI_ETYPE_ERRNO: _bindgen_ty_92 = 1;
pub const EI_ETYPE_ERRNO_NULL: _bindgen_ty_92 = 2;
pub const EI_ETYPE_TRUE: _bindgen_ty_92 = 3;
pub type _bindgen_ty_92 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: ffi::c_ulong,
    pub etype: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const ffi::c_char,
    pub function: *const ffi::c_char,
    pub filename: *const ffi::c_char,
    pub format: *const ffi::c_char,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub key: _ddebug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ddebug__bindgen_ty_1 {
    pub dd_key_true: static_key_true,
    pub dd_key_false: static_key_false,
}
impl Default for _ddebug__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ddebug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lineno_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lineno_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn class_id(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_class_id(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn class_id_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_class_id_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flags(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flags_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flags_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: ffi::c_uint,
        class_id: ffi::c_uint,
        flags: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::core::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let class_id: u32 = unsafe { ::core::mem::transmute(class_id) };
            class_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_BITS: class_map_type = 0;
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NUM: class_map_type = 1;
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_NAMES: class_map_type = 2;
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NAMES: class_map_type = 3;
pub type class_map_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_map {
    pub link: list_head,
    pub mod_: *mut module,
    pub mod_name: *const ffi::c_char,
    pub class_names: *mut *const ffi::c_char,
    pub length: ffi::c_int,
    pub base: ffi::c_int,
    pub map_type: class_map_type,
}
impl Default for ddebug_class_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug_info {
    pub descs: *mut _ddebug,
    pub classes: *mut ddebug_class_map,
    pub num_descs: ffi::c_uint,
    pub num_classes: ffi::c_uint,
}
impl Default for _ddebug_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_param {
    pub __bindgen_anon_1: ddebug_class_param__bindgen_ty_1,
    pub flags: [ffi::c_char; 8usize],
    pub map: *const ddebug_class_map,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddebug_class_param__bindgen_ty_1 {
    pub bits: *mut ffi::c_ulong,
    pub lvl: *mut ffi::c_uint,
}
impl Default for ddebug_class_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ddebug_class_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mod_arch_specific {}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct modversion_info {
    pub crc: ffi::c_ulong,
    pub name: [ffi::c_char; 56usize],
}
impl Default for modversion_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
impl Default for module_kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const module_attribute,
            arg2: *mut module_kobject,
            arg3: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut module, arg2: *const ffi::c_char)>,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ffi::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
impl Default for module_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_version_attribute {
    pub mattr: module_attribute,
    pub module_name: *const ffi::c_char,
    pub version: *const ffi::c_char,
}
impl Default for module_version_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
impl Default for mod_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mod_mem_type_MOD_TEXT: mod_mem_type = 0;
pub const mod_mem_type_MOD_DATA: mod_mem_type = 1;
pub const mod_mem_type_MOD_RODATA: mod_mem_type = 2;
pub const mod_mem_type_MOD_RO_AFTER_INIT: mod_mem_type = 3;
pub const mod_mem_type_MOD_INIT_TEXT: mod_mem_type = 4;
pub const mod_mem_type_MOD_INIT_DATA: mod_mem_type = 5;
pub const mod_mem_type_MOD_INIT_RODATA: mod_mem_type = 6;
pub const mod_mem_type_MOD_MEM_NUM_TYPES: mod_mem_type = 7;
pub const mod_mem_type_MOD_INVALID: mod_mem_type = -1;
pub type mod_mem_type = ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_memory {
    pub base: *mut ffi::c_void,
    pub is_rox: bool_,
    pub size: ffi::c_uint,
    pub mtn: mod_tree_node,
}
impl Default for module_memory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: ffi::c_uint,
    pub strtab: *mut ffi::c_char,
    pub typetab: *mut ffi::c_char,
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
pub type probe_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_driver {
    pub name: *const ffi::c_char,
    pub bus: *const bus_type,
    pub owner: *mut module,
    pub mod_name: *const ffi::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
impl Default for device_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut device_driver, buf: *mut ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut device_driver,
            buf: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for driver_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pdev_archdata {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pin_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_interface {
    pub name: *const ffi::c_char,
    pub subsys: *const bus_type,
    pub node: list_head,
    pub add_dev: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface) -> ffi::c_int,
    >,
    pub remove_dev:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface)>,
}
impl Default for subsys_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_type {
    pub name: *const ffi::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut ffi::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
impl Default for device_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for device_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_ext_attribute {
    pub attr: device_attribute,
    pub var: *mut ffi::c_void,
}
impl Default for dev_ext_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: ffi::c_uint,
    pub min_align_mask: ffi::c_uint,
    pub segment_boundary_mask: ffi::c_ulong,
}
pub const device_link_state_DL_STATE_NONE: device_link_state = -1;
pub const device_link_state_DL_STATE_DORMANT: device_link_state = 0;
pub const device_link_state_DL_STATE_AVAILABLE: device_link_state = 1;
pub const device_link_state_DL_STATE_CONSUMER_PROBE: device_link_state = 2;
pub const device_link_state_DL_STATE_ACTIVE: device_link_state = 3;
pub const device_link_state_DL_STATE_SUPPLIER_UNBIND: device_link_state = 4;
pub type device_link_state = ffi::c_int;
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
pub type dl_dev_state = ffi::c_uint;
pub const device_removable_DEVICE_REMOVABLE_NOT_SUPPORTED: device_removable = 0;
pub const device_removable_DEVICE_REMOVABLE_UNKNOWN: device_removable = 1;
pub const device_removable_DEVICE_FIXED: device_removable = 2;
pub const device_removable_DEVICE_REMOVABLE: device_removable = 3;
pub type device_removable = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state,
}
impl Default for dev_links_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
impl Default for dev_msi_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const device_physical_location_panel_DEVICE_PANEL_TOP: device_physical_location_panel = 0;
pub const device_physical_location_panel_DEVICE_PANEL_BOTTOM: device_physical_location_panel = 1;
pub const device_physical_location_panel_DEVICE_PANEL_LEFT: device_physical_location_panel = 2;
pub const device_physical_location_panel_DEVICE_PANEL_RIGHT: device_physical_location_panel = 3;
pub const device_physical_location_panel_DEVICE_PANEL_FRONT: device_physical_location_panel = 4;
pub const device_physical_location_panel_DEVICE_PANEL_BACK: device_physical_location_panel = 5;
pub const device_physical_location_panel_DEVICE_PANEL_UNKNOWN: device_physical_location_panel = 6;
pub type device_physical_location_panel = ffi::c_uint;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_UPPER:
    device_physical_location_vertical_position = 0;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_CENTER:
    device_physical_location_vertical_position = 1;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_LOWER:
    device_physical_location_vertical_position = 2;
pub type device_physical_location_vertical_position = ffi::c_uint;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_LEFT:
    device_physical_location_horizontal_position = 0;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_CENTER:
    device_physical_location_horizontal_position = 1;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_RIGHT:
    device_physical_location_horizontal_position = 2;
pub type device_physical_location_horizontal_position = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel,
    pub vertical_position: device_physical_location_vertical_position,
    pub horizontal_position: device_physical_location_horizontal_position,
    pub dock: bool_,
    pub lid: bool_,
}
impl Default for device_physical_location {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const ffi::c_char,
    pub type_: *const device_type,
    pub bus: *const bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut ffi::c_void,
    pub driver_data: *mut ffi::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub pins: *mut dev_pin_info,
    pub msi: dev_msi_info,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *mut bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub dma_mem: *mut dma_coherent_mem,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *const class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offline_disabled_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_offline_disabled_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offline_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_offline_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn of_node_reused_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_of_node_reused_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_synced_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_state_synced_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn can_match_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_can_match_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dma_coherent(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dma_coherent(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dma_coherent_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dma_coherent_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dma_skip_sync(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dma_skip_sync(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dma_skip_sync_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dma_skip_sync_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
        dma_coherent: bool_,
        dma_skip_sync: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dma_coherent: u8 = unsafe { ::core::mem::transmute(dma_coherent) };
            dma_coherent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dma_skip_sync: u8 = unsafe { ::core::mem::transmute(dma_skip_sync) };
            dma_skip_sync as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_link {
    pub supplier: *mut device,
    pub s_node: list_head,
    pub consumer: *mut device,
    pub c_node: list_head,
    pub link_dev: device,
    pub status: device_link_state,
    pub flags: u32_,
    pub rpm_active: refcount_t,
    pub kref: kref,
    pub rm_work: work_struct,
    pub supplier_preactivated: bool_,
}
impl Default for device_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const ffi::c_char,
    pub id: ffi::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: ffi::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: ffi::c_ulong,
    pub active_count: ffi::c_ulong,
    pub relax_count: ffi::c_ulong,
    pub expire_count: ffi::c_ulong,
    pub wakeup_count: ffi::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for wakeup_source {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_active_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn autosleep_enabled_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_autosleep_enabled_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}

pub type class_device_t = *mut device;
pub const class_device_is_conditional: bool_ = false;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_le {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_client {
    pub max_msg_length: __u32,
    pub protocol_version: __u8,
    pub reserved: [__u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mei_connect_client_data {
    pub __bindgen_anon_1: mei_connect_client_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mei_connect_client_data__bindgen_ty_1 {
    pub in_client_uuid: uuid_le,
    pub out_client_properties: mei_client,
}
impl Default for mei_connect_client_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mei_connect_client_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_connect_client_vtag {
    pub in_client_uuid: uuid_le,
    pub vtag: __u8,
    pub reserved: [__u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mei_connect_client_data_vtag {
    pub __bindgen_anon_1: mei_connect_client_data_vtag__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mei_connect_client_data_vtag__bindgen_ty_1 {
    pub connect: mei_connect_client_vtag,
    pub out_client_properties: mei_client,
}
impl Default for mei_connect_client_data_vtag__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mei_connect_client_data_vtag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kernel_ulong_t = ffi::c_ulong;
pub const PCI_ID_F_VFIO_DRIVER_OVERRIDE: _bindgen_ty_93 = 1;
pub type _bindgen_ty_93 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_device_id {
    pub vendor: __u32,
    pub device: __u32,
    pub subvendor: __u32,
    pub subdevice: __u32,
    pub class: __u32,
    pub class_mask: __u32,
    pub driver_data: kernel_ulong_t,
    pub override_only: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ieee1394_device_id {
    pub match_flags: __u32,
    pub vendor_id: __u32,
    pub model_id: __u32,
    pub specifier_id: __u32,
    pub version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct usb_device_id {
    pub match_flags: __u16,
    pub idVendor: __u16,
    pub idProduct: __u16,
    pub bcdDevice_lo: __u16,
    pub bcdDevice_hi: __u16,
    pub bDeviceClass: __u8,
    pub bDeviceSubClass: __u8,
    pub bDeviceProtocol: __u8,
    pub bInterfaceClass: __u8,
    pub bInterfaceSubClass: __u8,
    pub bInterfaceProtocol: __u8,
    pub bInterfaceNumber: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hid_device_id {
    pub bus: __u16,
    pub group: __u16,
    pub vendor: __u32,
    pub product: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ccw_device_id {
    pub match_flags: __u16,
    pub cu_type: __u16,
    pub dev_type: __u16,
    pub cu_model: __u8,
    pub dev_model: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ap_device_id {
    pub match_flags: __u16,
    pub dev_type: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct css_device_id {
    pub match_flags: __u8,
    pub type_: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 16usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
    pub devs: [pnp_card_device_id__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id__bindgen_ty_1 {
    pub id: [__u8; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct serio_device_id {
    pub type_: __u8,
    pub extra: __u8,
    pub id: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hda_device_id {
    pub vendor_id: __u32,
    pub rev_id: __u32,
    pub api_version: __u8,
    pub name: *const ffi::c_char,
    pub driver_data: ffi::c_ulong,
}
impl Default for hda_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdw_device_id {
    pub mfg_id: __u16,
    pub part_id: __u16,
    pub sdw_version: __u8,
    pub class_id: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_device_id {
    pub name: [ffi::c_char; 32usize],
    pub type_: [ffi::c_char; 32usize],
    pub compatible: [ffi::c_char; 128usize],
    pub data: *const ffi::c_void,
}
impl Default for of_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vio_device_id {
    pub type_: [ffi::c_char; 32usize],
    pub compat: [ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcmcia_device_id {
    pub match_flags: __u16,
    pub manf_id: __u16,
    pub card_id: __u16,
    pub func_id: __u8,
    pub function: __u8,
    pub device_no: __u8,
    pub prod_id_hash: [__u32; 4usize],
    pub prod_id: [*const ffi::c_char; 4usize],
    pub driver_info: kernel_ulong_t,
    pub cisfile: *mut ffi::c_char,
}
impl Default for pcmcia_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct input_device_id {
    pub flags: kernel_ulong_t,
    pub bustype: __u16,
    pub vendor: __u16,
    pub product: __u16,
    pub version: __u16,
    pub evbit: [kernel_ulong_t; 1usize],
    pub keybit: [kernel_ulong_t; 12usize],
    pub relbit: [kernel_ulong_t; 1usize],
    pub absbit: [kernel_ulong_t; 1usize],
    pub mscbit: [kernel_ulong_t; 1usize],
    pub ledbit: [kernel_ulong_t; 1usize],
    pub sndbit: [kernel_ulong_t; 1usize],
    pub ffbit: [kernel_ulong_t; 2usize],
    pub swbit: [kernel_ulong_t; 1usize],
    pub propbit: [kernel_ulong_t; 1usize],
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct eisa_device_id {
    pub sig: [ffi::c_char; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct parisc_device_id {
    pub hw_type: __u8,
    pub hversion_rev: __u8,
    pub hversion: __u16,
    pub sversion: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdio_device_id {
    pub class: __u8,
    pub vendor: __u16,
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct ssb_device_id {
    pub vendor: __u16,
    pub coreid: __u16,
    pub revision: __u8,
    pub __pad: __u8,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct bcma_device_id {
    pub manuf: __u16,
    pub id: __u16,
    pub rev: __u8,
    pub class: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct virtio_device_id {
    pub device: __u32,
    pub vendor: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hv_vmbus_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rpmsg_device_id {
    pub name: [ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct i2c_device_id {
    pub name: [ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_epf_device_id {
    pub name: [ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i3c_device_id {
    pub match_flags: __u8,
    pub dcr: __u8,
    pub manuf_id: __u16,
    pub part_id: __u16,
    pub extra_info: __u16,
    pub data: *const ffi::c_void,
}
impl Default for i3c_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spi_device_id {
    pub name: [ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct slim_device_id {
    pub manf_id: __u16,
    pub prod_code: __u16,
    pub dev_index: __u16,
    pub instance: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct apr_device_id {
    pub name: [ffi::c_char; 32usize],
    pub domain_id: __u32,
    pub svc_id: __u32,
    pub svc_version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spmi_device_id {
    pub name: [ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
pub const dmi_field_DMI_NONE: dmi_field = 0;
pub const dmi_field_DMI_BIOS_VENDOR: dmi_field = 1;
pub const dmi_field_DMI_BIOS_VERSION: dmi_field = 2;
pub const dmi_field_DMI_BIOS_DATE: dmi_field = 3;
pub const dmi_field_DMI_BIOS_RELEASE: dmi_field = 4;
pub const dmi_field_DMI_EC_FIRMWARE_RELEASE: dmi_field = 5;
pub const dmi_field_DMI_SYS_VENDOR: dmi_field = 6;
pub const dmi_field_DMI_PRODUCT_NAME: dmi_field = 7;
pub const dmi_field_DMI_PRODUCT_VERSION: dmi_field = 8;
pub const dmi_field_DMI_PRODUCT_SERIAL: dmi_field = 9;
pub const dmi_field_DMI_PRODUCT_UUID: dmi_field = 10;
pub const dmi_field_DMI_PRODUCT_SKU: dmi_field = 11;
pub const dmi_field_DMI_PRODUCT_FAMILY: dmi_field = 12;
pub const dmi_field_DMI_BOARD_VENDOR: dmi_field = 13;
pub const dmi_field_DMI_BOARD_NAME: dmi_field = 14;
pub const dmi_field_DMI_BOARD_VERSION: dmi_field = 15;
pub const dmi_field_DMI_BOARD_SERIAL: dmi_field = 16;
pub const dmi_field_DMI_BOARD_ASSET_TAG: dmi_field = 17;
pub const dmi_field_DMI_CHASSIS_VENDOR: dmi_field = 18;
pub const dmi_field_DMI_CHASSIS_TYPE: dmi_field = 19;
pub const dmi_field_DMI_CHASSIS_VERSION: dmi_field = 20;
pub const dmi_field_DMI_CHASSIS_SERIAL: dmi_field = 21;
pub const dmi_field_DMI_CHASSIS_ASSET_TAG: dmi_field = 22;
pub const dmi_field_DMI_STRING_MAX: dmi_field = 23;
pub const dmi_field_DMI_OEM_STRING: dmi_field = 24;
pub type dmi_field = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_strmatch {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub substr: [ffi::c_char; 79usize],
}
impl Default for dmi_strmatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dmi_strmatch {
    #[inline]
    pub fn slot(&self) -> ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slot(&mut self, val: ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot_raw(this: *const Self) -> ffi::c_uchar {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot_raw(this: *mut Self, val: ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn exact_match(&self) -> ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exact_match_raw(this: *const Self) -> ffi::c_uchar {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_exact_match_raw(this: *mut Self, val: ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot: ffi::c_uchar,
        exact_match: ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let slot: u8 = unsafe { ::core::mem::transmute(slot) };
            slot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exact_match: u8 = unsafe { ::core::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_system_id {
    pub callback:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dmi_system_id) -> ffi::c_int>,
    pub ident: *const ffi::c_char,
    pub matches: [dmi_strmatch; 4usize],
    pub driver_data: *mut ffi::c_void,
}
impl Default for dmi_system_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_device_id {
    pub name: [ffi::c_char; 24usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mdio_device_id {
    pub phy_id: __u32,
    pub phy_id_mask: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct zorro_device_id {
    pub id: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct isapnp_device_id {
    pub card_vendor: ffi::c_ushort,
    pub card_device: ffi::c_ushort,
    pub vendor: ffi::c_ushort,
    pub function: ffi::c_ushort,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_id {
    pub id: ffi::c_uint,
    pub mask: ffi::c_uint,
    pub data: *mut ffi::c_void,
}
impl Default for amba_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mips_cdmm_device_id {
    pub type_: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_cpu_id {
    pub vendor: __u16,
    pub family: __u16,
    pub model: __u16,
    pub steppings: __u16,
    pub feature: __u16,
    pub flags: __u16,
    pub type_: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_feature {
    pub feature: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipack_device_id {
    pub format: __u8,
    pub vendor: __u32,
    pub device: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_cl_device_id {
    pub name: [ffi::c_char; 32usize],
    pub uuid: uuid_le,
    pub version: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rio_device_id {
    pub did: __u16,
    pub vid: __u16,
    pub asm_did: __u16,
    pub asm_vid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mcb_device_id {
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ulpi_device_id {
    pub vendor: __u16,
    pub product: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsl_mc_device_id {
    pub vendor: __u16,
    pub obj_type: [ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tb_service_id {
    pub match_flags: __u32,
    pub protocol_key: [ffi::c_char; 9usize],
    pub protocol_id: __u32,
    pub protocol_version: __u32,
    pub protocol_revision: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct typec_device_id {
    pub svid: __u16,
    pub mode: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tee_client_device_id {
    pub uuid: uuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wmi_device_id {
    pub guid_string: [ffi::c_char; 37usize],
    pub context: *const ffi::c_void,
}
impl Default for wmi_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mhi_device_id {
    pub chan: [ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct auxiliary_device_id {
    pub name: [ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ssam_device_id {
    pub match_flags: __u8,
    pub domain: __u8,
    pub category: __u8,
    pub target: __u8,
    pub instance: __u8,
    pub function: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dfl_device_id {
    pub type_: __u16,
    pub feature_id: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ishtp_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
pub const CDX_ID_F_VFIO_DRIVER_OVERRIDE: _bindgen_ty_94 = 1;
pub type _bindgen_ty_94 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdx_device_id {
    pub vendor: __u16,
    pub device: __u16,
    pub subvendor: __u16,
    pub subdevice: __u16,
    pub class: __u32,
    pub class_mask: __u32,
    pub override_only: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vchiq_device_id {
    pub name: [ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct coreboot_device_id {
    pub tag: __u32,
    pub driver_data: kernel_ulong_t,
}
pub const dev_dma_attr_DEV_DMA_NOT_SUPPORTED: dev_dma_attr = 0;
pub const dev_dma_attr_DEV_DMA_NON_COHERENT: dev_dma_attr = 1;
pub const dev_dma_attr_DEV_DMA_COHERENT: dev_dma_attr = 2;
pub type dev_dma_attr = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
impl Default for fwnode_handle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_link {
    pub supplier: *mut fwnode_handle,
    pub s_hook: list_head,
    pub consumer: *mut fwnode_handle,
    pub c_hook: list_head,
    pub flags: u8_,
}
impl Default for fwnode_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: ffi::c_uint,
    pub id: ffi::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
impl Default for fwnode_endpoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: ffi::c_uint,
    pub args: [u64_; 16usize],
}
impl Default for fwnode_reference_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            dev: *const device,
        ) -> *const ffi::c_void,
    >,
    pub device_dma_supported:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_dma_attr:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> dev_dma_attr>,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle, propname: *const ffi::c_char) -> bool_,
    >,
    pub property_read_bool: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle, propname: *const ffi::c_char) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const ffi::c_char,
            elem_size: ffi::c_uint,
            val: *mut ffi::c_void,
            nval: usize,
        ) -> ffi::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const ffi::c_char,
            val: *mut *const ffi::c_char,
            nval: usize,
        ) -> ffi::c_int,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ffi::c_char,
    >,
    pub get_name_prefix: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ffi::c_char,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const ffi::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const ffi::c_char,
            nargs_prop: *const ffi::c_char,
            nargs: ffi::c_uint,
            index: ffi::c_uint,
            args: *mut fwnode_reference_args,
        ) -> ffi::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> ffi::c_int,
    >,
    pub iomap: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle, index: ffi::c_int) -> *mut ffi::c_void,
    >,
    pub irq_get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle, index: ffi::c_uint) -> ffi::c_int,
    >,
    pub add_links:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> ffi::c_int>,
}

pub const dev_prop_type_DEV_PROP_U8: dev_prop_type = 0;
pub const dev_prop_type_DEV_PROP_U16: dev_prop_type = 1;
pub const dev_prop_type_DEV_PROP_U32: dev_prop_type = 2;
pub const dev_prop_type_DEV_PROP_U64: dev_prop_type = 3;
pub const dev_prop_type_DEV_PROP_STRING: dev_prop_type = 4;
pub const dev_prop_type_DEV_PROP_REF: dev_prop_type = 5;
pub type dev_prop_type = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct software_node_ref_args {
    pub node: *const software_node,
    pub nargs: ffi::c_uint,
    pub args: [u64_; 16usize],
}
impl Default for software_node_ref_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct property_entry {
    pub name: *const ffi::c_char,
    pub length: usize,
    pub is_inline: bool_,
    pub type_: dev_prop_type,
    pub __bindgen_anon_1: property_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union property_entry__bindgen_ty_1 {
    pub pointer: *const ffi::c_void,
    pub value: property_entry__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union property_entry__bindgen_ty_1__bindgen_ty_1 {
    pub u8_data: [u8_; 8usize],
    pub u16_data: [u16_; 4usize],
    pub u32_data: [u32_; 2usize],
    pub u64_data: [u64_; 1usize],
    pub str_: [*const ffi::c_char; 1usize],
}
impl Default for property_entry__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for property_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for property_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type devcon_match_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        fwnode: *const fwnode_handle,
        id: *const ffi::c_char,
        data: *mut ffi::c_void,
    ) -> *mut ffi::c_void,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct software_node {
    pub name: *const ffi::c_char,
    pub parent: *const software_node,
    pub properties: *const property_entry,
}
impl Default for software_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct access_coordinate {
    pub read_bandwidth: ffi::c_uint,
    pub write_bandwidth: ffi::c_uint,
    pub read_latency: ffi::c_uint,
    pub write_latency: ffi::c_uint,
}
pub const access_coordinate_class_ACCESS_COORDINATE_LOCAL: access_coordinate_class = 0;
pub const access_coordinate_class_ACCESS_COORDINATE_CPU: access_coordinate_class = 1;
pub const access_coordinate_class_ACCESS_COORDINATE_MAX: access_coordinate_class = 2;
pub type access_coordinate_class = ffi::c_uint;
pub const cache_indexing_NODE_CACHE_DIRECT_MAP: cache_indexing = 0;
pub const cache_indexing_NODE_CACHE_INDEXED: cache_indexing = 1;
pub const cache_indexing_NODE_CACHE_OTHER: cache_indexing = 2;
pub type cache_indexing = ffi::c_uint;
pub const cache_write_policy_NODE_CACHE_WRITE_BACK: cache_write_policy = 0;
pub const cache_write_policy_NODE_CACHE_WRITE_THROUGH: cache_write_policy = 1;
pub const cache_write_policy_NODE_CACHE_WRITE_OTHER: cache_write_policy = 2;
pub type cache_write_policy = ffi::c_uint;
pub const cache_mode_NODE_CACHE_ADDR_MODE_RESERVED: cache_mode = 0;
pub const cache_mode_NODE_CACHE_ADDR_MODE_EXTENDED_LINEAR: cache_mode = 1;
pub type cache_mode = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct node_cache_attrs {
    pub indexing: cache_indexing,
    pub write_policy: cache_write_policy,
    pub size: u64_,
    pub line_size: u16_,
    pub level: u8_,
    pub address_mode: u16_,
}
impl Default for node_cache_attrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct node {
    pub dev: device,
    pub access_list: list_head,
}
impl Default for node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_block {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct node_notify {
    pub nid: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_domain_ops {
    _unused: [u8; 0],
}

pub type acpi_native_int = s64;
pub type acpi_size = u64_;
pub type acpi_io_address = u64_;
pub type acpi_physical_address = u64_;
pub type acpi_status = u32_;
pub type acpi_name = u32_;
pub type acpi_string = *mut ffi::c_char;
pub type acpi_handle = *mut ffi::c_void;
pub type acpi_owner_id = u16_;
pub type acpi_integer = u64_;
pub type acpi_object_type = u32_;
pub type acpi_event_type = u32_;
pub type acpi_event_status = u32_;
pub type acpi_adr_space_type = u8_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_object {
    pub type_: acpi_object_type,
    pub integer: acpi_object__bindgen_ty_1,
    pub string: acpi_object__bindgen_ty_2,
    pub buffer: acpi_object__bindgen_ty_3,
    pub package: acpi_object__bindgen_ty_4,
    pub reference: acpi_object__bindgen_ty_5,
    pub processor: acpi_object__bindgen_ty_6,
    pub power_resource: acpi_object__bindgen_ty_7,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_object__bindgen_ty_1 {
    pub type_: acpi_object_type,
    pub value: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_object__bindgen_ty_2 {
    pub type_: acpi_object_type,
    pub length: u32_,
    pub pointer: *mut ffi::c_char,
}
impl Default for acpi_object__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_object__bindgen_ty_3 {
    pub type_: acpi_object_type,
    pub length: u32_,
    pub pointer: *mut u8_,
}
impl Default for acpi_object__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_object__bindgen_ty_4 {
    pub type_: acpi_object_type,
    pub count: u32_,
    pub elements: *mut acpi_object,
}
impl Default for acpi_object__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_object__bindgen_ty_5 {
    pub type_: acpi_object_type,
    pub actual_type: acpi_object_type,
    pub handle: acpi_handle,
}
impl Default for acpi_object__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_object__bindgen_ty_6 {
    pub type_: acpi_object_type,
    pub proc_id: u32_,
    pub pblk_address: acpi_io_address,
    pub pblk_length: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_object__bindgen_ty_7 {
    pub type_: acpi_object_type,
    pub system_level: u32_,
    pub resource_order: u32_,
}
impl Default for acpi_object {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_object_list {
    pub count: u32_,
    pub pointer: *mut acpi_object,
}
impl Default for acpi_object_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_buffer {
    pub length: acpi_size,
    pub pointer: *mut ffi::c_void,
}
impl Default for acpi_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_predefined_names {
    pub name: *const ffi::c_char,
    pub type_: u8_,
    pub val: *mut ffi::c_char,
}
impl Default for acpi_predefined_names {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_system_info {
    pub acpi_ca_version: u32_,
    pub flags: u32_,
    pub timer_resolution: u32_,
    pub reserved1: u32_,
    pub reserved2: u32_,
    pub debug_level: u32_,
    pub debug_layer: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_statistics {
    pub sci_count: u32_,
    pub gpe_count: u32_,
    pub fixed_event_count: [u32_; 5usize],
    pub method_count: u32_,
}
pub type acpi_osd_handler =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ffi::c_void) -> u32_>;
pub type acpi_osd_exec_callback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ffi::c_void)>;
pub type acpi_sci_handler =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ffi::c_void) -> u32_>;
pub type acpi_gbl_event_handler = ::core::option::Option<
    unsafe extern "C" fn(
        event_type: u32_,
        device: acpi_handle,
        event_number: u32_,
        context: *mut ffi::c_void,
    ),
>;
pub type acpi_event_handler =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ffi::c_void) -> u32_>;
pub type acpi_gpe_handler = ::core::option::Option<
    unsafe extern "C" fn(
        gpe_device: acpi_handle,
        gpe_number: u32_,
        context: *mut ffi::c_void,
    ) -> u32_,
>;
pub type acpi_notify_handler = ::core::option::Option<
    unsafe extern "C" fn(device: acpi_handle, value: u32_, context: *mut ffi::c_void),
>;
pub type acpi_object_handler =
    ::core::option::Option<unsafe extern "C" fn(object: acpi_handle, data: *mut ffi::c_void)>;
pub type acpi_init_handler = ::core::option::Option<
    unsafe extern "C" fn(object: acpi_handle, function: u32_) -> acpi_status,
>;
pub type acpi_exception_handler = ::core::option::Option<
    unsafe extern "C" fn(
        aml_status: acpi_status,
        name: acpi_name,
        opcode: u16_,
        aml_offset: u32_,
        context: *mut ffi::c_void,
    ) -> acpi_status,
>;
pub type acpi_table_handler = ::core::option::Option<
    unsafe extern "C" fn(
        event: u32_,
        table: *mut ffi::c_void,
        context: *mut ffi::c_void,
    ) -> acpi_status,
>;
pub type acpi_adr_space_handler = ::core::option::Option<
    unsafe extern "C" fn(
        function: u32_,
        address: acpi_physical_address,
        bit_width: u32_,
        value: *mut u64_,
        handler_context: *mut ffi::c_void,
        region_context: *mut ffi::c_void,
    ) -> acpi_status,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_connection_info {
    pub connection: *mut u8_,
    pub length: u16_,
    pub access_length: u8_,
}
impl Default for acpi_connection_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_pcc_info {
    pub subspace_id: u8_,
    pub length: u16_,
    pub internal_buffer: *mut u8_,
}
impl Default for acpi_pcc_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ffh_info {
    pub offset: u64_,
    pub length: u64_,
}
pub type acpi_adr_space_setup = ::core::option::Option<
    unsafe extern "C" fn(
        region_handle: acpi_handle,
        function: u32_,
        handler_context: *mut ffi::c_void,
        region_context: *mut *mut ffi::c_void,
    ) -> acpi_status,
>;
pub type acpi_walk_callback = ::core::option::Option<
    unsafe extern "C" fn(
        object: acpi_handle,
        nesting_level: u32_,
        context: *mut ffi::c_void,
        return_value: *mut *mut ffi::c_void,
    ) -> acpi_status,
>;
pub type acpi_interface_handler = ::core::option::Option<
    unsafe extern "C" fn(interface_name: acpi_string, supported: u32_) -> u32_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_pnp_device_id {
    pub length: u32_,
    pub string: *mut ffi::c_char,
}
impl Default for acpi_pnp_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_pnp_device_id_list {
    pub count: u32_,
    pub list_size: u32_,
    pub ids: __IncompleteArrayField<acpi_pnp_device_id>,
}
impl Default for acpi_pnp_device_id_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_device_info {
    pub info_size: u32_,
    pub name: u32_,
    pub type_: acpi_object_type,
    pub param_count: u8_,
    pub valid: u16_,
    pub flags: u8_,
    pub highest_dstates: [u8_; 4usize],
    pub lowest_dstates: [u8_; 5usize],
    pub address: u64_,
    pub hardware_id: acpi_pnp_device_id,
    pub unique_id: acpi_pnp_device_id,
    pub class_code: acpi_pnp_device_id,
    pub compatible_id_list: acpi_pnp_device_id_list,
}
impl Default for acpi_device_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pci_id {
    pub segment: u16_,
    pub bus: u16_,
    pub device: u16_,
    pub function: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_mem_mapping {
    pub physical_address: acpi_physical_address,
    pub logical_address: *mut u8_,
    pub length: acpi_size,
    pub next_mm: *mut acpi_mem_mapping,
}
impl Default for acpi_mem_mapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_mem_space_context {
    pub length: u32_,
    pub address: acpi_physical_address,
    pub cur_mm: *mut acpi_mem_mapping,
    pub first_mm: *mut acpi_mem_mapping,
}
impl Default for acpi_mem_space_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_data_table_mapping {
    pub pointer: *mut ffi::c_void,
}
impl Default for acpi_data_table_mapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_memory_list {
    pub list_name: *const ffi::c_char,
    pub list_head: *mut ffi::c_void,
    pub object_size: u16_,
    pub max_depth: u16_,
    pub current_depth: u16_,
}
impl Default for acpi_memory_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const acpi_trace_event_type_ACPI_TRACE_AML_METHOD: acpi_trace_event_type = 0;
pub const acpi_trace_event_type_ACPI_TRACE_AML_OPCODE: acpi_trace_event_type = 1;
pub const acpi_trace_event_type_ACPI_TRACE_AML_REGION: acpi_trace_event_type = 2;
pub type acpi_trace_event_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_exception_info {
    pub name: *mut ffi::c_char,
}
impl Default for acpi_exception_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_header {
    pub signature: [ffi::c_char; 4usize],
    pub length: u32_,
    pub revision: u8_,
    pub checksum: u8_,
    pub oem_id: [ffi::c_char; 6usize],
    pub oem_table_id: [ffi::c_char; 8usize],
    pub oem_revision: u32_,
    pub asl_compiler_id: [ffi::c_char; 4usize],
    pub asl_compiler_revision: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_generic_address {
    pub space_id: u8_,
    pub bit_width: u8_,
    pub bit_offset: u8_,
    pub access_width: u8_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_rsdp {
    pub signature: [ffi::c_char; 8usize],
    pub checksum: u8_,
    pub oem_id: [ffi::c_char; 6usize],
    pub revision: u8_,
    pub rsdt_physical_address: u32_,
    pub length: u32_,
    pub xsdt_physical_address: u64_,
    pub extended_checksum: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rsdp_common {
    pub signature: [ffi::c_char; 8usize],
    pub checksum: u8_,
    pub oem_id: [ffi::c_char; 6usize],
    pub revision: u8_,
    pub rsdt_physical_address: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rsdp_extension {
    pub length: u32_,
    pub xsdt_physical_address: u64_,
    pub extended_checksum: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_rsdt {
    pub header: acpi_table_header,
    pub table_offset_entry: [u32_; 1usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_xsdt {
    pub header: acpi_table_header,
    pub table_offset_entry: [u64_; 1usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_facs {
    pub signature: [ffi::c_char; 4usize],
    pub length: u32_,
    pub hardware_signature: u32_,
    pub firmware_waking_vector: u32_,
    pub global_lock: u32_,
    pub flags: u32_,
    pub xfirmware_waking_vector: u64_,
    pub version: u8_,
    pub reserved: [u8_; 3usize],
    pub ospm_flags: u32_,
    pub reserved1: [u8_; 24usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_fadt {
    pub header: acpi_table_header,
    pub facs: u32_,
    pub dsdt: u32_,
    pub model: u8_,
    pub preferred_profile: u8_,
    pub sci_interrupt: u16_,
    pub smi_command: u32_,
    pub acpi_enable: u8_,
    pub acpi_disable: u8_,
    pub s4_bios_request: u8_,
    pub pstate_control: u8_,
    pub pm1a_event_block: u32_,
    pub pm1b_event_block: u32_,
    pub pm1a_control_block: u32_,
    pub pm1b_control_block: u32_,
    pub pm2_control_block: u32_,
    pub pm_timer_block: u32_,
    pub gpe0_block: u32_,
    pub gpe1_block: u32_,
    pub pm1_event_length: u8_,
    pub pm1_control_length: u8_,
    pub pm2_control_length: u8_,
    pub pm_timer_length: u8_,
    pub gpe0_block_length: u8_,
    pub gpe1_block_length: u8_,
    pub gpe1_base: u8_,
    pub cst_control: u8_,
    pub c2_latency: u16_,
    pub c3_latency: u16_,
    pub flush_size: u16_,
    pub flush_stride: u16_,
    pub duty_offset: u8_,
    pub duty_width: u8_,
    pub day_alarm: u8_,
    pub month_alarm: u8_,
    pub century: u8_,
    pub boot_flags: u16_,
    pub reserved: u8_,
    pub flags: u32_,
    pub reset_register: acpi_generic_address,
    pub reset_value: u8_,
    pub arm_boot_flags: u16_,
    pub minor_revision: u8_,
    pub Xfacs: u64_,
    pub Xdsdt: u64_,
    pub xpm1a_event_block: acpi_generic_address,
    pub xpm1b_event_block: acpi_generic_address,
    pub xpm1a_control_block: acpi_generic_address,
    pub xpm1b_control_block: acpi_generic_address,
    pub xpm2_control_block: acpi_generic_address,
    pub xpm_timer_block: acpi_generic_address,
    pub xgpe0_block: acpi_generic_address,
    pub xgpe1_block: acpi_generic_address,
    pub sleep_control: acpi_generic_address,
    pub sleep_status: acpi_generic_address,
    pub hypervisor_id: u64_,
}
pub const acpi_preferred_pm_profiles_PM_UNSPECIFIED: acpi_preferred_pm_profiles = 0;
pub const acpi_preferred_pm_profiles_PM_DESKTOP: acpi_preferred_pm_profiles = 1;
pub const acpi_preferred_pm_profiles_PM_MOBILE: acpi_preferred_pm_profiles = 2;
pub const acpi_preferred_pm_profiles_PM_WORKSTATION: acpi_preferred_pm_profiles = 3;
pub const acpi_preferred_pm_profiles_PM_ENTERPRISE_SERVER: acpi_preferred_pm_profiles = 4;
pub const acpi_preferred_pm_profiles_PM_SOHO_SERVER: acpi_preferred_pm_profiles = 5;
pub const acpi_preferred_pm_profiles_PM_APPLIANCE_PC: acpi_preferred_pm_profiles = 6;
pub const acpi_preferred_pm_profiles_PM_PERFORMANCE_SERVER: acpi_preferred_pm_profiles = 7;
pub const acpi_preferred_pm_profiles_PM_TABLET: acpi_preferred_pm_profiles = 8;
pub const acpi_preferred_pm_profiles_NR_PM_PROFILES: acpi_preferred_pm_profiles = 9;
pub type acpi_preferred_pm_profiles = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_name_union {
    pub integer: u32_,
    pub ascii: [ffi::c_char; 4usize],
}
impl Default for acpi_name_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_table_desc {
    pub address: acpi_physical_address,
    pub pointer: *mut acpi_table_header,
    pub length: u32_,
    pub signature: acpi_name_union,
    pub owner_id: acpi_owner_id,
    pub flags: u8_,
    pub validation_count: u16_,
}
impl Default for acpi_table_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_subtable_header {
    pub type_: u8_,
    pub length: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_whea_header {
    pub action: u8_,
    pub instruction: u8_,
    pub flags: u8_,
    pub reserved: u8_,
    pub register_region: acpi_generic_address,
    pub value: u64_,
    pub mask: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_aspt {
    pub header: acpi_table_header,
    pub num_entries: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aspt_header {
    pub type_: u16_,
    pub length: u16_,
}
pub const acpi_aspt_type_ACPI_ASPT_TYPE_GLOBAL_REGS: acpi_aspt_type = 0;
pub const acpi_aspt_type_ACPI_ASPT_TYPE_SEV_MBOX_REGS: acpi_aspt_type = 1;
pub const acpi_aspt_type_ACPI_ASPT_TYPE_ACPI_MBOX_REGS: acpi_aspt_type = 2;
pub type acpi_aspt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aspt_global_regs {
    pub header: acpi_aspt_header,
    pub reserved: u32_,
    pub feature_reg_addr: u64_,
    pub irq_en_reg_addr: u64_,
    pub irq_st_reg_addr: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aspt_sev_mbox_regs {
    pub header: acpi_aspt_header,
    pub mbox_irq_id: u8_,
    pub reserved: [u8_; 3usize],
    pub cmd_resp_reg_addr: u64_,
    pub cmd_buf_lo_reg_addr: u64_,
    pub cmd_buf_hi_reg_addr: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aspt_acpi_mbox_regs {
    pub header: acpi_aspt_header,
    pub reserved1: u32_,
    pub cmd_resp_reg_addr: u64_,
    pub reserved2: [u64_; 2usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_subtbl_hdr_16 {
    pub type_: u16_,
    pub length: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_asf {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_header {
    pub type_: u8_,
    pub reserved: u8_,
    pub length: u16_,
}
pub const acpi_asf_type_ACPI_ASF_TYPE_INFO: acpi_asf_type = 0;
pub const acpi_asf_type_ACPI_ASF_TYPE_ALERT: acpi_asf_type = 1;
pub const acpi_asf_type_ACPI_ASF_TYPE_CONTROL: acpi_asf_type = 2;
pub const acpi_asf_type_ACPI_ASF_TYPE_BOOT: acpi_asf_type = 3;
pub const acpi_asf_type_ACPI_ASF_TYPE_ADDRESS: acpi_asf_type = 4;
pub const acpi_asf_type_ACPI_ASF_TYPE_RESERVED: acpi_asf_type = 5;
pub type acpi_asf_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_info {
    pub header: acpi_asf_header,
    pub min_reset_value: u8_,
    pub min_poll_interval: u8_,
    pub system_id: u16_,
    pub mfg_id: u32_,
    pub flags: u8_,
    pub reserved2: [u8_; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_alert {
    pub header: acpi_asf_header,
    pub assert_mask: u8_,
    pub deassert_mask: u8_,
    pub alerts: u8_,
    pub data_length: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_alert_data {
    pub address: u8_,
    pub command: u8_,
    pub mask: u8_,
    pub value: u8_,
    pub sensor_type: u8_,
    pub type_: u8_,
    pub offset: u8_,
    pub source_type: u8_,
    pub severity: u8_,
    pub sensor_number: u8_,
    pub entity: u8_,
    pub instance: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_remote {
    pub header: acpi_asf_header,
    pub controls: u8_,
    pub data_length: u8_,
    pub reserved2: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_control_data {
    pub function: u8_,
    pub address: u8_,
    pub command: u8_,
    pub value: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_rmcp {
    pub header: acpi_asf_header,
    pub capabilities: [u8_; 7usize],
    pub completion_code: u8_,
    pub enterprise_id: u32_,
    pub command: u8_,
    pub parameter: u16_,
    pub boot_options: u16_,
    pub oem_parameters: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_asf_address {
    pub header: acpi_asf_header,
    pub eprom_address: u8_,
    pub devices: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_bert {
    pub header: acpi_table_header,
    pub region_length: u32_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_bert_region {
    pub block_status: u32_,
    pub raw_data_offset: u32_,
    pub raw_data_length: u32_,
    pub data_length: u32_,
    pub error_severity: u32_,
}
pub const acpi_bert_error_severity_ACPI_BERT_ERROR_CORRECTABLE: acpi_bert_error_severity = 0;
pub const acpi_bert_error_severity_ACPI_BERT_ERROR_FATAL: acpi_bert_error_severity = 1;
pub const acpi_bert_error_severity_ACPI_BERT_ERROR_CORRECTED: acpi_bert_error_severity = 2;
pub const acpi_bert_error_severity_ACPI_BERT_ERROR_NONE: acpi_bert_error_severity = 3;
pub const acpi_bert_error_severity_ACPI_BERT_ERROR_RESERVED: acpi_bert_error_severity = 4;
pub type acpi_bert_error_severity = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_bgrt {
    pub header: acpi_table_header,
    pub version: u16_,
    pub status: u8_,
    pub image_type: u8_,
    pub image_address: u64_,
    pub image_offset_x: u32_,
    pub image_offset_y: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_boot {
    pub header: acpi_table_header,
    pub cmos_index: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_cdat {
    pub length: u32_,
    pub revision: u8_,
    pub checksum: u8_,
    pub reserved: [u8_; 6usize],
    pub sequence: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_header {
    pub type_: u8_,
    pub reserved: u8_,
    pub length: u16_,
}
pub const acpi_cdat_type_ACPI_CDAT_TYPE_DSMAS: acpi_cdat_type = 0;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_DSLBIS: acpi_cdat_type = 1;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_DSMSCIS: acpi_cdat_type = 2;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_DSIS: acpi_cdat_type = 3;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_DSEMTS: acpi_cdat_type = 4;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_SSLBIS: acpi_cdat_type = 5;
pub const acpi_cdat_type_ACPI_CDAT_TYPE_RESERVED: acpi_cdat_type = 6;
pub type acpi_cdat_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_dsmas {
    pub dsmad_handle: u8_,
    pub flags: u8_,
    pub reserved: u16_,
    pub dpa_base_address: u64_,
    pub dpa_length: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_dslbis {
    pub handle: u8_,
    pub flags: u8_,
    pub data_type: u8_,
    pub reserved: u8_,
    pub entry_base_unit: u64_,
    pub entry: [u16_; 3usize],
    pub reserved2: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_dsmscis {
    pub dsmas_handle: u8_,
    pub reserved: [u8_; 3usize],
    pub side_cache_size: u64_,
    pub cache_attributes: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_dsis {
    pub flags: u8_,
    pub handle: u8_,
    pub reserved: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_dsemts {
    pub dsmas_handle: u8_,
    pub memory_type: u8_,
    pub reserved: u16_,
    pub dpa_offset: u64_,
    pub range_length: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_sslbis {
    pub data_type: u8_,
    pub reserved: [u8_; 3usize],
    pub entry_base_unit: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cdat_sslbe {
    pub portx_id: u16_,
    pub porty_id: u16_,
    pub latency_or_bandwidth: u16_,
    pub reserved: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_cedt {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cedt_header {
    pub type_: u8_,
    pub reserved: u8_,
    pub length: u16_,
}
pub const acpi_cedt_type_ACPI_CEDT_TYPE_CHBS: acpi_cedt_type = 0;
pub const acpi_cedt_type_ACPI_CEDT_TYPE_CFMWS: acpi_cedt_type = 1;
pub const acpi_cedt_type_ACPI_CEDT_TYPE_CXIMS: acpi_cedt_type = 2;
pub const acpi_cedt_type_ACPI_CEDT_TYPE_RDPAS: acpi_cedt_type = 3;
pub const acpi_cedt_type_ACPI_CEDT_TYPE_RESERVED: acpi_cedt_type = 4;
pub type acpi_cedt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cedt_chbs {
    pub header: acpi_cedt_header,
    pub uid: u32_,
    pub cxl_version: u32_,
    pub reserved: u32_,
    pub base: u64_,
    pub length: u64_,
}
#[repr(C, packed)]
pub struct acpi_cedt_cfmws {
    pub header: acpi_cedt_header,
    pub reserved1: u32_,
    pub base_hpa: u64_,
    pub window_size: u64_,
    pub interleave_ways: u8_,
    pub interleave_arithmetic: u8_,
    pub reserved2: u16_,
    pub granularity: u32_,
    pub restrictions: u16_,
    pub qtg_id: u16_,
    pub interleave_targets: __IncompleteArrayField<u32_>,
}
impl Default for acpi_cedt_cfmws {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cedt_cfmws_target_element {
    pub interleave_target: u32_,
}
#[repr(C, packed)]
pub struct acpi_cedt_cxims {
    pub header: acpi_cedt_header,
    pub reserved1: u16_,
    pub hbig: u8_,
    pub nr_xormaps: u8_,
    pub xormap_list: __IncompleteArrayField<u64_>,
}
impl Default for acpi_cedt_cxims {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cedt_cxims_target_element {
    pub xormap: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cedt_rdpas {
    pub header: acpi_cedt_header,
    pub segment: u16_,
    pub bdf: u16_,
    pub protocol: u8_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_cpep {
    pub header: acpi_table_header,
    pub reserved: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_cpep_polling {
    pub header: acpi_subtable_header,
    pub id: u8_,
    pub eid: u8_,
    pub interval: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_csrt {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_csrt_group {
    pub length: u32_,
    pub vendor_id: u32_,
    pub subvendor_id: u32_,
    pub device_id: u16_,
    pub subdevice_id: u16_,
    pub revision: u16_,
    pub reserved: u16_,
    pub shared_info_length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_csrt_shared_info {
    pub major_version: u16_,
    pub minor_version: u16_,
    pub mmio_base_low: u32_,
    pub mmio_base_high: u32_,
    pub gsi_interrupt: u32_,
    pub interrupt_polarity: u8_,
    pub interrupt_mode: u8_,
    pub num_channels: u8_,
    pub dma_address_width: u8_,
    pub base_request_line: u16_,
    pub num_handshake_signals: u16_,
    pub max_block_size: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_csrt_descriptor {
    pub length: u32_,
    pub type_: u16_,
    pub subtype: u16_,
    pub uid: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_dbg2 {
    pub header: acpi_table_header,
    pub info_offset: u32_,
    pub info_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dbg2_header {
    pub info_offset: u32_,
    pub info_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dbg2_device {
    pub revision: u8_,
    pub length: u16_,
    pub register_count: u8_,
    pub namepath_length: u16_,
    pub namepath_offset: u16_,
    pub oem_data_length: u16_,
    pub oem_data_offset: u16_,
    pub port_type: u16_,
    pub port_subtype: u16_,
    pub reserved: u16_,
    pub base_address_offset: u16_,
    pub address_size_offset: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_dbgp {
    pub header: acpi_table_header,
    pub type_: u8_,
    pub reserved: [u8_; 3usize],
    pub debug_port: acpi_generic_address,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_dmar {
    pub header: acpi_table_header,
    pub width: u8_,
    pub flags: u8_,
    pub reserved: [u8_; 10usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_header {
    pub type_: u16_,
    pub length: u16_,
}
pub const acpi_dmar_type_ACPI_DMAR_TYPE_HARDWARE_UNIT: acpi_dmar_type = 0;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_RESERVED_MEMORY: acpi_dmar_type = 1;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_ROOT_ATS: acpi_dmar_type = 2;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_HARDWARE_AFFINITY: acpi_dmar_type = 3;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_NAMESPACE: acpi_dmar_type = 4;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_SATC: acpi_dmar_type = 5;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_SIDP: acpi_dmar_type = 6;
pub const acpi_dmar_type_ACPI_DMAR_TYPE_RESERVED: acpi_dmar_type = 7;
pub type acpi_dmar_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_device_scope {
    pub entry_type: u8_,
    pub length: u8_,
    pub flags: u8_,
    pub reserved: u8_,
    pub enumeration_id: u8_,
    pub bus: u8_,
}
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_NOT_USED: acpi_dmar_scope_type = 0;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_ENDPOINT: acpi_dmar_scope_type = 1;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_BRIDGE: acpi_dmar_scope_type = 2;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_IOAPIC: acpi_dmar_scope_type = 3;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_HPET: acpi_dmar_scope_type = 4;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_NAMESPACE: acpi_dmar_scope_type = 5;
pub const acpi_dmar_scope_type_ACPI_DMAR_SCOPE_TYPE_RESERVED: acpi_dmar_scope_type = 6;
pub type acpi_dmar_scope_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_pci_path {
    pub device: u8_,
    pub function: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_hardware_unit {
    pub header: acpi_dmar_header,
    pub flags: u8_,
    pub size: u8_,
    pub segment: u16_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_reserved_memory {
    pub header: acpi_dmar_header,
    pub reserved: u16_,
    pub segment: u16_,
    pub base_address: u64_,
    pub end_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_atsr {
    pub header: acpi_dmar_header,
    pub flags: u8_,
    pub reserved: u8_,
    pub segment: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_rhsa {
    pub header: acpi_dmar_header,
    pub reserved: u32_,
    pub base_address: u64_,
    pub proximity_domain: u32_,
}
#[repr(C)]
pub struct acpi_dmar_andd {
    pub header: acpi_dmar_header,
    pub reserved: [u8_; 3usize],
    pub device_number: u8_,
    pub __bindgen_anon_1: acpi_dmar_andd__bindgen_ty_1,
}
#[repr(C)]
pub struct acpi_dmar_andd__bindgen_ty_1 {
    pub __pad: __BindgenUnionField<ffi::c_char>,
    pub __bindgen_anon_1: __BindgenUnionField<acpi_dmar_andd__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_dmar_andd__bindgen_ty_1__bindgen_ty_1 {
    pub __Empty_device_name: acpi_dmar_andd__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub device_name: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_andd__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for acpi_dmar_andd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_dmar_andd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_satc {
    pub header: acpi_dmar_header,
    pub flags: u8_,
    pub reserved: u8_,
    pub segment: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_dmar_sidp {
    pub header: acpi_dmar_header,
    pub reserved: u16_,
    pub segment: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_drtm {
    pub header: acpi_table_header,
    pub entry_base_address: u64_,
    pub entry_length: u64_,
    pub entry_address32: u32_,
    pub entry_address64: u64_,
    pub exit_address: u64_,
    pub log_area_address: u64_,
    pub log_area_length: u32_,
    pub arch_dependent_address: u64_,
    pub flags: u32_,
}
#[repr(C, packed)]
pub struct acpi_drtm_vtable_list {
    pub validated_table_count: u32_,
    pub validated_tables: __IncompleteArrayField<u64_>,
}
impl Default for acpi_drtm_vtable_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_drtm_resource {
    pub size: [u8_; 7usize],
    pub type_: u8_,
    pub address: u64_,
}
#[repr(C, packed)]
pub struct acpi_drtm_resource_list {
    pub resource_count: u32_,
    pub resources: __IncompleteArrayField<acpi_drtm_resource>,
}
impl Default for acpi_drtm_resource_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_drtm_dps_id {
    pub dps_id_length: u32_,
    pub dps_id: [u8_; 16usize],
}
#[repr(C, packed)]
pub struct acpi_table_ecdt {
    pub header: acpi_table_header,
    pub control: acpi_generic_address,
    pub data: acpi_generic_address,
    pub uid: u32_,
    pub gpe: u8_,
    pub id: __IncompleteArrayField<u8_>,
}
impl Default for acpi_table_ecdt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_einj {
    pub header: acpi_table_header,
    pub header_length: u32_,
    pub flags: u8_,
    pub reserved: [u8_; 3usize],
    pub entries: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_einj_entry {
    pub whea_header: acpi_whea_header,
}
pub const acpi_einj_actions_ACPI_EINJ_BEGIN_OPERATION: acpi_einj_actions = 0;
pub const acpi_einj_actions_ACPI_EINJ_GET_TRIGGER_TABLE: acpi_einj_actions = 1;
pub const acpi_einj_actions_ACPI_EINJ_SET_ERROR_TYPE: acpi_einj_actions = 2;
pub const acpi_einj_actions_ACPI_EINJ_GET_ERROR_TYPE: acpi_einj_actions = 3;
pub const acpi_einj_actions_ACPI_EINJ_END_OPERATION: acpi_einj_actions = 4;
pub const acpi_einj_actions_ACPI_EINJ_EXECUTE_OPERATION: acpi_einj_actions = 5;
pub const acpi_einj_actions_ACPI_EINJ_CHECK_BUSY_STATUS: acpi_einj_actions = 6;
pub const acpi_einj_actions_ACPI_EINJ_GET_COMMAND_STATUS: acpi_einj_actions = 7;
pub const acpi_einj_actions_ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS: acpi_einj_actions = 8;
pub const acpi_einj_actions_ACPI_EINJ_GET_EXECUTE_TIMINGS: acpi_einj_actions = 9;
pub const acpi_einj_actions_ACPI_EINJV2_GET_ERROR_TYPE: acpi_einj_actions = 17;
pub const acpi_einj_actions_ACPI_EINJ_ACTION_RESERVED: acpi_einj_actions = 18;
pub const acpi_einj_actions_ACPI_EINJ_TRIGGER_ERROR: acpi_einj_actions = 255;
pub type acpi_einj_actions = ffi::c_uint;
pub const acpi_einj_instructions_ACPI_EINJ_READ_REGISTER: acpi_einj_instructions = 0;
pub const acpi_einj_instructions_ACPI_EINJ_READ_REGISTER_VALUE: acpi_einj_instructions = 1;
pub const acpi_einj_instructions_ACPI_EINJ_WRITE_REGISTER: acpi_einj_instructions = 2;
pub const acpi_einj_instructions_ACPI_EINJ_WRITE_REGISTER_VALUE: acpi_einj_instructions = 3;
pub const acpi_einj_instructions_ACPI_EINJ_NOOP: acpi_einj_instructions = 4;
pub const acpi_einj_instructions_ACPI_EINJ_FLUSH_CACHELINE: acpi_einj_instructions = 5;
pub const acpi_einj_instructions_ACPI_EINJ_INSTRUCTION_RESERVED: acpi_einj_instructions = 6;
pub type acpi_einj_instructions = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_einj_error_type_with_addr {
    pub error_type: u32_,
    pub vendor_struct_offset: u32_,
    pub flags: u32_,
    pub apic_id: u32_,
    pub address: u64_,
    pub range: u64_,
    pub pcie_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_einj_vendor {
    pub length: u32_,
    pub pcie_id: u32_,
    pub vendor_id: u16_,
    pub device_id: u16_,
    pub revision_id: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_einj_trigger {
    pub header_size: u32_,
    pub revision: u32_,
    pub table_size: u32_,
    pub entry_count: u32_,
}
pub const acpi_einj_command_status_ACPI_EINJ_SUCCESS: acpi_einj_command_status = 0;
pub const acpi_einj_command_status_ACPI_EINJ_FAILURE: acpi_einj_command_status = 1;
pub const acpi_einj_command_status_ACPI_EINJ_INVALID_ACCESS: acpi_einj_command_status = 2;
pub const acpi_einj_command_status_ACPI_EINJ_STATUS_RESERVED: acpi_einj_command_status = 3;
pub type acpi_einj_command_status = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_erst {
    pub header: acpi_table_header,
    pub header_length: u32_,
    pub reserved: u32_,
    pub entries: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erst_entry {
    pub whea_header: acpi_whea_header,
}
pub const acpi_erst_actions_ACPI_ERST_BEGIN_WRITE: acpi_erst_actions = 0;
pub const acpi_erst_actions_ACPI_ERST_BEGIN_READ: acpi_erst_actions = 1;
pub const acpi_erst_actions_ACPI_ERST_BEGIN_CLEAR: acpi_erst_actions = 2;
pub const acpi_erst_actions_ACPI_ERST_END: acpi_erst_actions = 3;
pub const acpi_erst_actions_ACPI_ERST_SET_RECORD_OFFSET: acpi_erst_actions = 4;
pub const acpi_erst_actions_ACPI_ERST_EXECUTE_OPERATION: acpi_erst_actions = 5;
pub const acpi_erst_actions_ACPI_ERST_CHECK_BUSY_STATUS: acpi_erst_actions = 6;
pub const acpi_erst_actions_ACPI_ERST_GET_COMMAND_STATUS: acpi_erst_actions = 7;
pub const acpi_erst_actions_ACPI_ERST_GET_RECORD_ID: acpi_erst_actions = 8;
pub const acpi_erst_actions_ACPI_ERST_SET_RECORD_ID: acpi_erst_actions = 9;
pub const acpi_erst_actions_ACPI_ERST_GET_RECORD_COUNT: acpi_erst_actions = 10;
pub const acpi_erst_actions_ACPI_ERST_BEGIN_DUMMY_WRIITE: acpi_erst_actions = 11;
pub const acpi_erst_actions_ACPI_ERST_NOT_USED: acpi_erst_actions = 12;
pub const acpi_erst_actions_ACPI_ERST_GET_ERROR_RANGE: acpi_erst_actions = 13;
pub const acpi_erst_actions_ACPI_ERST_GET_ERROR_LENGTH: acpi_erst_actions = 14;
pub const acpi_erst_actions_ACPI_ERST_GET_ERROR_ATTRIBUTES: acpi_erst_actions = 15;
pub const acpi_erst_actions_ACPI_ERST_EXECUTE_TIMINGS: acpi_erst_actions = 16;
pub const acpi_erst_actions_ACPI_ERST_ACTION_RESERVED: acpi_erst_actions = 17;
pub type acpi_erst_actions = ffi::c_uint;
pub const acpi_erst_instructions_ACPI_ERST_READ_REGISTER: acpi_erst_instructions = 0;
pub const acpi_erst_instructions_ACPI_ERST_READ_REGISTER_VALUE: acpi_erst_instructions = 1;
pub const acpi_erst_instructions_ACPI_ERST_WRITE_REGISTER: acpi_erst_instructions = 2;
pub const acpi_erst_instructions_ACPI_ERST_WRITE_REGISTER_VALUE: acpi_erst_instructions = 3;
pub const acpi_erst_instructions_ACPI_ERST_NOOP: acpi_erst_instructions = 4;
pub const acpi_erst_instructions_ACPI_ERST_LOAD_VAR1: acpi_erst_instructions = 5;
pub const acpi_erst_instructions_ACPI_ERST_LOAD_VAR2: acpi_erst_instructions = 6;
pub const acpi_erst_instructions_ACPI_ERST_STORE_VAR1: acpi_erst_instructions = 7;
pub const acpi_erst_instructions_ACPI_ERST_ADD: acpi_erst_instructions = 8;
pub const acpi_erst_instructions_ACPI_ERST_SUBTRACT: acpi_erst_instructions = 9;
pub const acpi_erst_instructions_ACPI_ERST_ADD_VALUE: acpi_erst_instructions = 10;
pub const acpi_erst_instructions_ACPI_ERST_SUBTRACT_VALUE: acpi_erst_instructions = 11;
pub const acpi_erst_instructions_ACPI_ERST_STALL: acpi_erst_instructions = 12;
pub const acpi_erst_instructions_ACPI_ERST_STALL_WHILE_TRUE: acpi_erst_instructions = 13;
pub const acpi_erst_instructions_ACPI_ERST_SKIP_NEXT_IF_TRUE: acpi_erst_instructions = 14;
pub const acpi_erst_instructions_ACPI_ERST_GOTO: acpi_erst_instructions = 15;
pub const acpi_erst_instructions_ACPI_ERST_SET_SRC_ADDRESS_BASE: acpi_erst_instructions = 16;
pub const acpi_erst_instructions_ACPI_ERST_SET_DST_ADDRESS_BASE: acpi_erst_instructions = 17;
pub const acpi_erst_instructions_ACPI_ERST_MOVE_DATA: acpi_erst_instructions = 18;
pub const acpi_erst_instructions_ACPI_ERST_INSTRUCTION_RESERVED: acpi_erst_instructions = 19;
pub type acpi_erst_instructions = ffi::c_uint;
pub const acpi_erst_command_status_ACPI_ERST_SUCCESS: acpi_erst_command_status = 0;
pub const acpi_erst_command_status_ACPI_ERST_NO_SPACE: acpi_erst_command_status = 1;
pub const acpi_erst_command_status_ACPI_ERST_NOT_AVAILABLE: acpi_erst_command_status = 2;
pub const acpi_erst_command_status_ACPI_ERST_FAILURE: acpi_erst_command_status = 3;
pub const acpi_erst_command_status_ACPI_ERST_RECORD_EMPTY: acpi_erst_command_status = 4;
pub const acpi_erst_command_status_ACPI_ERST_NOT_FOUND: acpi_erst_command_status = 5;
pub const acpi_erst_command_status_ACPI_ERST_STATUS_RESERVED: acpi_erst_command_status = 6;
pub type acpi_erst_command_status = ffi::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_erst_info {
    pub signature: u16_,
    pub data: [u8_; 48usize],
}
impl Default for acpi_erst_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_fpdt {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_fpdt_header {
    pub type_: u16_,
    pub length: u8_,
    pub revision: u8_,
}
pub const acpi_fpdt_type_ACPI_FPDT_TYPE_BOOT: acpi_fpdt_type = 0;
pub const acpi_fpdt_type_ACPI_FPDT_TYPE_S3PERF: acpi_fpdt_type = 1;
pub type acpi_fpdt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_fpdt_boot_pointer {
    pub header: acpi_fpdt_header,
    pub reserved: [u8_; 4usize],
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_fpdt_s3pt_pointer {
    pub header: acpi_fpdt_header,
    pub reserved: [u8_; 4usize],
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_s3pt {
    pub signature: [u8_; 4usize],
    pub length: u32_,
}
pub const acpi_s3pt_type_ACPI_S3PT_TYPE_RESUME: acpi_s3pt_type = 0;
pub const acpi_s3pt_type_ACPI_S3PT_TYPE_SUSPEND: acpi_s3pt_type = 1;
pub const acpi_s3pt_type_ACPI_FPDT_BOOT_PERFORMANCE: acpi_s3pt_type = 2;
pub type acpi_s3pt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_s3pt_resume {
    pub header: acpi_fpdt_header,
    pub resume_count: u32_,
    pub full_resume: u64_,
    pub average_resume: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_s3pt_suspend {
    pub header: acpi_fpdt_header,
    pub suspend_start: u64_,
    pub suspend_end: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_fpdt_boot {
    pub header: acpi_fpdt_header,
    pub reserved: [u8_; 4usize],
    pub reset_end: u64_,
    pub load_start: u64_,
    pub startup_start: u64_,
    pub exit_services_entry: u64_,
    pub exit_services_exit: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_gtdt {
    pub header: acpi_table_header,
    pub counter_block_addresss: u64_,
    pub reserved: u32_,
    pub secure_el1_interrupt: u32_,
    pub secure_el1_flags: u32_,
    pub non_secure_el1_interrupt: u32_,
    pub non_secure_el1_flags: u32_,
    pub virtual_timer_interrupt: u32_,
    pub virtual_timer_flags: u32_,
    pub non_secure_el2_interrupt: u32_,
    pub non_secure_el2_flags: u32_,
    pub counter_read_block_address: u64_,
    pub platform_timer_count: u32_,
    pub platform_timer_offset: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtdt_el2 {
    pub virtual_el2_timer_gsiv: u32_,
    pub virtual_el2_timer_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtdt_header {
    pub type_: u8_,
    pub length: u16_,
}
pub const acpi_gtdt_type_ACPI_GTDT_TYPE_TIMER_BLOCK: acpi_gtdt_type = 0;
pub const acpi_gtdt_type_ACPI_GTDT_TYPE_WATCHDOG: acpi_gtdt_type = 1;
pub const acpi_gtdt_type_ACPI_GTDT_TYPE_RESERVED: acpi_gtdt_type = 2;
pub type acpi_gtdt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtdt_timer_block {
    pub header: acpi_gtdt_header,
    pub reserved: u8_,
    pub block_address: u64_,
    pub timer_count: u32_,
    pub timer_offset: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtdt_timer_entry {
    pub frame_number: u8_,
    pub reserved: [u8_; 3usize],
    pub base_address: u64_,
    pub el0_base_address: u64_,
    pub timer_interrupt: u32_,
    pub timer_flags: u32_,
    pub virtual_timer_interrupt: u32_,
    pub virtual_timer_flags: u32_,
    pub common_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtdt_watchdog {
    pub header: acpi_gtdt_header,
    pub reserved: u8_,
    pub refresh_frame_address: u64_,
    pub control_frame_address: u64_,
    pub timer_interrupt: u32_,
    pub timer_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_hest {
    pub header: acpi_table_header,
    pub error_source_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_header {
    pub type_: u16_,
    pub source_id: u16_,
}
pub const acpi_hest_types_ACPI_HEST_TYPE_IA32_CHECK: acpi_hest_types = 0;
pub const acpi_hest_types_ACPI_HEST_TYPE_IA32_CORRECTED_CHECK: acpi_hest_types = 1;
pub const acpi_hest_types_ACPI_HEST_TYPE_IA32_NMI: acpi_hest_types = 2;
pub const acpi_hest_types_ACPI_HEST_TYPE_NOT_USED3: acpi_hest_types = 3;
pub const acpi_hest_types_ACPI_HEST_TYPE_NOT_USED4: acpi_hest_types = 4;
pub const acpi_hest_types_ACPI_HEST_TYPE_NOT_USED5: acpi_hest_types = 5;
pub const acpi_hest_types_ACPI_HEST_TYPE_AER_ROOT_PORT: acpi_hest_types = 6;
pub const acpi_hest_types_ACPI_HEST_TYPE_AER_ENDPOINT: acpi_hest_types = 7;
pub const acpi_hest_types_ACPI_HEST_TYPE_AER_BRIDGE: acpi_hest_types = 8;
pub const acpi_hest_types_ACPI_HEST_TYPE_GENERIC_ERROR: acpi_hest_types = 9;
pub const acpi_hest_types_ACPI_HEST_TYPE_GENERIC_ERROR_V2: acpi_hest_types = 10;
pub const acpi_hest_types_ACPI_HEST_TYPE_IA32_DEFERRED_CHECK: acpi_hest_types = 11;
pub const acpi_hest_types_ACPI_HEST_TYPE_RESERVED: acpi_hest_types = 12;
pub type acpi_hest_types = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_ia_error_bank {
    pub bank_number: u8_,
    pub clear_status_on_init: u8_,
    pub status_format: u8_,
    pub reserved: u8_,
    pub control_register: u32_,
    pub control_data: u64_,
    pub status_register: u32_,
    pub address_register: u32_,
    pub misc_register: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_aer_common {
    pub reserved1: u16_,
    pub flags: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub bus: u32_,
    pub device: u16_,
    pub function: u16_,
    pub device_control: u16_,
    pub reserved2: u16_,
    pub uncorrectable_mask: u32_,
    pub uncorrectable_severity: u32_,
    pub correctable_mask: u32_,
    pub advanced_capabilities: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_notify {
    pub type_: u8_,
    pub length: u8_,
    pub config_write_enable: u16_,
    pub poll_interval: u32_,
    pub vector: u32_,
    pub polling_threshold_value: u32_,
    pub polling_threshold_window: u32_,
    pub error_threshold_value: u32_,
    pub error_threshold_window: u32_,
}
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_POLLED: acpi_hest_notify_types = 0;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_EXTERNAL: acpi_hest_notify_types = 1;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_LOCAL: acpi_hest_notify_types = 2;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_SCI: acpi_hest_notify_types = 3;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_NMI: acpi_hest_notify_types = 4;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_CMCI: acpi_hest_notify_types = 5;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_MCE: acpi_hest_notify_types = 6;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_GPIO: acpi_hest_notify_types = 7;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_SEA: acpi_hest_notify_types = 8;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_SEI: acpi_hest_notify_types = 9;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_GSIV: acpi_hest_notify_types = 10;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED: acpi_hest_notify_types = 11;
pub const acpi_hest_notify_types_ACPI_HEST_NOTIFY_RESERVED: acpi_hest_notify_types = 12;
pub type acpi_hest_notify_types = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_ia_machine_check {
    pub header: acpi_hest_header,
    pub reserved1: u16_,
    pub flags: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub global_capability_data: u64_,
    pub global_control_data: u64_,
    pub num_hardware_banks: u8_,
    pub reserved3: [u8_; 7usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_ia_corrected {
    pub header: acpi_hest_header,
    pub reserved1: u16_,
    pub flags: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub notify: acpi_hest_notify,
    pub num_hardware_banks: u8_,
    pub reserved2: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_ia_nmi {
    pub header: acpi_hest_header,
    pub reserved: u32_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub max_raw_data_length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_aer_root {
    pub header: acpi_hest_header,
    pub aer: acpi_hest_aer_common,
    pub root_error_command: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_aer {
    pub header: acpi_hest_header,
    pub aer: acpi_hest_aer_common,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_aer_bridge {
    pub header: acpi_hest_header,
    pub aer: acpi_hest_aer_common,
    pub uncorrectable_mask2: u32_,
    pub uncorrectable_severity2: u32_,
    pub advanced_capabilities2: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_generic {
    pub header: acpi_hest_header,
    pub related_source_id: u16_,
    pub reserved: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub max_raw_data_length: u32_,
    pub error_status_address: acpi_generic_address,
    pub notify: acpi_hest_notify,
    pub error_block_length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_generic_v2 {
    pub header: acpi_hest_header,
    pub related_source_id: u16_,
    pub reserved: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub max_raw_data_length: u32_,
    pub error_status_address: acpi_generic_address,
    pub notify: acpi_hest_notify,
    pub error_block_length: u32_,
    pub read_ack_register: acpi_generic_address,
    pub read_ack_preserve: u64_,
    pub read_ack_write: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_generic_status {
    pub block_status: u32_,
    pub raw_data_offset: u32_,
    pub raw_data_length: u32_,
    pub data_length: u32_,
    pub error_severity: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_generic_data {
    pub section_type: [u8_; 16usize],
    pub error_severity: u32_,
    pub revision: u16_,
    pub validation_bits: u8_,
    pub flags: u8_,
    pub error_data_length: u32_,
    pub fru_id: [u8_; 16usize],
    pub fru_text: [u8_; 20usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_generic_data_v300 {
    pub section_type: [u8_; 16usize],
    pub error_severity: u32_,
    pub revision: u16_,
    pub validation_bits: u8_,
    pub flags: u8_,
    pub error_data_length: u32_,
    pub fru_id: [u8_; 16usize],
    pub fru_text: [u8_; 20usize],
    pub time_stamp: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hest_ia_deferred_check {
    pub header: acpi_hest_header,
    pub reserved1: u16_,
    pub flags: u8_,
    pub enabled: u8_,
    pub records_to_preallocate: u32_,
    pub max_sections_per_record: u32_,
    pub notify: acpi_hest_notify,
    pub num_hardware_banks: u8_,
    pub reserved2: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_hmat {
    pub header: acpi_table_header,
    pub reserved: u32_,
}
pub const acpi_hmat_type_ACPI_HMAT_TYPE_PROXIMITY: acpi_hmat_type = 0;
pub const acpi_hmat_type_ACPI_HMAT_TYPE_LOCALITY: acpi_hmat_type = 1;
pub const acpi_hmat_type_ACPI_HMAT_TYPE_CACHE: acpi_hmat_type = 2;
pub const acpi_hmat_type_ACPI_HMAT_TYPE_RESERVED: acpi_hmat_type = 3;
pub type acpi_hmat_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hmat_structure {
    pub type_: u16_,
    pub reserved: u16_,
    pub length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hmat_proximity_domain {
    pub header: acpi_hmat_structure,
    pub flags: u16_,
    pub reserved1: u16_,
    pub processor_PD: u32_,
    pub memory_PD: u32_,
    pub reserved2: u32_,
    pub reserved3: u64_,
    pub reserved4: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hmat_locality {
    pub header: acpi_hmat_structure,
    pub flags: u8_,
    pub data_type: u8_,
    pub min_transfer_size: u8_,
    pub reserved1: u8_,
    pub number_of_initiator_Pds: u32_,
    pub number_of_target_Pds: u32_,
    pub reserved2: u32_,
    pub entry_base_unit: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_hmat_cache {
    pub header: acpi_hmat_structure,
    pub memory_PD: u32_,
    pub reserved1: u32_,
    pub cache_size: u64_,
    pub cache_attributes: u32_,
    pub address_mode: u16_,
    pub number_of_SMBIOShandles: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_hpet {
    pub header: acpi_table_header,
    pub id: u32_,
    pub address: acpi_generic_address,
    pub sequence: u8_,
    pub minimum_tick: u16_,
    pub flags: u8_,
}
pub const acpi_hpet_page_protect_ACPI_HPET_NO_PAGE_PROTECT: acpi_hpet_page_protect = 0;
pub const acpi_hpet_page_protect_ACPI_HPET_PAGE_PROTECT4: acpi_hpet_page_protect = 1;
pub const acpi_hpet_page_protect_ACPI_HPET_PAGE_PROTECT64: acpi_hpet_page_protect = 2;
pub type acpi_hpet_page_protect = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_ibft {
    pub header: acpi_table_header,
    pub reserved: [u8_; 12usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ibft_header {
    pub type_: u8_,
    pub version: u8_,
    pub length: u16_,
    pub index: u8_,
    pub flags: u8_,
}
pub const acpi_ibft_type_ACPI_IBFT_TYPE_NOT_USED: acpi_ibft_type = 0;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_CONTROL: acpi_ibft_type = 1;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_INITIATOR: acpi_ibft_type = 2;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_NIC: acpi_ibft_type = 3;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_TARGET: acpi_ibft_type = 4;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_EXTENSIONS: acpi_ibft_type = 5;
pub const acpi_ibft_type_ACPI_IBFT_TYPE_RESERVED: acpi_ibft_type = 6;
pub type acpi_ibft_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ibft_control {
    pub header: acpi_ibft_header,
    pub extensions: u16_,
    pub initiator_offset: u16_,
    pub nic0_offset: u16_,
    pub target0_offset: u16_,
    pub nic1_offset: u16_,
    pub target1_offset: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ibft_initiator {
    pub header: acpi_ibft_header,
    pub sns_server: [u8_; 16usize],
    pub slp_server: [u8_; 16usize],
    pub primary_server: [u8_; 16usize],
    pub secondary_server: [u8_; 16usize],
    pub name_length: u16_,
    pub name_offset: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ibft_nic {
    pub header: acpi_ibft_header,
    pub ip_address: [u8_; 16usize],
    pub subnet_mask_prefix: u8_,
    pub origin: u8_,
    pub gateway: [u8_; 16usize],
    pub primary_dns: [u8_; 16usize],
    pub secondary_dns: [u8_; 16usize],
    pub dhcp: [u8_; 16usize],
    pub vlan: u16_,
    pub mac_address: [u8_; 6usize],
    pub pci_address: u16_,
    pub name_length: u16_,
    pub name_offset: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ibft_target {
    pub header: acpi_ibft_header,
    pub target_ip_address: [u8_; 16usize],
    pub target_ip_socket: u16_,
    pub target_boot_lun: [u8_; 8usize],
    pub chap_type: u8_,
    pub nic_association: u8_,
    pub target_name_length: u16_,
    pub target_name_offset: u16_,
    pub chap_name_length: u16_,
    pub chap_name_offset: u16_,
    pub chap_secret_length: u16_,
    pub chap_secret_offset: u16_,
    pub reverse_chap_name_length: u16_,
    pub reverse_chap_name_offset: u16_,
    pub reverse_chap_secret_length: u16_,
    pub reverse_chap_secret_offset: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_aest {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_hdr {
    pub type_: u8_,
    pub length: u16_,
    pub reserved: u8_,
    pub node_specific_offset: u32_,
    pub node_interface_offset: u32_,
    pub node_interrupt_offset: u32_,
    pub node_interrupt_count: u32_,
    pub timestamp_rate: u64_,
    pub reserved1: u64_,
    pub error_injection_rate: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_processor {
    pub processor_id: u32_,
    pub resource_type: u8_,
    pub reserved: u8_,
    pub flags: u8_,
    pub revision: u8_,
    pub processor_affinity: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_processor_cache {
    pub cache_reference: u32_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_processor_tlb {
    pub tlb_level: u32_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_processor_generic {
    pub resource: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_memory {
    pub srat_proximity_domain: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_smmu {
    pub iort_node_reference: u32_,
    pub subcomponent_reference: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_vendor {
    pub acpi_hid: u32_,
    pub acpi_uid: u32_,
    pub vendor_specific_data: [u8_; 16usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_vendor_v2 {
    pub acpi_hid: [ffi::c_char; 8usize],
    pub acpi_uid: u32_,
    pub vendor_specific_data: [u8_; 16usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_gic {
    pub interface_type: u32_,
    pub instance_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_pcie {
    pub iort_node_reference: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_proxy {
    pub node_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface {
    pub type_: u8_,
    pub reserved: [u8_; 3usize],
    pub flags: u32_,
    pub address: u64_,
    pub error_record_index: u32_,
    pub error_record_count: u32_,
    pub error_record_implemented: u64_,
    pub error_status_reporting: u64_,
    pub addressing_mode: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface_header {
    pub type_: u8_,
    pub group_format: u8_,
    pub reserved: [u8_; 2usize],
    pub flags: u32_,
    pub address: u64_,
    pub error_record_index: u32_,
    pub error_record_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface_common {
    pub error_node_device: u32_,
    pub processor_affinity: u32_,
    pub error_group_register_base: u64_,
    pub fault_inject_register_base: u64_,
    pub interrupt_config_register_base: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface_4k {
    pub error_record_implemented: u64_,
    pub error_status_reporting: u64_,
    pub addressing_mode: u64_,
    pub common: acpi_aest_node_interface_common,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface_16k {
    pub error_record_implemented: [u64_; 4usize],
    pub error_status_reporting: [u64_; 4usize],
    pub addressing_mode: [u64_; 4usize],
    pub common: acpi_aest_node_interface_common,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interface_64k {
    pub error_record_implemented: [u64_; 14usize],
    pub error_status_reporting: [u64_; 14usize],
    pub addressing_mode: [u64_; 14usize],
    pub common: acpi_aest_node_interface_common,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interrupt {
    pub type_: u8_,
    pub reserved: [u8_; 2usize],
    pub flags: u8_,
    pub gsiv: u32_,
    pub iort_id: u8_,
    pub reserved1: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_aest_node_interrupt_v2 {
    pub type_: u8_,
    pub reserved: [u8_; 2usize],
    pub flags: u8_,
    pub gsiv: u32_,
    pub reserved1: [u8_; 4usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_agdi {
    pub header: acpi_table_header,
    pub flags: u8_,
    pub reserved: [u8_; 3usize],
    pub sdei_event: u32_,
    pub gsiv: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_apmt {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_apmt_node {
    pub length: u16_,
    pub flags: u8_,
    pub type_: u8_,
    pub id: u32_,
    pub inst_primary: u64_,
    pub inst_secondary: u32_,
    pub base_address0: u64_,
    pub base_address1: u64_,
    pub ovflw_irq: u32_,
    pub reserved: u32_,
    pub ovflw_irq_flags: u32_,
    pub proc_affinity: u32_,
    pub impl_id: u32_,
}
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_MC: acpi_apmt_node_type = 0;
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_SMMU: acpi_apmt_node_type = 1;
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_PCIE_ROOT: acpi_apmt_node_type = 2;
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_ACPI: acpi_apmt_node_type = 3;
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_CACHE: acpi_apmt_node_type = 4;
pub const acpi_apmt_node_type_ACPI_APMT_NODE_TYPE_COUNT: acpi_apmt_node_type = 5;
pub type acpi_apmt_node_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_bdat {
    pub header: acpi_table_header,
    pub gas: acpi_generic_address,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_ccel {
    pub header: acpi_table_header,
    pub CCtype: u8_,
    pub Ccsub_type: u8_,
    pub reserved: u16_,
    pub log_area_minimum_length: u64_,
    pub log_area_start_address: u64_,
}
#[repr(C, packed)]
pub struct acpi_table_erdt {
    pub header: acpi_table_header,
    pub max_clos: u32_,
    pub reserved: [u8_; 24usize],
    pub erdt_substructures: __IncompleteArrayField<u8_>,
}
impl Default for acpi_table_erdt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const acpi_erdt_type_ACPI_ERDT_TYPE_RMDD: acpi_erdt_type = 0;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_CACD: acpi_erdt_type = 1;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_DACD: acpi_erdt_type = 2;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_CMRC: acpi_erdt_type = 3;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_MMRC: acpi_erdt_type = 4;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_MARC: acpi_erdt_type = 5;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_CARC: acpi_erdt_type = 6;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_CMRD: acpi_erdt_type = 7;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_IBRD: acpi_erdt_type = 8;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_IBAD: acpi_erdt_type = 9;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_CARD: acpi_erdt_type = 10;
pub const acpi_erdt_type_ACPI_ERDT_TYPE_RESERVED: acpi_erdt_type = 11;
pub type acpi_erdt_type = ffi::c_uint;
#[repr(C, packed)]
pub struct acpi_erdt_rmdd {
    pub header: acpi_subtbl_hdr_16,
    pub flags: u16_,
    pub IO_l3_slices: u16_,
    pub IO_l3_sets: u8_,
    pub IO_l3_ways: u8_,
    pub reserved: u64_,
    pub domain_id: u16_,
    pub max_rmid: u32_,
    pub creg_base: u64_,
    pub creg_size: u16_,
    pub rmdd_structs: __IncompleteArrayField<u8_>,
}
impl Default for acpi_erdt_rmdd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_erdt_cacd {
    pub header: acpi_subtbl_hdr_16,
    pub reserved: u16_,
    pub domain_id: u16_,
    pub X2APICIDS: __IncompleteArrayField<u32_>,
}
impl Default for acpi_erdt_cacd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_erdt_dacd {
    pub header: acpi_subtbl_hdr_16,
    pub reserved: u16_,
    pub domain_id: u16_,
    pub dev_paths: __IncompleteArrayField<u8_>,
}
impl Default for acpi_erdt_dacd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_erdt_dacd_dev_paths {
    pub header: acpi_subtable_header,
    pub segment: u16_,
    pub reserved: u8_,
    pub start_bus: u8_,
    pub path: __IncompleteArrayField<u8_>,
}
impl Default for acpi_erdt_dacd_dev_paths {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_cmrc {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u32_,
    pub flags: u32_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 11usize],
    pub cmt_reg_base: u64_,
    pub cmt_reg_size: u32_,
    pub clump_size: u16_,
    pub clump_stride: u16_,
    pub up_scale: u64_,
}
#[repr(C, packed)]
pub struct acpi_erdt_mmrc {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u32_,
    pub flags: u32_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 11usize],
    pub reg_base: u64_,
    pub reg_size: u32_,
    pub counter_width: u8_,
    pub up_scale: u64_,
    pub reserved3: [u8_; 7usize],
    pub corr_factor_list_len: u32_,
    pub corr_factor_list: __IncompleteArrayField<u32_>,
}
impl Default for acpi_erdt_mmrc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_marc {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u16_,
    pub flags: u16_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 7usize],
    pub reg_base_opt: u64_,
    pub reg_base_min: u64_,
    pub reg_base_max: u64_,
    pub mba_reg_size: u32_,
    pub mba_ctrl_range: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_carc {
    pub header: acpi_subtbl_hdr_16,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_cmrd {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u32_,
    pub flags: u32_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 11usize],
    pub reg_base: u64_,
    pub reg_size: u32_,
    pub cmt_reg_off: u16_,
    pub cmt_clump_size: u16_,
    pub up_scale: u64_,
}
#[repr(C, packed)]
pub struct acpi_erdt_ibrd {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u32_,
    pub flags: u32_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 11usize],
    pub reg_base: u64_,
    pub reg_size: u32_,
    pub total_bw_offset: u16_,
    pub Iomiss_bw_offset: u16_,
    pub total_bw_clump: u16_,
    pub Iomiss_bw_clump: u16_,
    pub reserved3: [u8_; 7usize],
    pub counter_width: u8_,
    pub up_scale: u64_,
    pub corr_factor_list_len: u32_,
    pub corr_factor_list: __IncompleteArrayField<u32_>,
}
impl Default for acpi_erdt_ibrd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_ibad {
    pub header: acpi_subtbl_hdr_16,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_erdt_card {
    pub header: acpi_subtbl_hdr_16,
    pub reserved1: u32_,
    pub flags: u32_,
    pub contention_mask: u32_,
    pub index_fn: u8_,
    pub reserved2: [u8_; 7usize],
    pub reg_base: u64_,
    pub reg_size: u32_,
    pub cat_reg_offset: u16_,
    pub cat_reg_block_size: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_iort {
    pub header: acpi_table_header,
    pub node_count: u32_,
    pub node_offset: u32_,
    pub reserved: u32_,
}
#[repr(C, packed)]
pub struct acpi_iort_node {
    pub type_: u8_,
    pub length: u16_,
    pub revision: u8_,
    pub identifier: u32_,
    pub mapping_count: u32_,
    pub mapping_offset: u32_,
    pub node_data: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_iort_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const acpi_iort_node_type_ACPI_IORT_NODE_ITS_GROUP: acpi_iort_node_type = 0;
pub const acpi_iort_node_type_ACPI_IORT_NODE_NAMED_COMPONENT: acpi_iort_node_type = 1;
pub const acpi_iort_node_type_ACPI_IORT_NODE_PCI_ROOT_COMPLEX: acpi_iort_node_type = 2;
pub const acpi_iort_node_type_ACPI_IORT_NODE_SMMU: acpi_iort_node_type = 3;
pub const acpi_iort_node_type_ACPI_IORT_NODE_SMMU_V3: acpi_iort_node_type = 4;
pub const acpi_iort_node_type_ACPI_IORT_NODE_PMCG: acpi_iort_node_type = 5;
pub const acpi_iort_node_type_ACPI_IORT_NODE_RMR: acpi_iort_node_type = 6;
pub type acpi_iort_node_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_id_mapping {
    pub input_base: u32_,
    pub id_count: u32_,
    pub output_base: u32_,
    pub output_reference: u32_,
    pub flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_memory_access {
    pub cache_coherency: u32_,
    pub hints: u8_,
    pub reserved: u16_,
    pub memory_flags: u8_,
}
#[repr(C, packed)]
pub struct acpi_iort_its_group {
    pub its_count: u32_,
    pub identifiers: __IncompleteArrayField<u32_>,
}
impl Default for acpi_iort_its_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_iort_named_component {
    pub node_flags: u32_,
    pub memory_properties: u64_,
    pub memory_address_limit: u8_,
    pub device_name: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_iort_named_component {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_iort_root_complex {
    pub memory_properties: u64_,
    pub ats_attribute: u32_,
    pub pci_segment_number: u32_,
    pub memory_address_limit: u8_,
    pub pasid_capabilities: u16_,
    pub reserved: __IncompleteArrayField<u8_>,
}
impl Default for acpi_iort_root_complex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_iort_smmu {
    pub base_address: u64_,
    pub span: u64_,
    pub model: u32_,
    pub flags: u32_,
    pub global_interrupt_offset: u32_,
    pub context_interrupt_count: u32_,
    pub context_interrupt_offset: u32_,
    pub pmu_interrupt_count: u32_,
    pub pmu_interrupt_offset: u32_,
    pub interrupts: __IncompleteArrayField<u64_>,
}
impl Default for acpi_iort_smmu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_smmu_gsi {
    pub nsg_irpt: u32_,
    pub nsg_irpt_flags: u32_,
    pub nsg_cfg_irpt: u32_,
    pub nsg_cfg_irpt_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_smmu_v3 {
    pub base_address: u64_,
    pub flags: u32_,
    pub reserved: u32_,
    pub vatos_address: u64_,
    pub model: u32_,
    pub event_gsiv: u32_,
    pub pri_gsiv: u32_,
    pub gerr_gsiv: u32_,
    pub sync_gsiv: u32_,
    pub pxm: u32_,
    pub id_mapping_index: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_pmcg {
    pub page0_base_address: u64_,
    pub overflow_gsiv: u32_,
    pub node_reference: u32_,
    pub page1_base_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_rmr {
    pub flags: u32_,
    pub rmr_count: u32_,
    pub rmr_offset: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_iort_rmr_desc {
    pub base_address: u64_,
    pub length: u64_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_ivrs {
    pub header: acpi_table_header,
    pub info: u32_,
    pub reserved: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_header {
    pub type_: u8_,
    pub flags: u8_,
    pub length: u16_,
    pub device_id: u16_,
}
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_HARDWARE1: acpi_ivrs_type = 16;
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_HARDWARE2: acpi_ivrs_type = 17;
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_HARDWARE3: acpi_ivrs_type = 64;
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_MEMORY1: acpi_ivrs_type = 32;
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_MEMORY2: acpi_ivrs_type = 33;
pub const acpi_ivrs_type_ACPI_IVRS_TYPE_MEMORY3: acpi_ivrs_type = 34;
pub type acpi_ivrs_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_hardware_10 {
    pub header: acpi_ivrs_header,
    pub capability_offset: u16_,
    pub base_address: u64_,
    pub pci_segment_group: u16_,
    pub info: u16_,
    pub feature_reporting: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_hardware_11 {
    pub header: acpi_ivrs_header,
    pub capability_offset: u16_,
    pub base_address: u64_,
    pub pci_segment_group: u16_,
    pub info: u16_,
    pub attributes: u32_,
    pub efr_register_image: u64_,
    pub reserved: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_de_header {
    pub type_: u8_,
    pub id: u16_,
    pub data_setting: u8_,
}
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_PAD4: acpi_ivrs_device_entry_type = 0;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_ALL: acpi_ivrs_device_entry_type = 1;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_SELECT: acpi_ivrs_device_entry_type = 2;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_START: acpi_ivrs_device_entry_type = 3;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_END: acpi_ivrs_device_entry_type = 4;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_PAD8: acpi_ivrs_device_entry_type = 64;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_NOT_USED: acpi_ivrs_device_entry_type = 65;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_ALIAS_SELECT: acpi_ivrs_device_entry_type = 66;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_ALIAS_START: acpi_ivrs_device_entry_type = 67;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_EXT_SELECT: acpi_ivrs_device_entry_type = 70;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_EXT_START: acpi_ivrs_device_entry_type = 71;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_SPECIAL: acpi_ivrs_device_entry_type = 72;
pub const acpi_ivrs_device_entry_type_ACPI_IVRS_TYPE_HID: acpi_ivrs_device_entry_type = 240;
pub type acpi_ivrs_device_entry_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_device4 {
    pub header: acpi_ivrs_de_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_device8a {
    pub header: acpi_ivrs_de_header,
    pub reserved1: u8_,
    pub used_id: u16_,
    pub reserved2: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_device8b {
    pub header: acpi_ivrs_de_header,
    pub extended_data: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_device8c {
    pub header: acpi_ivrs_de_header,
    pub handle: u8_,
    pub used_id: u16_,
    pub variety: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_device_hid {
    pub header: acpi_ivrs_de_header,
    pub acpi_hid: u64_,
    pub acpi_cid: u64_,
    pub uid_type: u8_,
    pub uid_length: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ivrs_memory {
    pub header: acpi_ivrs_header,
    pub aux_data: u16_,
    pub reserved: u64_,
    pub start_address: u64_,
    pub memory_length: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_lpit {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_lpit_header {
    pub type_: u32_,
    pub length: u32_,
    pub unique_id: u16_,
    pub reserved: u16_,
    pub flags: u32_,
}
pub const acpi_lpit_type_ACPI_LPIT_TYPE_NATIVE_CSTATE: acpi_lpit_type = 0;
pub const acpi_lpit_type_ACPI_LPIT_TYPE_RESERVED: acpi_lpit_type = 1;
pub type acpi_lpit_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_lpit_native {
    pub header: acpi_lpit_header,
    pub entry_trigger: acpi_generic_address,
    pub residency: u32_,
    pub latency: u32_,
    pub residency_counter: acpi_generic_address,
    pub counter_frequency: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_madt {
    pub header: acpi_table_header,
    pub address: u32_,
    pub flags: u32_,
}
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_APIC: acpi_madt_type = 0;
pub const acpi_madt_type_ACPI_MADT_TYPE_IO_APIC: acpi_madt_type = 1;
pub const acpi_madt_type_ACPI_MADT_TYPE_INTERRUPT_OVERRIDE: acpi_madt_type = 2;
pub const acpi_madt_type_ACPI_MADT_TYPE_NMI_SOURCE: acpi_madt_type = 3;
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_APIC_NMI: acpi_madt_type = 4;
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE: acpi_madt_type = 5;
pub const acpi_madt_type_ACPI_MADT_TYPE_IO_SAPIC: acpi_madt_type = 6;
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_SAPIC: acpi_madt_type = 7;
pub const acpi_madt_type_ACPI_MADT_TYPE_INTERRUPT_SOURCE: acpi_madt_type = 8;
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_X2APIC: acpi_madt_type = 9;
pub const acpi_madt_type_ACPI_MADT_TYPE_LOCAL_X2APIC_NMI: acpi_madt_type = 10;
pub const acpi_madt_type_ACPI_MADT_TYPE_GENERIC_INTERRUPT: acpi_madt_type = 11;
pub const acpi_madt_type_ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR: acpi_madt_type = 12;
pub const acpi_madt_type_ACPI_MADT_TYPE_GENERIC_MSI_FRAME: acpi_madt_type = 13;
pub const acpi_madt_type_ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR: acpi_madt_type = 14;
pub const acpi_madt_type_ACPI_MADT_TYPE_GENERIC_TRANSLATOR: acpi_madt_type = 15;
pub const acpi_madt_type_ACPI_MADT_TYPE_MULTIPROC_WAKEUP: acpi_madt_type = 16;
pub const acpi_madt_type_ACPI_MADT_TYPE_CORE_PIC: acpi_madt_type = 17;
pub const acpi_madt_type_ACPI_MADT_TYPE_LIO_PIC: acpi_madt_type = 18;
pub const acpi_madt_type_ACPI_MADT_TYPE_HT_PIC: acpi_madt_type = 19;
pub const acpi_madt_type_ACPI_MADT_TYPE_EIO_PIC: acpi_madt_type = 20;
pub const acpi_madt_type_ACPI_MADT_TYPE_MSI_PIC: acpi_madt_type = 21;
pub const acpi_madt_type_ACPI_MADT_TYPE_BIO_PIC: acpi_madt_type = 22;
pub const acpi_madt_type_ACPI_MADT_TYPE_LPC_PIC: acpi_madt_type = 23;
pub const acpi_madt_type_ACPI_MADT_TYPE_RINTC: acpi_madt_type = 24;
pub const acpi_madt_type_ACPI_MADT_TYPE_IMSIC: acpi_madt_type = 25;
pub const acpi_madt_type_ACPI_MADT_TYPE_APLIC: acpi_madt_type = 26;
pub const acpi_madt_type_ACPI_MADT_TYPE_PLIC: acpi_madt_type = 27;
pub const acpi_madt_type_ACPI_MADT_TYPE_RESERVED: acpi_madt_type = 28;
pub const acpi_madt_type_ACPI_MADT_TYPE_OEM_RESERVED: acpi_madt_type = 128;
pub type acpi_madt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_local_apic {
    pub header: acpi_subtable_header,
    pub processor_id: u8_,
    pub id: u8_,
    pub lapic_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_io_apic {
    pub header: acpi_subtable_header,
    pub id: u8_,
    pub reserved: u8_,
    pub address: u32_,
    pub global_irq_base: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_interrupt_override {
    pub header: acpi_subtable_header,
    pub bus: u8_,
    pub source_irq: u8_,
    pub global_irq: u32_,
    pub inti_flags: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_nmi_source {
    pub header: acpi_subtable_header,
    pub inti_flags: u16_,
    pub global_irq: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_local_apic_nmi {
    pub header: acpi_subtable_header,
    pub processor_id: u8_,
    pub inti_flags: u16_,
    pub lint: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_local_apic_override {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_io_sapic {
    pub header: acpi_subtable_header,
    pub id: u8_,
    pub reserved: u8_,
    pub global_irq_base: u32_,
    pub address: u64_,
}
#[repr(C, packed)]
pub struct acpi_madt_local_sapic {
    pub header: acpi_subtable_header,
    pub processor_id: u8_,
    pub id: u8_,
    pub eid: u8_,
    pub reserved: [u8_; 3usize],
    pub lapic_flags: u32_,
    pub uid: u32_,
    pub uid_string: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_madt_local_sapic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_interrupt_source {
    pub header: acpi_subtable_header,
    pub inti_flags: u16_,
    pub type_: u8_,
    pub id: u8_,
    pub eid: u8_,
    pub io_sapic_vector: u8_,
    pub global_irq: u32_,
    pub flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_local_x2apic {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub local_apic_id: u32_,
    pub lapic_flags: u32_,
    pub uid: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_local_x2apic_nmi {
    pub header: acpi_subtable_header,
    pub inti_flags: u16_,
    pub uid: u32_,
    pub lint: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_generic_interrupt {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub cpu_interface_number: u32_,
    pub uid: u32_,
    pub flags: u32_,
    pub parking_version: u32_,
    pub performance_interrupt: u32_,
    pub parked_address: u64_,
    pub base_address: u64_,
    pub gicv_base_address: u64_,
    pub gich_base_address: u64_,
    pub vgic_interrupt: u32_,
    pub gicr_base_address: u64_,
    pub arm_mpidr: u64_,
    pub efficiency_class: u8_,
    pub reserved2: [u8_; 1usize],
    pub spe_interrupt: u16_,
    pub trbe_interrupt: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_generic_distributor {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub gic_id: u32_,
    pub base_address: u64_,
    pub global_irq_base: u32_,
    pub version: u8_,
    pub reserved2: [u8_; 3usize],
}
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_NONE: acpi_madt_gic_version = 0;
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_V1: acpi_madt_gic_version = 1;
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_V2: acpi_madt_gic_version = 2;
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_V3: acpi_madt_gic_version = 3;
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_V4: acpi_madt_gic_version = 4;
pub const acpi_madt_gic_version_ACPI_MADT_GIC_VERSION_RESERVED: acpi_madt_gic_version = 5;
pub type acpi_madt_gic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_generic_msi_frame {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub msi_frame_id: u32_,
    pub base_address: u64_,
    pub flags: u32_,
    pub spi_count: u16_,
    pub spi_base: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_generic_redistributor {
    pub header: acpi_subtable_header,
    pub flags: u8_,
    pub reserved: u8_,
    pub base_address: u64_,
    pub length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_generic_translator {
    pub header: acpi_subtable_header,
    pub flags: u8_,
    pub reserved: u8_,
    pub translation_id: u32_,
    pub base_address: u64_,
    pub reserved2: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_multiproc_wakeup {
    pub header: acpi_subtable_header,
    pub version: u16_,
    pub reserved: u32_,
    pub mailbox_address: u64_,
    pub reset_vector: u64_,
}
pub const acpi_madt_multiproc_wakeup_version_ACPI_MADT_MP_WAKEUP_VERSION_NONE:
    acpi_madt_multiproc_wakeup_version = 0;
pub const acpi_madt_multiproc_wakeup_version_ACPI_MADT_MP_WAKEUP_VERSION_V1:
    acpi_madt_multiproc_wakeup_version = 1;
pub const acpi_madt_multiproc_wakeup_version_ACPI_MADT_MP_WAKEUP_VERSION_RESERVED:
    acpi_madt_multiproc_wakeup_version = 2;
pub type acpi_madt_multiproc_wakeup_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_madt_multiproc_wakeup_mailbox {
    pub command: u16_,
    pub reserved: u16_,
    pub apic_id: u32_,
    pub wakeup_vector: u64_,
    pub reserved_os: [u8_; 2032usize],
    pub reserved_firmware: [u8_; 2048usize],
}
impl Default for acpi_madt_multiproc_wakeup_mailbox {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_core_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub processor_id: u32_,
    pub core_id: u32_,
    pub flags: u32_,
}
pub const acpi_madt_core_pic_version_ACPI_MADT_CORE_PIC_VERSION_NONE: acpi_madt_core_pic_version =
    0;
pub const acpi_madt_core_pic_version_ACPI_MADT_CORE_PIC_VERSION_V1: acpi_madt_core_pic_version = 1;
pub const acpi_madt_core_pic_version_ACPI_MADT_CORE_PIC_VERSION_RESERVED:
    acpi_madt_core_pic_version = 2;
pub type acpi_madt_core_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_lio_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub address: u64_,
    pub size: u16_,
    pub cascade: [u8_; 2usize],
    pub cascade_map: [u32_; 2usize],
}
pub const acpi_madt_lio_pic_version_ACPI_MADT_LIO_PIC_VERSION_NONE: acpi_madt_lio_pic_version = 0;
pub const acpi_madt_lio_pic_version_ACPI_MADT_LIO_PIC_VERSION_V1: acpi_madt_lio_pic_version = 1;
pub const acpi_madt_lio_pic_version_ACPI_MADT_LIO_PIC_VERSION_RESERVED: acpi_madt_lio_pic_version =
    2;
pub type acpi_madt_lio_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_ht_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub address: u64_,
    pub size: u16_,
    pub cascade: [u8_; 8usize],
}
pub const acpi_madt_ht_pic_version_ACPI_MADT_HT_PIC_VERSION_NONE: acpi_madt_ht_pic_version = 0;
pub const acpi_madt_ht_pic_version_ACPI_MADT_HT_PIC_VERSION_V1: acpi_madt_ht_pic_version = 1;
pub const acpi_madt_ht_pic_version_ACPI_MADT_HT_PIC_VERSION_RESERVED: acpi_madt_ht_pic_version = 2;
pub type acpi_madt_ht_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_eio_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub cascade: u8_,
    pub node: u8_,
    pub node_map: u64_,
}
pub const acpi_madt_eio_pic_version_ACPI_MADT_EIO_PIC_VERSION_NONE: acpi_madt_eio_pic_version = 0;
pub const acpi_madt_eio_pic_version_ACPI_MADT_EIO_PIC_VERSION_V1: acpi_madt_eio_pic_version = 1;
pub const acpi_madt_eio_pic_version_ACPI_MADT_EIO_PIC_VERSION_RESERVED: acpi_madt_eio_pic_version =
    2;
pub type acpi_madt_eio_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_msi_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub msg_address: u64_,
    pub start: u32_,
    pub count: u32_,
}
pub const acpi_madt_msi_pic_version_ACPI_MADT_MSI_PIC_VERSION_NONE: acpi_madt_msi_pic_version = 0;
pub const acpi_madt_msi_pic_version_ACPI_MADT_MSI_PIC_VERSION_V1: acpi_madt_msi_pic_version = 1;
pub const acpi_madt_msi_pic_version_ACPI_MADT_MSI_PIC_VERSION_RESERVED: acpi_madt_msi_pic_version =
    2;
pub type acpi_madt_msi_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_bio_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub address: u64_,
    pub size: u16_,
    pub id: u16_,
    pub gsi_base: u16_,
}
pub const acpi_madt_bio_pic_version_ACPI_MADT_BIO_PIC_VERSION_NONE: acpi_madt_bio_pic_version = 0;
pub const acpi_madt_bio_pic_version_ACPI_MADT_BIO_PIC_VERSION_V1: acpi_madt_bio_pic_version = 1;
pub const acpi_madt_bio_pic_version_ACPI_MADT_BIO_PIC_VERSION_RESERVED: acpi_madt_bio_pic_version =
    2;
pub type acpi_madt_bio_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_lpc_pic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub address: u64_,
    pub size: u16_,
    pub cascade: u8_,
}
pub const acpi_madt_lpc_pic_version_ACPI_MADT_LPC_PIC_VERSION_NONE: acpi_madt_lpc_pic_version = 0;
pub const acpi_madt_lpc_pic_version_ACPI_MADT_LPC_PIC_VERSION_V1: acpi_madt_lpc_pic_version = 1;
pub const acpi_madt_lpc_pic_version_ACPI_MADT_LPC_PIC_VERSION_RESERVED: acpi_madt_lpc_pic_version =
    2;
pub type acpi_madt_lpc_pic_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_rintc {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub reserved: u8_,
    pub flags: u32_,
    pub hart_id: u64_,
    pub uid: u32_,
    pub ext_intc_id: u32_,
    pub imsic_addr: u64_,
    pub imsic_size: u32_,
}
pub const acpi_madt_rintc_version_ACPI_MADT_RINTC_VERSION_NONE: acpi_madt_rintc_version = 0;
pub const acpi_madt_rintc_version_ACPI_MADT_RINTC_VERSION_V1: acpi_madt_rintc_version = 1;
pub const acpi_madt_rintc_version_ACPI_MADT_RINTC_VERSION_RESERVED: acpi_madt_rintc_version = 2;
pub type acpi_madt_rintc_version = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_imsic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub reserved: u8_,
    pub flags: u32_,
    pub num_ids: u16_,
    pub num_guest_ids: u16_,
    pub guest_index_bits: u8_,
    pub hart_index_bits: u8_,
    pub group_index_bits: u8_,
    pub group_index_shift: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_aplic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub id: u8_,
    pub flags: u32_,
    pub hw_id: [u8_; 8usize],
    pub num_idcs: u16_,
    pub num_sources: u16_,
    pub gsi_base: u32_,
    pub base_addr: u64_,
    pub size: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_plic {
    pub header: acpi_subtable_header,
    pub version: u8_,
    pub id: u8_,
    pub hw_id: [u8_; 8usize],
    pub num_irqs: u16_,
    pub max_prio: u16_,
    pub flags: u32_,
    pub size: u32_,
    pub base_addr: u64_,
    pub gsi_base: u32_,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_madt_oem_data {
    pub __bindgen_anon_1: acpi_madt_oem_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_madt_oem_data__bindgen_ty_1 {
    pub __Empty_oem_data: acpi_madt_oem_data__bindgen_ty_1__bindgen_ty_1,
    pub oem_data: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_madt_oem_data__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_mcfg {
    pub header: acpi_table_header,
    pub reserved: [u8_; 8usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mcfg_allocation {
    pub address: u64_,
    pub pci_segment: u16_,
    pub start_bus_number: u8_,
    pub end_bus_number: u8_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_mchi {
    pub header: acpi_table_header,
    pub interface_type: u8_,
    pub protocol: u8_,
    pub protocol_data: u64_,
    pub interrupt_type: u8_,
    pub gpe: u8_,
    pub pci_device_flag: u8_,
    pub global_interrupt: u32_,
    pub control_register: acpi_generic_address,
    pub pci_segment: u8_,
    pub pci_bus: u8_,
    pub pci_device: u8_,
    pub pci_function: u8_,
}
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_PROCESSOR_CACHE: acpi_mpam_locator_type =
    0;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_MEMORY: acpi_mpam_locator_type = 1;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_SMMU: acpi_mpam_locator_type = 2;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_MEMORY_CACHE: acpi_mpam_locator_type = 3;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_ACPI_DEVICE: acpi_mpam_locator_type = 4;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_INTERCONNECT: acpi_mpam_locator_type = 5;
pub const acpi_mpam_locator_type_ACPI_MPAM_LOCATION_TYPE_UNKNOWN: acpi_mpam_locator_type = 255;
pub type acpi_mpam_locator_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_func_deps {
    pub producer: u32_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_cache_locator {
    pub cache_reference: u64_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_memory_locator {
    pub proximity_domain: u64_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_smmu_locator {
    pub smmu_interface: u64_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_memcache_locator {
    pub reserved: [u8_; 7usize],
    pub level: u8_,
    pub reference: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_acpi_locator {
    pub acpi_hw_id: u64_,
    pub acpi_unique_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_interconnect_locator {
    pub inter_connect_desc_tbl_off: u64_,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_resource_generic_locator {
    pub descriptor1: u64_,
    pub descriptor2: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_mpam_resource_locator {
    pub cache_locator: acpi_mpam_resource_cache_locator,
    pub memory_locator: acpi_mpam_resource_memory_locator,
    pub smmu_locator: acpi_mpam_resource_smmu_locator,
    pub mem_cache_locator: acpi_mpam_resource_memcache_locator,
    pub acpi_locator: acpi_mpam_resource_acpi_locator,
    pub interconnect_ifc_locator: acpi_mpam_resource_interconnect_locator,
    pub generic_locator: acpi_mpam_resource_generic_locator,
}
impl Default for acpi_mpam_resource_locator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_mpam_resource_node {
    pub identifier: u32_,
    pub ris_index: u8_,
    pub reserved1: u16_,
    pub locator_type: u8_,
    pub locator: acpi_mpam_resource_locator,
    pub num_functional_deps: u32_,
}
impl Default for acpi_mpam_resource_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpam_msc_node {
    pub length: u16_,
    pub interface_type: u8_,
    pub reserved: u8_,
    pub identifier: u32_,
    pub base_address: u64_,
    pub mmio_size: u32_,
    pub overflow_interrupt: u32_,
    pub overflow_interrupt_flags: u32_,
    pub reserved1: u32_,
    pub overflow_interrupt_affinity: u32_,
    pub error_interrupt: u32_,
    pub error_interrupt_flags: u32_,
    pub reserved2: u32_,
    pub error_interrupt_affinity: u32_,
    pub max_nrdy_usec: u32_,
    pub hardware_id_linked_device: u64_,
    pub instance_id_linked_device: u32_,
    pub num_resource_nodes: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_mpam {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_mpst {
    pub header: acpi_table_header,
    pub channel_id: u8_,
    pub reserved1: [u8_; 3usize],
    pub power_node_count: u16_,
    pub reserved2: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_channel {
    pub channel_id: u8_,
    pub reserved1: [u8_; 3usize],
    pub power_node_count: u16_,
    pub reserved2: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_power_node {
    pub flags: u8_,
    pub reserved1: u8_,
    pub node_id: u16_,
    pub length: u32_,
    pub range_address: u64_,
    pub range_length: u64_,
    pub num_power_states: u32_,
    pub num_physical_components: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_power_state {
    pub power_state: u8_,
    pub info_index: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_component {
    pub component_id: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_data_hdr {
    pub characteristics_count: u16_,
    pub reserved: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_power_data {
    pub structure_id: u8_,
    pub flags: u8_,
    pub reserved1: u16_,
    pub average_power: u32_,
    pub power_saving: u32_,
    pub exit_latency: u64_,
    pub reserved2: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mpst_shared {
    pub signature: u32_,
    pub pcc_command: u16_,
    pub pcc_status: u16_,
    pub command_register: u32_,
    pub status_register: u32_,
    pub power_state_id: u32_,
    pub power_node_id: u32_,
    pub energy_consumed: u64_,
    pub average_power: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_msct {
    pub header: acpi_table_header,
    pub proximity_offset: u32_,
    pub max_proximity_domains: u32_,
    pub max_clock_domains: u32_,
    pub max_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_msct_proximity {
    pub revision: u8_,
    pub length: u8_,
    pub range_start: u32_,
    pub range_end: u32_,
    pub processor_capacity: u32_,
    pub memory_capacity: u64_,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_table_mrrm {
    pub header: acpi_table_header,
    pub max_mem_region: u8_,
    pub flags: u8_,
    pub reserved: [u8_; 26usize],
    pub memory_range_entry: __IncompleteArrayField<u8_>,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_mrrm_mem_range_entry {
    pub header: acpi_subtbl_hdr_16,
    pub reserved0: u32_,
    pub addr_base: u64_,
    pub addr_len: u64_,
    pub region_id_flags: u16_,
    pub local_region_id: u8_,
    pub remote_region_id: u8_,
    pub reserved1: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_msdm {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_nfit {
    pub header: acpi_table_header,
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_header {
    pub type_: u16_,
    pub length: u16_,
}
pub const acpi_nfit_type_ACPI_NFIT_TYPE_SYSTEM_ADDRESS: acpi_nfit_type = 0;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_MEMORY_MAP: acpi_nfit_type = 1;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_INTERLEAVE: acpi_nfit_type = 2;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_SMBIOS: acpi_nfit_type = 3;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_CONTROL_REGION: acpi_nfit_type = 4;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_DATA_REGION: acpi_nfit_type = 5;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_FLUSH_ADDRESS: acpi_nfit_type = 6;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_CAPABILITIES: acpi_nfit_type = 7;
pub const acpi_nfit_type_ACPI_NFIT_TYPE_RESERVED: acpi_nfit_type = 8;
pub type acpi_nfit_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_system_address {
    pub header: acpi_nfit_header,
    pub range_index: u16_,
    pub flags: u16_,
    pub reserved: u32_,
    pub proximity_domain: u32_,
    pub range_guid: [u8_; 16usize],
    pub address: u64_,
    pub length: u64_,
    pub memory_mapping: u64_,
    pub location_cookie: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_memory_map {
    pub header: acpi_nfit_header,
    pub device_handle: u32_,
    pub physical_id: u16_,
    pub region_id: u16_,
    pub range_index: u16_,
    pub region_index: u16_,
    pub region_size: u64_,
    pub region_offset: u64_,
    pub address: u64_,
    pub interleave_index: u16_,
    pub interleave_ways: u16_,
    pub flags: u16_,
    pub reserved: u16_,
}
#[repr(C, packed)]
pub struct acpi_nfit_interleave {
    pub header: acpi_nfit_header,
    pub interleave_index: u16_,
    pub reserved: u16_,
    pub line_count: u32_,
    pub line_size: u32_,
    pub line_offset: __IncompleteArrayField<u32_>,
}
impl Default for acpi_nfit_interleave {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_nfit_smbios {
    pub header: acpi_nfit_header,
    pub reserved: u32_,
    pub data: __IncompleteArrayField<u8_>,
}
impl Default for acpi_nfit_smbios {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_control_region {
    pub header: acpi_nfit_header,
    pub region_index: u16_,
    pub vendor_id: u16_,
    pub device_id: u16_,
    pub revision_id: u16_,
    pub subsystem_vendor_id: u16_,
    pub subsystem_device_id: u16_,
    pub subsystem_revision_id: u16_,
    pub valid_fields: u8_,
    pub manufacturing_location: u8_,
    pub manufacturing_date: u16_,
    pub reserved: [u8_; 2usize],
    pub serial_number: u32_,
    pub code: u16_,
    pub windows: u16_,
    pub window_size: u64_,
    pub command_offset: u64_,
    pub command_size: u64_,
    pub status_offset: u64_,
    pub status_size: u64_,
    pub flags: u16_,
    pub reserved1: [u8_; 6usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_data_region {
    pub header: acpi_nfit_header,
    pub region_index: u16_,
    pub windows: u16_,
    pub offset: u64_,
    pub size: u64_,
    pub capacity: u64_,
    pub start_address: u64_,
}
#[repr(C, packed)]
pub struct acpi_nfit_flush_address {
    pub header: acpi_nfit_header,
    pub device_handle: u32_,
    pub hint_count: u16_,
    pub reserved: [u8_; 6usize],
    pub hint_address: __IncompleteArrayField<u64_>,
}
impl Default for acpi_nfit_flush_address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nfit_capabilities {
    pub header: acpi_nfit_header,
    pub highest_capability: u8_,
    pub reserved: [u8_; 3usize],
    pub capabilities: u32_,
    pub reserved2: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct nfit_device_handle {
    pub handle: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_nhlt {
    pub header: acpi_table_header,
    pub endpoints_count: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_endpoint {
    pub length: u32_,
    pub link_type: u8_,
    pub instance_id: u8_,
    pub vendor_id: u16_,
    pub device_id: u16_,
    pub revision_id: u16_,
    pub subsystem_id: u32_,
    pub device_type: u8_,
    pub direction: u8_,
    pub virtual_bus_id: u8_,
}
#[repr(C, packed)]
pub struct acpi_nhlt_config {
    pub capabilities_size: u32_,
    pub capabilities: __IncompleteArrayField<u8_>,
}
impl Default for acpi_nhlt_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_gendevice_config {
    pub virtual_slot: u8_,
    pub config_type: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_micdevice_config {
    pub virtual_slot: u8_,
    pub config_type: u8_,
    pub array_type: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_vendor_mic_config {
    pub type_: u8_,
    pub panel: u8_,
    pub speaker_position_distance: u16_,
    pub horizontal_offset: u16_,
    pub vertical_offset: u16_,
    pub frequency_low_band: u8_,
    pub frequency_high_band: u8_,
    pub direction_angle: u16_,
    pub elevation_angle: u16_,
    pub work_vertical_angle_begin: u16_,
    pub work_vertical_angle_end: u16_,
    pub work_horizontal_angle_begin: u16_,
    pub work_horizontal_angle_end: u16_,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_nhlt_vendor_micdevice_config {
    pub virtual_slot: u8_,
    pub config_type: u8_,
    pub array_type: u8_,
    pub mics_count: u8_,
    pub mics: __IncompleteArrayField<acpi_nhlt_vendor_mic_config>,
}
#[repr(C)]
pub struct acpi_nhlt_device_config {
    pub virtual_slot: __BindgenUnionField<u8_>,
    pub gen_: __BindgenUnionField<acpi_nhlt_gendevice_config>,
    pub mic: __BindgenUnionField<acpi_nhlt_micdevice_config>,
    pub vendor_mic: __BindgenUnionField<acpi_nhlt_vendor_micdevice_config>,
    pub bindgen_union_field: [u8; 4usize],
}
impl Default for acpi_nhlt_device_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_wave_formatext {
    pub format_tag: u16_,
    pub channel_count: u16_,
    pub samples_per_sec: u32_,
    pub avg_bytes_per_sec: u32_,
    pub block_align: u16_,
    pub bits_per_sample: u16_,
    pub extra_format_size: u16_,
    pub valid_bits_per_sample: u16_,
    pub channel_mask: u32_,
    pub subformat: [u8_; 16usize],
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_nhlt_format_config {
    pub format: acpi_nhlt_wave_formatext,
    pub config: acpi_nhlt_config,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_nhlt_formats_config {
    pub formats_count: u8_,
    pub formats: __IncompleteArrayField<acpi_nhlt_format_config>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_nhlt_device_info {
    pub id: [u8_; 16usize],
    pub instance_id: u8_,
    pub port_id: u8_,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_nhlt_devices_info {
    pub devices_count: u8_,
    pub devices: __IncompleteArrayField<acpi_nhlt_device_info>,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_pcct {
    pub header: acpi_table_header,
    pub flags: u32_,
    pub reserved: u64_,
}
pub const acpi_pcct_type_ACPI_PCCT_TYPE_GENERIC_SUBSPACE: acpi_pcct_type = 0;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE: acpi_pcct_type = 1;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2: acpi_pcct_type = 2;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE: acpi_pcct_type = 3;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE: acpi_pcct_type = 4;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_HW_REG_COMM_SUBSPACE: acpi_pcct_type = 5;
pub const acpi_pcct_type_ACPI_PCCT_TYPE_RESERVED: acpi_pcct_type = 6;
pub type acpi_pcct_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_subspace {
    pub header: acpi_subtable_header,
    pub reserved: [u8_; 6usize],
    pub base_address: u64_,
    pub length: u64_,
    pub doorbell_register: acpi_generic_address,
    pub preserve_mask: u64_,
    pub write_mask: u64_,
    pub latency: u32_,
    pub max_access_rate: u32_,
    pub min_turnaround_time: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_hw_reduced {
    pub header: acpi_subtable_header,
    pub platform_interrupt: u32_,
    pub flags: u8_,
    pub reserved: u8_,
    pub base_address: u64_,
    pub length: u64_,
    pub doorbell_register: acpi_generic_address,
    pub preserve_mask: u64_,
    pub write_mask: u64_,
    pub latency: u32_,
    pub max_access_rate: u32_,
    pub min_turnaround_time: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_hw_reduced_type2 {
    pub header: acpi_subtable_header,
    pub platform_interrupt: u32_,
    pub flags: u8_,
    pub reserved: u8_,
    pub base_address: u64_,
    pub length: u64_,
    pub doorbell_register: acpi_generic_address,
    pub preserve_mask: u64_,
    pub write_mask: u64_,
    pub latency: u32_,
    pub max_access_rate: u32_,
    pub min_turnaround_time: u16_,
    pub platform_ack_register: acpi_generic_address,
    pub ack_preserve_mask: u64_,
    pub ack_write_mask: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_ext_pcc_master {
    pub header: acpi_subtable_header,
    pub platform_interrupt: u32_,
    pub flags: u8_,
    pub reserved1: u8_,
    pub base_address: u64_,
    pub length: u32_,
    pub doorbell_register: acpi_generic_address,
    pub preserve_mask: u64_,
    pub write_mask: u64_,
    pub latency: u32_,
    pub max_access_rate: u32_,
    pub min_turnaround_time: u32_,
    pub platform_ack_register: acpi_generic_address,
    pub ack_preserve_mask: u64_,
    pub ack_set_mask: u64_,
    pub reserved2: u64_,
    pub cmd_complete_register: acpi_generic_address,
    pub cmd_complete_mask: u64_,
    pub cmd_update_register: acpi_generic_address,
    pub cmd_update_preserve_mask: u64_,
    pub cmd_update_set_mask: u64_,
    pub error_status_register: acpi_generic_address,
    pub error_status_mask: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_ext_pcc_slave {
    pub header: acpi_subtable_header,
    pub platform_interrupt: u32_,
    pub flags: u8_,
    pub reserved1: u8_,
    pub base_address: u64_,
    pub length: u32_,
    pub doorbell_register: acpi_generic_address,
    pub preserve_mask: u64_,
    pub write_mask: u64_,
    pub latency: u32_,
    pub max_access_rate: u32_,
    pub min_turnaround_time: u32_,
    pub platform_ack_register: acpi_generic_address,
    pub ack_preserve_mask: u64_,
    pub ack_set_mask: u64_,
    pub reserved2: u64_,
    pub cmd_complete_register: acpi_generic_address,
    pub cmd_complete_mask: u64_,
    pub cmd_update_register: acpi_generic_address,
    pub cmd_update_preserve_mask: u64_,
    pub cmd_update_set_mask: u64_,
    pub error_status_register: acpi_generic_address,
    pub error_status_mask: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_hw_reg {
    pub header: acpi_subtable_header,
    pub version: u16_,
    pub base_address: u64_,
    pub length: u64_,
    pub doorbell_register: acpi_generic_address,
    pub doorbell_preserve: u64_,
    pub doorbell_write: u64_,
    pub cmd_complete_register: acpi_generic_address,
    pub cmd_complete_mask: u64_,
    pub error_status_register: acpi_generic_address,
    pub error_status_mask: u64_,
    pub nominal_latency: u32_,
    pub min_turnaround_time: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_shared_memory {
    pub signature: u32_,
    pub command: u16_,
    pub status: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pcct_ext_pcc_shared_memory {
    pub signature: u32_,
    pub flags: u32_,
    pub length: u32_,
    pub command: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_pdtt {
    pub header: acpi_table_header,
    pub trigger_count: u8_,
    pub reserved: [u8_; 3usize],
    pub array_offset: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pdtt_channel {
    pub subchannel_id: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_phat {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_phat_header {
    pub type_: u16_,
    pub length: u16_,
    pub revision: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_phat_version_data {
    pub header: acpi_phat_header,
    pub reserved: [u8_; 3usize],
    pub element_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_phat_version_element {
    pub guid: [u8_; 16usize],
    pub version_value: u64_,
    pub producer_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_phat_health_data {
    pub header: acpi_phat_header,
    pub reserved: [u8_; 2usize],
    pub health: u8_,
    pub device_guid: [u8_; 16usize],
    pub device_specific_offset: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_pmtt {
    pub header: acpi_table_header,
    pub memory_device_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pmtt_header {
    pub type_: u8_,
    pub reserved1: u8_,
    pub length: u16_,
    pub flags: u16_,
    pub reserved2: u16_,
    pub memory_device_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pmtt_socket {
    pub header: acpi_pmtt_header,
    pub socket_id: u16_,
    pub reserved: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pmtt_controller {
    pub header: acpi_pmtt_header,
    pub controller_id: u16_,
    pub reserved: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pmtt_physical_component {
    pub header: acpi_pmtt_header,
    pub bios_handle: u32_,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_pmtt_vendor_specific {
    pub header: acpi_pmtt_header,
    pub type_uuid: [u8_; 16usize],
    pub specific: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_pptt {
    pub header: acpi_table_header,
}
pub const acpi_pptt_type_ACPI_PPTT_TYPE_PROCESSOR: acpi_pptt_type = 0;
pub const acpi_pptt_type_ACPI_PPTT_TYPE_CACHE: acpi_pptt_type = 1;
pub const acpi_pptt_type_ACPI_PPTT_TYPE_ID: acpi_pptt_type = 2;
pub const acpi_pptt_type_ACPI_PPTT_TYPE_RESERVED: acpi_pptt_type = 3;
pub type acpi_pptt_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pptt_processor {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub flags: u32_,
    pub parent: u32_,
    pub acpi_processor_id: u32_,
    pub number_of_priv_resources: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pptt_cache {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub flags: u32_,
    pub next_level_of_cache: u32_,
    pub size: u32_,
    pub number_of_sets: u32_,
    pub associativity: u8_,
    pub attributes: u8_,
    pub line_size: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pptt_cache_v1 {
    pub cache_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pptt_id {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub vendor_id: u32_,
    pub level1_id: u64_,
    pub level2_id: u64_,
    pub major_rev: u16_,
    pub minor_rev: u16_,
    pub spin_rev: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_prmt {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_prmt_header {
    pub platform_guid: [u8_; 16usize],
    pub module_info_offset: u32_,
    pub module_info_count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_prmt_module_header {
    pub revision: u16_,
    pub length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_prmt_module_info {
    pub revision: u16_,
    pub length: u16_,
    pub module_guid: [u8_; 16usize],
    pub major_rev: u16_,
    pub minor_rev: u16_,
    pub handler_info_count: u16_,
    pub handler_info_offset: u32_,
    pub mmio_list_pointer: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_prmt_handler_info {
    pub revision: u16_,
    pub length: u16_,
    pub handler_guid: [u8_; 16usize],
    pub handler_address: u64_,
    pub static_data_buffer_address: u64_,
    pub acpi_param_buffer_address: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_rasf {
    pub header: acpi_table_header,
    pub channel_id: [u8_; 12usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rasf_shared_memory {
    pub signature: u32_,
    pub command: u16_,
    pub status: u16_,
    pub version: u16_,
    pub capabilities: [u8_; 16usize],
    pub set_capabilities: [u8_; 16usize],
    pub num_parameter_blocks: u16_,
    pub set_capabilities_status: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rasf_parameter_block {
    pub type_: u16_,
    pub version: u16_,
    pub length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rasf_patrol_scrub_parameter {
    pub header: acpi_rasf_parameter_block,
    pub patrol_scrub_command: u16_,
    pub requested_address_range: [u64_; 2usize],
    pub actual_address_range: [u64_; 2usize],
    pub flags: u16_,
    pub requested_speed: u8_,
}
pub const acpi_rasf_commands_ACPI_RASF_EXECUTE_RASF_COMMAND: acpi_rasf_commands = 1;
pub type acpi_rasf_commands = ffi::c_uint;
pub const acpi_rasf_capabiliities_ACPI_HW_PATROL_SCRUB_SUPPORTED: acpi_rasf_capabiliities = 0;
pub const acpi_rasf_capabiliities_ACPI_SW_PATROL_SCRUB_EXPOSED: acpi_rasf_capabiliities = 1;
pub type acpi_rasf_capabiliities = ffi::c_uint;
pub const acpi_rasf_patrol_scrub_commands_ACPI_RASF_GET_PATROL_PARAMETERS:
    acpi_rasf_patrol_scrub_commands = 1;
pub const acpi_rasf_patrol_scrub_commands_ACPI_RASF_START_PATROL_SCRUBBER:
    acpi_rasf_patrol_scrub_commands = 2;
pub const acpi_rasf_patrol_scrub_commands_ACPI_RASF_STOP_PATROL_SCRUBBER:
    acpi_rasf_patrol_scrub_commands = 3;
pub type acpi_rasf_patrol_scrub_commands = ffi::c_uint;
pub const acpi_rasf_status_ACPI_RASF_SUCCESS: acpi_rasf_status = 0;
pub const acpi_rasf_status_ACPI_RASF_NOT_VALID: acpi_rasf_status = 1;
pub const acpi_rasf_status_ACPI_RASF_NOT_SUPPORTED: acpi_rasf_status = 2;
pub const acpi_rasf_status_ACPI_RASF_BUSY: acpi_rasf_status = 3;
pub const acpi_rasf_status_ACPI_RASF_FAILED: acpi_rasf_status = 4;
pub const acpi_rasf_status_ACPI_RASF_ABORTED: acpi_rasf_status = 5;
pub const acpi_rasf_status_ACPI_RASF_INVALID_DATA: acpi_rasf_status = 6;
pub type acpi_rasf_status = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_ras2 {
    pub header: acpi_table_header,
    pub reserved: u16_,
    pub num_pcc_descs: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ras2_pcc_desc {
    pub channel_id: u8_,
    pub reserved: u16_,
    pub feature_type: u8_,
    pub instance: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ras2_shmem {
    pub signature: u32_,
    pub command: u16_,
    pub status: u16_,
    pub version: u16_,
    pub features: [u8_; 16usize],
    pub set_caps: [u8_; 16usize],
    pub num_param_blks: u16_,
    pub set_caps_status: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ras2_parameter_block {
    pub type_: u16_,
    pub version: u16_,
    pub length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ras2_patrol_scrub_param {
    pub header: acpi_ras2_parameter_block,
    pub command: u16_,
    pub req_addr_range: [u64_; 2usize],
    pub actl_addr_range: [u64_; 2usize],
    pub flags: u32_,
    pub scrub_params_out: u32_,
    pub scrub_params_in: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_ras2_la2pa_translation_parameter {
    pub header: acpi_ras2_parameter_block,
    pub addr_translation_command: u16_,
    pub sub_inst_id: u64_,
    pub logical_address: u64_,
    pub physical_address: u64_,
    pub status: u32_,
}
pub const acpi_ras2_commands_ACPI_RAS2_EXECUTE_RAS2_COMMAND: acpi_ras2_commands = 1;
pub type acpi_ras2_commands = ffi::c_uint;
pub const acpi_ras2_features_ACPI_RAS2_PATROL_SCRUB_SUPPORTED: acpi_ras2_features = 0;
pub const acpi_ras2_features_ACPI_RAS2_LA2PA_TRANSLATION: acpi_ras2_features = 1;
pub type acpi_ras2_features = ffi::c_uint;
pub const acpi_ras2_patrol_scrub_commands_ACPI_RAS2_GET_PATROL_PARAMETERS:
    acpi_ras2_patrol_scrub_commands = 1;
pub const acpi_ras2_patrol_scrub_commands_ACPI_RAS2_START_PATROL_SCRUBBER:
    acpi_ras2_patrol_scrub_commands = 2;
pub const acpi_ras2_patrol_scrub_commands_ACPI_RAS2_STOP_PATROL_SCRUBBER:
    acpi_ras2_patrol_scrub_commands = 3;
pub type acpi_ras2_patrol_scrub_commands = ffi::c_uint;
pub const acpi_ras2_la2_pa_translation_commands_ACPI_RAS2_GET_LA2PA_TRANSLATION:
    acpi_ras2_la2_pa_translation_commands = 1;
pub type acpi_ras2_la2_pa_translation_commands = ffi::c_uint;
pub const acpi_ras2_la2_pa_translation_status_ACPI_RAS2_LA2PA_TRANSLATION_SUCCESS:
    acpi_ras2_la2_pa_translation_status = 0;
pub const acpi_ras2_la2_pa_translation_status_ACPI_RAS2_LA2PA_TRANSLATION_FAIL:
    acpi_ras2_la2_pa_translation_status = 1;
pub type acpi_ras2_la2_pa_translation_status = ffi::c_uint;
pub const acpi_ras2_status_ACPI_RAS2_SUCCESS: acpi_ras2_status = 0;
pub const acpi_ras2_status_ACPI_RAS2_NOT_VALID: acpi_ras2_status = 1;
pub const acpi_ras2_status_ACPI_RAS2_NOT_SUPPORTED: acpi_ras2_status = 2;
pub const acpi_ras2_status_ACPI_RAS2_BUSY: acpi_ras2_status = 3;
pub const acpi_ras2_status_ACPI_RAS2_FAILED: acpi_ras2_status = 4;
pub const acpi_ras2_status_ACPI_RAS2_ABORTED: acpi_ras2_status = 5;
pub const acpi_ras2_status_ACPI_RAS2_INVALID_DATA: acpi_ras2_status = 6;
pub type acpi_ras2_status = ffi::c_uint;
#[repr(C, packed)]
pub struct acpi_table_rgrt {
    pub header: acpi_table_header,
    pub version: u16_,
    pub image_type: u8_,
    pub reserved: u8_,
    pub image: __IncompleteArrayField<u8_>,
}
impl Default for acpi_table_rgrt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const acpi_rgrt_image_type_ACPI_RGRT_TYPE_RESERVED0: acpi_rgrt_image_type = 0;
pub const acpi_rgrt_image_type_ACPI_RGRT_IMAGE_TYPE_PNG: acpi_rgrt_image_type = 1;
pub const acpi_rgrt_image_type_ACPI_RGRT_TYPE_RESERVED: acpi_rgrt_image_type = 2;
pub type acpi_rgrt_image_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_rhct {
    pub header: acpi_table_header,
    pub flags: u32_,
    pub time_base_freq: u64_,
    pub node_count: u32_,
    pub node_offset: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rhct_node_header {
    pub type_: u16_,
    pub length: u16_,
    pub revision: u16_,
}
pub const acpi_rhct_node_type_ACPI_RHCT_NODE_TYPE_ISA_STRING: acpi_rhct_node_type = 0;
pub const acpi_rhct_node_type_ACPI_RHCT_NODE_TYPE_CMO: acpi_rhct_node_type = 1;
pub const acpi_rhct_node_type_ACPI_RHCT_NODE_TYPE_MMU: acpi_rhct_node_type = 2;
pub const acpi_rhct_node_type_ACPI_RHCT_NODE_TYPE_RESERVED: acpi_rhct_node_type = 3;
pub const acpi_rhct_node_type_ACPI_RHCT_NODE_TYPE_HART_INFO: acpi_rhct_node_type = 65535;
pub type acpi_rhct_node_type = ffi::c_uint;
#[repr(C, packed)]
pub struct acpi_rhct_isa_string {
    pub isa_length: u16_,
    pub isa: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_rhct_isa_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rhct_cmo_node {
    pub reserved: u8_,
    pub cbom_size: u8_,
    pub cbop_size: u8_,
    pub cboz_size: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rhct_mmu_node {
    pub reserved: u8_,
    pub mmu_type: u8_,
}
pub const acpi_rhct_mmu_type_ACPI_RHCT_MMU_TYPE_SV39: acpi_rhct_mmu_type = 0;
pub const acpi_rhct_mmu_type_ACPI_RHCT_MMU_TYPE_SV48: acpi_rhct_mmu_type = 1;
pub const acpi_rhct_mmu_type_ACPI_RHCT_MMU_TYPE_SV57: acpi_rhct_mmu_type = 2;
pub type acpi_rhct_mmu_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rhct_hart_info {
    pub num_offsets: u16_,
    pub uid: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_rimt {
    pub header: acpi_table_header,
    pub num_nodes: u32_,
    pub node_offset: u32_,
    pub reserved: u32_,
}
#[repr(C, packed)]
pub struct acpi_rimt_node {
    pub type_: u8_,
    pub revision: u8_,
    pub length: u16_,
    pub reserved: u16_,
    pub id: u16_,
    pub node_data: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_rimt_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const acpi_rimt_node_type_ACPI_RIMT_NODE_TYPE_IOMMU: acpi_rimt_node_type = 0;
pub const acpi_rimt_node_type_ACPI_RIMT_NODE_TYPE_PCIE_ROOT_COMPLEX: acpi_rimt_node_type = 1;
pub const acpi_rimt_node_type_ACPI_RIMT_NODE_TYPE_PLAT_DEVICE: acpi_rimt_node_type = 2;
pub type acpi_rimt_node_type = ffi::c_uint;
#[repr(C, packed)]
pub struct acpi_rimt_iommu {
    pub hardware_id: [u8_; 8usize],
    pub base_address: u64_,
    pub flags: u32_,
    pub proximity_domain: u32_,
    pub pcie_segment_number: u16_,
    pub pcie_bdf: u16_,
    pub num_interrupt_wires: u16_,
    pub interrupt_wire_offset: u16_,
    pub interrupt_wire: __IncompleteArrayField<u64_>,
}
impl Default for acpi_rimt_iommu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rimt_iommu_wire_gsi {
    pub irq_num: u32_,
    pub flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rimt_id_mapping {
    pub source_id_base: u32_,
    pub num_ids: u32_,
    pub dest_id_base: u32_,
    pub dest_offset: u32_,
    pub flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_rimt_pcie_rc {
    pub flags: u32_,
    pub reserved: u16_,
    pub pcie_segment_number: u16_,
    pub id_mapping_offset: u16_,
    pub num_id_mappings: u16_,
}
#[repr(C, packed)]
pub struct acpi_rimt_platform_device {
    pub id_mapping_offset: u16_,
    pub num_id_mappings: u16_,
    pub device_name: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_rimt_platform_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_sbst {
    pub header: acpi_table_header,
    pub warning_level: u32_,
    pub low_level: u32_,
    pub critical_level: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_sdei {
    pub header: acpi_table_header,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_sdev {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_header {
    pub type_: u8_,
    pub flags: u8_,
    pub length: u16_,
}
pub const acpi_sdev_type_ACPI_SDEV_TYPE_NAMESPACE_DEVICE: acpi_sdev_type = 0;
pub const acpi_sdev_type_ACPI_SDEV_TYPE_PCIE_ENDPOINT_DEVICE: acpi_sdev_type = 1;
pub const acpi_sdev_type_ACPI_SDEV_TYPE_RESERVED: acpi_sdev_type = 2;
pub type acpi_sdev_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_namespace {
    pub header: acpi_sdev_header,
    pub device_id_offset: u16_,
    pub device_id_length: u16_,
    pub vendor_data_offset: u16_,
    pub vendor_data_length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_secure_component {
    pub secure_component_offset: u16_,
    pub secure_component_length: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_component {
    pub header: acpi_sdev_header,
}
pub const acpi_sac_type_ACPI_SDEV_TYPE_ID_COMPONENT: acpi_sac_type = 0;
pub const acpi_sac_type_ACPI_SDEV_TYPE_MEM_COMPONENT: acpi_sac_type = 1;
pub type acpi_sac_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_id_component {
    pub header: acpi_sdev_header,
    pub hardware_id_offset: u16_,
    pub hardware_id_length: u16_,
    pub subsystem_id_offset: u16_,
    pub subsystem_id_length: u16_,
    pub hardware_revision: u16_,
    pub hardware_rev_present: u8_,
    pub class_code_present: u8_,
    pub pci_base_class: u8_,
    pub pci_sub_class: u8_,
    pub pci_programming_xface: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_mem_component {
    pub header: acpi_sdev_header,
    pub reserved: u32_,
    pub memory_base_address: u64_,
    pub memory_length: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_pcie {
    pub header: acpi_sdev_header,
    pub segment: u16_,
    pub start_bus: u16_,
    pub path_offset: u16_,
    pub path_length: u16_,
    pub vendor_data_offset: u16_,
    pub vendor_data_length: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_sdev_pcie_path {
    pub device: u8_,
    pub function: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_svkl {
    pub header: acpi_table_header,
    pub count: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_svkl_key {
    pub type_: u16_,
    pub format: u16_,
    pub size: u32_,
    pub address: u64_,
}
pub const acpi_svkl_type_ACPI_SVKL_TYPE_MAIN_STORAGE: acpi_svkl_type = 0;
pub const acpi_svkl_type_ACPI_SVKL_TYPE_RESERVED: acpi_svkl_type = 1;
pub type acpi_svkl_type = ffi::c_uint;
pub const acpi_svkl_format_ACPI_SVKL_FORMAT_RAW_BINARY: acpi_svkl_format = 0;
pub const acpi_svkl_format_ACPI_SVKL_FORMAT_RESERVED: acpi_svkl_format = 1;
pub type acpi_svkl_format = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tdel {
    pub header: acpi_table_header,
    pub reserved: u32_,
    pub log_area_minimum_length: u64_,
    pub log_area_start_address: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_slic {
    pub header: acpi_table_header,
}
#[repr(C, packed)]
pub struct acpi_table_slit {
    pub header: acpi_table_header,
    pub locality_count: u64_,
    pub entry: __IncompleteArrayField<u8_>,
}
impl Default for acpi_table_slit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_table_spcr {
    pub header: acpi_table_header,
    pub interface_type: u8_,
    pub reserved: [u8_; 3usize],
    pub serial_port: acpi_generic_address,
    pub interrupt_type: u8_,
    pub pc_interrupt: u8_,
    pub interrupt: u32_,
    pub baud_rate: u8_,
    pub parity: u8_,
    pub stop_bits: u8_,
    pub flow_control: u8_,
    pub terminal_type: u8_,
    pub language: u8_,
    pub pci_device_id: u16_,
    pub pci_vendor_id: u16_,
    pub pci_bus: u8_,
    pub pci_device: u8_,
    pub pci_function: u8_,
    pub pci_flags: u32_,
    pub pci_segment: u8_,
    pub uart_clk_freq: u32_,
    pub precise_baudrate: u32_,
    pub name_space_string_length: u16_,
    pub name_space_string_offset: u16_,
    pub name_space_string: __IncompleteArrayField<ffi::c_char>,
}
impl Default for acpi_table_spcr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_spmi {
    pub header: acpi_table_header,
    pub interface_type: u8_,
    pub reserved: u8_,
    pub spec_revision: u16_,
    pub interrupt_type: u8_,
    pub gpe_number: u8_,
    pub reserved1: u8_,
    pub pci_device_flag: u8_,
    pub interrupt: u32_,
    pub ipmi_register: acpi_generic_address,
    pub pci_segment: u8_,
    pub pci_bus: u8_,
    pub pci_device: u8_,
    pub pci_function: u8_,
    pub reserved2: u8_,
}
pub const acpi_spmi_interface_types_ACPI_SPMI_NOT_USED: acpi_spmi_interface_types = 0;
pub const acpi_spmi_interface_types_ACPI_SPMI_KEYBOARD: acpi_spmi_interface_types = 1;
pub const acpi_spmi_interface_types_ACPI_SPMI_SMI: acpi_spmi_interface_types = 2;
pub const acpi_spmi_interface_types_ACPI_SPMI_BLOCK_TRANSFER: acpi_spmi_interface_types = 3;
pub const acpi_spmi_interface_types_ACPI_SPMI_SMBUS: acpi_spmi_interface_types = 4;
pub const acpi_spmi_interface_types_ACPI_SPMI_RESERVED: acpi_spmi_interface_types = 5;
pub type acpi_spmi_interface_types = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_srat {
    pub header: acpi_table_header,
    pub table_revision: u32_,
    pub reserved: u64_,
}
pub const acpi_srat_type_ACPI_SRAT_TYPE_CPU_AFFINITY: acpi_srat_type = 0;
pub const acpi_srat_type_ACPI_SRAT_TYPE_MEMORY_AFFINITY: acpi_srat_type = 1;
pub const acpi_srat_type_ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY: acpi_srat_type = 2;
pub const acpi_srat_type_ACPI_SRAT_TYPE_GICC_AFFINITY: acpi_srat_type = 3;
pub const acpi_srat_type_ACPI_SRAT_TYPE_GIC_ITS_AFFINITY: acpi_srat_type = 4;
pub const acpi_srat_type_ACPI_SRAT_TYPE_GENERIC_AFFINITY: acpi_srat_type = 5;
pub const acpi_srat_type_ACPI_SRAT_TYPE_GENERIC_PORT_AFFINITY: acpi_srat_type = 6;
pub const acpi_srat_type_ACPI_SRAT_TYPE_RINTC_AFFINITY: acpi_srat_type = 7;
pub const acpi_srat_type_ACPI_SRAT_TYPE_RESERVED: acpi_srat_type = 8;
pub type acpi_srat_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_cpu_affinity {
    pub header: acpi_subtable_header,
    pub proximity_domain_lo: u8_,
    pub apic_id: u8_,
    pub flags: u32_,
    pub local_sapic_eid: u8_,
    pub proximity_domain_hi: [u8_; 3usize],
    pub clock_domain: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_mem_affinity {
    pub header: acpi_subtable_header,
    pub proximity_domain: u32_,
    pub reserved: u16_,
    pub base_address: u64_,
    pub length: u64_,
    pub reserved1: u32_,
    pub flags: u32_,
    pub reserved2: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_x2apic_cpu_affinity {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub proximity_domain: u32_,
    pub apic_id: u32_,
    pub flags: u32_,
    pub clock_domain: u32_,
    pub reserved2: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_gicc_affinity {
    pub header: acpi_subtable_header,
    pub proximity_domain: u32_,
    pub acpi_processor_uid: u32_,
    pub flags: u32_,
    pub clock_domain: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_gic_its_affinity {
    pub header: acpi_subtable_header,
    pub proximity_domain: u32_,
    pub reserved: u16_,
    pub its_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_generic_affinity {
    pub header: acpi_subtable_header,
    pub reserved: u8_,
    pub device_handle_type: u8_,
    pub proximity_domain: u32_,
    pub device_handle: [u8_; 16usize],
    pub flags: u32_,
    pub reserved1: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_srat_rintc_affinity {
    pub header: acpi_subtable_header,
    pub reserved: u16_,
    pub proximity_domain: u32_,
    pub acpi_processor_uid: u32_,
    pub flags: u32_,
    pub clock_domain: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_stao {
    pub header: acpi_table_header,
    pub ignore_uart: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tcpa_hdr {
    pub header: acpi_table_header,
    pub platform_class: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tcpa_client {
    pub minimum_log_length: u32_,
    pub log_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tcpa_server {
    pub reserved: u16_,
    pub minimum_log_length: u64_,
    pub log_address: u64_,
    pub spec_revision: u16_,
    pub device_flags: u8_,
    pub interrupt_flags: u8_,
    pub gpe_number: u8_,
    pub reserved2: [u8_; 3usize],
    pub global_interrupt: u32_,
    pub address: acpi_generic_address,
    pub reserved3: u32_,
    pub config_address: acpi_generic_address,
    pub group: u8_,
    pub bus: u8_,
    pub device: u8_,
    pub function: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tpm23 {
    pub header: acpi_table_header,
    pub reserved: u32_,
    pub control_address: u64_,
    pub start_method: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_tmp23_trailer {
    pub reserved: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_tpm2 {
    pub header: acpi_table_header,
    pub platform_class: u16_,
    pub reserved: u16_,
    pub control_address: u64_,
    pub start_method: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_tpm2_phy {
    pub start_method_specific: [u8_; 12usize],
    pub log_area_minimum_length: u32_,
    pub log_area_start_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_tpm2_trailer {
    pub method_parameters: [u8_; 12usize],
    pub minimum_log_length: u32_,
    pub log_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_tpm2_arm_smc {
    pub global_interrupt: u32_,
    pub interrupt_flags: u8_,
    pub operation_flags: u8_,
    pub reserved: u16_,
    pub function_id: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_uefi {
    pub header: acpi_table_header,
    pub identifier: [u8_; 16usize],
    pub data_offset: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_viot {
    pub header: acpi_table_header,
    pub node_count: u16_,
    pub node_offset: u16_,
    pub reserved: [u8_; 8usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_viot_header {
    pub type_: u8_,
    pub reserved: u8_,
    pub length: u16_,
}
pub const acpi_viot_node_type_ACPI_VIOT_NODE_PCI_RANGE: acpi_viot_node_type = 1;
pub const acpi_viot_node_type_ACPI_VIOT_NODE_MMIO: acpi_viot_node_type = 2;
pub const acpi_viot_node_type_ACPI_VIOT_NODE_VIRTIO_IOMMU_PCI: acpi_viot_node_type = 3;
pub const acpi_viot_node_type_ACPI_VIOT_NODE_VIRTIO_IOMMU_MMIO: acpi_viot_node_type = 4;
pub const acpi_viot_node_type_ACPI_VIOT_RESERVED: acpi_viot_node_type = 5;
pub type acpi_viot_node_type = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_viot_pci_range {
    pub header: acpi_viot_header,
    pub endpoint_start: u32_,
    pub segment_start: u16_,
    pub segment_end: u16_,
    pub bdf_start: u16_,
    pub bdf_end: u16_,
    pub output_node: u16_,
    pub reserved: [u8_; 6usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_viot_mmio {
    pub header: acpi_viot_header,
    pub endpoint: u32_,
    pub base_address: u64_,
    pub output_node: u16_,
    pub reserved: [u8_; 6usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_viot_virtio_iommu_pci {
    pub header: acpi_viot_header,
    pub segment: u16_,
    pub bdf: u16_,
    pub reserved: [u8_; 8usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_viot_virtio_iommu_mmio {
    pub header: acpi_viot_header,
    pub reserved: [u8_; 4usize],
    pub base_address: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_waet {
    pub header: acpi_table_header,
    pub flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_wdat {
    pub header: acpi_table_header,
    pub header_length: u32_,
    pub pci_segment: u16_,
    pub pci_bus: u8_,
    pub pci_device: u8_,
    pub pci_function: u8_,
    pub reserved: [u8_; 3usize],
    pub timer_period: u32_,
    pub max_count: u32_,
    pub min_count: u32_,
    pub flags: u8_,
    pub reserved2: [u8_; 3usize],
    pub entries: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_wdat_entry {
    pub action: u8_,
    pub instruction: u8_,
    pub reserved: u16_,
    pub register_region: acpi_generic_address,
    pub value: u32_,
    pub mask: u32_,
}
pub const acpi_wdat_actions_ACPI_WDAT_RESET: acpi_wdat_actions = 1;
pub const acpi_wdat_actions_ACPI_WDAT_GET_CURRENT_COUNTDOWN: acpi_wdat_actions = 4;
pub const acpi_wdat_actions_ACPI_WDAT_GET_COUNTDOWN: acpi_wdat_actions = 5;
pub const acpi_wdat_actions_ACPI_WDAT_SET_COUNTDOWN: acpi_wdat_actions = 6;
pub const acpi_wdat_actions_ACPI_WDAT_GET_RUNNING_STATE: acpi_wdat_actions = 8;
pub const acpi_wdat_actions_ACPI_WDAT_SET_RUNNING_STATE: acpi_wdat_actions = 9;
pub const acpi_wdat_actions_ACPI_WDAT_GET_STOPPED_STATE: acpi_wdat_actions = 10;
pub const acpi_wdat_actions_ACPI_WDAT_SET_STOPPED_STATE: acpi_wdat_actions = 11;
pub const acpi_wdat_actions_ACPI_WDAT_GET_REBOOT: acpi_wdat_actions = 16;
pub const acpi_wdat_actions_ACPI_WDAT_SET_REBOOT: acpi_wdat_actions = 17;
pub const acpi_wdat_actions_ACPI_WDAT_GET_SHUTDOWN: acpi_wdat_actions = 18;
pub const acpi_wdat_actions_ACPI_WDAT_SET_SHUTDOWN: acpi_wdat_actions = 19;
pub const acpi_wdat_actions_ACPI_WDAT_GET_STATUS: acpi_wdat_actions = 32;
pub const acpi_wdat_actions_ACPI_WDAT_SET_STATUS: acpi_wdat_actions = 33;
pub const acpi_wdat_actions_ACPI_WDAT_ACTION_RESERVED: acpi_wdat_actions = 34;
pub type acpi_wdat_actions = ffi::c_uint;
pub const acpi_wdat_instructions_ACPI_WDAT_READ_VALUE: acpi_wdat_instructions = 0;
pub const acpi_wdat_instructions_ACPI_WDAT_READ_COUNTDOWN: acpi_wdat_instructions = 1;
pub const acpi_wdat_instructions_ACPI_WDAT_WRITE_VALUE: acpi_wdat_instructions = 2;
pub const acpi_wdat_instructions_ACPI_WDAT_WRITE_COUNTDOWN: acpi_wdat_instructions = 3;
pub const acpi_wdat_instructions_ACPI_WDAT_INSTRUCTION_RESERVED: acpi_wdat_instructions = 4;
pub const acpi_wdat_instructions_ACPI_WDAT_PRESERVE_REGISTER: acpi_wdat_instructions = 128;
pub type acpi_wdat_instructions = ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_wddt {
    pub header: acpi_table_header,
    pub spec_version: u16_,
    pub table_version: u16_,
    pub pci_vendor_id: u16_,
    pub address: acpi_generic_address,
    pub max_count: u16_,
    pub min_count: u16_,
    pub period: u16_,
    pub status: u16_,
    pub capability: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_wdrt {
    pub header: acpi_table_header,
    pub control_register: acpi_generic_address,
    pub count_register: acpi_generic_address,
    pub pci_device_id: u16_,
    pub pci_vendor_id: u16_,
    pub pci_bus: u8_,
    pub pci_device: u8_,
    pub pci_function: u8_,
    pub pci_segment: u8_,
    pub max_count: u16_,
    pub units: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_wpbt {
    pub header: acpi_table_header,
    pub handoff_size: u32_,
    pub handoff_address: u64_,
    pub layout: u8_,
    pub type_: u8_,
    pub arguments_length: u16_,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_wpbt_unicode {
    pub unicode_string: *mut u16_,
}
impl Default for acpi_wpbt_unicode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_wsmt {
    pub header: acpi_table_header,
    pub protection_flags: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_table_xenv {
    pub header: acpi_table_header,
    pub grant_table_address: u64_,
    pub grant_table_size: u64_,
    pub event_interrupt: u32_,
    pub event_flags: u8_,
}
pub type acpi_rs_length = u16_;
pub type acpi_rsdesc_size = u32_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_uuid {
    pub data: [u8_; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_vendor_uuid {
    pub subtype: u8_,
    pub data: [u8_; 16usize],
}
#[repr(C)]
pub struct acpi_resource_irq {
    pub descriptor_length: u8_,
    pub triggering: u8_,
    pub polarity: u8_,
    pub shareable: u8_,
    pub wake_capable: u8_,
    pub interrupt_count: u8_,
    pub __bindgen_anon_1: acpi_resource_irq__bindgen_ty_1,
}
#[repr(C)]
pub struct acpi_resource_irq__bindgen_ty_1 {
    pub interrupt: __BindgenUnionField<u8_>,
    pub __bindgen_anon_1: __BindgenUnionField<acpi_resource_irq__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_resource_irq__bindgen_ty_1__bindgen_ty_1 {
    pub __Empty_interrupts: acpi_resource_irq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub interrupts: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_irq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for acpi_resource_irq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_resource_irq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_resource_dma {
    pub type_: u8_,
    pub bus_master: u8_,
    pub transfer: u8_,
    pub channel_count: u8_,
    pub __bindgen_anon_1: acpi_resource_dma__bindgen_ty_1,
}
#[repr(C)]
pub struct acpi_resource_dma__bindgen_ty_1 {
    pub channel: __BindgenUnionField<u8_>,
    pub __bindgen_anon_1: __BindgenUnionField<acpi_resource_dma__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_resource_dma__bindgen_ty_1__bindgen_ty_1 {
    pub __Empty_channels: acpi_resource_dma__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub channels: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_dma__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for acpi_resource_dma__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_resource_dma {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_start_dependent {
    pub descriptor_length: u8_,
    pub compatibility_priority: u8_,
    pub performance_robustness: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_io {
    pub io_decode: u8_,
    pub alignment: u8_,
    pub address_length: u8_,
    pub minimum: u16_,
    pub maximum: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_fixed_io {
    pub address: u16_,
    pub address_length: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_fixed_dma {
    pub request_lines: u16_,
    pub channels: u16_,
    pub width: u8_,
}
#[repr(C, packed)]
pub struct acpi_resource_vendor {
    pub byte_length: u16_,
    pub byte_data: __IncompleteArrayField<u8_>,
}
impl Default for acpi_resource_vendor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_resource_vendor_typed {
    pub byte_length: u16_,
    pub uuid_subtype: u8_,
    pub uuid: [u8_; 16usize],
    pub byte_data: __IncompleteArrayField<u8_>,
}
impl Default for acpi_resource_vendor_typed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_end_tag {
    pub checksum: u8_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_memory24 {
    pub write_protect: u8_,
    pub minimum: u16_,
    pub maximum: u16_,
    pub alignment: u16_,
    pub address_length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_memory32 {
    pub write_protect: u8_,
    pub minimum: u32_,
    pub maximum: u32_,
    pub alignment: u32_,
    pub address_length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_fixed_memory32 {
    pub write_protect: u8_,
    pub address: u32_,
    pub address_length: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_memory_attribute {
    pub write_protect: u8_,
    pub caching: u8_,
    pub range_type: u8_,
    pub translation: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_io_attribute {
    pub range_type: u8_,
    pub translation: u8_,
    pub translation_type: u8_,
    pub reserved1: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_resource_attribute {
    pub mem: acpi_memory_attribute,
    pub io: acpi_io_attribute,
    pub type_specific: u8_,
}
impl Default for acpi_resource_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_label {
    pub string_length: u16_,
    pub string_ptr: *mut ffi::c_char,
}
impl Default for acpi_resource_label {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_source {
    pub index: u8_,
    pub string_length: u16_,
    pub string_ptr: *mut ffi::c_char,
}
impl Default for acpi_resource_source {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_address16_attribute {
    pub granularity: u16_,
    pub minimum: u16_,
    pub maximum: u16_,
    pub translation_offset: u16_,
    pub address_length: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_address32_attribute {
    pub granularity: u32_,
    pub minimum: u32_,
    pub maximum: u32_,
    pub translation_offset: u32_,
    pub address_length: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_address64_attribute {
    pub granularity: u64_,
    pub minimum: u64_,
    pub maximum: u64_,
    pub translation_offset: u64_,
    pub address_length: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_resource_address {
    pub resource_type: u8_,
    pub producer_consumer: u8_,
    pub decode: u8_,
    pub min_address_fixed: u8_,
    pub max_address_fixed: u8_,
    pub info: acpi_resource_attribute,
}
impl Default for acpi_resource_address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_resource_address16 {
    pub resource_type: u8_,
    pub producer_consumer: u8_,
    pub decode: u8_,
    pub min_address_fixed: u8_,
    pub max_address_fixed: u8_,
    pub info: acpi_resource_attribute,
    pub address: acpi_address16_attribute,
    pub resource_source: acpi_resource_source,
}
impl Default for acpi_resource_address16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_resource_address32 {
    pub resource_type: u8_,
    pub producer_consumer: u8_,
    pub decode: u8_,
    pub min_address_fixed: u8_,
    pub max_address_fixed: u8_,
    pub info: acpi_resource_attribute,
    pub address: acpi_address32_attribute,
    pub resource_source: acpi_resource_source,
}
impl Default for acpi_resource_address32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_resource_address64 {
    pub resource_type: u8_,
    pub producer_consumer: u8_,
    pub decode: u8_,
    pub min_address_fixed: u8_,
    pub max_address_fixed: u8_,
    pub info: acpi_resource_attribute,
    pub address: acpi_address64_attribute,
    pub resource_source: acpi_resource_source,
}
impl Default for acpi_resource_address64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_extended_address64 {
    pub resource_type: u8_,
    pub producer_consumer: u8_,
    pub decode: u8_,
    pub min_address_fixed: u8_,
    pub max_address_fixed: u8_,
    pub info: acpi_resource_attribute,
    pub revision_ID: u8_,
    pub address: acpi_address64_attribute,
    pub type_specific: u64_,
}
impl Default for acpi_resource_extended_address64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_resource_extended_irq {
    pub producer_consumer: u8_,
    pub triggering: u8_,
    pub polarity: u8_,
    pub shareable: u8_,
    pub wake_capable: u8_,
    pub interrupt_count: u8_,
    pub resource_source: acpi_resource_source,
    pub __bindgen_anon_1: acpi_resource_extended_irq__bindgen_ty_1,
}
#[repr(C, packed)]
pub struct acpi_resource_extended_irq__bindgen_ty_1 {
    pub interrupt: __BindgenUnionField<u32_>,
    pub __bindgen_anon_1:
        __BindgenUnionField<acpi_resource_extended_irq__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C, packed)]
pub struct acpi_resource_extended_irq__bindgen_ty_1__bindgen_ty_1 {
    pub __Empty_interrupts: acpi_resource_extended_irq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub interrupts: __IncompleteArrayField<u32_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_extended_irq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for acpi_resource_extended_irq__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_resource_extended_irq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_resource_extended_irq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct acpi_resource_generic_register {
    pub space_id: u8_,
    pub bit_width: u8_,
    pub bit_offset: u8_,
    pub access_size: u8_,
    pub address: u64_,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_gpio {
    pub revision_id: u8_,
    pub connection_type: u8_,
    pub producer_consumer: u8_,
    pub pin_config: u8_,
    pub shareable: u8_,
    pub wake_capable: u8_,
    pub io_restriction: u8_,
    pub triggering: u8_,
    pub polarity: u8_,
    pub drive_strength: u16_,
    pub debounce_timeout: u16_,
    pub pin_table_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub pin_table: *mut u16_,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_gpio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_common_serialbus {
    pub revision_id: u8_,
    pub type_: u8_,
    pub producer_consumer: u8_,
    pub slave_mode: u8_,
    pub connection_sharing: u8_,
    pub type_revision_id: u8_,
    pub type_data_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_common_serialbus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_i2c_serialbus {
    pub revision_id: u8_,
    pub type_: u8_,
    pub producer_consumer: u8_,
    pub slave_mode: u8_,
    pub connection_sharing: u8_,
    pub type_revision_id: u8_,
    pub type_data_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub vendor_data: *mut u8_,
    pub access_mode: u8_,
    pub slave_address: u16_,
    pub connection_speed: u32_,
}
impl Default for acpi_resource_i2c_serialbus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_spi_serialbus {
    pub revision_id: u8_,
    pub type_: u8_,
    pub producer_consumer: u8_,
    pub slave_mode: u8_,
    pub connection_sharing: u8_,
    pub type_revision_id: u8_,
    pub type_data_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub vendor_data: *mut u8_,
    pub wire_mode: u8_,
    pub device_polarity: u8_,
    pub data_bit_length: u8_,
    pub clock_phase: u8_,
    pub clock_polarity: u8_,
    pub device_selection: u16_,
    pub connection_speed: u32_,
}
impl Default for acpi_resource_spi_serialbus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_uart_serialbus {
    pub revision_id: u8_,
    pub type_: u8_,
    pub producer_consumer: u8_,
    pub slave_mode: u8_,
    pub connection_sharing: u8_,
    pub type_revision_id: u8_,
    pub type_data_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub vendor_data: *mut u8_,
    pub endian: u8_,
    pub data_bits: u8_,
    pub stop_bits: u8_,
    pub flow_control: u8_,
    pub parity: u8_,
    pub lines_enabled: u8_,
    pub rx_fifo_size: u16_,
    pub tx_fifo_size: u16_,
    pub default_baud_rate: u32_,
}
impl Default for acpi_resource_uart_serialbus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_csi2_serialbus {
    pub revision_id: u8_,
    pub type_: u8_,
    pub producer_consumer: u8_,
    pub slave_mode: u8_,
    pub connection_sharing: u8_,
    pub type_revision_id: u8_,
    pub type_data_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub vendor_data: *mut u8_,
    pub local_port_instance: u8_,
    pub phy_type: u8_,
}
impl Default for acpi_resource_csi2_serialbus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_pin_function {
    pub revision_id: u8_,
    pub pin_config: u8_,
    pub shareable: u8_,
    pub function_number: u16_,
    pub pin_table_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub pin_table: *mut u16_,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_pin_function {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_pin_config {
    pub revision_id: u8_,
    pub producer_consumer: u8_,
    pub shareable: u8_,
    pub pin_config_type: u8_,
    pub pin_config_value: u32_,
    pub pin_table_length: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub pin_table: *mut u16_,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_pin_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_clock_input {
    pub revision_id: u8_,
    pub mode: u8_,
    pub scale: u8_,
    pub frequency_divisor: u16_,
    pub frequency_numerator: u32_,
    pub resource_source: acpi_resource_source,
}
impl Default for acpi_resource_clock_input {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_pin_group {
    pub revision_id: u8_,
    pub producer_consumer: u8_,
    pub pin_table_length: u16_,
    pub vendor_length: u16_,
    pub pin_table: *mut u16_,
    pub resource_label: acpi_resource_label,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_pin_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_pin_group_function {
    pub revision_id: u8_,
    pub producer_consumer: u8_,
    pub shareable: u8_,
    pub function_number: u16_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub resource_source_label: acpi_resource_label,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_pin_group_function {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct acpi_resource_pin_group_config {
    pub revision_id: u8_,
    pub producer_consumer: u8_,
    pub shareable: u8_,
    pub pin_config_type: u8_,
    pub pin_config_value: u32_,
    pub vendor_length: u16_,
    pub resource_source: acpi_resource_source,
    pub resource_source_label: acpi_resource_label,
    pub vendor_data: *mut u8_,
}
impl Default for acpi_resource_pin_group_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_resource_data {
    pub irq: __BindgenUnionField<acpi_resource_irq>,
    pub dma: __BindgenUnionField<acpi_resource_dma>,
    pub start_dpf: __BindgenUnionField<acpi_resource_start_dependent>,
    pub io: __BindgenUnionField<acpi_resource_io>,
    pub fixed_io: __BindgenUnionField<acpi_resource_fixed_io>,
    pub fixed_dma: __BindgenUnionField<acpi_resource_fixed_dma>,
    pub vendor: __BindgenUnionField<acpi_resource_vendor>,
    pub vendor_typed: __BindgenUnionField<acpi_resource_vendor_typed>,
    pub end_tag: __BindgenUnionField<acpi_resource_end_tag>,
    pub memory24: __BindgenUnionField<acpi_resource_memory24>,
    pub memory32: __BindgenUnionField<acpi_resource_memory32>,
    pub fixed_memory32: __BindgenUnionField<acpi_resource_fixed_memory32>,
    pub address16: __BindgenUnionField<acpi_resource_address16>,
    pub address32: __BindgenUnionField<acpi_resource_address32>,
    pub address64: __BindgenUnionField<acpi_resource_address64>,
    pub ext_address64: __BindgenUnionField<acpi_resource_extended_address64>,
    pub extended_irq: __BindgenUnionField<acpi_resource_extended_irq>,
    pub generic_reg: __BindgenUnionField<acpi_resource_generic_register>,
    pub gpio: __BindgenUnionField<acpi_resource_gpio>,
    pub i2c_serial_bus: __BindgenUnionField<acpi_resource_i2c_serialbus>,
    pub spi_serial_bus: __BindgenUnionField<acpi_resource_spi_serialbus>,
    pub uart_serial_bus: __BindgenUnionField<acpi_resource_uart_serialbus>,
    pub csi2_serial_bus: __BindgenUnionField<acpi_resource_csi2_serialbus>,
    pub common_serial_bus: __BindgenUnionField<acpi_resource_common_serialbus>,
    pub pin_function: __BindgenUnionField<acpi_resource_pin_function>,
    pub pin_config: __BindgenUnionField<acpi_resource_pin_config>,
    pub pin_group: __BindgenUnionField<acpi_resource_pin_group>,
    pub pin_group_function: __BindgenUnionField<acpi_resource_pin_group_function>,
    pub pin_group_config: __BindgenUnionField<acpi_resource_pin_group_config>,
    pub clock_input: __BindgenUnionField<acpi_resource_clock_input>,
    pub address: __BindgenUnionField<acpi_resource_address>,
    pub bindgen_union_field: [u8; 60usize],
}
impl Default for acpi_resource_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct acpi_resource {
    pub type_: u32_,
    pub length: u32_,
    pub data: acpi_resource_data,
}
impl Default for acpi_resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct acpi_pci_routing_table {
    pub length: u32_,
    pub pin: u32_,
    pub address: u64_,
    pub source_index: u32_,
    pub __bindgen_anon_1: acpi_pci_routing_table__bindgen_ty_1,
}
#[repr(C)]
pub struct acpi_pci_routing_table__bindgen_ty_1 {
    pub pad: __BindgenUnionField<[ffi::c_char; 4usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<acpi_pci_routing_table__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 4usize],
}
#[repr(C)]
#[derive(Default)]
pub struct acpi_pci_routing_table__bindgen_ty_1__bindgen_ty_1 {
    pub __Empty_source: acpi_pci_routing_table__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub source: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pci_routing_table__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for acpi_pci_routing_table__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_pci_routing_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const acpi_execute_type_OSL_GLOBAL_LOCK_HANDLER: acpi_execute_type = 0;
pub const acpi_execute_type_OSL_NOTIFY_HANDLER: acpi_execute_type = 1;
pub const acpi_execute_type_OSL_GPE_HANDLER: acpi_execute_type = 2;
pub const acpi_execute_type_OSL_DEBUGGER_MAIN_THREAD: acpi_execute_type = 3;
pub const acpi_execute_type_OSL_DEBUGGER_EXEC_THREAD: acpi_execute_type = 4;
pub const acpi_execute_type_OSL_EC_POLL_HANDLER: acpi_execute_type = 5;
pub const acpi_execute_type_OSL_EC_BURST_HANDLER: acpi_execute_type = 6;
pub type acpi_execute_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_signal_fatal_info {
    pub type_: u32_,
    pub code: u32_,
    pub argument: u32_,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_fde_info {
    pub floppy0: u32_,
    pub floppy1: u32_,
    pub floppy2: u32_,
    pub floppy3: u32_,
    pub tape: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_grt_info {
    pub year: u16_,
    pub month: u8_,
    pub day: u8_,
    pub hour: u8_,
    pub minute: u8_,
    pub second: u8_,
    pub valid: u8_,
    pub milliseconds: u16_,
    pub timezone: u16_,
    pub daylight: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_gtm_info {
    pub pio_speed0: u32_,
    pub dma_speed0: u32_,
    pub pio_speed1: u32_,
    pub dma_speed1: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pld_info {
    pub revision: u8_,
    pub ignore_color: u8_,
    pub red: u8_,
    pub green: u8_,
    pub blue: u8_,
    pub width: u16_,
    pub height: u16_,
    pub user_visible: u8_,
    pub dock: u8_,
    pub lid: u8_,
    pub panel: u8_,
    pub vertical_position: u8_,
    pub horizontal_position: u8_,
    pub shape: u8_,
    pub group_orientation: u8_,
    pub group_token: u8_,
    pub group_position: u8_,
    pub bay: u8_,
    pub ejectable: u8_,
    pub ospm_eject_required: u8_,
    pub cabinet_number: u8_,
    pub card_cage_number: u8_,
    pub reference: u8_,
    pub rotation: u8_,
    pub order: u8_,
    pub reserved: u8_,
    pub vertical_offset: u16_,
    pub horizontal_offset: u16_,
}

pub type acpi_walk_resource_callback = ::core::option::Option<
    unsafe extern "C" fn(resource: *mut acpi_resource, context: *mut ffi::c_void) -> acpi_status,
>;

pub type acpi_tbl_entry_handler = ::core::option::Option<
    unsafe extern "C" fn(header: *mut acpi_subtable_headers, end: ffi::c_ulong) -> ffi::c_int,
>;
pub type acpi_tbl_entry_handler_arg = ::core::option::Option<
    unsafe extern "C" fn(
        header: *mut acpi_subtable_headers,
        arg: *mut ffi::c_void,
        end: ffi::c_ulong,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_subtable_proc {
    pub id: ffi::c_int,
    pub handler: acpi_tbl_entry_handler,
    pub handler_arg: acpi_tbl_entry_handler_arg,
    pub arg: *mut ffi::c_void,
    pub count: ffi::c_int,
}
impl Default for acpi_subtable_proc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fw_table_header {
    pub acpi: acpi_table_header,
    pub cdat: acpi_table_cdat,
}
impl Default for fw_table_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_subtable_headers {
    pub common: acpi_subtable_header,
    pub hmat: acpi_hmat_structure,
    pub prmt: acpi_prmt_module_header,
    pub cedt: acpi_cedt_header,
    pub cdat: acpi_cdat_header,
}
impl Default for acpi_subtable_headers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_handle_list {
    pub count: u32_,
    pub handles: *mut acpi_handle,
}
impl Default for acpi_handle_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_dir_entry {
    _unused: [u8; 0],
}

pub const acpi_bus_device_type_ACPI_BUS_TYPE_DEVICE: acpi_bus_device_type = 0;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_POWER: acpi_bus_device_type = 1;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_PROCESSOR: acpi_bus_device_type = 2;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_THERMAL: acpi_bus_device_type = 3;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_POWER_BUTTON: acpi_bus_device_type = 4;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_SLEEP_BUTTON: acpi_bus_device_type = 5;
pub const acpi_bus_device_type_ACPI_BUS_TYPE_ECDT_EC: acpi_bus_device_type = 6;
pub const acpi_bus_device_type_ACPI_BUS_DEVICE_TYPE_COUNT: acpi_bus_device_type = 7;
pub type acpi_bus_device_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_hotplug_profile {
    pub kobj: kobject,
    pub scan_dependent:
        ::core::option::Option<unsafe extern "C" fn(adev: *mut acpi_device) -> ffi::c_int>,
    pub notify_online: ::core::option::Option<unsafe extern "C" fn(adev: *mut acpi_device)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for acpi_hotplug_profile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl acpi_hotplug_profile {
    #[inline]
    pub fn enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn demand_offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_demand_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn demand_offline_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_demand_offline_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: bool_,
        demand_offline: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u8 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let demand_offline: u8 = unsafe { ::core::mem::transmute(demand_offline) };
            demand_offline as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_scan_handler {
    pub list_node: list_head,
    pub ids: *const acpi_device_id,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            idstr: *const ffi::c_char,
            matchid: *mut *const acpi_device_id,
        ) -> bool_,
    >,
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut acpi_device, id: *const acpi_device_id) -> ffi::c_int,
    >,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut acpi_device)>,
    pub post_eject: ::core::option::Option<unsafe extern "C" fn(dev: *mut acpi_device)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(phys_dev: *mut device)>,
    pub unbind: ::core::option::Option<unsafe extern "C" fn(phys_dev: *mut device)>,
    pub hotplug: acpi_hotplug_profile,
}
impl Default for acpi_scan_handler {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type acpi_hp_notify =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut acpi_device, arg2: u32_) -> ffi::c_int>;
pub type acpi_hp_uevent =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut acpi_device, arg2: u32_)>;
pub type acpi_hp_fixup = ::core::option::Option<unsafe extern "C" fn(arg1: *mut acpi_device)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_hotplug_context {
    pub self_: *mut acpi_device,
    pub notify: acpi_hp_notify,
    pub uevent: acpi_hp_uevent,
    pub fixup: acpi_hp_fixup,
}
impl Default for acpi_hotplug_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type acpi_op_add =
    ::core::option::Option<unsafe extern "C" fn(device: *mut acpi_device) -> ffi::c_int>;
pub type acpi_op_remove = ::core::option::Option<unsafe extern "C" fn(device: *mut acpi_device)>;
pub type acpi_op_notify =
    ::core::option::Option<unsafe extern "C" fn(device: *mut acpi_device, event: u32_)>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_ops {
    pub add: acpi_op_add,
    pub remove: acpi_op_remove,
    pub notify: acpi_op_notify,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_driver {
    pub name: [ffi::c_char; 80usize],
    pub class: [ffi::c_char; 80usize],
    pub ids: *const acpi_device_id,
    pub flags: ffi::c_uint,
    pub ops: acpi_device_ops,
    pub drv: device_driver,
}
impl Default for acpi_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_status {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl acpi_device_status {
    #[inline]
    pub fn present(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn present_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_present_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enabled(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn show_in_ui(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_in_ui(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn show_in_ui_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_show_in_ui_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn functional(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_functional(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn functional_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_functional_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn battery_present(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_battery_present(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn battery_present_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_battery_present_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        present: u32_,
        enabled: u32_,
        show_in_ui: u32_,
        functional: u32_,
        battery_present: u32_,
        reserved: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let present: u32 = unsafe { ::core::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let show_in_ui: u32 = unsafe { ::core::mem::transmute(show_in_ui) };
            show_in_ui as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let functional: u32 = unsafe { ::core::mem::transmute(functional) };
            functional as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let battery_present: u32 = unsafe { ::core::mem::transmute(battery_present) };
            battery_present as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_flags {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl acpi_device_flags {
    #[inline]
    pub fn dynamic_status(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dynamic_status(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dynamic_status_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dynamic_status_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn removable(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_removable(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn removable_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_removable_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ejectable(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ejectable(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ejectable_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ejectable_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_manageable(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_manageable(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_manageable_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_manageable_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn match_driver(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_match_driver(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn match_driver_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_match_driver_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn visited(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_visited(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn visited_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_visited_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hotplug_notify(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hotplug_notify(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hotplug_notify_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hotplug_notify_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_dock_station(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dock_station(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_dock_station_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_dock_station_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn of_compatible_ok(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_of_compatible_ok(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn of_compatible_ok_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_of_compatible_ok_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn coherent_dma(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coherent_dma(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn coherent_dma_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_coherent_dma_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cca_seen(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cca_seen(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cca_seen_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cca_seen_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enumeration_by_parent(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enumeration_by_parent(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enumeration_by_parent_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enumeration_by_parent_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn honor_deps(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_honor_deps(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn honor_deps_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_honor_deps_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dynamic_status: u32_,
        removable: u32_,
        ejectable: u32_,
        power_manageable: u32_,
        match_driver: u32_,
        initialized: u32_,
        visited: u32_,
        hotplug_notify: u32_,
        is_dock_station: u32_,
        of_compatible_ok: u32_,
        coherent_dma: u32_,
        cca_seen: u32_,
        enumeration_by_parent: u32_,
        honor_deps: u32_,
        reserved: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dynamic_status: u32 = unsafe { ::core::mem::transmute(dynamic_status) };
            dynamic_status as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let removable: u32 = unsafe { ::core::mem::transmute(removable) };
            removable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ejectable: u32 = unsafe { ::core::mem::transmute(ejectable) };
            ejectable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let power_manageable: u32 = unsafe { ::core::mem::transmute(power_manageable) };
            power_manageable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let match_driver: u32 = unsafe { ::core::mem::transmute(match_driver) };
            match_driver as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let initialized: u32 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let visited: u32 = unsafe { ::core::mem::transmute(visited) };
            visited as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hotplug_notify: u32 = unsafe { ::core::mem::transmute(hotplug_notify) };
            hotplug_notify as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_dock_station: u32 = unsafe { ::core::mem::transmute(is_dock_station) };
            is_dock_station as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let of_compatible_ok: u32 = unsafe { ::core::mem::transmute(of_compatible_ok) };
            of_compatible_ok as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let coherent_dma: u32 = unsafe { ::core::mem::transmute(coherent_dma) };
            coherent_dma as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cca_seen: u32 = unsafe { ::core::mem::transmute(cca_seen) };
            cca_seen as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enumeration_by_parent: u32 =
                unsafe { ::core::mem::transmute(enumeration_by_parent) };
            enumeration_by_parent as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let honor_deps: u32 = unsafe { ::core::mem::transmute(honor_deps) };
            honor_deps as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_dir {
    pub entry: *mut proc_dir_entry,
}
impl Default for acpi_device_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type acpi_bus_id = [ffi::c_char; 8usize];
pub type acpi_bus_address = u64_;
pub type acpi_device_name = [ffi::c_char; 40usize];
pub type acpi_device_class = [ffi::c_char; 20usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_hardware_id {
    pub list: list_head,
    pub id: *const ffi::c_char,
}
impl Default for acpi_hardware_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_pnp_type {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl acpi_pnp_type {
    #[inline]
    pub fn hardware_id(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hardware_id(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hardware_id_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hardware_id_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bus_address(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bus_address(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bus_address_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bus_address_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn platform_id(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_platform_id(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn platform_id_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_platform_id_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn backlight(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backlight(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn backlight_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_backlight_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hardware_id: u32_,
        bus_address: u32_,
        platform_id: u32_,
        backlight: u32_,
        reserved: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hardware_id: u32 = unsafe { ::core::mem::transmute(hardware_id) };
            hardware_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bus_address: u32 = unsafe { ::core::mem::transmute(bus_address) };
            bus_address as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let platform_id: u32 = unsafe { ::core::mem::transmute(platform_id) };
            platform_id as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let backlight: u32 = unsafe { ::core::mem::transmute(backlight) };
            backlight as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_pnp {
    pub bus_id: acpi_bus_id,
    pub instance_no: ffi::c_int,
    pub type_: acpi_pnp_type,
    pub bus_address: acpi_bus_address,
    pub unique_id: *mut ffi::c_char,
    pub ids: list_head,
    pub device_name: acpi_device_name,
    pub device_class: acpi_device_class,
}
impl Default for acpi_device_pnp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_power_flags {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl acpi_device_power_flags {
    #[inline]
    pub fn explicit_get(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_explicit_get(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn explicit_get_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_explicit_get_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_resources(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_resources(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_resources_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_resources_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inrush_current(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inrush_current(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inrush_current_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inrush_current_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_removed(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_removed(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_removed_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_removed_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_parent(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_parent(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_parent_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_parent_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dsw_present(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsw_present(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dsw_present_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dsw_present_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        explicit_get: u32_,
        power_resources: u32_,
        inrush_current: u32_,
        power_removed: u32_,
        ignore_parent: u32_,
        dsw_present: u32_,
        reserved: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let explicit_get: u32 = unsafe { ::core::mem::transmute(explicit_get) };
            explicit_get as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_resources: u32 = unsafe { ::core::mem::transmute(power_resources) };
            power_resources as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inrush_current: u32 = unsafe { ::core::mem::transmute(inrush_current) };
            inrush_current as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let power_removed: u32 = unsafe { ::core::mem::transmute(power_removed) };
            power_removed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ignore_parent: u32 = unsafe { ::core::mem::transmute(ignore_parent) };
            ignore_parent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsw_present: u32 = unsafe { ::core::mem::transmute(dsw_present) };
            dsw_present as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_power_state {
    pub resources: list_head,
    pub flags: acpi_device_power_state__bindgen_ty_1,
    pub power: ffi::c_int,
    pub latency: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_power_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl acpi_device_power_state__bindgen_ty_1 {
    #[inline]
    pub fn valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn explicit_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_explicit_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn explicit_set_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_explicit_set_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid: u8_,
        explicit_set: u8_,
        reserved: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u8 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let explicit_set: u8 = unsafe { ::core::mem::transmute(explicit_set) };
            explicit_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for acpi_device_power_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_power {
    pub state: ffi::c_int,
    pub flags: acpi_device_power_flags,
    pub states: [acpi_device_power_state; 5usize],
    pub state_for_enumeration: u8_,
}
impl Default for acpi_device_power {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_dep_data {
    pub node: list_head,
    pub supplier: acpi_handle,
    pub consumer: acpi_handle,
    pub honor_dep: bool_,
    pub met: bool_,
    pub free_when_met: bool_,
}
impl Default for acpi_dep_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_perf_flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl acpi_device_perf_flags {
    #[inline]
    pub fn reserved(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_perf_state {
    pub flags: acpi_device_perf_state__bindgen_ty_1,
    pub power: u8_,
    pub performance: u8_,
    pub latency: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_perf_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl acpi_device_perf_state__bindgen_ty_1 {
    #[inline]
    pub fn valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(valid: u8_, reserved: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u8 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_perf {
    pub state: ffi::c_int,
    pub flags: acpi_device_perf_flags,
    pub state_count: ffi::c_int,
    pub states: *mut acpi_device_perf_state,
}
impl Default for acpi_device_perf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_wakeup_flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl acpi_device_wakeup_flags {
    #[inline]
    pub fn valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn notifier_present(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_notifier_present(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn notifier_present_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_notifier_present_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid: u8_,
        notifier_present: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u8 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let notifier_present: u8 = unsafe { ::core::mem::transmute(notifier_present) };
            notifier_present as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_wakeup_context {
    pub func:
        ::core::option::Option<unsafe extern "C" fn(context: *mut acpi_device_wakeup_context)>,
    pub dev: *mut device,
}
impl Default for acpi_device_wakeup_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_wakeup {
    pub gpe_device: acpi_handle,
    pub gpe_number: u64_,
    pub sleep_state: u64_,
    pub resources: list_head,
    pub flags: acpi_device_wakeup_flags,
    pub context: acpi_device_wakeup_context,
    pub ws: *mut wakeup_source,
    pub prepare_count: ffi::c_int,
    pub enable_count: ffi::c_int,
}
impl Default for acpi_device_wakeup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_physical_node {
    pub node: list_head,
    pub dev: *mut device,
    pub node_id: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for acpi_device_physical_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl acpi_device_physical_node {
    #[inline]
    pub fn put_online(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_put_online(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn put_online_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_put_online_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(put_online: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let put_online: u8 = unsafe { ::core::mem::transmute(put_online) };
            put_online as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_properties {
    pub list: list_head,
    pub guid: *const guid_t,
    pub properties: *mut acpi_object,
    pub bufs: *mut *mut ffi::c_void,
}
impl Default for acpi_device_properties {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_data {
    pub pointer: *const acpi_object,
    pub properties: list_head,
    pub of_compatible: *const acpi_object,
    pub subnodes: list_head,
}
impl Default for acpi_device_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_gpio_mapping {
    _unused: [u8; 0],
}
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_ROTATION:
    acpi_device_swnode_dev_props = 0;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_CLOCK_FREQUENCY:
    acpi_device_swnode_dev_props = 1;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_LED_MAX_MICROAMP:
    acpi_device_swnode_dev_props = 2;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_MICROAMP:
    acpi_device_swnode_dev_props = 3;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_TIMEOUT_US:
    acpi_device_swnode_dev_props = 4;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_NUM_OF: acpi_device_swnode_dev_props =
    5;
pub const acpi_device_swnode_dev_props_ACPI_DEVICE_SWNODE_DEV_NUM_ENTRIES:
    acpi_device_swnode_dev_props = 6;
pub type acpi_device_swnode_dev_props = ffi::c_uint;
pub const acpi_device_swnode_port_props_ACPI_DEVICE_SWNODE_PORT_REG: acpi_device_swnode_port_props =
    0;
pub const acpi_device_swnode_port_props_ACPI_DEVICE_SWNODE_PORT_NUM_OF:
    acpi_device_swnode_port_props = 1;
pub const acpi_device_swnode_port_props_ACPI_DEVICE_SWNODE_PORT_NUM_ENTRIES:
    acpi_device_swnode_port_props = 2;
pub type acpi_device_swnode_port_props = ffi::c_uint;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_REMOTE_EP: acpi_device_swnode_ep_props =
    0;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_BUS_TYPE: acpi_device_swnode_ep_props =
    1;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_REG: acpi_device_swnode_ep_props = 2;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_CLOCK_LANES:
    acpi_device_swnode_ep_props = 3;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_DATA_LANES:
    acpi_device_swnode_ep_props = 4;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_LANE_POLARITIES:
    acpi_device_swnode_ep_props = 5;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_LINK_FREQUENCIES:
    acpi_device_swnode_ep_props = 6;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_NUM_OF: acpi_device_swnode_ep_props = 7;
pub const acpi_device_swnode_ep_props_ACPI_DEVICE_SWNODE_EP_NUM_ENTRIES:
    acpi_device_swnode_ep_props = 8;
pub type acpi_device_swnode_ep_props = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_software_node_port {
    pub port_name: [ffi::c_char; 9usize],
    pub data_lanes: [u32_; 8usize],
    pub lane_polarities: [u32_; 9usize],
    pub link_frequencies: [u64_; 8usize],
    pub port_nr: ffi::c_uint,
    pub crs_csi2_local: bool_,
    pub port_props: [property_entry; 2usize],
    pub ep_props: [property_entry; 8usize],
    pub remote_ep: [software_node_ref_args; 1usize],
}
impl Default for acpi_device_software_node_port {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device_software_nodes {
    pub dev_props: [property_entry; 6usize],
    pub nodes: *mut software_node,
    pub nodeptrs: *mut *const software_node,
    pub ports: *mut acpi_device_software_node_port,
    pub num_ports: ffi::c_uint,
}
impl Default for acpi_device_software_nodes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device {
    pub pld_crc: u32_,
    pub device_type: ffi::c_int,
    pub handle: acpi_handle,
    pub fwnode: fwnode_handle,
    pub wakeup_list: list_head,
    pub del_list: list_head,
    pub status: acpi_device_status,
    pub flags: acpi_device_flags,
    pub pnp: acpi_device_pnp,
    pub power: acpi_device_power,
    pub wakeup: acpi_device_wakeup,
    pub performance: acpi_device_perf,
    pub dir: acpi_device_dir,
    pub data: acpi_device_data,
    pub handler: *mut acpi_scan_handler,
    pub hp: *mut acpi_hotplug_context,
    pub swnodes: *mut acpi_device_software_nodes,
    pub driver_gpios: *const acpi_gpio_mapping,
    pub driver_data: *mut ffi::c_void,
    pub dev: device,
    pub physical_node_count: ffi::c_uint,
    pub dep_unmet: ffi::c_uint,
    pub physical_node_list: list_head,
    pub physical_node_lock: mutex,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut acpi_device)>,
}
impl Default for acpi_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_data_node {
    pub sibling: list_head,
    pub name: *const ffi::c_char,
    pub handle: acpi_handle,
    pub fwnode: fwnode_handle,
    pub parent: *mut fwnode_handle,
    pub data: acpi_device_data,
    pub kobj: kobject,
    pub kobj_done: completion,
}
impl Default for acpi_data_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_bus_event {
    pub node: list_head,
    pub device_class: acpi_device_class,
    pub bus_id: acpi_bus_id,
    pub type_: u32_,
    pub data: u32_,
}
impl Default for acpi_bus_event {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_bus_type {
    pub list: list_head,
    pub name: *const ffi::c_char,
    pub match_: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> bool_>,
    pub find_companion:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut acpi_device>,
    pub setup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
}
impl Default for acpi_bus_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const acpi_bridge_type_ACPI_BRIDGE_TYPE_PCIE: acpi_bridge_type = 1;
pub const acpi_bridge_type_ACPI_BRIDGE_TYPE_CXL: acpi_bridge_type = 2;
pub type acpi_bridge_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_pci_root {
    pub device: *mut acpi_device,
    pub bus: *mut pci_bus,
    pub segment: u16_,
    pub bridge_type: ffi::c_int,
    pub secondary: resource,
    pub osc_support_set: u32_,
    pub osc_control_set: u32_,
    pub osc_ext_support_set: u32_,
    pub osc_ext_control_set: u32_,
    pub mcfg_addr: phys_addr_t,
}
impl Default for acpi_pci_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_ops {
    _unused: [u8; 0],
}

pub type pgtbl_mod_mask = ffi::c_uint;

pub const LOGIC_PIO_INDIRECT: _bindgen_ty_95 = 0;
pub const LOGIC_PIO_CPU_MMIO: _bindgen_ty_95 = 1;
pub type _bindgen_ty_95 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct logic_pio_hwaddr {
    pub list: list_head,
    pub fwnode: *const fwnode_handle,
    pub hw_start: resource_size_t,
    pub io_start: resource_size_t,
    pub size: resource_size_t,
    pub flags: ffi::c_ulong,
    pub hostdata: *mut ffi::c_void,
    pub ops: *const logic_pio_host_ops,
}
impl Default for logic_pio_hwaddr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct logic_pio_host_ops {
    pub in_: ::core::option::Option<
        unsafe extern "C" fn(hostdata: *mut ffi::c_void, addr: ffi::c_ulong, dwidth: usize) -> u32_,
    >,
    pub out: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ffi::c_void,
            addr: ffi::c_ulong,
            val: u32_,
            dwidth: usize,
        ),
    >,
    pub ins: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ffi::c_void,
            addr: ffi::c_ulong,
            buffer: *mut ffi::c_void,
            dwidth: usize,
            count: ffi::c_uint,
        ) -> u32_,
    >,
    pub outs: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ffi::c_void,
            addr: ffi::c_ulong,
            buffer: *const ffi::c_void,
            dwidth: usize,
            count: ffi::c_uint,
        ),
    >,
}

pub const MEMREMAP_WB: _bindgen_ty_96 = 1;
pub const MEMREMAP_WT: _bindgen_ty_96 = 2;
pub const MEMREMAP_WC: _bindgen_ty_96 = 4;
pub const MEMREMAP_ENC: _bindgen_ty_96 = 8;
pub const MEMREMAP_DEC: _bindgen_ty_96 = 16;
pub type _bindgen_ty_96 = ffi::c_uint;

pub type phys_cpuid_t = u64_;

pub const acpi_irq_model_id_ACPI_IRQ_MODEL_PIC: acpi_irq_model_id = 0;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_IOAPIC: acpi_irq_model_id = 1;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_IOSAPIC: acpi_irq_model_id = 2;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_PLATFORM: acpi_irq_model_id = 3;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_GIC: acpi_irq_model_id = 4;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_LPIC: acpi_irq_model_id = 5;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_RINTC: acpi_irq_model_id = 6;
pub const acpi_irq_model_id_ACPI_IRQ_MODEL_COUNT: acpi_irq_model_id = 7;
pub type acpi_irq_model_id = ffi::c_uint;

pub const acpi_interrupt_id_ACPI_INTERRUPT_PMI: acpi_interrupt_id = 1;
pub const acpi_interrupt_id_ACPI_INTERRUPT_INIT: acpi_interrupt_id = 2;
pub const acpi_interrupt_id_ACPI_INTERRUPT_CPEI: acpi_interrupt_id = 3;
pub const acpi_interrupt_id_ACPI_INTERRUPT_COUNT: acpi_interrupt_id = 4;
pub type acpi_interrupt_id = ffi::c_uint;
pub const acpi_address_range_id_ACPI_ADDRESS_RANGE_MEMORY: acpi_address_range_id = 1;
pub const acpi_address_range_id_ACPI_ADDRESS_RANGE_RESERVED: acpi_address_range_id = 2;
pub const acpi_address_range_id_ACPI_ADDRESS_RANGE_ACPI: acpi_address_range_id = 3;
pub const acpi_address_range_id_ACPI_ADDRESS_RANGE_NVS: acpi_address_range_id = 4;
pub const acpi_address_range_id_ACPI_ADDRESS_RANGE_COUNT: acpi_address_range_id = 5;
pub type acpi_address_range_id = ffi::c_uint;
pub type acpi_tbl_table_handler =
    ::core::option::Option<unsafe extern "C" fn(table: *mut acpi_table_header) -> ffi::c_int>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_debugger_ops {
    pub create_thread: ::core::option::Option<
        unsafe extern "C" fn(
            function: acpi_osd_exec_callback,
            context: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub write_log: ::core::option::Option<unsafe extern "C" fn(msg: *const ffi::c_char) -> isize>,
    pub read_cmd: ::core::option::Option<
        unsafe extern "C" fn(buffer: *mut ffi::c_char, length: usize) -> isize,
    >,
    pub wait_command_ready: ::core::option::Option<
        unsafe extern "C" fn(
            single_step: bool_,
            buffer: *mut ffi::c_char,
            length: usize,
        ) -> ffi::c_int,
    >,
    pub notify_command_complete: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_debugger {
    pub ops: *const acpi_debugger_ops,
    pub owner: *mut module,
    pub lock: mutex,
}
impl Default for acpi_debugger {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_processor_power {
    _unused: [u8; 0],
}

pub type acpi_gsi_domain_disp_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32_) -> *mut fwnode_handle>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_prt_entry {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_osc_context {
    pub uuid_str: *mut ffi::c_char,
    pub rev: ffi::c_int,
    pub cap: acpi_buffer,
    pub ret: acpi_buffer,
}
impl Default for acpi_osc_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const acpi_predicate_all_versions: acpi_predicate = 0;
pub const acpi_predicate_less_than_or_equal: acpi_predicate = 1;
pub const acpi_predicate_equal: acpi_predicate = 2;
pub const acpi_predicate_greater_than_or_equal: acpi_predicate = 3;
pub type acpi_predicate = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_platform_list {
    pub oem_id: [ffi::c_char; 7usize],
    pub oem_table_id: [ffi::c_char; 9usize],
    pub oem_revision: u32_,
    pub table: *mut ffi::c_char,
    pub pred: acpi_predicate,
    pub reason: *mut ffi::c_char,
    pub data: u32_,
}
impl Default for acpi_platform_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const acpi_reconfig_event_ACPI_RECONFIG_DEVICE_ADD: acpi_reconfig_event = 0;
pub const acpi_reconfig_event_ACPI_RECONFIG_DEVICE_REMOVE: acpi_reconfig_event = 1;
pub type acpi_reconfig_event = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_s2idle_dev_ops {
    pub list_node: list_head,
    pub prepare: ::core::option::Option<unsafe extern "C" fn()>,
    pub check: ::core::option::Option<unsafe extern "C" fn()>,
    pub restore: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for acpi_s2idle_dev_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type acpi_probe_entry_validate_subtbl = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut acpi_subtable_header, arg2: *mut acpi_probe_entry) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_probe_entry {
    pub id: [__u8; 5usize],
    pub type_: __u8,
    pub subtable_valid: acpi_probe_entry_validate_subtbl,
    pub __bindgen_anon_1: acpi_probe_entry__bindgen_ty_1,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union acpi_probe_entry__bindgen_ty_1 {
    pub probe_table: acpi_tbl_table_handler,
    pub probe_subtbl: acpi_tbl_entry_handler,
}
impl Default for acpi_probe_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for acpi_probe_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type depot_stack_handle_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union handle_parts {
    pub handle: depot_stack_handle_t,
    pub __bindgen_anon_1: handle_parts__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct handle_parts__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl handle_parts__bindgen_ty_1 {
    #[inline]
    pub fn pool_index_plus_1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_pool_index_plus_1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pool_index_plus_1_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                17u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pool_index_plus_1_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extra(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_extra(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extra_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_extra_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pool_index_plus_1: u32_,
        offset: u32_,
        extra: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 17u8, {
            let pool_index_plus_1: u32 = unsafe { ::core::mem::transmute(pool_index_plus_1) };
            pool_index_plus_1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 10u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let extra: u32 = unsafe { ::core::mem::transmute(extra) };
            extra as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for handle_parts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stack_record {
    pub hash_list: list_head,
    pub hash: u32_,
    pub size: u32_,
    pub handle: handle_parts,
    pub count: refcount_t,
    pub __bindgen_anon_1: stack_record__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union stack_record__bindgen_ty_1 {
    pub entries: [ffi::c_ulong; 64usize],
    pub __bindgen_anon_1: stack_record__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stack_record__bindgen_ty_1__bindgen_ty_1 {
    pub free_list: list_head,
    pub rcu_state: ffi::c_ulong,
}
impl Default for stack_record__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for stack_record__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for stack_record {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type depot_flags_t = u32_;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex_base {
    pub wait_lock: raw_spinlock_t,
    pub waiters: rb_root_cached,
    pub owner: *mut task_struct,
}
impl Default for rt_mutex_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex {
    pub rtmutex: rt_mutex_base,
}
impl Default for rt_mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex_waiter {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ww_class {
    pub stamp: atomic_long_t,
    pub acquire_key: lock_class_key,
    pub mutex_key: lock_class_key,
    pub acquire_name: *const ffi::c_char,
    pub mutex_name: *const ffi::c_char,
    pub is_wait_die: ffi::c_uint,
}
impl Default for ww_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ww_mutex {
    pub base: mutex,
    pub ctx: *mut ww_acquire_ctx,
}
impl Default for ww_mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ww_acquire_ctx {
    pub task: *mut task_struct,
    pub stamp: ffi::c_ulong,
    pub acquired: ffi::c_uint,
    pub wounded: ffi::c_ushort,
    pub is_wait_die: ffi::c_ushort,
}
impl Default for ww_acquire_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_modeset_acquire_ctx {
    pub ww_ctx: ww_acquire_ctx,
    pub contended: *mut drm_modeset_lock,
    pub stack_depot: depot_stack_handle_t,
    pub locked: list_head,
    pub trylock_only: bool_,
    pub interruptible: bool_,
}
impl Default for drm_modeset_acquire_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_modeset_lock {
    pub mutex: ww_mutex,
    pub head: list_head,
}
impl Default for drm_modeset_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_crtc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_plane {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_atomic_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_format_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_display_mode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_config_funcs {
    pub fb_create: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            file_priv: *mut drm_file,
            info: *const drm_format_info,
            mode_cmd: *const drm_mode_fb_cmd2,
        ) -> *mut drm_framebuffer,
    >,
    pub get_format_info: ::core::option::Option<
        unsafe extern "C" fn(pixel_format: u32_, modifier: u64_) -> *const drm_format_info,
    >,
    pub mode_valid: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            mode: *const drm_display_mode,
        ) -> drm_mode_status,
    >,
    pub atomic_check: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut drm_device, state: *mut drm_atomic_state) -> ffi::c_int,
    >,
    pub atomic_commit: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            state: *mut drm_atomic_state,
            nonblock: bool_,
        ) -> ffi::c_int,
    >,
    pub atomic_state_alloc:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut drm_device) -> *mut drm_atomic_state>,
    pub atomic_state_clear:
        ::core::option::Option<unsafe extern "C" fn(state: *mut drm_atomic_state)>,
    pub atomic_state_free:
        ::core::option::Option<unsafe extern "C" fn(state: *mut drm_atomic_state)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_mode_config {
    pub mutex: mutex,
    pub connection_mutex: drm_modeset_lock,
    pub acquire_ctx: *mut drm_modeset_acquire_ctx,
    pub idr_mutex: mutex,
    pub object_idr: idr,
    pub tile_idr: idr,
    pub fb_lock: mutex,
    pub num_fb: ffi::c_int,
    pub fb_list: list_head,
    pub connector_list_lock: spinlock_t,
    pub num_connector: ffi::c_int,
    pub connector_ida: ida,
    pub connector_list: list_head,
    pub connector_free_list: llist_head,
    pub connector_free_work: work_struct,
    pub num_encoder: ffi::c_int,
    pub encoder_list: list_head,
    pub num_total_plane: ffi::c_int,
    pub plane_list: list_head,
    pub panic_lock: raw_spinlock,
    pub num_crtc: ffi::c_int,
    pub crtc_list: list_head,
    pub property_list: list_head,
    pub privobj_list: list_head,
    pub min_width: ffi::c_uint,
    pub min_height: ffi::c_uint,
    pub max_width: ffi::c_uint,
    pub max_height: ffi::c_uint,
    pub funcs: *const drm_mode_config_funcs,
    pub poll_enabled: bool_,
    pub poll_running: bool_,
    pub delayed_event: bool_,
    pub output_poll_work: delayed_work,
    pub blob_lock: mutex,
    pub property_blob_list: list_head,
    pub edid_property: *mut drm_property,
    pub dpms_property: *mut drm_property,
    pub path_property: *mut drm_property,
    pub tile_property: *mut drm_property,
    pub link_status_property: *mut drm_property,
    pub plane_type_property: *mut drm_property,
    pub prop_src_x: *mut drm_property,
    pub prop_src_y: *mut drm_property,
    pub prop_src_w: *mut drm_property,
    pub prop_src_h: *mut drm_property,
    pub prop_crtc_x: *mut drm_property,
    pub prop_crtc_y: *mut drm_property,
    pub prop_crtc_w: *mut drm_property,
    pub prop_crtc_h: *mut drm_property,
    pub prop_fb_id: *mut drm_property,
    pub prop_in_fence_fd: *mut drm_property,
    pub prop_out_fence_ptr: *mut drm_property,
    pub prop_crtc_id: *mut drm_property,
    pub prop_fb_damage_clips: *mut drm_property,
    pub prop_active: *mut drm_property,
    pub prop_mode_id: *mut drm_property,
    pub prop_vrr_enabled: *mut drm_property,
    pub dvi_i_subconnector_property: *mut drm_property,
    pub dvi_i_select_subconnector_property: *mut drm_property,
    pub dp_subconnector_property: *mut drm_property,
    pub tv_subconnector_property: *mut drm_property,
    pub tv_select_subconnector_property: *mut drm_property,
    pub legacy_tv_mode_property: *mut drm_property,
    pub tv_mode_property: *mut drm_property,
    pub tv_left_margin_property: *mut drm_property,
    pub tv_right_margin_property: *mut drm_property,
    pub tv_top_margin_property: *mut drm_property,
    pub tv_bottom_margin_property: *mut drm_property,
    pub tv_brightness_property: *mut drm_property,
    pub tv_contrast_property: *mut drm_property,
    pub tv_flicker_reduction_property: *mut drm_property,
    pub tv_overscan_property: *mut drm_property,
    pub tv_saturation_property: *mut drm_property,
    pub tv_hue_property: *mut drm_property,
    pub scaling_mode_property: *mut drm_property,
    pub aspect_ratio_property: *mut drm_property,
    pub content_type_property: *mut drm_property,
    pub degamma_lut_property: *mut drm_property,
    pub degamma_lut_size_property: *mut drm_property,
    pub ctm_property: *mut drm_property,
    pub gamma_lut_property: *mut drm_property,
    pub gamma_lut_size_property: *mut drm_property,
    pub suggested_x_property: *mut drm_property,
    pub suggested_y_property: *mut drm_property,
    pub non_desktop_property: *mut drm_property,
    pub panel_orientation_property: *mut drm_property,
    pub writeback_fb_id_property: *mut drm_property,
    pub writeback_pixel_formats_property: *mut drm_property,
    pub writeback_out_fence_ptr_property: *mut drm_property,
    pub hdr_output_metadata_property: *mut drm_property,
    pub content_protection_property: *mut drm_property,
    pub hdcp_content_type_property: *mut drm_property,
    pub preferred_depth: u32,
    pub prefer_shadow: u32,
    pub quirk_addfb_prefer_xbgr_30bpp: bool_,
    pub quirk_addfb_prefer_host_byte_order: bool_,
    pub async_page_flip: bool_,
    pub fb_modifiers_not_supported: bool_,
    pub normalize_zpos: bool_,
    pub modifiers_property: *mut drm_property,
    pub async_modifiers_property: *mut drm_property,
    pub size_hints_property: *mut drm_property,
    pub cursor_width: u32,
    pub cursor_height: u32,
    pub suspend_state: *mut drm_atomic_state,
    pub helper_private: *mut drm_mode_config_helper_funcs,
}
impl Default for drm_mode_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_master {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_vblank_crtc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_vram_mm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_fb_helper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_controller {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_wedge_task_info {
    pub pid: pid_t,
    pub comm: [ffi::c_char; 16usize],
}
pub const switch_power_state_DRM_SWITCH_POWER_ON: switch_power_state = 0;
pub const switch_power_state_DRM_SWITCH_POWER_OFF: switch_power_state = 1;
pub const switch_power_state_DRM_SWITCH_POWER_CHANGING: switch_power_state = 2;
pub const switch_power_state_DRM_SWITCH_POWER_DYNAMIC_OFF: switch_power_state = 3;
pub type switch_power_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_device {
    pub if_version: ffi::c_int,
    pub ref_: kref,
    pub dev: *mut device,
    pub dma_dev: *mut device,
    pub managed: drm_device__bindgen_ty_1,
    pub driver: *const drm_driver,
    pub dev_private: *mut ffi::c_void,
    pub primary: *mut drm_minor,
    pub render: *mut drm_minor,
    pub accel: *mut drm_minor,
    pub registered: bool_,
    pub master: *mut drm_master,
    pub driver_features: u32_,
    pub unplugged: bool_,
    pub anon_inode: *mut inode,
    pub unique: *mut ffi::c_char,
    pub struct_mutex: mutex,
    pub master_mutex: mutex,
    pub open_count: atomic_t,
    pub filelist_mutex: mutex,
    pub filelist: list_head,
    pub filelist_internal: list_head,
    pub clientlist_mutex: mutex,
    pub clientlist: list_head,
    pub vblank_disable_immediate: bool_,
    pub vblank: *mut drm_vblank_crtc,
    pub vblank_time_lock: spinlock_t,
    pub vbl_lock: spinlock_t,
    pub max_vblank_count: u32_,
    pub vblank_event_list: list_head,
    pub event_lock: spinlock_t,
    pub num_crtcs: ffi::c_uint,
    pub mode_config: drm_mode_config,
    pub object_name_lock: mutex,
    pub object_name_idr: idr,
    pub vma_offset_manager: *mut drm_vma_offset_manager,
    pub vram_mm: *mut drm_vram_mm,
    pub switch_power_state: switch_power_state,
    pub fb_helper: *mut drm_fb_helper,
    pub debugfs_root: *mut dentry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_device__bindgen_ty_1 {
    pub resources: list_head,
    pub final_kfree: *mut ffi::c_void,
    pub lock: spinlock_t,
}
impl Default for drm_device__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for drm_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmem_cgroup_region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_fb_helper_surface_size {
    _unused: [u8; 0],
}
pub const drm_driver_feature_DRIVER_GEM: drm_driver_feature = 1;
pub const drm_driver_feature_DRIVER_MODESET: drm_driver_feature = 2;
pub const drm_driver_feature_DRIVER_RENDER: drm_driver_feature = 8;
pub const drm_driver_feature_DRIVER_ATOMIC: drm_driver_feature = 16;
pub const drm_driver_feature_DRIVER_SYNCOBJ: drm_driver_feature = 32;
pub const drm_driver_feature_DRIVER_SYNCOBJ_TIMELINE: drm_driver_feature = 64;
pub const drm_driver_feature_DRIVER_COMPUTE_ACCEL: drm_driver_feature = 128;
pub const drm_driver_feature_DRIVER_GEM_GPUVA: drm_driver_feature = 256;
pub const drm_driver_feature_DRIVER_CURSOR_HOTSPOT: drm_driver_feature = 512;
pub const drm_driver_feature_DRIVER_USE_AGP: drm_driver_feature = 33554432;
pub const drm_driver_feature_DRIVER_LEGACY: drm_driver_feature = 67108864;
pub const drm_driver_feature_DRIVER_PCI_DMA: drm_driver_feature = 134217728;
pub const drm_driver_feature_DRIVER_SG: drm_driver_feature = 268435456;
pub const drm_driver_feature_DRIVER_HAVE_DMA: drm_driver_feature = 536870912;
pub const drm_driver_feature_DRIVER_HAVE_IRQ: drm_driver_feature = 1073741824;
pub type drm_driver_feature = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_driver {
    pub load: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut drm_device, flags: ffi::c_ulong) -> ffi::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut drm_device, arg2: *mut drm_file) -> ffi::c_int,
    >,
    pub postclose:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut drm_device, arg2: *mut drm_file)>,
    pub unload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut drm_device)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut drm_device)>,
    pub master_set: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut drm_device, file_priv: *mut drm_file, from_open: bool_),
    >,
    pub master_drop: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut drm_device, file_priv: *mut drm_file),
    >,
    pub debugfs_init: ::core::option::Option<unsafe extern "C" fn(minor: *mut drm_minor)>,
    pub gem_create_object: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut drm_device, size: usize) -> *mut drm_gem_object,
    >,
    pub prime_handle_to_fd: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            file_priv: *mut drm_file,
            handle: u32,
            flags: u32,
            prime_fd: *mut ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub prime_fd_to_handle: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            file_priv: *mut drm_file,
            prime_fd: ffi::c_int,
            handle: *mut u32,
        ) -> ffi::c_int,
    >,
    pub gem_prime_import: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut drm_device, dma_buf: *mut dma_buf) -> *mut drm_gem_object,
    >,
    pub gem_prime_import_sg_table: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut drm_device,
            attach: *mut dma_buf_attachment,
            sgt: *mut sg_table,
        ) -> *mut drm_gem_object,
    >,
    pub dumb_create: ::core::option::Option<
        unsafe extern "C" fn(
            file_priv: *mut drm_file,
            dev: *mut drm_device,
            args: *mut drm_mode_create_dumb,
        ) -> ffi::c_int,
    >,
    pub dumb_map_offset: ::core::option::Option<
        unsafe extern "C" fn(
            file_priv: *mut drm_file,
            dev: *mut drm_device,
            handle: u32,
            offset: *mut u64,
        ) -> ffi::c_int,
    >,
    pub fbdev_probe: ::core::option::Option<
        unsafe extern "C" fn(
            fbdev_helper: *mut drm_fb_helper,
            sizes: *mut drm_fb_helper_surface_size,
        ) -> ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(p: *mut drm_printer, f: *mut drm_file)>,
    pub major: ffi::c_int,
    pub minor: ffi::c_int,
    pub patchlevel: ffi::c_int,
    pub name: *mut ffi::c_char,
    pub desc: *mut ffi::c_char,
    pub driver_features: u32_,
    pub ioctls: *const drm_ioctl_desc,
    pub num_ioctls: ffi::c_int,
    pub fops: *const file_operations,
}
impl Default for drm_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type drm_handle_t = ffi::c_uint;
pub type drm_context_t = ffi::c_uint;
pub type drm_drawable_t = ffi::c_uint;
pub type drm_magic_t = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_clip_rect {
    pub x1: ffi::c_ushort,
    pub y1: ffi::c_ushort,
    pub x2: ffi::c_ushort,
    pub y2: ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_drawable_info {
    pub num_rects: ffi::c_uint,
    pub rects: *mut drm_clip_rect,
}
impl Default for drm_drawable_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_tex_region {
    pub next: ffi::c_uchar,
    pub prev: ffi::c_uchar,
    pub in_use: ffi::c_uchar,
    pub padding: ffi::c_uchar,
    pub age: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_hw_lock {
    pub lock: ffi::c_uint,
    pub padding: [ffi::c_char; 60usize],
}
impl Default for drm_hw_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct drm_version {
    pub version_major: ffi::c_int,
    pub version_minor: ffi::c_int,
    pub version_patchlevel: ffi::c_int,
    pub name_len: __kernel_size_t,
    pub name: *mut ffi::c_char,
    pub date_len: __kernel_size_t,
    pub date: *mut ffi::c_char,
    pub desc_len: __kernel_size_t,
    pub desc: *mut ffi::c_char,
}
impl Default for drm_version {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct drm_unique {
    pub unique_len: __kernel_size_t,
    pub unique: *mut ffi::c_char,
}
impl Default for drm_unique {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_list {
    pub count: ffi::c_int,
    pub version: *mut drm_version,
}
impl Default for drm_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_block {
    pub unused: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1,
    pub irq: ffi::c_int,
}
pub const drm_control_DRM_ADD_COMMAND: drm_control__bindgen_ty_1 = 0;
pub const drm_control_DRM_RM_COMMAND: drm_control__bindgen_ty_1 = 1;
pub const drm_control_DRM_INST_HANDLER: drm_control__bindgen_ty_1 = 2;
pub const drm_control_DRM_UNINST_HANDLER: drm_control__bindgen_ty_1 = 3;
pub type drm_control__bindgen_ty_1 = ffi::c_uint;
impl Default for drm_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const drm_map_type__DRM_FRAME_BUFFER: drm_map_type = 0;
pub const drm_map_type__DRM_REGISTERS: drm_map_type = 1;
pub const drm_map_type__DRM_SHM: drm_map_type = 2;
pub const drm_map_type__DRM_AGP: drm_map_type = 3;
pub const drm_map_type__DRM_SCATTER_GATHER: drm_map_type = 4;
pub const drm_map_type__DRM_CONSISTENT: drm_map_type = 5;
pub type drm_map_type = ffi::c_uint;
pub const drm_map_flags__DRM_RESTRICTED: drm_map_flags = 1;
pub const drm_map_flags__DRM_READ_ONLY: drm_map_flags = 2;
pub const drm_map_flags__DRM_LOCKED: drm_map_flags = 4;
pub const drm_map_flags__DRM_KERNEL: drm_map_flags = 8;
pub const drm_map_flags__DRM_WRITE_COMBINING: drm_map_flags = 16;
pub const drm_map_flags__DRM_CONTAINS_LOCK: drm_map_flags = 32;
pub const drm_map_flags__DRM_REMOVABLE: drm_map_flags = 64;
pub const drm_map_flags__DRM_DRIVER: drm_map_flags = 128;
pub type drm_map_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_ctx_priv_map {
    pub ctx_id: ffi::c_uint,
    pub handle: *mut ffi::c_void,
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_map {
    pub offset: ffi::c_ulong,
    pub size: ffi::c_ulong,
    pub type_: drm_map_type,
    pub flags: drm_map_flags,
    pub handle: *mut ffi::c_void,
    pub mtrr: ffi::c_int,
}
impl Default for drm_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_client {
    pub idx: ffi::c_int,
    pub auth: ffi::c_int,
    pub pid: ffi::c_ulong,
    pub uid: ffi::c_ulong,
    pub magic: ffi::c_ulong,
    pub iocs: ffi::c_ulong,
}
pub const drm_stat_type__DRM_STAT_LOCK: drm_stat_type = 0;
pub const drm_stat_type__DRM_STAT_OPENS: drm_stat_type = 1;
pub const drm_stat_type__DRM_STAT_CLOSES: drm_stat_type = 2;
pub const drm_stat_type__DRM_STAT_IOCTLS: drm_stat_type = 3;
pub const drm_stat_type__DRM_STAT_LOCKS: drm_stat_type = 4;
pub const drm_stat_type__DRM_STAT_UNLOCKS: drm_stat_type = 5;
pub const drm_stat_type__DRM_STAT_VALUE: drm_stat_type = 6;
pub const drm_stat_type__DRM_STAT_BYTE: drm_stat_type = 7;
pub const drm_stat_type__DRM_STAT_COUNT: drm_stat_type = 8;
pub const drm_stat_type__DRM_STAT_IRQ: drm_stat_type = 9;
pub const drm_stat_type__DRM_STAT_PRIMARY: drm_stat_type = 10;
pub const drm_stat_type__DRM_STAT_SECONDARY: drm_stat_type = 11;
pub const drm_stat_type__DRM_STAT_DMA: drm_stat_type = 12;
pub const drm_stat_type__DRM_STAT_SPECIAL: drm_stat_type = 13;
pub const drm_stat_type__DRM_STAT_MISSED: drm_stat_type = 14;
pub type drm_stat_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_stats {
    pub count: ffi::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: ffi::c_ulong,
    pub type_: drm_stat_type,
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for drm_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const drm_lock_flags__DRM_LOCK_READY: drm_lock_flags = 1;
pub const drm_lock_flags__DRM_LOCK_QUIESCENT: drm_lock_flags = 2;
pub const drm_lock_flags__DRM_LOCK_FLUSH: drm_lock_flags = 4;
pub const drm_lock_flags__DRM_LOCK_FLUSH_ALL: drm_lock_flags = 8;
pub const drm_lock_flags__DRM_HALT_ALL_QUEUES: drm_lock_flags = 16;
pub const drm_lock_flags__DRM_HALT_CUR_QUEUES: drm_lock_flags = 32;
pub type drm_lock_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_lock {
    pub context: ffi::c_int,
    pub flags: drm_lock_flags,
}
impl Default for drm_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const drm_dma_flags__DRM_DMA_BLOCK: drm_dma_flags = 1;
pub const drm_dma_flags__DRM_DMA_WHILE_LOCKED: drm_dma_flags = 2;
pub const drm_dma_flags__DRM_DMA_PRIORITY: drm_dma_flags = 4;
pub const drm_dma_flags__DRM_DMA_WAIT: drm_dma_flags = 16;
pub const drm_dma_flags__DRM_DMA_SMALLER_OK: drm_dma_flags = 32;
pub const drm_dma_flags__DRM_DMA_LARGER_OK: drm_dma_flags = 64;
pub type drm_dma_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_buf_desc {
    pub count: ffi::c_int,
    pub size: ffi::c_int,
    pub low_mark: ffi::c_int,
    pub high_mark: ffi::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    pub agp_start: ffi::c_ulong,
}
pub const drm_buf_desc__DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 = 1;
pub const drm_buf_desc__DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 = 2;
pub const drm_buf_desc__DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 = 4;
pub const drm_buf_desc__DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 = 8;
pub const drm_buf_desc__DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 = 16;
pub type drm_buf_desc__bindgen_ty_1 = ffi::c_uint;
impl Default for drm_buf_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_buf_info {
    pub count: ffi::c_int,
    pub list: *mut drm_buf_desc,
}
impl Default for drm_buf_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_buf_free {
    pub count: ffi::c_int,
    pub list: *mut ffi::c_int,
}
impl Default for drm_buf_free {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_buf_pub {
    pub idx: ffi::c_int,
    pub total: ffi::c_int,
    pub used: ffi::c_int,
    pub address: *mut ffi::c_void,
}
impl Default for drm_buf_pub {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_buf_map {
    pub count: ffi::c_int,
    pub virtual_: *mut ffi::c_void,
    pub list: *mut drm_buf_pub,
}
impl Default for drm_buf_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_dma {
    pub context: ffi::c_int,
    pub send_count: ffi::c_int,
    pub send_indices: *mut ffi::c_int,
    pub send_sizes: *mut ffi::c_int,
    pub flags: drm_dma_flags,
    pub request_count: ffi::c_int,
    pub request_size: ffi::c_int,
    pub request_indices: *mut ffi::c_int,
    pub request_sizes: *mut ffi::c_int,
    pub granted_count: ffi::c_int,
}
impl Default for drm_dma {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const drm_ctx_flags__DRM_CONTEXT_PRESERVED: drm_ctx_flags = 1;
pub const drm_ctx_flags__DRM_CONTEXT_2DONLY: drm_ctx_flags = 2;
pub type drm_ctx_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
impl Default for drm_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_ctx_res {
    pub count: ffi::c_int,
    pub contexts: *mut drm_ctx,
}
impl Default for drm_ctx_res {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
pub const drm_drawable_info_type_t_DRM_DRAWABLE_CLIPRECTS: drm_drawable_info_type_t = 0;
pub type drm_drawable_info_type_t = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: ffi::c_uint,
    pub num: ffi::c_uint,
    pub data: ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_irq_busid {
    pub irq: ffi::c_int,
    pub busnum: ffi::c_int,
    pub devnum: ffi::c_int,
    pub funcnum: ffi::c_int,
}
pub const drm_vblank_seq_type__DRM_VBLANK_ABSOLUTE: drm_vblank_seq_type = 0;
pub const drm_vblank_seq_type__DRM_VBLANK_RELATIVE: drm_vblank_seq_type = 1;
pub const drm_vblank_seq_type__DRM_VBLANK_HIGH_CRTC_MASK: drm_vblank_seq_type = 62;
pub const drm_vblank_seq_type__DRM_VBLANK_EVENT: drm_vblank_seq_type = 67108864;
pub const drm_vblank_seq_type__DRM_VBLANK_FLIP: drm_vblank_seq_type = 134217728;
pub const drm_vblank_seq_type__DRM_VBLANK_NEXTONMISS: drm_vblank_seq_type = 268435456;
pub const drm_vblank_seq_type__DRM_VBLANK_SECONDARY: drm_vblank_seq_type = 536870912;
pub const drm_vblank_seq_type__DRM_VBLANK_SIGNAL: drm_vblank_seq_type = 1073741824;
pub type drm_vblank_seq_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: ffi::c_uint,
    pub signal: ffi::c_ulong,
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: ffi::c_uint,
    pub tval_sec: ffi::c_long,
    pub tval_usec: ffi::c_long,
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union drm_wait_vblank {
    pub request: drm_wait_vblank_request,
    pub reply: drm_wait_vblank_reply,
}
impl Default for drm_wait_vblank {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_agp_mode {
    pub mode: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_agp_buffer {
    pub size: ffi::c_ulong,
    pub handle: ffi::c_ulong,
    pub type_: ffi::c_ulong,
    pub physical: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_agp_binding {
    pub handle: ffi::c_ulong,
    pub offset: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_agp_info {
    pub agp_version_major: ffi::c_int,
    pub agp_version_minor: ffi::c_int,
    pub mode: ffi::c_ulong,
    pub aperture_base: ffi::c_ulong,
    pub aperture_size: ffi::c_ulong,
    pub memory_allowed: ffi::c_ulong,
    pub memory_used: ffi::c_ulong,
    pub id_vendor: ffi::c_ushort,
    pub id_device: ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_scatter_gather {
    pub size: ffi::c_ulong,
    pub handle: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_set_version {
    pub drm_di_major: ffi::c_int,
    pub drm_di_minor: ffi::c_int,
    pub drm_dd_major: ffi::c_int,
    pub drm_dd_minor: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_gem_close {
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_gem_flink {
    pub handle: __u32,
    pub name: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_gem_open {
    pub name: __u32,
    pub handle: __u32,
    pub size: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_prime_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_create {
    pub handle: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_destroy {
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub pad: __u32,
    pub point: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_transfer {
    pub src_handle: __u32,
    pub dst_handle: __u32,
    pub src_point: __u64,
    pub dst_point: __u64,
    pub flags: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_wait {
    pub handles: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
    pub deadline_nsec: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_timeline_wait {
    pub handles: __u64,
    pub points: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
    pub deadline_nsec: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_eventfd {
    pub handle: __u32,
    pub flags: __u32,
    pub point: __u64,
    pub fd: __s32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_array {
    pub handles: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_syncobj_timeline_array {
    pub handles: __u64,
    pub points: __u64,
    pub count_handles: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_crtc_get_sequence {
    pub crtc_id: __u32,
    pub active: __u32,
    pub sequence: __u64,
    pub sequence_ns: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_crtc_queue_sequence {
    pub crtc_id: __u32,
    pub flags: __u32,
    pub sequence: __u64,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_set_client_name {
    pub name_len: __u64,
    pub name: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub x: __u32,
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub possible_crtcs: __u32,
    pub gamma_size: __u32,
    pub count_format_types: __u32,
    pub format_type_ptr: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Automatic: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Unknown: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_VGA: drm_mode_subconnector = 1;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVID: drm_mode_subconnector = 3;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVIA: drm_mode_subconnector = 4;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Composite: drm_mode_subconnector = 5;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SVIDEO: drm_mode_subconnector = 6;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Component: drm_mode_subconnector = 8;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SCART: drm_mode_subconnector = 9;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DisplayPort: drm_mode_subconnector = 10;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_HDMIA: drm_mode_subconnector = 11;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Native: drm_mode_subconnector = 15;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Wireless: drm_mode_subconnector = 18;
pub type drm_mode_subconnector = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_connector {
    pub encoders_ptr: __u64,
    pub modes_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_modes: __u32,
    pub count_props: __u32,
    pub count_encoders: __u32,
    pub encoder_id: __u32,
    pub connector_id: __u32,
    pub connector_type: __u32,
    pub connector_type_id: __u32,
    pub connection: __u32,
    pub mm_width: __u32,
    pub mm_height: __u32,
    pub subpixel: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_property {
    pub values_ptr: __u64,
    pub enum_blob_ptr: __u64,
    pub prop_id: __u32,
    pub flags: __u32,
    pub name: [ffi::c_char; 32usize],
    pub count_values: __u32,
    pub count_enum_blobs: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_fb_cmd2 {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pixel_format: __u32,
    pub flags: __u32,
    pub handles: [__u32; 4usize],
    pub pitches: [__u32; 4usize],
    pub offsets: [__u32; 4usize],
    pub modifier: [__u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_color_ctm {
    pub matrix: [__u64; 9usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_plane_size_hint {
    pub width: __u16,
    pub height: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hdr_metadata_infoframe {
    pub eotf: __u8,
    pub metadata_type: __u8,
    pub display_primaries: [hdr_metadata_infoframe__bindgen_ty_1; 3usize],
    pub white_point: hdr_metadata_infoframe__bindgen_ty_2,
    pub max_display_mastering_luminance: __u16,
    pub min_display_mastering_luminance: __u16,
    pub max_cll: __u16,
    pub max_fall: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hdr_metadata_infoframe__bindgen_ty_1 {
    pub x: __u16,
    pub y: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hdr_metadata_infoframe__bindgen_ty_2 {
    pub x: __u16,
    pub y: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hdr_output_metadata {
    pub metadata_type: __u32,
    pub __bindgen_anon_1: hdr_output_metadata__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hdr_output_metadata__bindgen_ty_1 {
    pub hdmi_metadata_type1: hdr_metadata_infoframe,
}
impl Default for hdr_output_metadata__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for hdr_output_metadata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_map_dumb {
    pub handle: __u32,
    pub pad: __u32,
    pub offset: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_format_modifier_blob {
    pub version: __u32,
    pub flags: __u32,
    pub count_formats: __u32,
    pub formats_offset: __u32,
    pub count_modifiers: __u32,
    pub modifiers_offset: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_format_modifier {
    pub formats: __u64,
    pub offset: __u32,
    pub pad: __u32,
    pub modifier: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_create_blob {
    pub data: __u64,
    pub length: __u32,
    pub blob_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_create_lease {
    pub object_ids: __u64,
    pub object_count: __u32,
    pub flags: __u32,
    pub lessee_id: __u32,
    pub fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_list_lessees {
    pub count_lessees: __u32,
    pub pad: __u32,
    pub lessees_ptr: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_get_lease {
    pub count_objects: __u32,
    pub pad: __u32,
    pub objects_ptr: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_revoke_lease {
    pub lessee_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_rect {
    pub x1: __s32,
    pub y1: __s32,
    pub x2: __s32,
    pub y2: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_closefb {
    pub fb_id: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub crtc_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_event_crtc_sequence {
    pub base: drm_event,
    pub user_data: __u64,
    pub time_ns: __s64,
    pub sequence: __u64,
}

pub type class_mmap_read_lock_t = *mut mm_struct;
pub const class_mmap_read_lock_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}

pub type stack_trace_consume_fn = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut ffi::c_void, addr: ffi::c_ulong) -> bool_,
>;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: ffi::c_ulong,
    pub end_pfn: ffi::c_ulong,
    pub reserve: ffi::c_ulong,
    pub free: ffi::c_ulong,
    pub align: ffi::c_ulong,
    pub alloc: ffi::c_ulong,
    pub inaccessible: bool_,
}
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_COHERENT: memory_type = 2;
pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 3;
pub const memory_type_MEMORY_DEVICE_GENERIC: memory_type = 4;
pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 5;
pub type memory_type = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            pgmap: *mut dev_pagemap,
            pfn: ffi::c_ulong,
            nr_pages: ffi::c_ulong,
            mf_flags: ffi::c_int,
        ) -> ffi::c_int,
    >,
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: ffi::c_uint,
    pub vmemmap_shift: ffi::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut ffi::c_void,
    pub nr_range: ffi::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub __bindgen_anon_1: __BindgenUnionField<dev_pagemap__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Default)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_ranges: dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ranges: __IncompleteArrayField<range>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for dev_pagemap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dev_pagemap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma_chain {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: ffi::c_ulong,
    pub address: ffi::c_ulong,
    pub real_address: ffi::c_ulong,
}
impl Default for vm_fault__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
}
impl Default for vm_fault__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_fault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct, addr: ffi::c_ulong) -> ffi::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> ffi::c_int>,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            start: ffi::c_ulong,
            end: ffi::c_ulong,
            newflags: ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, order: ffi::c_uint) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: ffi::c_ulong,
            end_pgoff: ffi::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> ffi::c_ulong>,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: ffi::c_ulong,
            buf: *mut ffi::c_void,
            len: ffi::c_int,
            write: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const ffi::c_char,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: ffi::c_ulong) -> *mut page,
    >,
}

pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_UNSUPPORTED: transparent_hugepage_flag = 0;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_FLAG: transparent_hugepage_flag = 1;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG: transparent_hugepage_flag =
    2;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG:
    transparent_hugepage_flag = 3;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG:
    transparent_hugepage_flag = 4;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG:
    transparent_hugepage_flag = 5;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG:
    transparent_hugepage_flag = 6;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG:
    transparent_hugepage_flag = 7;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG:
    transparent_hugepage_flag = 8;
pub type transparent_hugepage_flag = ffi::c_uint;

pub const mthp_stat_item_MTHP_STAT_ANON_FAULT_ALLOC: mthp_stat_item = 0;
pub const mthp_stat_item_MTHP_STAT_ANON_FAULT_FALLBACK: mthp_stat_item = 1;
pub const mthp_stat_item_MTHP_STAT_ANON_FAULT_FALLBACK_CHARGE: mthp_stat_item = 2;
pub const mthp_stat_item_MTHP_STAT_ZSWPOUT: mthp_stat_item = 3;
pub const mthp_stat_item_MTHP_STAT_SWPIN: mthp_stat_item = 4;
pub const mthp_stat_item_MTHP_STAT_SWPIN_FALLBACK: mthp_stat_item = 5;
pub const mthp_stat_item_MTHP_STAT_SWPIN_FALLBACK_CHARGE: mthp_stat_item = 6;
pub const mthp_stat_item_MTHP_STAT_SWPOUT: mthp_stat_item = 7;
pub const mthp_stat_item_MTHP_STAT_SWPOUT_FALLBACK: mthp_stat_item = 8;
pub const mthp_stat_item_MTHP_STAT_SHMEM_ALLOC: mthp_stat_item = 9;
pub const mthp_stat_item_MTHP_STAT_SHMEM_FALLBACK: mthp_stat_item = 10;
pub const mthp_stat_item_MTHP_STAT_SHMEM_FALLBACK_CHARGE: mthp_stat_item = 11;
pub const mthp_stat_item_MTHP_STAT_SPLIT: mthp_stat_item = 12;
pub const mthp_stat_item_MTHP_STAT_SPLIT_FAILED: mthp_stat_item = 13;
pub const mthp_stat_item_MTHP_STAT_SPLIT_DEFERRED: mthp_stat_item = 14;
pub const mthp_stat_item_MTHP_STAT_NR_ANON: mthp_stat_item = 15;
pub const mthp_stat_item_MTHP_STAT_NR_ANON_PARTIALLY_MAPPED: mthp_stat_item = 16;
pub const mthp_stat_item___MTHP_STAT_COUNT: mthp_stat_item = 17;
pub type mthp_stat_item = ffi::c_uint;

pub const REGION_INTERSECTS: _bindgen_ty_97 = 0;
pub const REGION_DISJOINT: _bindgen_ty_97 = 1;
pub const REGION_MIXED: _bindgen_ty_97 = 2;
pub type _bindgen_ty_97 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub union release_pages_arg {
    pub pages: *mut *mut page,
    pub folios: *mut *mut folio,
    pub encoded_pages: *mut *mut encoded_page,
}
impl Default for release_pages_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const vm_event_item_PGPGIN: vm_event_item = 0;
pub const vm_event_item_PGPGOUT: vm_event_item = 1;
pub const vm_event_item_PSWPIN: vm_event_item = 2;
pub const vm_event_item_PSWPOUT: vm_event_item = 3;
pub const vm_event_item_PGALLOC_DMA32: vm_event_item = 4;
pub const vm_event_item_PGALLOC_NORMAL: vm_event_item = 5;
pub const vm_event_item_PGALLOC_MOVABLE: vm_event_item = 6;
pub const vm_event_item_ALLOCSTALL_DMA32: vm_event_item = 7;
pub const vm_event_item_ALLOCSTALL_NORMAL: vm_event_item = 8;
pub const vm_event_item_ALLOCSTALL_MOVABLE: vm_event_item = 9;
pub const vm_event_item_PGSCAN_SKIP_DMA32: vm_event_item = 10;
pub const vm_event_item_PGSCAN_SKIP_NORMAL: vm_event_item = 11;
pub const vm_event_item_PGSCAN_SKIP_MOVABLE: vm_event_item = 12;
pub const vm_event_item_PGFREE: vm_event_item = 13;
pub const vm_event_item_PGACTIVATE: vm_event_item = 14;
pub const vm_event_item_PGDEACTIVATE: vm_event_item = 15;
pub const vm_event_item_PGLAZYFREE: vm_event_item = 16;
pub const vm_event_item_PGFAULT: vm_event_item = 17;
pub const vm_event_item_PGMAJFAULT: vm_event_item = 18;
pub const vm_event_item_PGLAZYFREED: vm_event_item = 19;
pub const vm_event_item_PGREFILL: vm_event_item = 20;
pub const vm_event_item_PGREUSE: vm_event_item = 21;
pub const vm_event_item_PGSTEAL_KSWAPD: vm_event_item = 22;
pub const vm_event_item_PGSTEAL_DIRECT: vm_event_item = 23;
pub const vm_event_item_PGSTEAL_KHUGEPAGED: vm_event_item = 24;
pub const vm_event_item_PGSTEAL_PROACTIVE: vm_event_item = 25;
pub const vm_event_item_PGSCAN_KSWAPD: vm_event_item = 26;
pub const vm_event_item_PGSCAN_DIRECT: vm_event_item = 27;
pub const vm_event_item_PGSCAN_KHUGEPAGED: vm_event_item = 28;
pub const vm_event_item_PGSCAN_PROACTIVE: vm_event_item = 29;
pub const vm_event_item_PGSCAN_DIRECT_THROTTLE: vm_event_item = 30;
pub const vm_event_item_PGSCAN_ANON: vm_event_item = 31;
pub const vm_event_item_PGSCAN_FILE: vm_event_item = 32;
pub const vm_event_item_PGSTEAL_ANON: vm_event_item = 33;
pub const vm_event_item_PGSTEAL_FILE: vm_event_item = 34;
pub const vm_event_item_PGINODESTEAL: vm_event_item = 35;
pub const vm_event_item_SLABS_SCANNED: vm_event_item = 36;
pub const vm_event_item_KSWAPD_INODESTEAL: vm_event_item = 37;
pub const vm_event_item_KSWAPD_LOW_WMARK_HIT_QUICKLY: vm_event_item = 38;
pub const vm_event_item_KSWAPD_HIGH_WMARK_HIT_QUICKLY: vm_event_item = 39;
pub const vm_event_item_PAGEOUTRUN: vm_event_item = 40;
pub const vm_event_item_PGROTATED: vm_event_item = 41;
pub const vm_event_item_DROP_PAGECACHE: vm_event_item = 42;
pub const vm_event_item_DROP_SLAB: vm_event_item = 43;
pub const vm_event_item_OOM_KILL: vm_event_item = 44;
pub const vm_event_item_PGMIGRATE_SUCCESS: vm_event_item = 45;
pub const vm_event_item_PGMIGRATE_FAIL: vm_event_item = 46;
pub const vm_event_item_THP_MIGRATION_SUCCESS: vm_event_item = 47;
pub const vm_event_item_THP_MIGRATION_FAIL: vm_event_item = 48;
pub const vm_event_item_THP_MIGRATION_SPLIT: vm_event_item = 49;
pub const vm_event_item_COMPACTMIGRATE_SCANNED: vm_event_item = 50;
pub const vm_event_item_COMPACTFREE_SCANNED: vm_event_item = 51;
pub const vm_event_item_COMPACTISOLATED: vm_event_item = 52;
pub const vm_event_item_COMPACTSTALL: vm_event_item = 53;
pub const vm_event_item_COMPACTFAIL: vm_event_item = 54;
pub const vm_event_item_COMPACTSUCCESS: vm_event_item = 55;
pub const vm_event_item_KCOMPACTD_WAKE: vm_event_item = 56;
pub const vm_event_item_KCOMPACTD_MIGRATE_SCANNED: vm_event_item = 57;
pub const vm_event_item_KCOMPACTD_FREE_SCANNED: vm_event_item = 58;
pub const vm_event_item_HTLB_BUDDY_PGALLOC: vm_event_item = 59;
pub const vm_event_item_HTLB_BUDDY_PGALLOC_FAIL: vm_event_item = 60;
pub const vm_event_item_UNEVICTABLE_PGCULLED: vm_event_item = 61;
pub const vm_event_item_UNEVICTABLE_PGSCANNED: vm_event_item = 62;
pub const vm_event_item_UNEVICTABLE_PGRESCUED: vm_event_item = 63;
pub const vm_event_item_UNEVICTABLE_PGMLOCKED: vm_event_item = 64;
pub const vm_event_item_UNEVICTABLE_PGMUNLOCKED: vm_event_item = 65;
pub const vm_event_item_UNEVICTABLE_PGCLEARED: vm_event_item = 66;
pub const vm_event_item_UNEVICTABLE_PGSTRANDED: vm_event_item = 67;
pub const vm_event_item_BALLOON_INFLATE: vm_event_item = 68;
pub const vm_event_item_BALLOON_DEFLATE: vm_event_item = 69;
pub const vm_event_item_BALLOON_MIGRATE: vm_event_item = 70;
pub const vm_event_item_SWAP_RA: vm_event_item = 71;
pub const vm_event_item_SWAP_RA_HIT: vm_event_item = 72;
pub const vm_event_item_SWPIN_ZERO: vm_event_item = 73;
pub const vm_event_item_SWPOUT_ZERO: vm_event_item = 74;
pub const vm_event_item_NR_VM_EVENT_ITEMS: vm_event_item = 75;
pub type vm_event_item = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reclaim_stat {
    pub nr_dirty: ffi::c_uint,
    pub nr_unqueued_dirty: ffi::c_uint,
    pub nr_congested: ffi::c_uint,
    pub nr_writeback: ffi::c_uint,
    pub nr_immediate: ffi::c_uint,
    pub nr_pageout: ffi::c_uint,
    pub nr_activate: [ffi::c_uint; 2usize],
    pub nr_ref_keep: ffi::c_uint,
    pub nr_unmap_fail: ffi::c_uint,
    pub nr_lazyfree_fail: ffi::c_uint,
    pub nr_demoted: ffi::c_uint,
}
pub const vm_stat_item_NR_DIRTY_THRESHOLD: vm_stat_item = 0;
pub const vm_stat_item_NR_DIRTY_BG_THRESHOLD: vm_stat_item = 1;
pub const vm_stat_item_NR_MEMMAP_PAGES: vm_stat_item = 2;
pub const vm_stat_item_NR_MEMMAP_BOOT_PAGES: vm_stat_item = 3;
pub const vm_stat_item_NR_VM_STAT_ITEMS: vm_stat_item = 4;
pub type vm_stat_item = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_event_state {
    pub event: [ffi::c_ulong; 75usize],
}
impl Default for vm_event_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct zap_details {
    pub single_folio: *mut folio,
    pub even_cows: bool_,
    pub reclaim_pt: bool_,
    pub zap_flags: zap_flags_t,
}
impl Default for zap_details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_range {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct follow_pfnmap_args {
    pub vma: *mut vm_area_struct,
    pub address: ffi::c_ulong,
    pub lock: *mut spinlock_t,
    pub ptep: *mut pte_t,
    pub pfn: ffi::c_ulong,
    pub addr_mask: ffi::c_ulong,
    pub pgprot: pgprot_t,
    pub writable: bool_,
    pub special: bool_,
}
impl Default for follow_pfnmap_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_unmapped_area_info {
    pub flags: ffi::c_ulong,
    pub length: ffi::c_ulong,
    pub low_limit: ffi::c_ulong,
    pub high_limit: ffi::c_ulong,
    pub align_mask: ffi::c_ulong,
    pub align_offset: ffi::c_ulong,
    pub start_gap: ffi::c_ulong,
}

pub type pte_fn_t = ::core::option::Option<
    unsafe extern "C" fn(pte: *mut pte_t, addr: ffi::c_ulong, data: *mut ffi::c_void) -> ffi::c_int,
>;

pub const mf_flags_MF_COUNT_INCREASED: mf_flags = 1;
pub const mf_flags_MF_ACTION_REQUIRED: mf_flags = 2;
pub const mf_flags_MF_MUST_KILL: mf_flags = 4;
pub const mf_flags_MF_SOFT_OFFLINE: mf_flags = 8;
pub const mf_flags_MF_UNPOISON: mf_flags = 16;
pub const mf_flags_MF_SW_SIMULATED: mf_flags = 32;
pub const mf_flags_MF_NO_RETRY: mf_flags = 64;
pub const mf_flags_MF_MEM_PRE_REMOVE: mf_flags = 128;
pub type mf_flags = ffi::c_uint;

pub const mf_result_MF_IGNORED: mf_result = 0;
pub const mf_result_MF_FAILED: mf_result = 1;
pub const mf_result_MF_DELAYED: mf_result = 2;
pub const mf_result_MF_RECOVERED: mf_result = 3;
pub type mf_result = ffi::c_uint;
pub const mf_action_page_type_MF_MSG_KERNEL: mf_action_page_type = 0;
pub const mf_action_page_type_MF_MSG_KERNEL_HIGH_ORDER: mf_action_page_type = 1;
pub const mf_action_page_type_MF_MSG_DIFFERENT_COMPOUND: mf_action_page_type = 2;
pub const mf_action_page_type_MF_MSG_HUGE: mf_action_page_type = 3;
pub const mf_action_page_type_MF_MSG_FREE_HUGE: mf_action_page_type = 4;
pub const mf_action_page_type_MF_MSG_GET_HWPOISON: mf_action_page_type = 5;
pub const mf_action_page_type_MF_MSG_UNMAP_FAILED: mf_action_page_type = 6;
pub const mf_action_page_type_MF_MSG_DIRTY_SWAPCACHE: mf_action_page_type = 7;
pub const mf_action_page_type_MF_MSG_CLEAN_SWAPCACHE: mf_action_page_type = 8;
pub const mf_action_page_type_MF_MSG_DIRTY_MLOCKED_LRU: mf_action_page_type = 9;
pub const mf_action_page_type_MF_MSG_CLEAN_MLOCKED_LRU: mf_action_page_type = 10;
pub const mf_action_page_type_MF_MSG_DIRTY_UNEVICTABLE_LRU: mf_action_page_type = 11;
pub const mf_action_page_type_MF_MSG_CLEAN_UNEVICTABLE_LRU: mf_action_page_type = 12;
pub const mf_action_page_type_MF_MSG_DIRTY_LRU: mf_action_page_type = 13;
pub const mf_action_page_type_MF_MSG_CLEAN_LRU: mf_action_page_type = 14;
pub const mf_action_page_type_MF_MSG_TRUNCATED_LRU: mf_action_page_type = 15;
pub const mf_action_page_type_MF_MSG_BUDDY: mf_action_page_type = 16;
pub const mf_action_page_type_MF_MSG_DAX: mf_action_page_type = 17;
pub const mf_action_page_type_MF_MSG_UNSPLIT_THP: mf_action_page_type = 18;
pub const mf_action_page_type_MF_MSG_ALREADY_POISONED: mf_action_page_type = 19;
pub const mf_action_page_type_MF_MSG_UNKNOWN: mf_action_page_type = 20;
pub type mf_action_page_type = ffi::c_uint;

#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page_snapshot {
    pub folio_snapshot: folio,
    pub page_snapshot: page,
    pub pfn: ffi::c_ulong,
    pub idx: ffi::c_ulong,
    pub flags: ffi::c_ulong,
}
impl Default for page_snapshot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scatterlist {
    pub page_link: ffi::c_ulong,
    pub offset: ffi::c_uint,
    pub length: ffi::c_uint,
    pub dma_address: dma_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: ffi::c_uint,
    pub orig_nents: ffi::c_uint,
}
impl Default for sg_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_append_table {
    pub sgt: sg_table,
    pub prv: *mut scatterlist,
    pub total_nents: ffi::c_uint,
}
impl Default for sg_append_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type sg_alloc_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: ffi::c_uint, arg2: gfp_t) -> *mut scatterlist,
>;
pub type sg_free_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut scatterlist, arg2: ffi::c_uint)>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_page_iter {
    pub sg: *mut scatterlist,
    pub sg_pgoffset: ffi::c_uint,
    pub __nents: ffi::c_uint,
    pub __pg_advance: ffi::c_int,
}
impl Default for sg_page_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_dma_page_iter {
    pub base: sg_page_iter,
}
impl Default for sg_dma_page_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_mapping_iter {
    pub page: *mut page,
    pub addr: *mut ffi::c_void,
    pub length: usize,
    pub consumed: usize,
    pub piter: sg_page_iter,
    pub __offset: ffi::c_uint,
    pub __remaining: ffi::c_uint,
    pub __flags: ffi::c_uint,
}
impl Default for sg_mapping_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_prime_file_private {
    pub lock: mutex,
    pub dmabufs: rb_root,
    pub handles: rb_root,
}
impl Default for drm_prime_file_private {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const drm_minor_type_DRM_MINOR_PRIMARY: drm_minor_type = 0;
pub const drm_minor_type_DRM_MINOR_CONTROL: drm_minor_type = 1;
pub const drm_minor_type_DRM_MINOR_RENDER: drm_minor_type = 2;
pub const drm_minor_type_DRM_MINOR_ACCEL: drm_minor_type = 32;
pub type drm_minor_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_minor {
    pub index: ffi::c_int,
    pub type_: ffi::c_int,
    pub kdev: *mut device,
    pub dev: *mut drm_device,
    pub debugfs_symlink: *mut dentry,
    pub debugfs_root: *mut dentry,
}
impl Default for drm_minor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_pending_event {
    pub completion: *mut completion,
    pub completion_release:
        ::core::option::Option<unsafe extern "C" fn(completion: *mut completion)>,
    pub event: *mut drm_event,
    pub fence: *mut dma_fence,
    pub file_priv: *mut drm_file,
    pub link: list_head,
    pub pending_link: list_head,
}
impl Default for drm_pending_event {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_file {
    pub authenticated: bool_,
    pub stereo_allowed: bool_,
    pub universal_planes: bool_,
    pub atomic: bool_,
    pub aspect_ratio_allowed: bool_,
    pub writeback_connectors: bool_,
    pub was_master: bool_,
    pub is_master: bool_,
    pub supports_virtualized_cursor_plane: bool_,
    pub master: *mut drm_master,
    pub master_lookup_lock: spinlock_t,
    pub pid: *mut pid,
    pub client_id: u64_,
    pub magic: drm_magic_t,
    pub lhead: list_head,
    pub minor: *mut drm_minor,
    pub object_idr: idr,
    pub table_lock: spinlock_t,
    pub syncobj_idr: idr,
    pub syncobj_table_lock: spinlock_t,
    pub filp: *mut file,
    pub driver_priv: *mut ffi::c_void,
    pub fbs: list_head,
    pub fbs_lock: mutex,
    pub blobs: list_head,
    pub event_wait: wait_queue_head_t,
    pub pending_event_list: list_head,
    pub event_list: list_head,
    pub event_space: ffi::c_int,
    pub event_read_lock: mutex,
    pub prime: drm_prime_file_private,
    pub client_name: *const ffi::c_char,
    pub client_name_lock: mutex,
    pub debugfs_client: *mut dentry,
}
impl Default for drm_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_memory_stats {
    pub shared: u64_,
    pub private: u64_,
    pub resident: u64_,
    pub purgeable: u64_,
    pub active: u64_,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct iosys_map {
    pub __bindgen_anon_1: iosys_map__bindgen_ty_1,
    pub is_iomem: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iosys_map__bindgen_ty_1 {
    pub vaddr_iomem: *mut ffi::c_void,
    pub vaddr: *mut ffi::c_void,
}
impl Default for iosys_map__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iosys_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fd {
    pub word: ffi::c_ulong,
}

pub type class_fd_t = fd;
pub type class_fd_raw_t = fd;
pub type class_fd_pos_t = fd;

pub type class_get_unused_fd_t = ffi::c_int;

pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
pub type dma_data_direction = i32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_iova_state {
    pub addr: dma_addr_t,
    pub __size: u64_,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_fence {
    pub lock: *mut spinlock_t,
    pub ops: *const dma_fence_ops,
    pub __bindgen_anon_1: dma_fence__bindgen_ty_1,
    pub context: u64_,
    pub seqno: u64_,
    pub flags: ffi::c_ulong,
    pub refcount: kref,
    pub error: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dma_fence__bindgen_ty_1 {
    pub cb_list: list_head,
    pub timestamp: ktime_t,
    pub rcu: callback_head,
}
impl Default for dma_fence__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dma_fence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const dma_fence_flag_bits_DMA_FENCE_FLAG_SEQNO64_BIT: dma_fence_flag_bits = 0;
pub const dma_fence_flag_bits_DMA_FENCE_FLAG_SIGNALED_BIT: dma_fence_flag_bits = 1;
pub const dma_fence_flag_bits_DMA_FENCE_FLAG_TIMESTAMP_BIT: dma_fence_flag_bits = 2;
pub const dma_fence_flag_bits_DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT: dma_fence_flag_bits = 3;
pub const dma_fence_flag_bits_DMA_FENCE_FLAG_USER_BITS: dma_fence_flag_bits = 4;
pub type dma_fence_flag_bits = ffi::c_uint;
pub type dma_fence_func_t =
    ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence, cb: *mut dma_fence_cb)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_fence_cb {
    pub node: list_head,
    pub func: dma_fence_func_t,
}
impl Default for dma_fence_cb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_fence_ops {
    pub get_driver_name:
        ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence) -> *const ffi::c_char>,
    pub get_timeline_name:
        ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence) -> *const ffi::c_char>,
    pub enable_signaling:
        ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence) -> bool_>,
    pub signaled: ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence) -> bool_>,
    pub wait: ::core::option::Option<
        unsafe extern "C" fn(
            fence: *mut dma_fence,
            intr: bool_,
            timeout: ffi::c_long,
        ) -> ffi::c_long,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence)>,
    pub set_deadline:
        ::core::option::Option<unsafe extern "C" fn(fence: *mut dma_fence, deadline: ktime_t)>,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_buf_ops {
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dma_buf, arg2: *mut dma_buf_attachment) -> ffi::c_int,
    >,
    pub detach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dma_buf, arg2: *mut dma_buf_attachment),
    >,
    pub pin:
        ::core::option::Option<unsafe extern "C" fn(attach: *mut dma_buf_attachment) -> ffi::c_int>,
    pub unpin: ::core::option::Option<unsafe extern "C" fn(attach: *mut dma_buf_attachment)>,
    pub map_dma_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dma_buf_attachment,
            arg2: dma_data_direction,
        ) -> *mut sg_table,
    >,
    pub unmap_dma_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dma_buf_attachment,
            arg2: *mut sg_table,
            arg3: dma_data_direction,
        ),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dma_buf)>,
    pub begin_cpu_access: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dma_buf, arg2: dma_data_direction) -> ffi::c_int,
    >,
    pub end_cpu_access: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dma_buf, arg2: dma_data_direction) -> ffi::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dma_buf, vma: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub vmap: ::core::option::Option<
        unsafe extern "C" fn(dmabuf: *mut dma_buf, map: *mut iosys_map) -> ffi::c_int,
    >,
    pub vunmap:
        ::core::option::Option<unsafe extern "C" fn(dmabuf: *mut dma_buf, map: *mut iosys_map)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_buf {
    pub size: usize,
    pub file: *mut file,
    pub attachments: list_head,
    pub ops: *const dma_buf_ops,
    pub vmapping_counter: ffi::c_uint,
    pub vmap_ptr: iosys_map,
    pub exp_name: *const ffi::c_char,
    pub name: *const ffi::c_char,
    pub name_lock: spinlock_t,
    pub owner: *mut module,
    pub list_node: list_head,
    pub priv_: *mut ffi::c_void,
    pub resv: *mut dma_resv,
    pub poll: wait_queue_head_t,
    pub cb_in: dma_buf_dma_buf_poll_cb_t,
    pub cb_out: dma_buf_dma_buf_poll_cb_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_buf_dma_buf_poll_cb_t {
    pub cb: dma_fence_cb,
    pub poll: *mut wait_queue_head_t,
    pub active: __poll_t,
}
impl Default for dma_buf_dma_buf_poll_cb_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dma_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_buf_attach_ops {
    pub allow_peer2peer: bool_,
    pub move_notify: ::core::option::Option<unsafe extern "C" fn(attach: *mut dma_buf_attachment)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_buf_attachment {
    pub dmabuf: *mut dma_buf,
    pub dev: *mut device,
    pub node: list_head,
    pub peer2peer: bool_,
    pub importer_ops: *const dma_buf_attach_ops,
    pub importer_priv: *mut ffi::c_void,
    pub priv_: *mut ffi::c_void,
}
impl Default for dma_buf_attachment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_buf_export_info {
    pub exp_name: *const ffi::c_char,
    pub owner: *mut module,
    pub ops: *const dma_buf_ops,
    pub size: usize,
    pub flags: ffi::c_int,
    pub resv: *mut dma_resv,
    pub priv_: *mut ffi::c_void,
}
impl Default for dma_buf_export_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_resv_list {
    _unused: [u8; 0],
}
pub const dma_resv_usage_DMA_RESV_USAGE_KERNEL: dma_resv_usage = 0;
pub const dma_resv_usage_DMA_RESV_USAGE_WRITE: dma_resv_usage = 1;
pub const dma_resv_usage_DMA_RESV_USAGE_READ: dma_resv_usage = 2;
pub const dma_resv_usage_DMA_RESV_USAGE_BOOKKEEP: dma_resv_usage = 3;
pub type dma_resv_usage = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_resv {
    pub lock: ww_mutex,
    pub fences: *mut dma_resv_list,
}
impl Default for dma_resv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_resv_iter {
    pub obj: *mut dma_resv,
    pub usage: dma_resv_usage,
    pub fence: *mut dma_fence,
    pub fence_usage: dma_resv_usage,
    pub index: ffi::c_uint,
    pub fences: *mut dma_resv_list,
    pub num_fences: ffi::c_uint,
    pub is_restarted: bool_,
}
impl Default for dma_resv_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct debugfs_regset32 {
    _unused: [u8; 0],
}

pub const drm_debug_category_DRM_UT_CORE: drm_debug_category = 0;
pub const drm_debug_category_DRM_UT_DRIVER: drm_debug_category = 1;
pub const drm_debug_category_DRM_UT_KMS: drm_debug_category = 2;
pub const drm_debug_category_DRM_UT_PRIME: drm_debug_category = 3;
pub const drm_debug_category_DRM_UT_ATOMIC: drm_debug_category = 4;
pub const drm_debug_category_DRM_UT_VBL: drm_debug_category = 5;
pub const drm_debug_category_DRM_UT_STATE: drm_debug_category = 6;
pub const drm_debug_category_DRM_UT_LEASE: drm_debug_category = 7;
pub const drm_debug_category_DRM_UT_DP: drm_debug_category = 8;
pub const drm_debug_category_DRM_UT_DRMRES: drm_debug_category = 9;
pub type drm_debug_category = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_printer {
    pub printfn:
        ::core::option::Option<unsafe extern "C" fn(p: *mut drm_printer, vaf: *mut va_format)>,
    pub puts:
        ::core::option::Option<unsafe extern "C" fn(p: *mut drm_printer, str_: *const ffi::c_char)>,
    pub arg: *mut ffi::c_void,
    pub origin: *const ffi::c_void,
    pub prefix: *const ffi::c_char,
    pub line: drm_printer__bindgen_ty_1,
    pub category: drm_debug_category,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_printer__bindgen_ty_1 {
    pub series: ffi::c_uint,
    pub counter: ffi::c_uint,
}
impl Default for drm_printer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_print_iterator {
    pub data: *mut ffi::c_void,
    pub start: isize,
    pub remain: isize,
    pub offset: isize,
}
impl Default for drm_print_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const drm_mm_insert_mode_DRM_MM_INSERT_BEST: drm_mm_insert_mode = 0;
pub const drm_mm_insert_mode_DRM_MM_INSERT_LOW: drm_mm_insert_mode = 1;
pub const drm_mm_insert_mode_DRM_MM_INSERT_HIGH: drm_mm_insert_mode = 2;
pub const drm_mm_insert_mode_DRM_MM_INSERT_EVICT: drm_mm_insert_mode = 3;
pub const drm_mm_insert_mode_DRM_MM_INSERT_ONCE: drm_mm_insert_mode = 2147483648;
pub const drm_mm_insert_mode_DRM_MM_INSERT_HIGHEST: drm_mm_insert_mode = 2147483650;
pub const drm_mm_insert_mode_DRM_MM_INSERT_LOWEST: drm_mm_insert_mode = 2147483649;
pub type drm_mm_insert_mode = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_mm_node {
    pub color: ffi::c_ulong,
    pub start: u64_,
    pub size: u64_,
    pub mm: *mut drm_mm,
    pub node_list: list_head,
    pub hole_stack: list_head,
    pub rb: rb_node,
    pub rb_hole_size: rb_node,
    pub rb_hole_addr: rb_node,
    pub __subtree_last: u64_,
    pub hole_size: u64_,
    pub subtree_max_hole: u64_,
    pub flags: ffi::c_ulong,
}
impl Default for drm_mm_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_mm {
    pub color_adjust: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const drm_mm_node,
            color: ffi::c_ulong,
            start: *mut u64_,
            end: *mut u64_,
        ),
    >,
    pub hole_stack: list_head,
    pub head_node: drm_mm_node,
    pub interval_tree: rb_root_cached,
    pub holes_size: rb_root_cached,
    pub holes_addr: rb_root,
    pub scan_active: ffi::c_ulong,
}
impl Default for drm_mm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_mm_scan {
    pub mm: *mut drm_mm,
    pub size: u64_,
    pub alignment: u64_,
    pub remainder_mask: u64_,
    pub range_start: u64_,
    pub range_end: u64_,
    pub hit_start: u64_,
    pub hit_end: u64_,
    pub color: ffi::c_ulong,
    pub mode: drm_mm_insert_mode,
}
impl Default for drm_mm_scan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_vma_offset_file {
    pub vm_rb: rb_node,
    pub vm_tag: *mut drm_file,
    pub vm_count: ffi::c_ulong,
}
impl Default for drm_vma_offset_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_vma_offset_node {
    pub vm_lock: rwlock_t,
    pub vm_node: drm_mm_node,
    pub vm_files: rb_root,
    pub driver_private: *mut ffi::c_void,
}
impl Default for drm_vma_offset_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_vma_offset_manager {
    pub vm_lock: rwlock_t,
    pub vm_addr_space_mm: drm_mm,
}
impl Default for drm_vma_offset_manager {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const drm_gem_object_status_DRM_GEM_OBJECT_RESIDENT: drm_gem_object_status = 1;
pub const drm_gem_object_status_DRM_GEM_OBJECT_PURGEABLE: drm_gem_object_status = 2;
pub const drm_gem_object_status_DRM_GEM_OBJECT_ACTIVE: drm_gem_object_status = 4;
pub type drm_gem_object_status = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_gem_object_funcs {
    pub free: ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object)>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(obj: *mut drm_gem_object, file: *mut drm_file) -> ffi::c_int,
    >,
    pub close:
        ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object, file: *mut drm_file)>,
    pub print_info: ::core::option::Option<
        unsafe extern "C" fn(p: *mut drm_printer, indent: ffi::c_uint, obj: *const drm_gem_object),
    >,
    pub export: ::core::option::Option<
        unsafe extern "C" fn(obj: *mut drm_gem_object, flags: ffi::c_int) -> *mut dma_buf,
    >,
    pub pin: ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object) -> ffi::c_int>,
    pub unpin: ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object)>,
    pub get_sg_table:
        ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object) -> *mut sg_table>,
    pub vmap: ::core::option::Option<
        unsafe extern "C" fn(obj: *mut drm_gem_object, map: *mut iosys_map) -> ffi::c_int,
    >,
    pub vunmap:
        ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object, map: *mut iosys_map)>,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(obj: *mut drm_gem_object, vma: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub evict: ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object) -> ffi::c_int>,
    pub status: ::core::option::Option<
        unsafe extern "C" fn(obj: *mut drm_gem_object) -> drm_gem_object_status,
    >,
    pub rss: ::core::option::Option<unsafe extern "C" fn(obj: *mut drm_gem_object) -> usize>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for drm_gem_object_funcs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_gem_lru {
    pub lock: *mut mutex,
    pub count: ffi::c_long,
    pub list: list_head,
}
impl Default for drm_gem_lru {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_gem_object {
    pub refcount: kref,
    pub handle_count: ffi::c_uint,
    pub dev: *mut drm_device,
    pub filp: *mut file,
    pub vma_node: drm_vma_offset_node,
    pub size: usize,
    pub name: ffi::c_int,
    pub dma_buf: *mut dma_buf,
    pub import_attach: *mut dma_buf_attachment,
    pub resv: *mut dma_resv,
    pub _resv: dma_resv,
    pub gpuva: drm_gem_object__bindgen_ty_1,
    pub funcs: *const drm_gem_object_funcs,
    pub lru_node: list_head,
    pub lru: *mut drm_gem_lru,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_gem_object__bindgen_ty_1 {
    pub list: list_head,
}
impl Default for drm_gem_object__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for drm_gem_object {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type drm_ioctl_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut drm_device,
        data: *mut ffi::c_void,
        file_priv: *mut drm_file,
    ) -> ffi::c_int,
>;
pub type drm_ioctl_compat_t = ::core::option::Option<
    unsafe extern "C" fn(filp: *mut file, cmd: ffi::c_uint, arg: ffi::c_ulong) -> ffi::c_int,
>;
pub const drm_ioctl_flags_DRM_AUTH: drm_ioctl_flags = 1;
pub const drm_ioctl_flags_DRM_MASTER: drm_ioctl_flags = 2;
pub const drm_ioctl_flags_DRM_ROOT_ONLY: drm_ioctl_flags = 4;
pub const drm_ioctl_flags_DRM_RENDER_ALLOW: drm_ioctl_flags = 32;
pub type drm_ioctl_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_ioctl_desc {
    pub cmd: ffi::c_uint,
    pub flags: drm_ioctl_flags,
    pub func: drm_ioctl_t,
    pub name: *const ffi::c_char,
}
impl Default for drm_ioctl_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct string_stream {
    _unused: [u8; 0],
}
pub const kunit_assert_type_KUNIT_ASSERTION: kunit_assert_type = 0;
pub const kunit_assert_type_KUNIT_EXPECTATION: kunit_assert_type = 1;
pub type kunit_assert_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_loc {
    pub line: ffi::c_int,
    pub file: *const ffi::c_char,
}
impl Default for kunit_loc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_assert {}
pub type assert_format_t = ::core::option::Option<
    unsafe extern "C" fn(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    ),
>;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_fail_assert {
    pub assert: kunit_assert,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_unary_assert {
    pub assert: kunit_assert,
    pub condition: *const ffi::c_char,
    pub expected_true: bool_,
}
impl Default for kunit_unary_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_ptr_not_err_assert {
    pub assert: kunit_assert,
    pub text: *const ffi::c_char,
    pub value: *const ffi::c_void,
}
impl Default for kunit_ptr_not_err_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert_text {
    pub operation: *const ffi::c_char,
    pub left_text: *const ffi::c_char,
    pub right_text: *const ffi::c_char,
}
impl Default for kunit_binary_assert_text {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: ffi::c_longlong,
    pub right_value: ffi::c_longlong,
}
impl Default for kunit_binary_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_ptr_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const ffi::c_void,
    pub right_value: *const ffi::c_void,
}
impl Default for kunit_binary_ptr_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_str_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const ffi::c_char,
    pub right_value: *const ffi::c_char,
}
impl Default for kunit_binary_str_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_mem_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const ffi::c_void,
    pub right_value: *const ffi::c_void,
    pub size: usize,
}
impl Default for kunit_mem_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type kunit_try_catch_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>;
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct kunit_try_catch {
    pub _bindgen_opaque_blob: [u64; 6usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct func_desc_t {
    pub addr: ffi::c_ulong,
}

pub const kunit_status_KUNIT_SUCCESS: kunit_status = 0;
pub const kunit_status_KUNIT_FAILURE: kunit_status = 1;
pub const kunit_status_KUNIT_SKIPPED: kunit_status = 2;
pub type kunit_status = ffi::c_uint;
pub const kunit_speed_KUNIT_SPEED_UNSET: kunit_speed = 0;
pub const kunit_speed_KUNIT_SPEED_VERY_SLOW: kunit_speed = 1;
pub const kunit_speed_KUNIT_SPEED_SLOW: kunit_speed = 2;
pub const kunit_speed_KUNIT_SPEED_NORMAL: kunit_speed = 3;
pub const kunit_speed_KUNIT_SPEED_MAX: kunit_speed = 3;
pub type kunit_speed = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_attributes {
    pub speed: kunit_speed,
}
impl Default for kunit_attributes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_case {
    pub run_case: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub name: *const ffi::c_char,
    pub generate_params: ::core::option::Option<
        unsafe extern "C" fn(
            prev: *const ffi::c_void,
            desc: *mut ffi::c_char,
        ) -> *const ffi::c_void,
    >,
    pub attr: kunit_attributes,
    pub status: kunit_status,
    pub module_name: *mut ffi::c_char,
    pub log: *mut string_stream,
}
impl Default for kunit_case {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_suite {
    pub name: [ffi::c_char; 256usize],
    pub suite_init:
        ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite) -> ffi::c_int>,
    pub suite_exit: ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite)>,
    pub init: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit) -> ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub test_cases: *mut kunit_case,
    pub attr: kunit_attributes,
    pub status_comment: [ffi::c_char; 256usize],
    pub debugfs: *mut dentry,
    pub log: *mut string_stream,
    pub suite_init_err: ffi::c_int,
    pub is_init: bool_,
}
impl Default for kunit_suite {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_suite_set {
    pub start: *const *mut kunit_suite,
    pub end: *const *mut kunit_suite,
}
impl Default for kunit_suite_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit {
    pub priv_: *mut ffi::c_void,
    pub name: *const ffi::c_char,
    pub log: *mut string_stream,
    pub try_catch: kunit_try_catch,
    pub param_value: *const ffi::c_void,
    pub param_index: ffi::c_int,
    pub lock: spinlock_t,
    pub status: kunit_status,
    pub resources: list_head,
    pub status_comment: [ffi::c_char; 256usize],
    pub last_seen: kunit_loc,
}
impl Default for kunit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type kunit_resource_init_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut kunit_resource, arg2: *mut ffi::c_void) -> ffi::c_int,
>;
pub type kunit_resource_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut kunit_resource)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_resource {
    pub data: *mut ffi::c_void,
    pub name: *const ffi::c_char,
    pub free: kunit_resource_free_t,
    pub refcount: kref,
    pub node: list_head,
    pub should_kfree: bool_,
}
impl Default for kunit_resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type kunit_resource_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        test: *mut kunit,
        res: *mut kunit_resource,
        match_data: *mut ffi::c_void,
    ) -> bool_,
>;

pub type kunit_action_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct auxiliary_device {
    pub dev: device,
    pub name: *const ffi::c_char,
    pub id: u32_,
    pub sysfs: auxiliary_device__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct auxiliary_device__bindgen_ty_1 {
    pub irqs: xarray,
    pub lock: mutex,
    pub irq_dir_exists: bool_,
}
impl Default for auxiliary_device__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for auxiliary_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct auxiliary_driver {
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(
            auxdev: *mut auxiliary_device,
            id: *const auxiliary_device_id,
        ) -> ffi::c_int,
    >,
    pub remove: ::core::option::Option<unsafe extern "C" fn(auxdev: *mut auxiliary_device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(auxdev: *mut auxiliary_device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(auxdev: *mut auxiliary_device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(auxdev: *mut auxiliary_device) -> ffi::c_int>,
    pub name: *const ffi::c_char,
    pub driver: device_driver,
    pub id_table: *const auxiliary_device_id,
}
impl Default for auxiliary_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct urb {
    _unused: [u8; 0],
}
pub const ctx_state_CT_STATE_DISABLED: ctx_state = -1;
pub const ctx_state_CT_STATE_KERNEL: ctx_state = 0;
pub const ctx_state_CT_STATE_IDLE: ctx_state = 1;
pub const ctx_state_CT_STATE_USER: ctx_state = 2;
pub const ctx_state_CT_STATE_GUEST: ctx_state = 3;
pub const ctx_state_CT_STATE_MAX: ctx_state = 4;
pub type ctx_state = ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct context_tracking {
    pub state: atomic_t,
    pub nesting: ffi::c_long,
    pub nmi_nesting: ffi::c_long,
}

#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irq_cpustat_t {
    pub __softirq_pending: ffi::c_uint,
}
impl Default for irq_cpustat_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type irq_flow_handler_t = ::core::option::Option<unsafe extern "C" fn(desc: *mut irq_desc)>;
pub const IRQC_IS_HARDIRQ: _bindgen_ty_98 = 0;
pub const IRQC_IS_NESTED: _bindgen_ty_98 = 1;
pub type _bindgen_ty_98 = ffi::c_uint;
pub type irq_handler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: ffi::c_int, arg2: *mut ffi::c_void) -> irqreturn_t,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irqaction {
    pub handler: irq_handler_t,
    pub dev_id: *mut ffi::c_void,
    pub percpu_dev_id: *mut ffi::c_void,
    pub next: *mut irqaction,
    pub thread_fn: irq_handler_t,
    pub thread: *mut task_struct,
    pub secondary: *mut irqaction,
    pub irq: ffi::c_uint,
    pub flags: ffi::c_uint,
    pub thread_flags: ffi::c_ulong,
    pub thread_mask: ffi::c_ulong,
    pub name: *const ffi::c_char,
    pub dir: *mut proc_dir_entry,
}
impl Default for irqaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_disable_irq_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_disable_irq_t {
    pub lock: *mut ffi::c_int,
}
impl Default for class_disable_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_affinity_notify {
    pub irq: ffi::c_uint,
    pub kref: kref,
    pub work: work_struct,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_affinity_notify, mask: *const cpumask_t),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(ref_: *mut kref)>,
}
impl Default for irq_affinity_notify {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_affinity {
    pub pre_vectors: ffi::c_uint,
    pub post_vectors: ffi::c_uint,
    pub nr_sets: ffi::c_uint,
    pub set_size: [ffi::c_uint; 4usize],
    pub calc_sets:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_affinity, nvecs: ffi::c_uint)>,
    pub priv_: *mut ffi::c_void,
}
impl Default for irq_affinity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irq_affinity_desc {
    pub mask: cpumask,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl irq_affinity_desc {
    #[inline]
    pub fn is_managed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_managed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_managed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_managed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_managed: ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_managed: u32 = unsafe { ::core::mem::transmute(is_managed) };
            is_managed as u64
        });
        __bindgen_bitfield_unit
    }
}

pub const irqchip_irq_state_IRQCHIP_STATE_PENDING: irqchip_irq_state = 0;
pub const irqchip_irq_state_IRQCHIP_STATE_ACTIVE: irqchip_irq_state = 1;
pub const irqchip_irq_state_IRQCHIP_STATE_MASKED: irqchip_irq_state = 2;
pub const irqchip_irq_state_IRQCHIP_STATE_LINE_LEVEL: irqchip_irq_state = 3;
pub type irqchip_irq_state = ffi::c_uint;

pub const HI_SOFTIRQ: _bindgen_ty_99 = 0;
pub const TIMER_SOFTIRQ: _bindgen_ty_99 = 1;
pub const NET_TX_SOFTIRQ: _bindgen_ty_99 = 2;
pub const NET_RX_SOFTIRQ: _bindgen_ty_99 = 3;
pub const BLOCK_SOFTIRQ: _bindgen_ty_99 = 4;
pub const IRQ_POLL_SOFTIRQ: _bindgen_ty_99 = 5;
pub const TASKLET_SOFTIRQ: _bindgen_ty_99 = 6;
pub const SCHED_SOFTIRQ: _bindgen_ty_99 = 7;
pub const HRTIMER_SOFTIRQ: _bindgen_ty_99 = 8;
pub const RCU_SOFTIRQ: _bindgen_ty_99 = 9;
pub const NR_SOFTIRQS: _bindgen_ty_99 = 10;
pub type _bindgen_ty_99 = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct softirq_action {
    pub action: ::core::option::Option<unsafe extern "C" fn()>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct tasklet_struct {
    pub next: *mut tasklet_struct,
    pub state: ffi::c_ulong,
    pub count: atomic_t,
    pub use_callback: bool_,
    pub __bindgen_anon_1: tasklet_struct__bindgen_ty_1,
    pub data: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tasklet_struct__bindgen_ty_1 {
    pub func: ::core::option::Option<unsafe extern "C" fn(data: ffi::c_ulong)>,
    pub callback: ::core::option::Option<unsafe extern "C" fn(t: *mut tasklet_struct)>,
}
impl Default for tasklet_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tasklet_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TASKLET_STATE_SCHED: _bindgen_ty_100 = 0;
pub const TASKLET_STATE_RUN: _bindgen_ty_100 = 1;
pub type _bindgen_ty_100 = ffi::c_uint;

pub const riscv_irqchip_type_ACPI_RISCV_IRQCHIP_INTC: riscv_irqchip_type = 0;
pub const riscv_irqchip_type_ACPI_RISCV_IRQCHIP_IMSIC: riscv_irqchip_type = 1;
pub const riscv_irqchip_type_ACPI_RISCV_IRQCHIP_PLIC: riscv_irqchip_type = 2;
pub const riscv_irqchip_type_ACPI_RISCV_IRQCHIP_APLIC: riscv_irqchip_type = 3;
pub type riscv_irqchip_type = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_msg {
    _unused: [u8; 0],
}
pub const IRQ_TYPE_NONE: _bindgen_ty_101 = 0;
pub const IRQ_TYPE_EDGE_RISING: _bindgen_ty_101 = 1;
pub const IRQ_TYPE_EDGE_FALLING: _bindgen_ty_101 = 2;
pub const IRQ_TYPE_EDGE_BOTH: _bindgen_ty_101 = 3;
pub const IRQ_TYPE_LEVEL_HIGH: _bindgen_ty_101 = 4;
pub const IRQ_TYPE_LEVEL_LOW: _bindgen_ty_101 = 8;
pub const IRQ_TYPE_LEVEL_MASK: _bindgen_ty_101 = 12;
pub const IRQ_TYPE_SENSE_MASK: _bindgen_ty_101 = 15;
pub const IRQ_TYPE_DEFAULT: _bindgen_ty_101 = 15;
pub const IRQ_TYPE_PROBE: _bindgen_ty_101 = 16;
pub const IRQ_LEVEL: _bindgen_ty_101 = 256;
pub const IRQ_PER_CPU: _bindgen_ty_101 = 512;
pub const IRQ_NOPROBE: _bindgen_ty_101 = 1024;
pub const IRQ_NOREQUEST: _bindgen_ty_101 = 2048;
pub const IRQ_NOAUTOEN: _bindgen_ty_101 = 4096;
pub const IRQ_NO_BALANCING: _bindgen_ty_101 = 8192;
pub const IRQ_NESTED_THREAD: _bindgen_ty_101 = 32768;
pub const IRQ_NOTHREAD: _bindgen_ty_101 = 65536;
pub const IRQ_PER_CPU_DEVID: _bindgen_ty_101 = 131072;
pub const IRQ_IS_POLLED: _bindgen_ty_101 = 262144;
pub const IRQ_DISABLE_UNLAZY: _bindgen_ty_101 = 524288;
pub const IRQ_HIDDEN: _bindgen_ty_101 = 1048576;
pub const IRQ_NO_DEBUG: _bindgen_ty_101 = 2097152;
pub type _bindgen_ty_101 = ffi::c_uint;
pub const IRQ_SET_MASK_OK: _bindgen_ty_102 = 0;
pub const IRQ_SET_MASK_OK_NOCOPY: _bindgen_ty_102 = 1;
pub const IRQ_SET_MASK_OK_DONE: _bindgen_ty_102 = 2;
pub type _bindgen_ty_102 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_common_data {
    pub state_use_accessors: ffi::c_uint,
    pub handler_data: *mut ffi::c_void,
    pub msi_desc: *mut msi_desc,
    pub affinity: cpumask_var_t,
    pub effective_affinity: cpumask_var_t,
    pub ipi_offset: ffi::c_uint,
}
impl Default for irq_common_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_data {
    pub mask: u32_,
    pub irq: ffi::c_uint,
    pub hwirq: irq_hw_number_t,
    pub common: *mut irq_common_data,
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub parent_data: *mut irq_data,
    pub chip_data: *mut ffi::c_void,
}
impl Default for irq_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IRQD_TRIGGER_MASK: _bindgen_ty_103 = 15;
pub const IRQD_SETAFFINITY_PENDING: _bindgen_ty_103 = 256;
pub const IRQD_ACTIVATED: _bindgen_ty_103 = 512;
pub const IRQD_NO_BALANCING: _bindgen_ty_103 = 1024;
pub const IRQD_PER_CPU: _bindgen_ty_103 = 2048;
pub const IRQD_AFFINITY_SET: _bindgen_ty_103 = 4096;
pub const IRQD_LEVEL: _bindgen_ty_103 = 8192;
pub const IRQD_WAKEUP_STATE: _bindgen_ty_103 = 16384;
pub const IRQD_IRQ_DISABLED: _bindgen_ty_103 = 65536;
pub const IRQD_IRQ_MASKED: _bindgen_ty_103 = 131072;
pub const IRQD_IRQ_INPROGRESS: _bindgen_ty_103 = 262144;
pub const IRQD_WAKEUP_ARMED: _bindgen_ty_103 = 524288;
pub const IRQD_FORWARDED_TO_VCPU: _bindgen_ty_103 = 1048576;
pub const IRQD_AFFINITY_MANAGED: _bindgen_ty_103 = 2097152;
pub const IRQD_IRQ_STARTED: _bindgen_ty_103 = 4194304;
pub const IRQD_MANAGED_SHUTDOWN: _bindgen_ty_103 = 8388608;
pub const IRQD_SINGLE_TARGET: _bindgen_ty_103 = 16777216;
pub const IRQD_DEFAULT_TRIGGER_SET: _bindgen_ty_103 = 33554432;
pub const IRQD_CAN_RESERVE: _bindgen_ty_103 = 67108864;
pub const IRQD_HANDLE_ENFORCE_IRQCTX: _bindgen_ty_103 = 134217728;
pub const IRQD_AFFINITY_ON_ACTIVATE: _bindgen_ty_103 = 268435456;
pub const IRQD_IRQ_ENABLED_ON_SUSPEND: _bindgen_ty_103 = 536870912;
pub const IRQD_RESEND_WHEN_IN_PROGRESS: _bindgen_ty_103 = 1073741824;
pub type _bindgen_ty_103 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_chip {
    pub name: *const ffi::c_char,
    pub irq_startup:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> ffi::c_uint>,
    pub irq_shutdown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_ack: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_mask_ack: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_eoi: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_set_affinity: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, dest: *const cpumask, force: bool_) -> ffi::c_int,
    >,
    pub irq_retrigger:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> ffi::c_int>,
    pub irq_set_type: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, flow_type: ffi::c_uint) -> ffi::c_int,
    >,
    pub irq_set_wake: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, on: ffi::c_uint) -> ffi::c_int,
    >,
    pub irq_bus_lock: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_bus_sync_unlock: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_suspend: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_resume: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_pm_shutdown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_calc_mask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_print_chip:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, p: *mut seq_file)>,
    pub irq_request_resources:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> ffi::c_int>,
    pub irq_release_resources: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_compose_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, msg: *mut msi_msg)>,
    pub irq_write_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, msg: *mut msi_msg)>,
    pub irq_get_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            which: irqchip_irq_state,
            state: *mut bool_,
        ) -> ffi::c_int,
    >,
    pub irq_set_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            which: irqchip_irq_state,
            state: bool_,
        ) -> ffi::c_int,
    >,
    pub irq_set_vcpu_affinity: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, vcpu_info: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub ipi_send_single:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, cpu: ffi::c_uint)>,
    pub ipi_send_mask:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, dest: *const cpumask)>,
    pub irq_nmi_setup:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> ffi::c_int>,
    pub irq_nmi_teardown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_force_complete_move: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub flags: ffi::c_ulong,
}
impl Default for irq_chip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IRQCHIP_SET_TYPE_MASKED: _bindgen_ty_104 = 1;
pub const IRQCHIP_EOI_IF_HANDLED: _bindgen_ty_104 = 2;
pub const IRQCHIP_MASK_ON_SUSPEND: _bindgen_ty_104 = 4;
pub const IRQCHIP_ONOFFLINE_ENABLED: _bindgen_ty_104 = 8;
pub const IRQCHIP_SKIP_SET_WAKE: _bindgen_ty_104 = 16;
pub const IRQCHIP_ONESHOT_SAFE: _bindgen_ty_104 = 32;
pub const IRQCHIP_EOI_THREADED: _bindgen_ty_104 = 64;
pub const IRQCHIP_SUPPORTS_LEVEL_MSI: _bindgen_ty_104 = 128;
pub const IRQCHIP_SUPPORTS_NMI: _bindgen_ty_104 = 256;
pub const IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND: _bindgen_ty_104 = 512;
pub const IRQCHIP_AFFINITY_PRE_STARTUP: _bindgen_ty_104 = 1024;
pub const IRQCHIP_IMMUTABLE: _bindgen_ty_104 = 2048;
pub const IRQCHIP_MOVE_DEFERRED: _bindgen_ty_104 = 4096;
pub type _bindgen_ty_104 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irqstat {
    pub cnt: ffi::c_uint,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irq_desc {
    pub irq_common_data: irq_common_data,
    pub irq_data: irq_data,
    pub kstat_irqs: *mut irqstat,
    pub handle_irq: irq_flow_handler_t,
    pub action: *mut irqaction,
    pub status_use_accessors: ffi::c_uint,
    pub core_internal_state__do_not_mess_with_it: ffi::c_uint,
    pub depth: ffi::c_uint,
    pub wake_depth: ffi::c_uint,
    pub tot_count: ffi::c_uint,
    pub irq_count: ffi::c_uint,
    pub last_unhandled: ffi::c_ulong,
    pub irqs_unhandled: ffi::c_uint,
    pub threads_handled: atomic_t,
    pub threads_handled_last: ffi::c_int,
    pub lock: raw_spinlock_t,
    pub percpu_enabled: *mut cpumask,
    pub percpu_affinity: *const cpumask,
    pub affinity_hint: *const cpumask,
    pub affinity_notify: *mut irq_affinity_notify,
    pub pending_mask: cpumask_var_t,
    pub threads_oneshot: ffi::c_ulong,
    pub threads_active: atomic_t,
    pub wait_for_threads: wait_queue_head_t,
    pub nr_actions: ffi::c_uint,
    pub no_suspend_depth: ffi::c_uint,
    pub cond_suspend_depth: ffi::c_uint,
    pub force_resume_depth: ffi::c_uint,
    pub dir: *mut proc_dir_entry,
    pub rcu: callback_head,
    pub kobj: kobject,
    pub request_mutex: mutex,
    pub parent_irq: ffi::c_int,
    pub owner: *mut module,
    pub name: *const ffi::c_char,
    pub resend_node: hlist_node,
}
impl Default for irq_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irq_chip_regs {
    pub enable: ffi::c_ulong,
    pub disable: ffi::c_ulong,
    pub mask: ffi::c_ulong,
    pub ack: ffi::c_ulong,
    pub eoi: ffi::c_ulong,
    pub type_: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_chip_type {
    pub chip: irq_chip,
    pub regs: irq_chip_regs,
    pub handler: irq_flow_handler_t,
    pub type_: u32_,
    pub mask_cache_priv: u32_,
    pub mask_cache: *mut u32_,
}
impl Default for irq_chip_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct irq_chip_generic {
    pub lock: raw_spinlock_t,
    pub reg_base: *mut ffi::c_void,
    pub reg_readl: ::core::option::Option<unsafe extern "C" fn(addr: *mut ffi::c_void) -> u32_>,
    pub reg_writel: ::core::option::Option<unsafe extern "C" fn(val: u32_, addr: *mut ffi::c_void)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
    pub irq_base: ffi::c_uint,
    pub irq_cnt: ffi::c_uint,
    pub mask_cache: u32_,
    pub wake_enabled: u32_,
    pub wake_active: u32_,
    pub num_ct: ffi::c_uint,
    pub private: *mut ffi::c_void,
    pub installed: ffi::c_ulong,
    pub unused: ffi::c_ulong,
    pub domain: *mut irq_domain,
    pub list: list_head,
    pub chip_types: __IncompleteArrayField<irq_chip_type>,
}
impl Default for irq_chip_generic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const irq_gc_flags_IRQ_GC_INIT_MASK_CACHE: irq_gc_flags = 1;
pub const irq_gc_flags_IRQ_GC_INIT_NESTED_LOCK: irq_gc_flags = 2;
pub const irq_gc_flags_IRQ_GC_MASK_CACHE_PER_TYPE: irq_gc_flags = 4;
pub const irq_gc_flags_IRQ_GC_NO_MASK: irq_gc_flags = 8;
pub const irq_gc_flags_IRQ_GC_BE_IO: irq_gc_flags = 16;
pub type irq_gc_flags = ffi::c_uint;
#[repr(C)]
pub struct irq_domain_chip_generic {
    pub irqs_per_chip: ffi::c_uint,
    pub num_chips: ffi::c_uint,
    pub irq_flags_to_clear: ffi::c_uint,
    pub irq_flags_to_set: ffi::c_uint,
    pub gc_flags: irq_gc_flags,
    pub exit: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
    pub gc: __IncompleteArrayField<*mut irq_chip_generic>,
}
impl Default for irq_domain_chip_generic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_domain_chip_generic_info {
    pub name: *const ffi::c_char,
    pub handler: irq_flow_handler_t,
    pub irqs_per_chip: ffi::c_uint,
    pub num_ct: ffi::c_uint,
    pub irq_flags_to_clear: ffi::c_uint,
    pub irq_flags_to_set: ffi::c_uint,
    pub gc_flags: irq_gc_flags,
    pub init: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic) -> ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
}
impl Default for irq_domain_chip_generic_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_matrix {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: ffi::c_uint,
    pub bv_offset: ffi::c_uint,
}
impl Default for bio_vec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: ffi::c_uint,
    pub bi_idx: ffi::c_uint,
    pub bi_bvec_done: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bvec_iter_all {
    pub bv: bio_vec,
    pub idx: ffi::c_int,
    pub done: ffi::c_uint,
}
impl Default for bvec_iter_all {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_integrity_payload {
    _unused: [u8; 0],
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_crypt_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_nr_sectors: sector_t,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: ffi::c_ulong,
    pub __bd_flags: atomic_t,
    pub bd_dev: dev_t,
    pub bd_mapping: *mut address_space,
    pub bd_openers: atomic_t,
    pub bd_size_lock: spinlock_t,
    pub bd_claiming: *mut ffi::c_void,
    pub bd_holder: *mut ffi::c_void,
    pub bd_holder_ops: *const blk_holder_ops,
    pub bd_holder_lock: mutex,
    pub bd_holders: ffi::c_int,
    pub bd_holder_dir: *mut kobject,
    pub bd_fsfreeze_count: atomic_t,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_meta_info: *mut partition_meta_info,
    pub bd_writers: ffi::c_int,
    pub bd_security: *mut ffi::c_void,
    pub bd_device: device,
}
impl Default for block_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_status_t = u8_;
pub type blk_short_t = u16_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
pub type blk_opf_t = __u32;
pub type blk_qc_t = ffi::c_uint;
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_bdev: *mut block_device,
    pub bi_opf: blk_opf_t,
    pub bi_flags: ffi::c_ushort,
    pub bi_ioprio: ffi::c_ushort,
    pub bi_write_hint: rw_hint,
    pub bi_write_stream: u8_,
    pub bi_status: blk_status_t,
    pub __bi_remaining: atomic_t,
    pub bi_iter: bvec_iter,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut ffi::c_void,
    pub bi_blkg: *mut blkcg_gq,
    pub bi_issue: bio_issue,
    pub bi_vcnt: ffi::c_ushort,
    pub bi_max_vecs: ffi::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_cookie: blk_qc_t,
    pub __bi_nr_segments: ffi::c_uint,
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BIO_PAGE_PINNED: _bindgen_ty_105 = 0;
pub const BIO_CLONED: _bindgen_ty_105 = 1;
pub const BIO_QUIET: _bindgen_ty_105 = 2;
pub const BIO_CHAIN: _bindgen_ty_105 = 3;
pub const BIO_REFFED: _bindgen_ty_105 = 4;
pub const BIO_BPS_THROTTLED: _bindgen_ty_105 = 5;
pub const BIO_TRACE_COMPLETION: _bindgen_ty_105 = 6;
pub const BIO_CGROUP_ACCT: _bindgen_ty_105 = 7;
pub const BIO_QOS_THROTTLED: _bindgen_ty_105 = 8;
pub const BIO_TG_BPS_THROTTLED: _bindgen_ty_105 = 8;
pub const BIO_QOS_MERGED: _bindgen_ty_105 = 9;
pub const BIO_REMAPPED: _bindgen_ty_105 = 10;
pub const BIO_ZONE_WRITE_PLUGGING: _bindgen_ty_105 = 11;
pub const BIO_EMULATES_ZONE_APPEND: _bindgen_ty_105 = 12;
pub const BIO_FLAG_LAST: _bindgen_ty_105 = 13;
pub type _bindgen_ty_105 = ffi::c_uint;
pub type blk_mq_req_flags_t = __u32;
pub const req_op_REQ_OP_READ: req_op = 0;
pub const req_op_REQ_OP_WRITE: req_op = 1;
pub const req_op_REQ_OP_FLUSH: req_op = 2;
pub const req_op_REQ_OP_DISCARD: req_op = 3;
pub const req_op_REQ_OP_SECURE_ERASE: req_op = 5;
pub const req_op_REQ_OP_ZONE_APPEND: req_op = 7;
pub const req_op_REQ_OP_WRITE_ZEROES: req_op = 9;
pub const req_op_REQ_OP_ZONE_OPEN: req_op = 10;
pub const req_op_REQ_OP_ZONE_CLOSE: req_op = 11;
pub const req_op_REQ_OP_ZONE_FINISH: req_op = 13;
pub const req_op_REQ_OP_ZONE_RESET: req_op = 15;
pub const req_op_REQ_OP_ZONE_RESET_ALL: req_op = 17;
pub const req_op_REQ_OP_DRV_IN: req_op = 34;
pub const req_op_REQ_OP_DRV_OUT: req_op = 35;
pub const req_op_REQ_OP_LAST: req_op = 36;
pub type req_op = ffi::c_uint;
pub const req_flag_bits___REQ_FAILFAST_DEV: req_flag_bits = 8;
pub const req_flag_bits___REQ_FAILFAST_TRANSPORT: req_flag_bits = 9;
pub const req_flag_bits___REQ_FAILFAST_DRIVER: req_flag_bits = 10;
pub const req_flag_bits___REQ_SYNC: req_flag_bits = 11;
pub const req_flag_bits___REQ_META: req_flag_bits = 12;
pub const req_flag_bits___REQ_PRIO: req_flag_bits = 13;
pub const req_flag_bits___REQ_NOMERGE: req_flag_bits = 14;
pub const req_flag_bits___REQ_IDLE: req_flag_bits = 15;
pub const req_flag_bits___REQ_INTEGRITY: req_flag_bits = 16;
pub const req_flag_bits___REQ_FUA: req_flag_bits = 17;
pub const req_flag_bits___REQ_PREFLUSH: req_flag_bits = 18;
pub const req_flag_bits___REQ_RAHEAD: req_flag_bits = 19;
pub const req_flag_bits___REQ_BACKGROUND: req_flag_bits = 20;
pub const req_flag_bits___REQ_NOWAIT: req_flag_bits = 21;
pub const req_flag_bits___REQ_POLLED: req_flag_bits = 22;
pub const req_flag_bits___REQ_ALLOC_CACHE: req_flag_bits = 23;
pub const req_flag_bits___REQ_SWAP: req_flag_bits = 24;
pub const req_flag_bits___REQ_DRV: req_flag_bits = 25;
pub const req_flag_bits___REQ_FS_PRIVATE: req_flag_bits = 26;
pub const req_flag_bits___REQ_ATOMIC: req_flag_bits = 27;
pub const req_flag_bits___REQ_P2PDMA: req_flag_bits = 28;
pub const req_flag_bits___REQ_NOUNMAP: req_flag_bits = 29;
pub const req_flag_bits___REQ_NR_BITS: req_flag_bits = 30;
pub type req_flag_bits = ffi::c_uint;
pub const stat_group_STAT_READ: stat_group = 0;
pub const stat_group_STAT_WRITE: stat_group = 1;
pub const stat_group_STAT_DISCARD: stat_group = 2;
pub const stat_group_STAT_FLUSH: stat_group = 3;
pub const stat_group_NR_STAT_GROUPS: stat_group = 4;
pub type stat_group = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64_,
    pub min: u64_,
    pub max: u64_,
    pub nr_samples: u32_,
    pub batch: u64_,
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(gfp_mask: gfp_t, pool_data: *mut ffi::c_void) -> *mut ffi::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(element: *mut ffi::c_void, pool_data: *mut ffi::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: ffi::c_int,
    pub curr_nr: ffi::c_int,
    pub elements: *mut *mut ffi::c_void,
    pub pool_data: *mut ffi::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
impl Default for mempool_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mempool_t = mempool_s;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio_iter {
    pub folio: *mut folio,
    pub offset: usize,
    pub length: usize,
    pub _next: *mut folio,
    pub _seg_count: usize,
    pub _i: ffi::c_int,
}
impl Default for folio_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const BIOSET_NEED_BVECS: _bindgen_ty_106 = 1;
pub const BIOSET_NEED_RESCUER: _bindgen_ty_106 = 2;
pub const BIOSET_PERCPU_CACHE: _bindgen_ty_106 = 4;
pub type _bindgen_ty_106 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: ffi::c_uint,
    pub cache: *mut bio_alloc_cache,
    pub bio_pool: mempool_t,
    pub bvec_pool: mempool_t,
    pub back_pad: ffi::c_uint,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
    pub cpuhp_dead: hlist_node,
}
impl Default for bio_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
impl Default for bio_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const blk_zone_type_BLK_ZONE_TYPE_CONVENTIONAL: blk_zone_type = 1;
pub const blk_zone_type_BLK_ZONE_TYPE_SEQWRITE_REQ: blk_zone_type = 2;
pub const blk_zone_type_BLK_ZONE_TYPE_SEQWRITE_PREF: blk_zone_type = 3;
pub type blk_zone_type = ffi::c_uint;
pub const blk_zone_cond_BLK_ZONE_COND_NOT_WP: blk_zone_cond = 0;
pub const blk_zone_cond_BLK_ZONE_COND_EMPTY: blk_zone_cond = 1;
pub const blk_zone_cond_BLK_ZONE_COND_IMP_OPEN: blk_zone_cond = 2;
pub const blk_zone_cond_BLK_ZONE_COND_EXP_OPEN: blk_zone_cond = 3;
pub const blk_zone_cond_BLK_ZONE_COND_CLOSED: blk_zone_cond = 4;
pub const blk_zone_cond_BLK_ZONE_COND_READONLY: blk_zone_cond = 13;
pub const blk_zone_cond_BLK_ZONE_COND_FULL: blk_zone_cond = 14;
pub const blk_zone_cond_BLK_ZONE_COND_OFFLINE: blk_zone_cond = 15;
pub type blk_zone_cond = ffi::c_uint;
pub const blk_zone_report_flags_BLK_ZONE_REP_CAPACITY: blk_zone_report_flags = 1;
pub type blk_zone_report_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_zone {
    pub start: __u64,
    pub len: __u64,
    pub wp: __u64,
    pub type_: __u8,
    pub cond: __u8,
    pub non_seq: __u8,
    pub reset: __u8,
    pub resv: [__u8; 4usize],
    pub capacity: __u64,
    pub reserved: [__u8; 24usize],
}
#[repr(C)]
#[derive(Default)]
pub struct blk_zone_report {
    pub sector: __u64,
    pub nr_zones: __u32,
    pub flags: __u32,
    pub zones: __IncompleteArrayField<blk_zone>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_zone_range {
    pub sector: __u64,
    pub nr_sectors: __u64,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sbitmap_word {
    pub word: ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 7usize],
    pub cleared: ffi::c_ulong,
    pub swap_lock: raw_spinlock_t,
}
impl Default for sbitmap_word {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbitmap {
    pub depth: ffi::c_uint,
    pub shift: ffi::c_uint,
    pub map_nr: ffi::c_uint,
    pub round_robin: bool_,
    pub map: *mut sbitmap_word,
    pub alloc_hint: *mut ffi::c_uint,
}
impl Default for sbitmap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sbq_wait_state {
    pub wait: wait_queue_head_t,
}
impl Default for sbq_wait_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbitmap_queue {
    pub sb: sbitmap,
    pub wake_batch: ffi::c_uint,
    pub wake_index: atomic_t,
    pub ws: *mut sbq_wait_state,
    pub ws_active: atomic_t,
    pub min_shallow_depth: ffi::c_uint,
    pub completion_cnt: atomic_t,
    pub wakeup_cnt: atomic_t,
}
impl Default for sbitmap_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type sb_for_each_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sbitmap, arg2: ffi::c_uint, arg3: *mut ffi::c_void) -> bool_,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbq_wait {
    pub sbq: *mut sbitmap_queue,
    pub wait: wait_queue_entry,
}
impl Default for sbq_wait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_trace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_io_hdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg_gq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_flush_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pr_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq_qos {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_queue_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_stat_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_crypto_profile {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [ffi::c_char; 37usize],
    pub volname: [u8_; 64usize],
}
impl Default for partition_meta_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GENHD_FL_REMOVABLE: _bindgen_ty_107 = 1;
pub const GENHD_FL_HIDDEN: _bindgen_ty_107 = 2;
pub const GENHD_FL_NO_PART: _bindgen_ty_107 = 4;
pub type _bindgen_ty_107 = ffi::c_uint;
pub const DISK_EVENT_MEDIA_CHANGE: _bindgen_ty_108 = 1;
pub const DISK_EVENT_EJECT_REQUEST: _bindgen_ty_108 = 2;
pub type _bindgen_ty_108 = ffi::c_uint;
pub const DISK_EVENT_FLAG_POLL: _bindgen_ty_109 = 1;
pub const DISK_EVENT_FLAG_UEVENT: _bindgen_ty_109 = 2;
pub const DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE: _bindgen_ty_109 = 4;
pub type _bindgen_ty_109 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct disk_events {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct badblocks {
    _unused: [u8; 0],
}
pub const blk_integrity_checksum_BLK_INTEGRITY_CSUM_NONE: blk_integrity_checksum = 0;
pub const blk_integrity_checksum_BLK_INTEGRITY_CSUM_IP: blk_integrity_checksum = 1;
pub const blk_integrity_checksum_BLK_INTEGRITY_CSUM_CRC: blk_integrity_checksum = 2;
pub const blk_integrity_checksum_BLK_INTEGRITY_CSUM_CRC64: blk_integrity_checksum = 3;
pub type blk_integrity_checksum = ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_integrity {
    pub flags: ffi::c_uchar,
    pub csum_type: blk_integrity_checksum,
    pub metadata_size: ffi::c_uchar,
    pub pi_offset: ffi::c_uchar,
    pub interval_exp: ffi::c_uchar,
    pub tag_size: ffi::c_uchar,
    pub pi_tuple_size: ffi::c_uchar,
}
impl Default for blk_integrity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_mode_t = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gendisk {
    pub major: ffi::c_int,
    pub first_minor: ffi::c_int,
    pub minors: ffi::c_int,
    pub disk_name: [ffi::c_char; 32usize],
    pub events: ffi::c_ushort,
    pub event_flags: ffi::c_ushort,
    pub part_tbl: xarray,
    pub part0: *mut block_device,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut ffi::c_void,
    pub bio_split: bio_set,
    pub flags: ffi::c_int,
    pub state: ffi::c_ulong,
    pub open_mutex: mutex,
    pub open_partitions: ffi::c_uint,
    pub bdi: *mut backing_dev_info,
    pub queue_kobj: kobject,
    pub slave_dir: *mut kobject,
    pub slave_bdevs: list_head,
    pub random: *mut timer_rand_state,
    pub ev: *mut disk_events,
    pub cdi: *mut cdrom_device_info,
    pub node_id: ffi::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
    pub diskseq: u64_,
    pub open_mode: blk_mode_t,
    pub ia_ranges: *mut blk_independent_access_ranges,
    pub rqos_state_mutex: mutex,
}
impl Default for gendisk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_features_t = ffi::c_uint;
pub type blk_flags_t = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct queue_limits {
    pub features: blk_features_t,
    pub flags: blk_flags_t,
    pub seg_boundary_mask: ffi::c_ulong,
    pub virt_boundary_mask: ffi::c_ulong,
    pub max_hw_sectors: ffi::c_uint,
    pub max_dev_sectors: ffi::c_uint,
    pub chunk_sectors: ffi::c_uint,
    pub max_sectors: ffi::c_uint,
    pub max_user_sectors: ffi::c_uint,
    pub max_segment_size: ffi::c_uint,
    pub min_segment_size: ffi::c_uint,
    pub physical_block_size: ffi::c_uint,
    pub logical_block_size: ffi::c_uint,
    pub alignment_offset: ffi::c_uint,
    pub io_min: ffi::c_uint,
    pub io_opt: ffi::c_uint,
    pub max_discard_sectors: ffi::c_uint,
    pub max_hw_discard_sectors: ffi::c_uint,
    pub max_user_discard_sectors: ffi::c_uint,
    pub max_secure_erase_sectors: ffi::c_uint,
    pub max_write_zeroes_sectors: ffi::c_uint,
    pub max_wzeroes_unmap_sectors: ffi::c_uint,
    pub max_hw_wzeroes_unmap_sectors: ffi::c_uint,
    pub max_user_wzeroes_unmap_sectors: ffi::c_uint,
    pub max_hw_zone_append_sectors: ffi::c_uint,
    pub max_zone_append_sectors: ffi::c_uint,
    pub discard_granularity: ffi::c_uint,
    pub discard_alignment: ffi::c_uint,
    pub zone_write_granularity: ffi::c_uint,
    pub atomic_write_hw_max: ffi::c_uint,
    pub atomic_write_max_sectors: ffi::c_uint,
    pub atomic_write_hw_boundary: ffi::c_uint,
    pub atomic_write_boundary_sectors: ffi::c_uint,
    pub atomic_write_hw_unit_min: ffi::c_uint,
    pub atomic_write_unit_min: ffi::c_uint,
    pub atomic_write_hw_unit_max: ffi::c_uint,
    pub atomic_write_unit_max: ffi::c_uint,
    pub max_segments: ffi::c_ushort,
    pub max_integrity_segments: ffi::c_ushort,
    pub max_discard_segments: ffi::c_ushort,
    pub max_write_streams: ffi::c_ushort,
    pub write_stream_granularity: ffi::c_uint,
    pub max_open_zones: ffi::c_uint,
    pub max_active_zones: ffi::c_uint,
    pub dma_alignment: ffi::c_uint,
    pub dma_pad_mask: ffi::c_uint,
    pub integrity: blk_integrity,
}
impl Default for queue_limits {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type report_zones_cb = ::core::option::Option<
    unsafe extern "C" fn(
        zone: *mut blk_zone,
        idx: ffi::c_uint,
        data: *mut ffi::c_void,
    ) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_independent_access_range {
    pub kobj: kobject,
    pub sector: sector_t,
    pub nr_sectors: sector_t,
}
impl Default for blk_independent_access_range {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct blk_independent_access_ranges {
    pub kobj: kobject,
    pub sysfs_registered: bool_,
    pub nr_ia_ranges: ffi::c_uint,
    pub ia_range: __IncompleteArrayField<blk_independent_access_range>,
}
impl Default for blk_independent_access_ranges {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub queuedata: *mut ffi::c_void,
    pub elevator: *mut elevator_queue,
    pub mq_ops: *const blk_mq_ops,
    pub queue_ctx: *mut blk_mq_ctx,
    pub queue_flags: ffi::c_ulong,
    pub rq_timeout: ffi::c_uint,
    pub queue_depth: ffi::c_uint,
    pub refs: refcount_t,
    pub nr_hw_queues: ffi::c_uint,
    pub hctx_table: xarray,
    pub q_usage_counter: percpu_ref,
    pub io_lock_cls_key: lock_class_key,
    pub io_lockdep_map: lockdep_map,
    pub q_lock_cls_key: lock_class_key,
    pub q_lockdep_map: lockdep_map,
    pub last_merge: *mut request,
    pub queue_lock: spinlock_t,
    pub quiesce_depth: ffi::c_int,
    pub disk: *mut gendisk,
    pub mq_kobj: *mut kobject,
    pub limits: queue_limits,
    pub dev: *mut device,
    pub rpm_status: rpm_status,
    pub pm_only: atomic_t,
    pub stats: *mut blk_queue_stats,
    pub rq_qos: *mut rq_qos,
    pub rq_qos_mutex: mutex,
    pub id: ffi::c_int,
    pub nr_requests: ffi::c_ulong,
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub nr_active_requests_shared_tags: atomic_t,
    pub sched_shared_tags: *mut blk_mq_tags,
    pub icq_list: list_head,
    pub blkcg_pols: [ffi::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub blkcg_mutex: mutex,
    pub node: ffi::c_int,
    pub requeue_lock: spinlock_t,
    pub requeue_list: list_head,
    pub requeue_work: delayed_work,
    pub fq: *mut blk_flush_queue,
    pub flush_list: list_head,
    pub elevator_lock: mutex,
    pub sysfs_lock: mutex,
    pub limits_lock: mutex,
    pub unused_hctx_list: list_head,
    pub unused_hctx_lock: spinlock_t,
    pub mq_freeze_depth: ffi::c_int,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub mq_freeze_lock: mutex,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub rqos_debugfs_dir: *mut dentry,
    pub debugfs_mutex: mutex,
}
impl Default for request_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const QUEUE_FLAG_DYING: _bindgen_ty_110 = 0;
pub const QUEUE_FLAG_NOMERGES: _bindgen_ty_110 = 1;
pub const QUEUE_FLAG_SAME_COMP: _bindgen_ty_110 = 2;
pub const QUEUE_FLAG_FAIL_IO: _bindgen_ty_110 = 3;
pub const QUEUE_FLAG_NOXMERGES: _bindgen_ty_110 = 4;
pub const QUEUE_FLAG_SAME_FORCE: _bindgen_ty_110 = 5;
pub const QUEUE_FLAG_INIT_DONE: _bindgen_ty_110 = 6;
pub const QUEUE_FLAG_STATS: _bindgen_ty_110 = 7;
pub const QUEUE_FLAG_REGISTERED: _bindgen_ty_110 = 8;
pub const QUEUE_FLAG_QUIESCED: _bindgen_ty_110 = 9;
pub const QUEUE_FLAG_RQ_ALLOC_TIME: _bindgen_ty_110 = 10;
pub const QUEUE_FLAG_HCTX_ACTIVE: _bindgen_ty_110 = 11;
pub const QUEUE_FLAG_SQ_SCHED: _bindgen_ty_110 = 12;
pub const QUEUE_FLAG_DISABLE_WBT_DEF: _bindgen_ty_110 = 13;
pub const QUEUE_FLAG_NO_ELV_SWITCH: _bindgen_ty_110 = 14;
pub const QUEUE_FLAG_QOS_ENABLED: _bindgen_ty_110 = 15;
pub const QUEUE_FLAG_MAX: _bindgen_ty_110 = 16;
pub type _bindgen_ty_110 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq_list {
    pub head: *mut request,
    pub tail: *mut request,
}
impl Default for rq_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_plug {
    pub mq_list: rq_list,
    pub cached_rqs: rq_list,
    pub cur_ktime: u64_,
    pub nr_ios: ffi::c_ushort,
    pub rq_count: ffi::c_ushort,
    pub multiple_queues: bool_,
    pub has_elevator: bool_,
    pub cb_list: list_head,
}
impl Default for blk_plug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_plug_cb_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_plug_cb, arg2: bool_)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_plug_cb {
    pub list: list_head,
    pub callback: blk_plug_cb_fn,
    pub data: *mut ffi::c_void,
}
impl Default for blk_plug_cb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const blk_default_limits_BLK_MAX_SEGMENTS: blk_default_limits = 128;
pub const blk_default_limits_BLK_SAFE_MAX_SECTORS: blk_default_limits = 255;
pub const blk_default_limits_BLK_MAX_SEGMENT_SIZE: blk_default_limits = 65536;
pub const blk_default_limits_BLK_SEG_BOUNDARY_MASK: blk_default_limits = 4294967295;
pub type blk_default_limits = ffi::c_uint;

pub const blk_unique_id_BLK_UID_T10: blk_unique_id = 1;
pub const blk_unique_id_BLK_UID_EUI64: blk_unique_id = 2;
pub const blk_unique_id_BLK_UID_NAA: blk_unique_id = 3;
pub type blk_unique_id = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device_operations {
    pub submit_bio: ::core::option::Option<unsafe extern "C" fn(bio: *mut bio)>,
    pub poll_bio: ::core::option::Option<
        unsafe extern "C" fn(
            bio: *mut bio,
            iob: *mut io_comp_batch,
            flags: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, mode: blk_mode_t) -> ffi::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(disk: *mut gendisk)>,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            bdev: *mut block_device,
            mode: blk_mode_t,
            cmd: ffi::c_uint,
            arg: ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            bdev: *mut block_device,
            mode: blk_mode_t,
            cmd: ffi::c_uint,
            arg: ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, clearing: ffi::c_uint) -> ffi::c_uint,
    >,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: *mut hd_geometry) -> ffi::c_int,
    >,
    pub set_read_only: ::core::option::Option<
        unsafe extern "C" fn(bdev: *mut block_device, ro: bool_) -> ffi::c_int,
    >,
    pub free_disk: ::core::option::Option<unsafe extern "C" fn(disk: *mut gendisk)>,
    pub swap_slot_free_notify:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut block_device, arg2: ffi::c_ulong)>,
    pub report_zones: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            sector: sector_t,
            nr_zones: ffi::c_uint,
            cb: report_zones_cb,
            data: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, mode: *mut umode_t) -> *mut ffi::c_char,
    >,
    pub get_unique_id: ::core::option::Option<
        unsafe extern "C" fn(
            disk: *mut gendisk,
            id: *mut u8_,
            id_type: blk_unique_id,
        ) -> ffi::c_int,
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
    pub alternative_gpt_sector: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, sector: *mut sector_t) -> ffi::c_int,
    >,
}
impl Default for block_device_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_holder_ops {
    pub mark_dead:
        ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device, surprise: bool_)>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device)>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device) -> ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device) -> ffi::c_int>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_comp_batch {
    pub req_list: rq_list,
    pub need_ts: bool_,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_comp_batch)>,
}
impl Default for io_comp_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const rq_end_io_ret_RQ_END_IO_NONE: rq_end_io_ret = 0;
pub const rq_end_io_ret_RQ_END_IO_FREE: rq_end_io_ret = 1;
pub type rq_end_io_ret = ffi::c_uint;
pub type rq_end_io_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request, arg2: blk_status_t) -> rq_end_io_ret,
>;
pub type req_flags_t = __u32;
pub const rqf_flags___RQF_STARTED: rqf_flags = 0;
pub const rqf_flags___RQF_FLUSH_SEQ: rqf_flags = 1;
pub const rqf_flags___RQF_MIXED_MERGE: rqf_flags = 2;
pub const rqf_flags___RQF_DONTPREP: rqf_flags = 3;
pub const rqf_flags___RQF_SCHED_TAGS: rqf_flags = 4;
pub const rqf_flags___RQF_USE_SCHED: rqf_flags = 5;
pub const rqf_flags___RQF_FAILED: rqf_flags = 6;
pub const rqf_flags___RQF_QUIET: rqf_flags = 7;
pub const rqf_flags___RQF_IO_STAT: rqf_flags = 8;
pub const rqf_flags___RQF_PM: rqf_flags = 9;
pub const rqf_flags___RQF_HASHED: rqf_flags = 10;
pub const rqf_flags___RQF_STATS: rqf_flags = 11;
pub const rqf_flags___RQF_SPECIAL_PAYLOAD: rqf_flags = 12;
pub const rqf_flags___RQF_ZONE_WRITE_PLUGGING: rqf_flags = 13;
pub const rqf_flags___RQF_TIMED_OUT: rqf_flags = 14;
pub const rqf_flags___RQF_RESV: rqf_flags = 15;
pub const rqf_flags___RQF_BITS: rqf_flags = 16;
pub type rqf_flags = ffi::c_uint;
pub const mq_rq_state_MQ_RQ_IDLE: mq_rq_state = 0;
pub const mq_rq_state_MQ_RQ_IN_FLIGHT: mq_rq_state = 1;
pub const mq_rq_state_MQ_RQ_COMPLETE: mq_rq_state = 2;
pub type mq_rq_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    pub q: *mut request_queue,
    pub mq_ctx: *mut blk_mq_ctx,
    pub mq_hctx: *mut blk_mq_hw_ctx,
    pub cmd_flags: blk_opf_t,
    pub rq_flags: req_flags_t,
    pub tag: ffi::c_int,
    pub internal_tag: ffi::c_int,
    pub timeout: ffi::c_uint,
    pub __data_len: ffi::c_uint,
    pub __sector: sector_t,
    pub bio: *mut bio,
    pub biotail: *mut bio,
    pub __bindgen_anon_1: request__bindgen_ty_1,
    pub part: *mut block_device,
    pub start_time_ns: u64_,
    pub io_start_time_ns: u64_,
    pub stats_sectors: ffi::c_ushort,
    pub nr_phys_segments: ffi::c_ushort,
    pub nr_integrity_segments: ffi::c_ushort,
    pub state: mq_rq_state,
    pub ref_: atomic_t,
    pub deadline: ffi::c_ulong,
    pub __bindgen_anon_2: request__bindgen_ty_2,
    pub __bindgen_anon_3: request__bindgen_ty_3,
    pub elv: request__bindgen_ty_4,
    pub flush: request__bindgen_ty_5,
    pub fifo_time: u64_,
    pub end_io: rq_end_io_fn,
    pub end_io_data: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_1 {
    pub queuelist: list_head,
    pub rq_next: *mut request,
}
impl Default for request__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_2 {
    pub hash: hlist_node,
    pub ipi_list: llist_node,
}
impl Default for request__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_3 {
    pub rb_node: rb_node,
    pub special_vec: bio_vec,
}
impl Default for request__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request__bindgen_ty_4 {
    pub icq: *mut io_cq,
    pub priv_: [*mut ffi::c_void; 2usize],
}
impl Default for request__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct request__bindgen_ty_5 {
    pub seq: ffi::c_uint,
    pub saved_end_io: rq_end_io_fn,
}
impl Default for request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const blk_eh_timer_return_BLK_EH_DONE: blk_eh_timer_return = 0;
pub const blk_eh_timer_return_BLK_EH_RESET_TIMER: blk_eh_timer_return = 1;
pub type blk_eh_timer_return = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx {
    pub __bindgen_anon_1: blk_mq_hw_ctx__bindgen_ty_1,
    pub run_work: delayed_work,
    pub cpumask: cpumask_var_t,
    pub next_cpu: ffi::c_int,
    pub next_cpu_batch: ffi::c_int,
    pub flags: ffi::c_ulong,
    pub sched_data: *mut ffi::c_void,
    pub queue: *mut request_queue,
    pub fq: *mut blk_flush_queue,
    pub driver_data: *mut ffi::c_void,
    pub ctx_map: sbitmap,
    pub dispatch_from: *mut blk_mq_ctx,
    pub dispatch_busy: ffi::c_uint,
    pub type_: ffi::c_ushort,
    pub nr_ctx: ffi::c_ushort,
    pub ctxs: *mut *mut blk_mq_ctx,
    pub dispatch_wait_lock: spinlock_t,
    pub dispatch_wait: wait_queue_entry_t,
    pub wait_index: atomic_t,
    pub tags: *mut blk_mq_tags,
    pub sched_tags: *mut blk_mq_tags,
    pub numa_node: ffi::c_uint,
    pub queue_num: ffi::c_uint,
    pub nr_active: atomic_t,
    pub cpuhp_online: hlist_node,
    pub cpuhp_dead: hlist_node,
    pub kobj: kobject,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub hctx_list: list_head,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub dispatch: list_head,
    pub state: ffi::c_ulong,
}
impl Default for blk_mq_hw_ctx__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for blk_mq_hw_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_queue_map {
    pub mq_map: *mut ffi::c_uint,
    pub nr_queues: ffi::c_uint,
    pub queue_offset: ffi::c_uint,
}
impl Default for blk_mq_queue_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hctx_type_HCTX_TYPE_DEFAULT: hctx_type = 0;
pub const hctx_type_HCTX_TYPE_READ: hctx_type = 1;
pub const hctx_type_HCTX_TYPE_POLL: hctx_type = 2;
pub const hctx_type_HCTX_MAX_TYPES: hctx_type = 3;
pub type hctx_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tag_set {
    pub ops: *const blk_mq_ops,
    pub map: [blk_mq_queue_map; 3usize],
    pub nr_maps: ffi::c_uint,
    pub nr_hw_queues: ffi::c_uint,
    pub queue_depth: ffi::c_uint,
    pub reserved_tags: ffi::c_uint,
    pub cmd_size: ffi::c_uint,
    pub numa_node: ffi::c_int,
    pub timeout: ffi::c_uint,
    pub flags: ffi::c_uint,
    pub driver_data: *mut ffi::c_void,
    pub tags: *mut *mut blk_mq_tags,
    pub shared_tags: *mut blk_mq_tags,
    pub tag_list_lock: mutex,
    pub tag_list: list_head,
    pub srcu: *mut srcu_struct,
    pub update_nr_hwq_lock: rw_semaphore,
}
impl Default for blk_mq_tag_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_queue_data {
    pub rq: *mut request,
    pub last: bool_,
}
impl Default for blk_mq_queue_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type busy_tag_iter_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request, arg2: *mut ffi::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_ops {
    pub queue_rq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *const blk_mq_queue_data,
        ) -> blk_status_t,
    >,
    pub commit_rqs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub queue_rqs: ::core::option::Option<unsafe extern "C" fn(rqlist: *mut rq_list)>,
    pub get_budget:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> ffi::c_int>,
    pub put_budget:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: ffi::c_int)>,
    pub set_rq_budget_token:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: ffi::c_int)>,
    pub get_rq_budget_token:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> ffi::c_int>,
    pub timeout:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> blk_eh_timer_return>,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut io_comp_batch) -> ffi::c_int,
    >,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut ffi::c_void,
            arg3: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub exit_hctx:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ffi::c_uint)>,
    pub init_request: ::core::option::Option<
        unsafe extern "C" fn(
            set: *mut blk_mq_tag_set,
            arg1: *mut request,
            arg2: ffi::c_uint,
            arg3: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub exit_request: ::core::option::Option<
        unsafe extern "C" fn(set: *mut blk_mq_tag_set, arg1: *mut request, arg2: ffi::c_uint),
    >,
    pub cleanup_rq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub busy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>,
    pub map_queues: ::core::option::Option<unsafe extern "C" fn(set: *mut blk_mq_tag_set)>,
    pub show_rq: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, rq: *mut request)>,
}
pub const BLK_MQ_F_TAG_QUEUE_SHARED: _bindgen_ty_111 = 2;
pub const BLK_MQ_F_STACKING: _bindgen_ty_111 = 4;
pub const BLK_MQ_F_TAG_HCTX_SHARED: _bindgen_ty_111 = 8;
pub const BLK_MQ_F_BLOCKING: _bindgen_ty_111 = 16;
pub const BLK_MQ_F_TAG_RR: _bindgen_ty_111 = 32;
pub const BLK_MQ_F_NO_SCHED_BY_DEFAULT: _bindgen_ty_111 = 64;
pub const BLK_MQ_F_MAX: _bindgen_ty_111 = 128;
pub type _bindgen_ty_111 = ffi::c_uint;
pub const BLK_MQ_S_STOPPED: _bindgen_ty_112 = 0;
pub const BLK_MQ_S_TAG_ACTIVE: _bindgen_ty_112 = 1;
pub const BLK_MQ_S_SCHED_RESTART: _bindgen_ty_112 = 2;
pub const BLK_MQ_S_INACTIVE: _bindgen_ty_112 = 3;
pub const BLK_MQ_S_MAX: _bindgen_ty_112 = 4;
pub type _bindgen_ty_112 = ffi::c_uint;

pub const BLK_MQ_REQ_NOWAIT: _bindgen_ty_113 = 1;
pub const BLK_MQ_REQ_RESERVED: _bindgen_ty_113 = 2;
pub const BLK_MQ_REQ_PM: _bindgen_ty_113 = 4;
pub type _bindgen_ty_113 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tags {
    pub nr_tags: ffi::c_uint,
    pub nr_reserved_tags: ffi::c_uint,
    pub active_queues: ffi::c_uint,
    pub bitmap_tags: sbitmap_queue,
    pub breserved_tags: sbitmap_queue,
    pub rqs: *mut *mut request,
    pub static_rqs: *mut *mut request,
    pub page_list: list_head,
    pub lock: spinlock_t,
}
impl Default for blk_mq_tags {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BLK_MQ_UNIQUE_TAG_BITS: _bindgen_ty_114 = 16;
pub const BLK_MQ_UNIQUE_TAG_MASK: _bindgen_ty_114 = 65535;
pub type _bindgen_ty_114 = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq_map_data {
    pub pages: *mut *mut page,
    pub offset: ffi::c_ulong,
    pub page_order: ffi::c_ushort,
    pub nr_entries: ffi::c_ushort,
    pub null_mapped: bool_,
    pub from_user: bool_,
}
impl Default for rq_map_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct req_iterator {
    pub iter: bvec_iter,
    pub bio: *mut bio,
}
impl Default for req_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_notifier {
    pub clk: *mut clk,
    pub notifier_head: srcu_notifier_head,
    pub node: list_head,
}
impl Default for clk_notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_notifier_data {
    pub clk: *mut clk,
    pub old_rate: ffi::c_ulong,
    pub new_rate: ffi::c_ulong,
}
impl Default for clk_notifier_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_bulk_data {
    pub id: *const ffi::c_char,
    pub clk: *mut clk,
}
impl Default for clk_bulk_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct config_item {
    pub ci_name: *mut ffi::c_char,
    pub ci_namebuf: [ffi::c_char; 20usize],
    pub ci_kref: kref,
    pub ci_entry: list_head,
    pub ci_parent: *mut config_item,
    pub ci_group: *mut config_group,
    pub ci_type: *const config_item_type,
    pub ci_dentry: *mut dentry,
}
impl Default for config_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct config_item_type {
    pub ct_owner: *mut module,
    pub ct_item_ops: *mut configfs_item_operations,
    pub ct_group_ops: *mut configfs_group_operations,
    pub ct_attrs: *mut *mut configfs_attribute,
    pub ct_bin_attrs: *mut *mut configfs_bin_attribute,
}
impl Default for config_item_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct config_group {
    pub cg_item: config_item,
    pub cg_children: list_head,
    pub cg_subsys: *mut configfs_subsystem,
    pub default_groups: list_head,
    pub group_entry: list_head,
}
impl Default for config_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct configfs_attribute {
    pub ca_name: *const ffi::c_char,
    pub ca_owner: *mut module,
    pub ca_mode: umode_t,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut config_item, arg2: *mut ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut config_item,
            arg2: *const ffi::c_char,
            arg3: usize,
        ) -> isize,
    >,
}
impl Default for configfs_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct configfs_bin_attribute {
    pub cb_attr: configfs_attribute,
    pub cb_private: *mut ffi::c_void,
    pub cb_max_size: usize,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut config_item, arg2: *mut ffi::c_void, arg3: usize) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut config_item,
            arg2: *const ffi::c_void,
            arg3: usize,
        ) -> isize,
    >,
}
impl Default for configfs_bin_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct configfs_item_operations {
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut config_item)>,
    pub allow_link: ::core::option::Option<
        unsafe extern "C" fn(src: *mut config_item, target: *mut config_item) -> ffi::c_int,
    >,
    pub drop_link: ::core::option::Option<
        unsafe extern "C" fn(src: *mut config_item, target: *mut config_item),
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct configfs_group_operations {
    pub make_item: ::core::option::Option<
        unsafe extern "C" fn(
            group: *mut config_group,
            name: *const ffi::c_char,
        ) -> *mut config_item,
    >,
    pub make_group: ::core::option::Option<
        unsafe extern "C" fn(
            group: *mut config_group,
            name: *const ffi::c_char,
        ) -> *mut config_group,
    >,
    pub disconnect_notify: ::core::option::Option<
        unsafe extern "C" fn(group: *mut config_group, item: *mut config_item),
    >,
    pub drop_item: ::core::option::Option<
        unsafe extern "C" fn(group: *mut config_group, item: *mut config_item),
    >,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            item: *mut config_item,
            attr: *mut configfs_attribute,
            n: ffi::c_int,
        ) -> bool_,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            item: *mut config_item,
            attr: *mut configfs_bin_attribute,
            n: ffi::c_int,
        ) -> bool_,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct configfs_subsystem {
    pub su_group: config_group,
    pub su_mutex: mutex,
}
impl Default for configfs_subsystem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const cpuhp_state_CPUHP_INVALID: cpuhp_state = -1;
pub const cpuhp_state_CPUHP_OFFLINE: cpuhp_state = 0;
pub const cpuhp_state_CPUHP_CREATE_THREADS: cpuhp_state = 1;
pub const cpuhp_state_CPUHP_PERF_X86_PREPARE: cpuhp_state = 2;
pub const cpuhp_state_CPUHP_PERF_X86_AMD_UNCORE_PREP: cpuhp_state = 3;
pub const cpuhp_state_CPUHP_PERF_POWER: cpuhp_state = 4;
pub const cpuhp_state_CPUHP_PERF_SUPERH: cpuhp_state = 5;
pub const cpuhp_state_CPUHP_X86_HPET_DEAD: cpuhp_state = 6;
pub const cpuhp_state_CPUHP_X86_MCE_DEAD: cpuhp_state = 7;
pub const cpuhp_state_CPUHP_VIRT_NET_DEAD: cpuhp_state = 8;
pub const cpuhp_state_CPUHP_IBMVNIC_DEAD: cpuhp_state = 9;
pub const cpuhp_state_CPUHP_SLUB_DEAD: cpuhp_state = 10;
pub const cpuhp_state_CPUHP_DEBUG_OBJ_DEAD: cpuhp_state = 11;
pub const cpuhp_state_CPUHP_MM_WRITEBACK_DEAD: cpuhp_state = 12;
pub const cpuhp_state_CPUHP_MM_VMSTAT_DEAD: cpuhp_state = 13;
pub const cpuhp_state_CPUHP_SOFTIRQ_DEAD: cpuhp_state = 14;
pub const cpuhp_state_CPUHP_NET_MVNETA_DEAD: cpuhp_state = 15;
pub const cpuhp_state_CPUHP_CPUIDLE_DEAD: cpuhp_state = 16;
pub const cpuhp_state_CPUHP_ARM64_FPSIMD_DEAD: cpuhp_state = 17;
pub const cpuhp_state_CPUHP_ARM_OMAP_WAKE_DEAD: cpuhp_state = 18;
pub const cpuhp_state_CPUHP_IRQ_POLL_DEAD: cpuhp_state = 19;
pub const cpuhp_state_CPUHP_BLOCK_SOFTIRQ_DEAD: cpuhp_state = 20;
pub const cpuhp_state_CPUHP_BIO_DEAD: cpuhp_state = 21;
pub const cpuhp_state_CPUHP_ACPI_CPUDRV_DEAD: cpuhp_state = 22;
pub const cpuhp_state_CPUHP_S390_PFAULT_DEAD: cpuhp_state = 23;
pub const cpuhp_state_CPUHP_BLK_MQ_DEAD: cpuhp_state = 24;
pub const cpuhp_state_CPUHP_FS_BUFF_DEAD: cpuhp_state = 25;
pub const cpuhp_state_CPUHP_PRINTK_DEAD: cpuhp_state = 26;
pub const cpuhp_state_CPUHP_MM_MEMCQ_DEAD: cpuhp_state = 27;
pub const cpuhp_state_CPUHP_PERCPU_CNT_DEAD: cpuhp_state = 28;
pub const cpuhp_state_CPUHP_RADIX_DEAD: cpuhp_state = 29;
pub const cpuhp_state_CPUHP_PAGE_ALLOC: cpuhp_state = 30;
pub const cpuhp_state_CPUHP_NET_DEV_DEAD: cpuhp_state = 31;
pub const cpuhp_state_CPUHP_IOMMU_IOVA_DEAD: cpuhp_state = 32;
pub const cpuhp_state_CPUHP_AP_ARM_CACHE_B15_RAC_DEAD: cpuhp_state = 33;
pub const cpuhp_state_CPUHP_PADATA_DEAD: cpuhp_state = 34;
pub const cpuhp_state_CPUHP_AP_DTPM_CPU_DEAD: cpuhp_state = 35;
pub const cpuhp_state_CPUHP_RANDOM_PREPARE: cpuhp_state = 36;
pub const cpuhp_state_CPUHP_WORKQUEUE_PREP: cpuhp_state = 37;
pub const cpuhp_state_CPUHP_POWER_NUMA_PREPARE: cpuhp_state = 38;
pub const cpuhp_state_CPUHP_HRTIMERS_PREPARE: cpuhp_state = 39;
pub const cpuhp_state_CPUHP_X2APIC_PREPARE: cpuhp_state = 40;
pub const cpuhp_state_CPUHP_SMPCFD_PREPARE: cpuhp_state = 41;
pub const cpuhp_state_CPUHP_RELAY_PREPARE: cpuhp_state = 42;
pub const cpuhp_state_CPUHP_MD_RAID5_PREPARE: cpuhp_state = 43;
pub const cpuhp_state_CPUHP_RCUTREE_PREP: cpuhp_state = 44;
pub const cpuhp_state_CPUHP_CPUIDLE_COUPLED_PREPARE: cpuhp_state = 45;
pub const cpuhp_state_CPUHP_POWERPC_PMAC_PREPARE: cpuhp_state = 46;
pub const cpuhp_state_CPUHP_POWERPC_MMU_CTX_PREPARE: cpuhp_state = 47;
pub const cpuhp_state_CPUHP_XEN_PREPARE: cpuhp_state = 48;
pub const cpuhp_state_CPUHP_XEN_EVTCHN_PREPARE: cpuhp_state = 49;
pub const cpuhp_state_CPUHP_ARM_SHMOBILE_SCU_PREPARE: cpuhp_state = 50;
pub const cpuhp_state_CPUHP_SH_SH3X_PREPARE: cpuhp_state = 51;
pub const cpuhp_state_CPUHP_TOPOLOGY_PREPARE: cpuhp_state = 52;
pub const cpuhp_state_CPUHP_NET_IUCV_PREPARE: cpuhp_state = 53;
pub const cpuhp_state_CPUHP_ARM_BL_PREPARE: cpuhp_state = 54;
pub const cpuhp_state_CPUHP_TRACE_RB_PREPARE: cpuhp_state = 55;
pub const cpuhp_state_CPUHP_MM_ZSWP_POOL_PREPARE: cpuhp_state = 56;
pub const cpuhp_state_CPUHP_KVM_PPC_BOOK3S_PREPARE: cpuhp_state = 57;
pub const cpuhp_state_CPUHP_ZCOMP_PREPARE: cpuhp_state = 58;
pub const cpuhp_state_CPUHP_TIMERS_PREPARE: cpuhp_state = 59;
pub const cpuhp_state_CPUHP_TMIGR_PREPARE: cpuhp_state = 60;
pub const cpuhp_state_CPUHP_MIPS_SOC_PREPARE: cpuhp_state = 61;
pub const cpuhp_state_CPUHP_BP_PREPARE_DYN: cpuhp_state = 62;
pub const cpuhp_state_CPUHP_BP_PREPARE_DYN_END: cpuhp_state = 82;
pub const cpuhp_state_CPUHP_BP_KICK_AP: cpuhp_state = 83;
pub const cpuhp_state_CPUHP_BRINGUP_CPU: cpuhp_state = 84;
pub const cpuhp_state_CPUHP_AP_IDLE_DEAD: cpuhp_state = 85;
pub const cpuhp_state_CPUHP_AP_OFFLINE: cpuhp_state = 86;
pub const cpuhp_state_CPUHP_AP_CACHECTRL_STARTING: cpuhp_state = 87;
pub const cpuhp_state_CPUHP_AP_SCHED_STARTING: cpuhp_state = 88;
pub const cpuhp_state_CPUHP_AP_RCUTREE_DYING: cpuhp_state = 89;
pub const cpuhp_state_CPUHP_AP_CPU_PM_STARTING: cpuhp_state = 90;
pub const cpuhp_state_CPUHP_AP_IRQ_GIC_STARTING: cpuhp_state = 91;
pub const cpuhp_state_CPUHP_AP_IRQ_HIP04_STARTING: cpuhp_state = 92;
pub const cpuhp_state_CPUHP_AP_IRQ_APPLE_AIC_STARTING: cpuhp_state = 93;
pub const cpuhp_state_CPUHP_AP_IRQ_ARMADA_XP_STARTING: cpuhp_state = 94;
pub const cpuhp_state_CPUHP_AP_IRQ_BCM2836_STARTING: cpuhp_state = 95;
pub const cpuhp_state_CPUHP_AP_IRQ_MIPS_GIC_STARTING: cpuhp_state = 96;
pub const cpuhp_state_CPUHP_AP_IRQ_EIOINTC_STARTING: cpuhp_state = 97;
pub const cpuhp_state_CPUHP_AP_IRQ_AVECINTC_STARTING: cpuhp_state = 98;
pub const cpuhp_state_CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING: cpuhp_state = 99;
pub const cpuhp_state_CPUHP_AP_IRQ_ACLINT_SSWI_STARTING: cpuhp_state = 100;
pub const cpuhp_state_CPUHP_AP_IRQ_RISCV_IMSIC_STARTING: cpuhp_state = 101;
pub const cpuhp_state_CPUHP_AP_IRQ_RISCV_SBI_IPI_STARTING: cpuhp_state = 102;
pub const cpuhp_state_CPUHP_AP_ARM_MVEBU_COHERENCY: cpuhp_state = 103;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING: cpuhp_state = 104;
pub const cpuhp_state_CPUHP_AP_PERF_X86_STARTING: cpuhp_state = 105;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_IBS_STARTING: cpuhp_state = 106;
pub const cpuhp_state_CPUHP_AP_PERF_XTENSA_STARTING: cpuhp_state = 107;
pub const cpuhp_state_CPUHP_AP_ARM_VFP_STARTING: cpuhp_state = 108;
pub const cpuhp_state_CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING: cpuhp_state = 109;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING: cpuhp_state = 110;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_ACPI_STARTING: cpuhp_state = 111;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_STARTING: cpuhp_state = 112;
pub const cpuhp_state_CPUHP_AP_PERF_RISCV_STARTING: cpuhp_state = 113;
pub const cpuhp_state_CPUHP_AP_ARM_L2X0_STARTING: cpuhp_state = 114;
pub const cpuhp_state_CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING: cpuhp_state = 115;
pub const cpuhp_state_CPUHP_AP_ARM_ARCH_TIMER_STARTING: cpuhp_state = 116;
pub const cpuhp_state_CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING: cpuhp_state = 117;
pub const cpuhp_state_CPUHP_AP_ARM_GLOBAL_TIMER_STARTING: cpuhp_state = 118;
pub const cpuhp_state_CPUHP_AP_JCORE_TIMER_STARTING: cpuhp_state = 119;
pub const cpuhp_state_CPUHP_AP_ARM_TWD_STARTING: cpuhp_state = 120;
pub const cpuhp_state_CPUHP_AP_QCOM_TIMER_STARTING: cpuhp_state = 121;
pub const cpuhp_state_CPUHP_AP_TEGRA_TIMER_STARTING: cpuhp_state = 122;
pub const cpuhp_state_CPUHP_AP_ARMADA_TIMER_STARTING: cpuhp_state = 123;
pub const cpuhp_state_CPUHP_AP_LOONGARCH_ARCH_TIMER_STARTING: cpuhp_state = 124;
pub const cpuhp_state_CPUHP_AP_MIPS_GIC_TIMER_STARTING: cpuhp_state = 125;
pub const cpuhp_state_CPUHP_AP_ARC_TIMER_STARTING: cpuhp_state = 126;
pub const cpuhp_state_CPUHP_AP_REALTEK_TIMER_STARTING: cpuhp_state = 127;
pub const cpuhp_state_CPUHP_AP_RISCV_TIMER_STARTING: cpuhp_state = 128;
pub const cpuhp_state_CPUHP_AP_CLINT_TIMER_STARTING: cpuhp_state = 129;
pub const cpuhp_state_CPUHP_AP_CSKY_TIMER_STARTING: cpuhp_state = 130;
pub const cpuhp_state_CPUHP_AP_TI_GP_TIMER_STARTING: cpuhp_state = 131;
pub const cpuhp_state_CPUHP_AP_HYPERV_TIMER_STARTING: cpuhp_state = 132;
pub const cpuhp_state_CPUHP_AP_DUMMY_TIMER_STARTING: cpuhp_state = 133;
pub const cpuhp_state_CPUHP_AP_ARM_XEN_STARTING: cpuhp_state = 134;
pub const cpuhp_state_CPUHP_AP_ARM_XEN_RUNSTATE_STARTING: cpuhp_state = 135;
pub const cpuhp_state_CPUHP_AP_ARM_CORESIGHT_STARTING: cpuhp_state = 136;
pub const cpuhp_state_CPUHP_AP_ARM_CORESIGHT_CTI_STARTING: cpuhp_state = 137;
pub const cpuhp_state_CPUHP_AP_ARM64_ISNDEP_STARTING: cpuhp_state = 138;
pub const cpuhp_state_CPUHP_AP_SMPCFD_DYING: cpuhp_state = 139;
pub const cpuhp_state_CPUHP_AP_HRTIMERS_DYING: cpuhp_state = 140;
pub const cpuhp_state_CPUHP_AP_TICK_DYING: cpuhp_state = 141;
pub const cpuhp_state_CPUHP_AP_X86_TBOOT_DYING: cpuhp_state = 142;
pub const cpuhp_state_CPUHP_AP_ARM_CACHE_B15_RAC_DYING: cpuhp_state = 143;
pub const cpuhp_state_CPUHP_AP_ONLINE: cpuhp_state = 144;
pub const cpuhp_state_CPUHP_TEARDOWN_CPU: cpuhp_state = 145;
pub const cpuhp_state_CPUHP_AP_ONLINE_IDLE: cpuhp_state = 146;
pub const cpuhp_state_CPUHP_AP_HYPERV_ONLINE: cpuhp_state = 147;
pub const cpuhp_state_CPUHP_AP_KVM_ONLINE: cpuhp_state = 148;
pub const cpuhp_state_CPUHP_AP_SCHED_WAIT_EMPTY: cpuhp_state = 149;
pub const cpuhp_state_CPUHP_AP_SMPBOOT_THREADS: cpuhp_state = 150;
pub const cpuhp_state_CPUHP_AP_IRQ_AFFINITY_ONLINE: cpuhp_state = 151;
pub const cpuhp_state_CPUHP_AP_BLK_MQ_ONLINE: cpuhp_state = 152;
pub const cpuhp_state_CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS: cpuhp_state = 153;
pub const cpuhp_state_CPUHP_AP_X86_INTEL_EPB_ONLINE: cpuhp_state = 154;
pub const cpuhp_state_CPUHP_AP_PERF_ONLINE: cpuhp_state = 155;
pub const cpuhp_state_CPUHP_AP_PERF_X86_ONLINE: cpuhp_state = 156;
pub const cpuhp_state_CPUHP_AP_PERF_X86_UNCORE_ONLINE: cpuhp_state = 157;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE: cpuhp_state = 158;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_POWER_ONLINE: cpuhp_state = 159;
pub const cpuhp_state_CPUHP_AP_PERF_S390_CF_ONLINE: cpuhp_state = 160;
pub const cpuhp_state_CPUHP_AP_PERF_S390_SF_ONLINE: cpuhp_state = 161;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CCI_ONLINE: cpuhp_state = 162;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CCN_ONLINE: cpuhp_state = 163;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE: cpuhp_state = 164;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE: cpuhp_state = 165;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE: cpuhp_state = 166;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_L3_ONLINE: cpuhp_state = 167;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_PA_ONLINE: cpuhp_state = 168;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE: cpuhp_state = 169;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE: cpuhp_state = 170;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE: cpuhp_state = 171;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_L2X0_ONLINE: cpuhp_state = 172;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE: cpuhp_state = 173;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE: cpuhp_state = 174;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE: cpuhp_state = 175;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE: cpuhp_state = 176;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE: cpuhp_state = 177;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_MRVL_PEM_ONLINE: cpuhp_state = 178;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE: cpuhp_state = 179;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE: cpuhp_state = 180;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE: cpuhp_state = 181;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE: cpuhp_state = 182;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE: cpuhp_state = 183;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE: cpuhp_state = 184;
pub const cpuhp_state_CPUHP_AP_PERF_CSKY_ONLINE: cpuhp_state = 185;
pub const cpuhp_state_CPUHP_AP_TMIGR_ONLINE: cpuhp_state = 186;
pub const cpuhp_state_CPUHP_AP_WATCHDOG_ONLINE: cpuhp_state = 187;
pub const cpuhp_state_CPUHP_AP_WORKQUEUE_ONLINE: cpuhp_state = 188;
pub const cpuhp_state_CPUHP_AP_RANDOM_ONLINE: cpuhp_state = 189;
pub const cpuhp_state_CPUHP_AP_RCUTREE_ONLINE: cpuhp_state = 190;
pub const cpuhp_state_CPUHP_AP_KTHREADS_ONLINE: cpuhp_state = 191;
pub const cpuhp_state_CPUHP_AP_BASE_CACHEINFO_ONLINE: cpuhp_state = 192;
pub const cpuhp_state_CPUHP_AP_ONLINE_DYN: cpuhp_state = 193;
pub const cpuhp_state_CPUHP_AP_ONLINE_DYN_END: cpuhp_state = 233;
pub const cpuhp_state_CPUHP_AP_X86_HPET_ONLINE: cpuhp_state = 234;
pub const cpuhp_state_CPUHP_AP_X86_KVM_CLK_ONLINE: cpuhp_state = 235;
pub const cpuhp_state_CPUHP_AP_ACTIVE: cpuhp_state = 236;
pub const cpuhp_state_CPUHP_ONLINE: cpuhp_state = 237;
pub type cpuhp_state = ffi::c_int;

pub const cpuhp_smt_control_CPU_SMT_ENABLED: cpuhp_smt_control = 0;
pub const cpuhp_smt_control_CPU_SMT_DISABLED: cpuhp_smt_control = 1;
pub const cpuhp_smt_control_CPU_SMT_FORCE_DISABLED: cpuhp_smt_control = 2;
pub const cpuhp_smt_control_CPU_SMT_NOT_SUPPORTED: cpuhp_smt_control = 3;
pub const cpuhp_smt_control_CPU_SMT_NOT_IMPLEMENTED: cpuhp_smt_control = 4;
pub type cpuhp_smt_control = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu {
    pub node_id: ffi::c_int,
    pub hotpluggable: ffi::c_int,
    pub dev: device,
}
impl Default for cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const cpu_attack_vectors_CPU_MITIGATE_USER_KERNEL: cpu_attack_vectors = 0;
pub const cpu_attack_vectors_CPU_MITIGATE_USER_USER: cpu_attack_vectors = 1;
pub const cpu_attack_vectors_CPU_MITIGATE_GUEST_HOST: cpu_attack_vectors = 2;
pub const cpu_attack_vectors_CPU_MITIGATE_GUEST_GUEST: cpu_attack_vectors = 3;
pub const cpu_attack_vectors_NR_CPU_ATTACK_VECTORS: cpu_attack_vectors = 4;
pub type cpu_attack_vectors = ffi::c_uint;
pub const smt_mitigations_SMT_MITIGATIONS_OFF: smt_mitigations = 0;
pub const smt_mitigations_SMT_MITIGATIONS_AUTO: smt_mitigations = 1;
pub const smt_mitigations_SMT_MITIGATIONS_ON: smt_mitigations = 2;
pub type smt_mitigations = ffi::c_uint;

pub type phandle = u32_;
pub type ihandle = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct property {
    pub name: *mut ffi::c_char,
    pub length: ffi::c_int,
    pub value: *mut ffi::c_void,
    pub next: *mut property,
    pub attr: bin_attribute,
}
impl Default for property {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_node {
    pub name: *const ffi::c_char,
    pub phandle: phandle,
    pub full_name: *const ffi::c_char,
    pub fwnode: fwnode_handle,
    pub properties: *mut property,
    pub deadprops: *mut property,
    pub parent: *mut device_node,
    pub child: *mut device_node,
    pub sibling: *mut device_node,
    pub kobj: kobject,
    pub _flags: ffi::c_ulong,
    pub data: *mut ffi::c_void,
}
impl Default for device_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_phandle_args {
    pub np: *mut device_node,
    pub args_count: ffi::c_int,
    pub args: [u32; 16usize],
}
impl Default for of_phandle_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_phandle_iterator {
    pub cells_name: *const ffi::c_char,
    pub cell_count: ffi::c_int,
    pub parent: *const device_node,
    pub list_end: *const __be32,
    pub phandle_end: *const __be32,
    pub cur: *const __be32,
    pub cur_count: u32,
    pub phandle: phandle,
    pub node: *mut device_node,
}
impl Default for of_phandle_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_reconfig_data {
    pub dn: *mut device_node,
    pub prop: *mut property,
    pub old_prop: *mut property,
}
impl Default for of_reconfig_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct kimage {
    _unused: [u8; 0],
}

pub type of_init_fn_2 = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut device_node, arg2: *mut device_node) -> ffi::c_int,
>;
pub type of_init_fn_1_ret =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut device_node) -> ffi::c_int>;
pub type of_init_fn_1 = ::core::option::Option<unsafe extern "C" fn(arg1: *mut device_node)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_changeset_entry {
    pub node: list_head,
    pub action: ffi::c_ulong,
    pub np: *mut device_node,
    pub prop: *mut property,
    pub old_prop: *mut property,
}
impl Default for of_changeset_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_changeset {
    pub entries: list_head,
}
impl Default for of_changeset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const of_reconfig_change_OF_RECONFIG_NO_CHANGE: of_reconfig_change = 0;
pub const of_reconfig_change_OF_RECONFIG_CHANGE_ADD: of_reconfig_change = 1;
pub const of_reconfig_change_OF_RECONFIG_CHANGE_REMOVE: of_reconfig_change = 2;
pub type of_reconfig_change = ffi::c_uint;
pub const of_overlay_notify_action_OF_OVERLAY_INIT: of_overlay_notify_action = 0;
pub const of_overlay_notify_action_OF_OVERLAY_PRE_APPLY: of_overlay_notify_action = 1;
pub const of_overlay_notify_action_OF_OVERLAY_POST_APPLY: of_overlay_notify_action = 2;
pub const of_overlay_notify_action_OF_OVERLAY_PRE_REMOVE: of_overlay_notify_action = 3;
pub const of_overlay_notify_action_OF_OVERLAY_POST_REMOVE: of_overlay_notify_action = 4;
pub type of_overlay_notify_action = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_overlay_notify_data {
    pub overlay: *mut device_node,
    pub target: *mut device_node,
}
impl Default for of_overlay_notify_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_opp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opp_table {
    _unused: [u8; 0],
}
pub const dev_pm_opp_event_OPP_EVENT_ADD: dev_pm_opp_event = 0;
pub const dev_pm_opp_event_OPP_EVENT_REMOVE: dev_pm_opp_event = 1;
pub const dev_pm_opp_event_OPP_EVENT_ENABLE: dev_pm_opp_event = 2;
pub const dev_pm_opp_event_OPP_EVENT_DISABLE: dev_pm_opp_event = 3;
pub const dev_pm_opp_event_OPP_EVENT_ADJUST_VOLTAGE: dev_pm_opp_event = 4;
pub type dev_pm_opp_event = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_opp_supply {
    pub u_volt: ffi::c_ulong,
    pub u_volt_min: ffi::c_ulong,
    pub u_volt_max: ffi::c_ulong,
    pub u_amp: ffi::c_ulong,
    pub u_watt: ffi::c_ulong,
}
pub type config_regulators_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut device,
        old_opp: *mut dev_pm_opp,
        new_opp: *mut dev_pm_opp,
        regulators: *mut *mut regulator,
        count: ffi::c_uint,
    ) -> ffi::c_int,
>;
pub type config_clks_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut device,
        opp_table: *mut opp_table,
        opp: *mut dev_pm_opp,
        data: *mut ffi::c_void,
        scaling_down: bool_,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_opp_config {
    pub clk_names: *const *const ffi::c_char,
    pub config_clks: config_clks_t,
    pub prop_name: *const ffi::c_char,
    pub config_regulators: config_regulators_t,
    pub supported_hw: *const ffi::c_uint,
    pub supported_hw_count: ffi::c_uint,
    pub regulator_names: *const *const ffi::c_char,
    pub required_dev: *mut device,
    pub required_dev_index: ffi::c_uint,
}
impl Default for dev_pm_opp_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_opp_data {
    pub turbo: bool_,
    pub level: ffi::c_uint,
    pub freq: ffi::c_ulong,
    pub u_volt: ffi::c_ulong,
}

pub const pm_qos_flags_status_PM_QOS_FLAGS_UNDEFINED: pm_qos_flags_status = -1;
pub const pm_qos_flags_status_PM_QOS_FLAGS_NONE: pm_qos_flags_status = 0;
pub const pm_qos_flags_status_PM_QOS_FLAGS_SOME: pm_qos_flags_status = 1;
pub const pm_qos_flags_status_PM_QOS_FLAGS_ALL: pm_qos_flags_status = 2;
pub type pm_qos_flags_status = ffi::c_int;
pub const pm_qos_type_PM_QOS_UNITIALIZED: pm_qos_type = 0;
pub const pm_qos_type_PM_QOS_MAX: pm_qos_type = 1;
pub const pm_qos_type_PM_QOS_MIN: pm_qos_type = 2;
pub type pm_qos_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_qos_constraints {
    pub list: plist_head,
    pub target_value: s32,
    pub default_value: s32,
    pub no_constraint_value: s32,
    pub type_: pm_qos_type,
    pub notifiers: *mut blocking_notifier_head,
}
impl Default for pm_qos_constraints {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_qos_request {
    pub node: plist_node,
    pub qos: *mut pm_qos_constraints,
}
impl Default for pm_qos_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_qos_flags_request {
    pub node: list_head,
    pub flags: s32,
}
impl Default for pm_qos_flags_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_qos_flags {
    pub list: list_head,
    pub effective_flags: s32,
}
impl Default for pm_qos_flags {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const freq_qos_req_type_FREQ_QOS_MIN: freq_qos_req_type = 1;
pub const freq_qos_req_type_FREQ_QOS_MAX: freq_qos_req_type = 2;
pub type freq_qos_req_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct freq_constraints {
    pub min_freq: pm_qos_constraints,
    pub min_freq_notifiers: blocking_notifier_head,
    pub max_freq: pm_qos_constraints,
    pub max_freq_notifiers: blocking_notifier_head,
}
impl Default for freq_constraints {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct freq_qos_request {
    pub type_: freq_qos_req_type,
    pub pnode: plist_node,
    pub qos: *mut freq_constraints,
}
impl Default for freq_qos_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const dev_pm_qos_req_type_DEV_PM_QOS_RESUME_LATENCY: dev_pm_qos_req_type = 1;
pub const dev_pm_qos_req_type_DEV_PM_QOS_LATENCY_TOLERANCE: dev_pm_qos_req_type = 2;
pub const dev_pm_qos_req_type_DEV_PM_QOS_MIN_FREQUENCY: dev_pm_qos_req_type = 3;
pub const dev_pm_qos_req_type_DEV_PM_QOS_MAX_FREQUENCY: dev_pm_qos_req_type = 4;
pub const dev_pm_qos_req_type_DEV_PM_QOS_FLAGS: dev_pm_qos_req_type = 5;
pub type dev_pm_qos_req_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos_request {
    pub type_: dev_pm_qos_req_type,
    pub data: dev_pm_qos_request__bindgen_ty_1,
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dev_pm_qos_request__bindgen_ty_1 {
    pub pnode: plist_node,
    pub flr: pm_qos_flags_request,
    pub freq: freq_qos_request,
}
impl Default for dev_pm_qos_request__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dev_pm_qos_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos {
    pub resume_latency: pm_qos_constraints,
    pub latency_tolerance: pm_qos_constraints,
    pub freq: freq_constraints,
    pub flags: pm_qos_flags,
    pub resume_latency_req: *mut dev_pm_qos_request,
    pub latency_tolerance_req: *mut dev_pm_qos_request,
    pub flags_req: *mut dev_pm_qos_request,
}
impl Default for dev_pm_qos {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pm_qos_req_action_PM_QOS_ADD_REQ: pm_qos_req_action = 0;
pub const pm_qos_req_action_PM_QOS_UPDATE_REQ: pm_qos_req_action = 1;
pub const pm_qos_req_action_PM_QOS_REMOVE_REQ: pm_qos_req_action = 2;
pub type pm_qos_req_action = ffi::c_uint;

pub const cpufreq_table_sorting_CPUFREQ_TABLE_UNSORTED: cpufreq_table_sorting = 0;
pub const cpufreq_table_sorting_CPUFREQ_TABLE_SORTED_ASCENDING: cpufreq_table_sorting = 1;
pub const cpufreq_table_sorting_CPUFREQ_TABLE_SORTED_DESCENDING: cpufreq_table_sorting = 2;
pub type cpufreq_table_sorting = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpufreq_cpuinfo {
    pub max_freq: ffi::c_uint,
    pub min_freq: ffi::c_uint,
    pub transition_latency: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_policy {
    pub cpus: cpumask_var_t,
    pub related_cpus: cpumask_var_t,
    pub real_cpus: cpumask_var_t,
    pub shared_type: ffi::c_uint,
    pub cpu: ffi::c_uint,
    pub clk: *mut clk,
    pub cpuinfo: cpufreq_cpuinfo,
    pub min: ffi::c_uint,
    pub max: ffi::c_uint,
    pub cur: ffi::c_uint,
    pub suspend_freq: ffi::c_uint,
    pub policy: ffi::c_uint,
    pub last_policy: ffi::c_uint,
    pub governor: *mut cpufreq_governor,
    pub governor_data: *mut ffi::c_void,
    pub last_governor: [ffi::c_char; 16usize],
    pub update: work_struct,
    pub constraints: freq_constraints,
    pub min_freq_req: *mut freq_qos_request,
    pub max_freq_req: *mut freq_qos_request,
    pub freq_table: *mut cpufreq_frequency_table,
    pub freq_table_sorted: cpufreq_table_sorting,
    pub policy_list: list_head,
    pub kobj: kobject,
    pub kobj_unregister: completion,
    pub rwsem: rw_semaphore,
    pub fast_switch_possible: bool_,
    pub fast_switch_enabled: bool_,
    pub strict_target: bool_,
    pub efficiencies_available: bool_,
    pub transition_delay_us: ffi::c_uint,
    pub dvfs_possible_from_any_cpu: bool_,
    pub boost_enabled: bool_,
    pub boost_supported: bool_,
    pub cached_target_freq: ffi::c_uint,
    pub cached_resolved_idx: ffi::c_uint,
    pub transition_ongoing: bool_,
    pub transition_lock: spinlock_t,
    pub transition_wait: wait_queue_head_t,
    pub transition_task: *mut task_struct,
    pub stats: *mut cpufreq_stats,
    pub driver_data: *mut ffi::c_void,
    pub cdev: *mut thermal_cooling_device,
    pub nb_min: notifier_block,
    pub nb_max: notifier_block,
}
impl Default for cpufreq_policy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_cpufreq_policy_write_t = *mut cpufreq_policy;
pub const class_cpufreq_policy_write_is_conditional: bool_ = false;
pub type class_cpufreq_policy_read_t = *mut cpufreq_policy;
pub const class_cpufreq_policy_read_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_policy_data {
    pub cpuinfo: cpufreq_cpuinfo,
    pub freq_table: *mut cpufreq_frequency_table,
    pub cpu: ffi::c_uint,
    pub min: ffi::c_uint,
    pub max: ffi::c_uint,
}
impl Default for cpufreq_policy_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_freqs {
    pub policy: *mut cpufreq_policy,
    pub old: ffi::c_uint,
    pub new: ffi::c_uint,
    pub flags: u8_,
}
impl Default for cpufreq_freqs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct freq_attr {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cpufreq_policy, arg2: *mut ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpufreq_policy,
            arg2: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for freq_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_driver {
    pub name: [ffi::c_char; 16usize],
    pub flags: u16_,
    pub driver_data: *mut ffi::c_void,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub verify: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy_data) -> ffi::c_int,
    >,
    pub setpolicy:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub target: ::core::option::Option<
        unsafe extern "C" fn(
            policy: *mut cpufreq_policy,
            target_freq: ffi::c_uint,
            relation: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub target_index: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, index: ffi::c_uint) -> ffi::c_int,
    >,
    pub fast_switch: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, target_freq: ffi::c_uint) -> ffi::c_uint,
    >,
    pub adjust_perf: ::core::option::Option<
        unsafe extern "C" fn(
            cpu: ffi::c_uint,
            min_perf: ffi::c_ulong,
            target_perf: ffi::c_ulong,
            capacity: ffi::c_ulong,
        ),
    >,
    pub get_intermediate: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, index: ffi::c_uint) -> ffi::c_uint,
    >,
    pub target_intermediate: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, index: ffi::c_uint) -> ffi::c_int,
    >,
    pub get: ::core::option::Option<unsafe extern "C" fn(cpu: ffi::c_uint) -> ffi::c_uint>,
    pub update_limits: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub bios_limit: ::core::option::Option<
        unsafe extern "C" fn(cpu: ffi::c_int, limit: *mut ffi::c_uint) -> ffi::c_int,
    >,
    pub online:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub offline:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub ready: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub attr: *mut *mut freq_attr,
    pub boost_enabled: bool_,
    pub set_boost: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, state: ffi::c_int) -> ffi::c_int,
    >,
    pub register_em: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
}
impl Default for cpufreq_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_governor {
    pub name: [ffi::c_char; 16usize],
    pub init:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub start:
        ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy) -> ffi::c_int>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub limits: ::core::option::Option<unsafe extern "C" fn(policy: *mut cpufreq_policy)>,
    pub show_setspeed: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, buf: *mut ffi::c_char) -> isize,
    >,
    pub store_setspeed: ::core::option::Option<
        unsafe extern "C" fn(policy: *mut cpufreq_policy, freq: ffi::c_uint) -> ffi::c_int,
    >,
    pub governor_list: list_head,
    pub owner: *mut module,
    pub flags: u8_,
}
impl Default for cpufreq_governor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct gov_attr_set {
    pub kobj: kobject,
    pub policy_list: list_head,
    pub update_lock: mutex,
    pub usage_count: ffi::c_int,
}
impl Default for gov_attr_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct governor_attr {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(attr_set: *mut gov_attr_set, buf: *mut ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            attr_set: *mut gov_attr_set,
            buf: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for governor_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpufreq_frequency_table {
    pub flags: ffi::c_uint,
    pub driver_data: ffi::c_uint,
    pub frequency: ffi::c_uint,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct faux_device {
    pub dev: device,
}
impl Default for faux_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct faux_device_ops {
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(faux_dev: *mut faux_device) -> ffi::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(faux_dev: *mut faux_device)>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: ffi::c_ushort,
    pub sin6_port: __be16,
    pub sin6_flowinfo: __be32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_ifindex: ffi::c_int,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_flowlabel_req {
    pub flr_dst: in6_addr,
    pub flr_label: __be32,
    pub flr_action: __u8,
    pub flr_share: __u8,
    pub flr_flags: __u16,
    pub flr_expires: __u16,
    pub flr_linger: __u16,
    pub __flr_pad: __u32,
}
impl Default for in6_flowlabel_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_inet {
    pub sa_family: ffi::c_ushort,
    pub sa_data: [ffi::c_char; 26usize],
}

pub type netdev_features_t = u64_;
pub const NETIF_F_SG_BIT: _bindgen_ty_115 = 0;
pub const NETIF_F_IP_CSUM_BIT: _bindgen_ty_115 = 1;
pub const __UNUSED_NETIF_F_1: _bindgen_ty_115 = 2;
pub const NETIF_F_HW_CSUM_BIT: _bindgen_ty_115 = 3;
pub const NETIF_F_IPV6_CSUM_BIT: _bindgen_ty_115 = 4;
pub const NETIF_F_HIGHDMA_BIT: _bindgen_ty_115 = 5;
pub const NETIF_F_FRAGLIST_BIT: _bindgen_ty_115 = 6;
pub const NETIF_F_HW_VLAN_CTAG_TX_BIT: _bindgen_ty_115 = 7;
pub const NETIF_F_HW_VLAN_CTAG_RX_BIT: _bindgen_ty_115 = 8;
pub const NETIF_F_HW_VLAN_CTAG_FILTER_BIT: _bindgen_ty_115 = 9;
pub const NETIF_F_VLAN_CHALLENGED_BIT: _bindgen_ty_115 = 10;
pub const NETIF_F_GSO_BIT: _bindgen_ty_115 = 11;
pub const __UNUSED_NETIF_F_12: _bindgen_ty_115 = 12;
pub const __UNUSED_NETIF_F_13: _bindgen_ty_115 = 13;
pub const NETIF_F_GRO_BIT: _bindgen_ty_115 = 14;
pub const NETIF_F_LRO_BIT: _bindgen_ty_115 = 15;
pub const NETIF_F_GSO_SHIFT: _bindgen_ty_115 = 16;
pub const NETIF_F_TSO_BIT: _bindgen_ty_115 = 16;
pub const NETIF_F_GSO_ROBUST_BIT: _bindgen_ty_115 = 17;
pub const NETIF_F_TSO_ECN_BIT: _bindgen_ty_115 = 18;
pub const NETIF_F_TSO_MANGLEID_BIT: _bindgen_ty_115 = 19;
pub const NETIF_F_TSO6_BIT: _bindgen_ty_115 = 20;
pub const NETIF_F_FSO_BIT: _bindgen_ty_115 = 21;
pub const NETIF_F_GSO_GRE_BIT: _bindgen_ty_115 = 22;
pub const NETIF_F_GSO_GRE_CSUM_BIT: _bindgen_ty_115 = 23;
pub const NETIF_F_GSO_IPXIP4_BIT: _bindgen_ty_115 = 24;
pub const NETIF_F_GSO_IPXIP6_BIT: _bindgen_ty_115 = 25;
pub const NETIF_F_GSO_UDP_TUNNEL_BIT: _bindgen_ty_115 = 26;
pub const NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT: _bindgen_ty_115 = 27;
pub const NETIF_F_GSO_PARTIAL_BIT: _bindgen_ty_115 = 28;
pub const NETIF_F_GSO_TUNNEL_REMCSUM_BIT: _bindgen_ty_115 = 29;
pub const NETIF_F_GSO_SCTP_BIT: _bindgen_ty_115 = 30;
pub const NETIF_F_GSO_ESP_BIT: _bindgen_ty_115 = 31;
pub const NETIF_F_GSO_UDP_BIT: _bindgen_ty_115 = 32;
pub const NETIF_F_GSO_UDP_L4_BIT: _bindgen_ty_115 = 33;
pub const NETIF_F_GSO_FRAGLIST_BIT: _bindgen_ty_115 = 34;
pub const NETIF_F_GSO_ACCECN_BIT: _bindgen_ty_115 = 35;
pub const NETIF_F_GSO_LAST: _bindgen_ty_115 = 35;
pub const NETIF_F_FCOE_CRC_BIT: _bindgen_ty_115 = 36;
pub const NETIF_F_SCTP_CRC_BIT: _bindgen_ty_115 = 37;
pub const NETIF_F_NTUPLE_BIT: _bindgen_ty_115 = 38;
pub const NETIF_F_RXHASH_BIT: _bindgen_ty_115 = 39;
pub const NETIF_F_RXCSUM_BIT: _bindgen_ty_115 = 40;
pub const NETIF_F_NOCACHE_COPY_BIT: _bindgen_ty_115 = 41;
pub const NETIF_F_LOOPBACK_BIT: _bindgen_ty_115 = 42;
pub const NETIF_F_RXFCS_BIT: _bindgen_ty_115 = 43;
pub const NETIF_F_RXALL_BIT: _bindgen_ty_115 = 44;
pub const NETIF_F_HW_VLAN_STAG_TX_BIT: _bindgen_ty_115 = 45;
pub const NETIF_F_HW_VLAN_STAG_RX_BIT: _bindgen_ty_115 = 46;
pub const NETIF_F_HW_VLAN_STAG_FILTER_BIT: _bindgen_ty_115 = 47;
pub const NETIF_F_HW_L2FW_DOFFLOAD_BIT: _bindgen_ty_115 = 48;
pub const NETIF_F_HW_TC_BIT: _bindgen_ty_115 = 49;
pub const NETIF_F_HW_ESP_BIT: _bindgen_ty_115 = 50;
pub const NETIF_F_HW_ESP_TX_CSUM_BIT: _bindgen_ty_115 = 51;
pub const NETIF_F_RX_UDP_TUNNEL_PORT_BIT: _bindgen_ty_115 = 52;
pub const NETIF_F_HW_TLS_TX_BIT: _bindgen_ty_115 = 53;
pub const NETIF_F_HW_TLS_RX_BIT: _bindgen_ty_115 = 54;
pub const NETIF_F_GRO_HW_BIT: _bindgen_ty_115 = 55;
pub const NETIF_F_HW_TLS_RECORD_BIT: _bindgen_ty_115 = 56;
pub const NETIF_F_GRO_FRAGLIST_BIT: _bindgen_ty_115 = 57;
pub const NETIF_F_HW_MACSEC_BIT: _bindgen_ty_115 = 58;
pub const NETIF_F_GRO_UDP_FWD_BIT: _bindgen_ty_115 = 59;
pub const NETIF_F_HW_HSR_TAG_INS_BIT: _bindgen_ty_115 = 60;
pub const NETIF_F_HW_HSR_TAG_RM_BIT: _bindgen_ty_115 = 61;
pub const NETIF_F_HW_HSR_FWD_BIT: _bindgen_ty_115 = 62;
pub const NETIF_F_HW_HSR_DUP_BIT: _bindgen_ty_115 = 63;
pub const NETDEV_FEATURE_COUNT: _bindgen_ty_115 = 64;
pub type _bindgen_ty_115 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hsiphash_key_t {
    pub key: [ffi::c_ulong; 2usize],
}

#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [ffi::c_uchar; 6usize],
    pub h_source: [ffi::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_stats {
    pub bytes: __u64,
    pub packets: __u32,
    pub drops: __u32,
    pub overlimits: __u32,
    pub bps: __u32,
    pub pps: __u32,
    pub qlen: __u32,
    pub backlog: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_estimator {
    pub interval: ffi::c_schar,
    pub ewma_log: ffi::c_uchar,
}
pub const tc_link_layer_TC_LINKLAYER_UNAWARE: tc_link_layer = 0;
pub const tc_link_layer_TC_LINKLAYER_ETHERNET: tc_link_layer = 1;
pub const tc_link_layer_TC_LINKLAYER_ATM: tc_link_layer = 2;
pub type tc_link_layer = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_ratespec {
    pub cell_log: ffi::c_uchar,
    pub linklayer: __u8,
    pub overhead: ffi::c_ushort,
    pub cell_align: ffi::c_short,
    pub mpu: ffi::c_ushort,
    pub rate: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sizespec {
    pub cell_log: ffi::c_uchar,
    pub size_log: ffi::c_uchar,
    pub cell_align: ffi::c_short,
    pub overhead: ffi::c_int,
    pub linklayer: ffi::c_uint,
    pub mpu: ffi::c_uint,
    pub mtu: ffi::c_uint,
    pub tsize: ffi::c_uint,
}
pub const TCA_STAB_UNSPEC: _bindgen_ty_116 = 0;
pub const TCA_STAB_BASE: _bindgen_ty_116 = 1;
pub const TCA_STAB_DATA: _bindgen_ty_116 = 2;
pub const __TCA_STAB_MAX: _bindgen_ty_116 = 3;
pub type _bindgen_ty_116 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fifo_qopt {
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_skbprio_qopt {
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_prio_qopt {
    pub bands: ffi::c_int,
    pub priomap: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_multiq_qopt {
    pub bands: __u16,
    pub max_bands: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_plug_qopt {
    pub action: ffi::c_int,
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_tbf_qopt {
    pub rate: tc_ratespec,
    pub peakrate: tc_ratespec,
    pub limit: __u32,
    pub buffer: __u32,
    pub mtu: __u32,
}
pub const TCA_TBF_UNSPEC: _bindgen_ty_117 = 0;
pub const TCA_TBF_PARMS: _bindgen_ty_117 = 1;
pub const TCA_TBF_RTAB: _bindgen_ty_117 = 2;
pub const TCA_TBF_PTAB: _bindgen_ty_117 = 3;
pub const TCA_TBF_RATE64: _bindgen_ty_117 = 4;
pub const TCA_TBF_PRATE64: _bindgen_ty_117 = 5;
pub const TCA_TBF_BURST: _bindgen_ty_117 = 6;
pub const TCA_TBF_PBURST: _bindgen_ty_117 = 7;
pub const TCA_TBF_PAD: _bindgen_ty_117 = 8;
pub const __TCA_TBF_MAX: _bindgen_ty_117 = 9;
pub type _bindgen_ty_117 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_qopt {
    pub quantum: ffi::c_uint,
    pub perturb_period: ffi::c_int,
    pub limit: __u32,
    pub divisor: ffi::c_uint,
    pub flows: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfqred_stats {
    pub prob_drop: __u32,
    pub forced_drop: __u32,
    pub prob_mark: __u32,
    pub forced_mark: __u32,
    pub prob_mark_head: __u32,
    pub forced_mark_head: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_qopt_v1 {
    pub v0: tc_sfq_qopt,
    pub depth: ffi::c_uint,
    pub headdrop: ffi::c_uint,
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: ffi::c_uchar,
    pub Plog: ffi::c_uchar,
    pub Scell_log: ffi::c_uchar,
    pub flags: ffi::c_uchar,
    pub max_P: __u32,
    pub stats: tc_sfqred_stats,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_xstats {
    pub allot: __s32,
}
pub const TCA_RED_UNSPEC: _bindgen_ty_118 = 0;
pub const TCA_RED_PARMS: _bindgen_ty_118 = 1;
pub const TCA_RED_STAB: _bindgen_ty_118 = 2;
pub const TCA_RED_MAX_P: _bindgen_ty_118 = 3;
pub const TCA_RED_FLAGS: _bindgen_ty_118 = 4;
pub const TCA_RED_EARLY_DROP_BLOCK: _bindgen_ty_118 = 5;
pub const TCA_RED_MARK_BLOCK: _bindgen_ty_118 = 6;
pub const __TCA_RED_MAX: _bindgen_ty_118 = 7;
pub type _bindgen_ty_118 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_red_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: ffi::c_uchar,
    pub Plog: ffi::c_uchar,
    pub Scell_log: ffi::c_uchar,
    pub flags: ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_red_xstats {
    pub early: __u32,
    pub pdrop: __u32,
    pub other: __u32,
    pub marked: __u32,
}
pub const TCA_GRED_UNSPEC: _bindgen_ty_119 = 0;
pub const TCA_GRED_PARMS: _bindgen_ty_119 = 1;
pub const TCA_GRED_STAB: _bindgen_ty_119 = 2;
pub const TCA_GRED_DPS: _bindgen_ty_119 = 3;
pub const TCA_GRED_MAX_P: _bindgen_ty_119 = 4;
pub const TCA_GRED_LIMIT: _bindgen_ty_119 = 5;
pub const TCA_GRED_VQ_LIST: _bindgen_ty_119 = 6;
pub const __TCA_GRED_MAX: _bindgen_ty_119 = 7;
pub type _bindgen_ty_119 = ffi::c_uint;
pub const TCA_GRED_VQ_ENTRY_UNSPEC: _bindgen_ty_120 = 0;
pub const TCA_GRED_VQ_ENTRY: _bindgen_ty_120 = 1;
pub const __TCA_GRED_VQ_ENTRY_MAX: _bindgen_ty_120 = 2;
pub type _bindgen_ty_120 = ffi::c_uint;
pub const TCA_GRED_VQ_UNSPEC: _bindgen_ty_121 = 0;
pub const TCA_GRED_VQ_PAD: _bindgen_ty_121 = 1;
pub const TCA_GRED_VQ_DP: _bindgen_ty_121 = 2;
pub const TCA_GRED_VQ_STAT_BYTES: _bindgen_ty_121 = 3;
pub const TCA_GRED_VQ_STAT_PACKETS: _bindgen_ty_121 = 4;
pub const TCA_GRED_VQ_STAT_BACKLOG: _bindgen_ty_121 = 5;
pub const TCA_GRED_VQ_STAT_PROB_DROP: _bindgen_ty_121 = 6;
pub const TCA_GRED_VQ_STAT_PROB_MARK: _bindgen_ty_121 = 7;
pub const TCA_GRED_VQ_STAT_FORCED_DROP: _bindgen_ty_121 = 8;
pub const TCA_GRED_VQ_STAT_FORCED_MARK: _bindgen_ty_121 = 9;
pub const TCA_GRED_VQ_STAT_PDROP: _bindgen_ty_121 = 10;
pub const TCA_GRED_VQ_STAT_OTHER: _bindgen_ty_121 = 11;
pub const TCA_GRED_VQ_FLAGS: _bindgen_ty_121 = 12;
pub const __TCA_GRED_VQ_MAX: _bindgen_ty_121 = 13;
pub type _bindgen_ty_121 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_gred_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub DP: __u32,
    pub backlog: __u32,
    pub qave: __u32,
    pub forced: __u32,
    pub early: __u32,
    pub other: __u32,
    pub pdrop: __u32,
    pub Wlog: __u8,
    pub Plog: __u8,
    pub Scell_log: __u8,
    pub prio: __u8,
    pub packets: __u32,
    pub bytesin: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_gred_sopt {
    pub DPs: __u32,
    pub def_DP: __u32,
    pub grio: __u8,
    pub flags: __u8,
    pub pad1: __u16,
}
pub const TCA_CHOKE_UNSPEC: _bindgen_ty_122 = 0;
pub const TCA_CHOKE_PARMS: _bindgen_ty_122 = 1;
pub const TCA_CHOKE_STAB: _bindgen_ty_122 = 2;
pub const TCA_CHOKE_MAX_P: _bindgen_ty_122 = 3;
pub const __TCA_CHOKE_MAX: _bindgen_ty_122 = 4;
pub type _bindgen_ty_122 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_choke_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: ffi::c_uchar,
    pub Plog: ffi::c_uchar,
    pub Scell_log: ffi::c_uchar,
    pub flags: ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_choke_xstats {
    pub early: __u32,
    pub pdrop: __u32,
    pub other: __u32,
    pub marked: __u32,
    pub matched: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_opt {
    pub rate: tc_ratespec,
    pub ceil: tc_ratespec,
    pub buffer: __u32,
    pub cbuffer: __u32,
    pub quantum: __u32,
    pub level: __u32,
    pub prio: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_glob {
    pub version: __u32,
    pub rate2quantum: __u32,
    pub defcls: __u32,
    pub debug: __u32,
    pub direct_pkts: __u32,
}
pub const TCA_HTB_UNSPEC: _bindgen_ty_123 = 0;
pub const TCA_HTB_PARMS: _bindgen_ty_123 = 1;
pub const TCA_HTB_INIT: _bindgen_ty_123 = 2;
pub const TCA_HTB_CTAB: _bindgen_ty_123 = 3;
pub const TCA_HTB_RTAB: _bindgen_ty_123 = 4;
pub const TCA_HTB_DIRECT_QLEN: _bindgen_ty_123 = 5;
pub const TCA_HTB_RATE64: _bindgen_ty_123 = 6;
pub const TCA_HTB_CEIL64: _bindgen_ty_123 = 7;
pub const TCA_HTB_PAD: _bindgen_ty_123 = 8;
pub const TCA_HTB_OFFLOAD: _bindgen_ty_123 = 9;
pub const __TCA_HTB_MAX: _bindgen_ty_123 = 10;
pub type _bindgen_ty_123 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_xstats {
    pub lends: __u32,
    pub borrows: __u32,
    pub giants: __u32,
    pub tokens: __s32,
    pub ctokens: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hfsc_qopt {
    pub defcls: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_service_curve {
    pub m1: __u32,
    pub d: __u32,
    pub m2: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hfsc_stats {
    pub work: __u64,
    pub rtwork: __u64,
    pub period: __u32,
    pub level: __u32,
}
pub const TCA_HFSC_UNSPEC: _bindgen_ty_124 = 0;
pub const TCA_HFSC_RSC: _bindgen_ty_124 = 1;
pub const TCA_HFSC_FSC: _bindgen_ty_124 = 2;
pub const TCA_HFSC_USC: _bindgen_ty_124 = 3;
pub const __TCA_HFSC_MAX: _bindgen_ty_124 = 4;
pub type _bindgen_ty_124 = ffi::c_uint;
pub const TCA_NETEM_UNSPEC: _bindgen_ty_125 = 0;
pub const TCA_NETEM_CORR: _bindgen_ty_125 = 1;
pub const TCA_NETEM_DELAY_DIST: _bindgen_ty_125 = 2;
pub const TCA_NETEM_REORDER: _bindgen_ty_125 = 3;
pub const TCA_NETEM_CORRUPT: _bindgen_ty_125 = 4;
pub const TCA_NETEM_LOSS: _bindgen_ty_125 = 5;
pub const TCA_NETEM_RATE: _bindgen_ty_125 = 6;
pub const TCA_NETEM_ECN: _bindgen_ty_125 = 7;
pub const TCA_NETEM_RATE64: _bindgen_ty_125 = 8;
pub const TCA_NETEM_PAD: _bindgen_ty_125 = 9;
pub const TCA_NETEM_LATENCY64: _bindgen_ty_125 = 10;
pub const TCA_NETEM_JITTER64: _bindgen_ty_125 = 11;
pub const TCA_NETEM_SLOT: _bindgen_ty_125 = 12;
pub const TCA_NETEM_SLOT_DIST: _bindgen_ty_125 = 13;
pub const TCA_NETEM_PRNG_SEED: _bindgen_ty_125 = 14;
pub const __TCA_NETEM_MAX: _bindgen_ty_125 = 15;
pub type _bindgen_ty_125 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_qopt {
    pub latency: __u32,
    pub limit: __u32,
    pub loss: __u32,
    pub gap: __u32,
    pub duplicate: __u32,
    pub jitter: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_corr {
    pub delay_corr: __u32,
    pub loss_corr: __u32,
    pub dup_corr: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_reorder {
    pub probability: __u32,
    pub correlation: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_corrupt {
    pub probability: __u32,
    pub correlation: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_rate {
    pub rate: __u32,
    pub packet_overhead: __s32,
    pub cell_size: __u32,
    pub cell_overhead: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_slot {
    pub min_delay: __s64,
    pub max_delay: __s64,
    pub max_packets: __s32,
    pub max_bytes: __s32,
    pub dist_delay: __s64,
    pub dist_jitter: __s64,
}
pub const NETEM_LOSS_UNSPEC: _bindgen_ty_126 = 0;
pub const NETEM_LOSS_GI: _bindgen_ty_126 = 1;
pub const NETEM_LOSS_GE: _bindgen_ty_126 = 2;
pub const __NETEM_LOSS_MAX: _bindgen_ty_126 = 3;
pub type _bindgen_ty_126 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_gimodel {
    pub p13: __u32,
    pub p31: __u32,
    pub p32: __u32,
    pub p14: __u32,
    pub p23: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_gemodel {
    pub p: __u32,
    pub r: __u32,
    pub h: __u32,
    pub k1: __u32,
}
pub const TCA_DRR_UNSPEC: _bindgen_ty_127 = 0;
pub const TCA_DRR_QUANTUM: _bindgen_ty_127 = 1;
pub const __TCA_DRR_MAX: _bindgen_ty_127 = 2;
pub type _bindgen_ty_127 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_drr_stats {
    pub deficit: __u32,
}
pub const TC_MQPRIO_HW_OFFLOAD_NONE: _bindgen_ty_128 = 0;
pub const TC_MQPRIO_HW_OFFLOAD_TCS: _bindgen_ty_128 = 1;
pub const __TC_MQPRIO_HW_OFFLOAD_MAX: _bindgen_ty_128 = 2;
pub type _bindgen_ty_128 = ffi::c_uint;
pub const TC_MQPRIO_MODE_DCB: _bindgen_ty_129 = 0;
pub const TC_MQPRIO_MODE_CHANNEL: _bindgen_ty_129 = 1;
pub const __TC_MQPRIO_MODE_MAX: _bindgen_ty_129 = 2;
pub type _bindgen_ty_129 = ffi::c_uint;
pub const TC_MQPRIO_SHAPER_DCB: _bindgen_ty_130 = 0;
pub const TC_MQPRIO_SHAPER_BW_RATE: _bindgen_ty_130 = 1;
pub const __TC_MQPRIO_SHAPER_MAX: _bindgen_ty_130 = 2;
pub type _bindgen_ty_130 = ffi::c_uint;
pub const TC_FP_EXPRESS: _bindgen_ty_131 = 1;
pub const TC_FP_PREEMPTIBLE: _bindgen_ty_131 = 2;
pub type _bindgen_ty_131 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_mqprio_qopt {
    pub num_tc: __u8,
    pub prio_tc_map: [__u8; 16usize],
    pub hw: __u8,
    pub count: [__u16; 16usize],
    pub offset: [__u16; 16usize],
}
pub const TCA_MQPRIO_TC_ENTRY_UNSPEC: _bindgen_ty_132 = 0;
pub const TCA_MQPRIO_TC_ENTRY_INDEX: _bindgen_ty_132 = 1;
pub const TCA_MQPRIO_TC_ENTRY_FP: _bindgen_ty_132 = 2;
pub const __TCA_MQPRIO_TC_ENTRY_CNT: _bindgen_ty_132 = 3;
pub const TCA_MQPRIO_TC_ENTRY_MAX: _bindgen_ty_132 = 2;
pub type _bindgen_ty_132 = ffi::c_uint;
pub const TCA_MQPRIO_UNSPEC: _bindgen_ty_133 = 0;
pub const TCA_MQPRIO_MODE: _bindgen_ty_133 = 1;
pub const TCA_MQPRIO_SHAPER: _bindgen_ty_133 = 2;
pub const TCA_MQPRIO_MIN_RATE64: _bindgen_ty_133 = 3;
pub const TCA_MQPRIO_MAX_RATE64: _bindgen_ty_133 = 4;
pub const TCA_MQPRIO_TC_ENTRY: _bindgen_ty_133 = 5;
pub const __TCA_MQPRIO_MAX: _bindgen_ty_133 = 6;
pub type _bindgen_ty_133 = ffi::c_uint;
pub const TCA_SFB_UNSPEC: _bindgen_ty_134 = 0;
pub const TCA_SFB_PARMS: _bindgen_ty_134 = 1;
pub const __TCA_SFB_MAX: _bindgen_ty_134 = 2;
pub type _bindgen_ty_134 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfb_qopt {
    pub rehash_interval: __u32,
    pub warmup_time: __u32,
    pub max: __u32,
    pub bin_size: __u32,
    pub increment: __u32,
    pub decrement: __u32,
    pub limit: __u32,
    pub penalty_rate: __u32,
    pub penalty_burst: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfb_xstats {
    pub earlydrop: __u32,
    pub penaltydrop: __u32,
    pub bucketdrop: __u32,
    pub queuedrop: __u32,
    pub childdrop: __u32,
    pub marked: __u32,
    pub maxqlen: __u32,
    pub maxprob: __u32,
    pub avgprob: __u32,
}
pub const TCA_QFQ_UNSPEC: _bindgen_ty_135 = 0;
pub const TCA_QFQ_WEIGHT: _bindgen_ty_135 = 1;
pub const TCA_QFQ_LMAX: _bindgen_ty_135 = 2;
pub const __TCA_QFQ_MAX: _bindgen_ty_135 = 3;
pub type _bindgen_ty_135 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_qfq_stats {
    pub weight: __u32,
    pub lmax: __u32,
}
pub const TCA_CODEL_UNSPEC: _bindgen_ty_136 = 0;
pub const TCA_CODEL_TARGET: _bindgen_ty_136 = 1;
pub const TCA_CODEL_LIMIT: _bindgen_ty_136 = 2;
pub const TCA_CODEL_INTERVAL: _bindgen_ty_136 = 3;
pub const TCA_CODEL_ECN: _bindgen_ty_136 = 4;
pub const TCA_CODEL_CE_THRESHOLD: _bindgen_ty_136 = 5;
pub const __TCA_CODEL_MAX: _bindgen_ty_136 = 6;
pub type _bindgen_ty_136 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_codel_xstats {
    pub maxpacket: __u32,
    pub count: __u32,
    pub lastcount: __u32,
    pub ldelay: __u32,
    pub drop_next: __s32,
    pub drop_overlimit: __u32,
    pub ecn_mark: __u32,
    pub dropping: __u32,
    pub ce_mark: __u32,
}
pub const TCA_FQ_CODEL_UNSPEC: _bindgen_ty_137 = 0;
pub const TCA_FQ_CODEL_TARGET: _bindgen_ty_137 = 1;
pub const TCA_FQ_CODEL_LIMIT: _bindgen_ty_137 = 2;
pub const TCA_FQ_CODEL_INTERVAL: _bindgen_ty_137 = 3;
pub const TCA_FQ_CODEL_ECN: _bindgen_ty_137 = 4;
pub const TCA_FQ_CODEL_FLOWS: _bindgen_ty_137 = 5;
pub const TCA_FQ_CODEL_QUANTUM: _bindgen_ty_137 = 6;
pub const TCA_FQ_CODEL_CE_THRESHOLD: _bindgen_ty_137 = 7;
pub const TCA_FQ_CODEL_DROP_BATCH_SIZE: _bindgen_ty_137 = 8;
pub const TCA_FQ_CODEL_MEMORY_LIMIT: _bindgen_ty_137 = 9;
pub const TCA_FQ_CODEL_CE_THRESHOLD_SELECTOR: _bindgen_ty_137 = 10;
pub const TCA_FQ_CODEL_CE_THRESHOLD_MASK: _bindgen_ty_137 = 11;
pub const __TCA_FQ_CODEL_MAX: _bindgen_ty_137 = 12;
pub type _bindgen_ty_137 = ffi::c_uint;
pub const TCA_FQ_CODEL_XSTATS_QDISC: _bindgen_ty_138 = 0;
pub const TCA_FQ_CODEL_XSTATS_CLASS: _bindgen_ty_138 = 1;
pub type _bindgen_ty_138 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_codel_qd_stats {
    pub maxpacket: __u32,
    pub drop_overlimit: __u32,
    pub ecn_mark: __u32,
    pub new_flow_count: __u32,
    pub new_flows_len: __u32,
    pub old_flows_len: __u32,
    pub ce_mark: __u32,
    pub memory_usage: __u32,
    pub drop_overmemory: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_codel_cl_stats {
    pub deficit: __s32,
    pub ldelay: __u32,
    pub count: __u32,
    pub lastcount: __u32,
    pub dropping: __u32,
    pub drop_next: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tc_fq_codel_xstats {
    pub type_: __u32,
    pub __bindgen_anon_1: tc_fq_codel_xstats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tc_fq_codel_xstats__bindgen_ty_1 {
    pub qdisc_stats: tc_fq_codel_qd_stats,
    pub class_stats: tc_fq_codel_cl_stats,
}
impl Default for tc_fq_codel_xstats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tc_fq_codel_xstats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TCA_FQ_UNSPEC: _bindgen_ty_139 = 0;
pub const TCA_FQ_PLIMIT: _bindgen_ty_139 = 1;
pub const TCA_FQ_FLOW_PLIMIT: _bindgen_ty_139 = 2;
pub const TCA_FQ_QUANTUM: _bindgen_ty_139 = 3;
pub const TCA_FQ_INITIAL_QUANTUM: _bindgen_ty_139 = 4;
pub const TCA_FQ_RATE_ENABLE: _bindgen_ty_139 = 5;
pub const TCA_FQ_FLOW_DEFAULT_RATE: _bindgen_ty_139 = 6;
pub const TCA_FQ_FLOW_MAX_RATE: _bindgen_ty_139 = 7;
pub const TCA_FQ_BUCKETS_LOG: _bindgen_ty_139 = 8;
pub const TCA_FQ_FLOW_REFILL_DELAY: _bindgen_ty_139 = 9;
pub const TCA_FQ_ORPHAN_MASK: _bindgen_ty_139 = 10;
pub const TCA_FQ_LOW_RATE_THRESHOLD: _bindgen_ty_139 = 11;
pub const TCA_FQ_CE_THRESHOLD: _bindgen_ty_139 = 12;
pub const TCA_FQ_TIMER_SLACK: _bindgen_ty_139 = 13;
pub const TCA_FQ_HORIZON: _bindgen_ty_139 = 14;
pub const TCA_FQ_HORIZON_DROP: _bindgen_ty_139 = 15;
pub const TCA_FQ_PRIOMAP: _bindgen_ty_139 = 16;
pub const TCA_FQ_WEIGHTS: _bindgen_ty_139 = 17;
pub const TCA_FQ_OFFLOAD_HORIZON: _bindgen_ty_139 = 18;
pub const __TCA_FQ_MAX: _bindgen_ty_139 = 19;
pub type _bindgen_ty_139 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_qd_stats {
    pub gc_flows: __u64,
    pub highprio_packets: __u64,
    pub tcp_retrans: __u64,
    pub throttled: __u64,
    pub flows_plimit: __u64,
    pub pkts_too_long: __u64,
    pub allocation_errors: __u64,
    pub time_next_delayed_flow: __s64,
    pub flows: __u32,
    pub inactive_flows: __u32,
    pub throttled_flows: __u32,
    pub unthrottle_latency_ns: __u32,
    pub ce_mark: __u64,
    pub horizon_drops: __u64,
    pub horizon_caps: __u64,
    pub fastpath_packets: __u64,
    pub band_drops: [__u64; 3usize],
    pub band_pkt_count: [__u32; 3usize],
    pub pad: __u32,
}
pub const TCA_HHF_UNSPEC: _bindgen_ty_140 = 0;
pub const TCA_HHF_BACKLOG_LIMIT: _bindgen_ty_140 = 1;
pub const TCA_HHF_QUANTUM: _bindgen_ty_140 = 2;
pub const TCA_HHF_HH_FLOWS_LIMIT: _bindgen_ty_140 = 3;
pub const TCA_HHF_RESET_TIMEOUT: _bindgen_ty_140 = 4;
pub const TCA_HHF_ADMIT_BYTES: _bindgen_ty_140 = 5;
pub const TCA_HHF_EVICT_TIMEOUT: _bindgen_ty_140 = 6;
pub const TCA_HHF_NON_HH_WEIGHT: _bindgen_ty_140 = 7;
pub const __TCA_HHF_MAX: _bindgen_ty_140 = 8;
pub type _bindgen_ty_140 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hhf_xstats {
    pub drop_overlimit: __u32,
    pub hh_overlimit: __u32,
    pub hh_tot_count: __u32,
    pub hh_cur_count: __u32,
}
pub const TCA_PIE_UNSPEC: _bindgen_ty_141 = 0;
pub const TCA_PIE_TARGET: _bindgen_ty_141 = 1;
pub const TCA_PIE_LIMIT: _bindgen_ty_141 = 2;
pub const TCA_PIE_TUPDATE: _bindgen_ty_141 = 3;
pub const TCA_PIE_ALPHA: _bindgen_ty_141 = 4;
pub const TCA_PIE_BETA: _bindgen_ty_141 = 5;
pub const TCA_PIE_ECN: _bindgen_ty_141 = 6;
pub const TCA_PIE_BYTEMODE: _bindgen_ty_141 = 7;
pub const TCA_PIE_DQ_RATE_ESTIMATOR: _bindgen_ty_141 = 8;
pub const __TCA_PIE_MAX: _bindgen_ty_141 = 9;
pub type _bindgen_ty_141 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_pie_xstats {
    pub prob: __u64,
    pub delay: __u32,
    pub avg_dq_rate: __u32,
    pub dq_rate_estimating: __u32,
    pub packets_in: __u32,
    pub dropped: __u32,
    pub overlimit: __u32,
    pub maxq: __u32,
    pub ecn_mark: __u32,
}
pub const TCA_FQ_PIE_UNSPEC: _bindgen_ty_142 = 0;
pub const TCA_FQ_PIE_LIMIT: _bindgen_ty_142 = 1;
pub const TCA_FQ_PIE_FLOWS: _bindgen_ty_142 = 2;
pub const TCA_FQ_PIE_TARGET: _bindgen_ty_142 = 3;
pub const TCA_FQ_PIE_TUPDATE: _bindgen_ty_142 = 4;
pub const TCA_FQ_PIE_ALPHA: _bindgen_ty_142 = 5;
pub const TCA_FQ_PIE_BETA: _bindgen_ty_142 = 6;
pub const TCA_FQ_PIE_QUANTUM: _bindgen_ty_142 = 7;
pub const TCA_FQ_PIE_MEMORY_LIMIT: _bindgen_ty_142 = 8;
pub const TCA_FQ_PIE_ECN_PROB: _bindgen_ty_142 = 9;
pub const TCA_FQ_PIE_ECN: _bindgen_ty_142 = 10;
pub const TCA_FQ_PIE_BYTEMODE: _bindgen_ty_142 = 11;
pub const TCA_FQ_PIE_DQ_RATE_ESTIMATOR: _bindgen_ty_142 = 12;
pub const __TCA_FQ_PIE_MAX: _bindgen_ty_142 = 13;
pub type _bindgen_ty_142 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_pie_xstats {
    pub packets_in: __u32,
    pub dropped: __u32,
    pub overlimit: __u32,
    pub overmemory: __u32,
    pub ecn_mark: __u32,
    pub new_flow_count: __u32,
    pub new_flows_len: __u32,
    pub old_flows_len: __u32,
    pub memory_usage: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbs_qopt {
    pub offload: __u8,
    pub _pad: [__u8; 3usize],
    pub hicredit: __s32,
    pub locredit: __s32,
    pub idleslope: __s32,
    pub sendslope: __s32,
}
pub const TCA_CBS_UNSPEC: _bindgen_ty_143 = 0;
pub const TCA_CBS_PARMS: _bindgen_ty_143 = 1;
pub const __TCA_CBS_MAX: _bindgen_ty_143 = 2;
pub type _bindgen_ty_143 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_etf_qopt {
    pub delta: __s32,
    pub clockid: __s32,
    pub flags: __u32,
}
pub const TCA_ETF_UNSPEC: _bindgen_ty_144 = 0;
pub const TCA_ETF_PARMS: _bindgen_ty_144 = 1;
pub const __TCA_ETF_MAX: _bindgen_ty_144 = 2;
pub type _bindgen_ty_144 = ffi::c_uint;
pub const TCA_CAKE_UNSPEC: _bindgen_ty_145 = 0;
pub const TCA_CAKE_PAD: _bindgen_ty_145 = 1;
pub const TCA_CAKE_BASE_RATE64: _bindgen_ty_145 = 2;
pub const TCA_CAKE_DIFFSERV_MODE: _bindgen_ty_145 = 3;
pub const TCA_CAKE_ATM: _bindgen_ty_145 = 4;
pub const TCA_CAKE_FLOW_MODE: _bindgen_ty_145 = 5;
pub const TCA_CAKE_OVERHEAD: _bindgen_ty_145 = 6;
pub const TCA_CAKE_RTT: _bindgen_ty_145 = 7;
pub const TCA_CAKE_TARGET: _bindgen_ty_145 = 8;
pub const TCA_CAKE_AUTORATE: _bindgen_ty_145 = 9;
pub const TCA_CAKE_MEMORY: _bindgen_ty_145 = 10;
pub const TCA_CAKE_NAT: _bindgen_ty_145 = 11;
pub const TCA_CAKE_RAW: _bindgen_ty_145 = 12;
pub const TCA_CAKE_WASH: _bindgen_ty_145 = 13;
pub const TCA_CAKE_MPU: _bindgen_ty_145 = 14;
pub const TCA_CAKE_INGRESS: _bindgen_ty_145 = 15;
pub const TCA_CAKE_ACK_FILTER: _bindgen_ty_145 = 16;
pub const TCA_CAKE_SPLIT_GSO: _bindgen_ty_145 = 17;
pub const TCA_CAKE_FWMARK: _bindgen_ty_145 = 18;
pub const __TCA_CAKE_MAX: _bindgen_ty_145 = 19;
pub type _bindgen_ty_145 = ffi::c_uint;
pub const __TCA_CAKE_STATS_INVALID: _bindgen_ty_146 = 0;
pub const TCA_CAKE_STATS_PAD: _bindgen_ty_146 = 1;
pub const TCA_CAKE_STATS_CAPACITY_ESTIMATE64: _bindgen_ty_146 = 2;
pub const TCA_CAKE_STATS_MEMORY_LIMIT: _bindgen_ty_146 = 3;
pub const TCA_CAKE_STATS_MEMORY_USED: _bindgen_ty_146 = 4;
pub const TCA_CAKE_STATS_AVG_NETOFF: _bindgen_ty_146 = 5;
pub const TCA_CAKE_STATS_MIN_NETLEN: _bindgen_ty_146 = 6;
pub const TCA_CAKE_STATS_MAX_NETLEN: _bindgen_ty_146 = 7;
pub const TCA_CAKE_STATS_MIN_ADJLEN: _bindgen_ty_146 = 8;
pub const TCA_CAKE_STATS_MAX_ADJLEN: _bindgen_ty_146 = 9;
pub const TCA_CAKE_STATS_TIN_STATS: _bindgen_ty_146 = 10;
pub const TCA_CAKE_STATS_DEFICIT: _bindgen_ty_146 = 11;
pub const TCA_CAKE_STATS_COBALT_COUNT: _bindgen_ty_146 = 12;
pub const TCA_CAKE_STATS_DROPPING: _bindgen_ty_146 = 13;
pub const TCA_CAKE_STATS_DROP_NEXT_US: _bindgen_ty_146 = 14;
pub const TCA_CAKE_STATS_P_DROP: _bindgen_ty_146 = 15;
pub const TCA_CAKE_STATS_BLUE_TIMER_US: _bindgen_ty_146 = 16;
pub const __TCA_CAKE_STATS_MAX: _bindgen_ty_146 = 17;
pub type _bindgen_ty_146 = ffi::c_uint;
pub const __TCA_CAKE_TIN_STATS_INVALID: _bindgen_ty_147 = 0;
pub const TCA_CAKE_TIN_STATS_PAD: _bindgen_ty_147 = 1;
pub const TCA_CAKE_TIN_STATS_SENT_PACKETS: _bindgen_ty_147 = 2;
pub const TCA_CAKE_TIN_STATS_SENT_BYTES64: _bindgen_ty_147 = 3;
pub const TCA_CAKE_TIN_STATS_DROPPED_PACKETS: _bindgen_ty_147 = 4;
pub const TCA_CAKE_TIN_STATS_DROPPED_BYTES64: _bindgen_ty_147 = 5;
pub const TCA_CAKE_TIN_STATS_ACKS_DROPPED_PACKETS: _bindgen_ty_147 = 6;
pub const TCA_CAKE_TIN_STATS_ACKS_DROPPED_BYTES64: _bindgen_ty_147 = 7;
pub const TCA_CAKE_TIN_STATS_ECN_MARKED_PACKETS: _bindgen_ty_147 = 8;
pub const TCA_CAKE_TIN_STATS_ECN_MARKED_BYTES64: _bindgen_ty_147 = 9;
pub const TCA_CAKE_TIN_STATS_BACKLOG_PACKETS: _bindgen_ty_147 = 10;
pub const TCA_CAKE_TIN_STATS_BACKLOG_BYTES: _bindgen_ty_147 = 11;
pub const TCA_CAKE_TIN_STATS_THRESHOLD_RATE64: _bindgen_ty_147 = 12;
pub const TCA_CAKE_TIN_STATS_TARGET_US: _bindgen_ty_147 = 13;
pub const TCA_CAKE_TIN_STATS_INTERVAL_US: _bindgen_ty_147 = 14;
pub const TCA_CAKE_TIN_STATS_WAY_INDIRECT_HITS: _bindgen_ty_147 = 15;
pub const TCA_CAKE_TIN_STATS_WAY_MISSES: _bindgen_ty_147 = 16;
pub const TCA_CAKE_TIN_STATS_WAY_COLLISIONS: _bindgen_ty_147 = 17;
pub const TCA_CAKE_TIN_STATS_PEAK_DELAY_US: _bindgen_ty_147 = 18;
pub const TCA_CAKE_TIN_STATS_AVG_DELAY_US: _bindgen_ty_147 = 19;
pub const TCA_CAKE_TIN_STATS_BASE_DELAY_US: _bindgen_ty_147 = 20;
pub const TCA_CAKE_TIN_STATS_SPARSE_FLOWS: _bindgen_ty_147 = 21;
pub const TCA_CAKE_TIN_STATS_BULK_FLOWS: _bindgen_ty_147 = 22;
pub const TCA_CAKE_TIN_STATS_UNRESPONSIVE_FLOWS: _bindgen_ty_147 = 23;
pub const TCA_CAKE_TIN_STATS_MAX_SKBLEN: _bindgen_ty_147 = 24;
pub const TCA_CAKE_TIN_STATS_FLOW_QUANTUM: _bindgen_ty_147 = 25;
pub const __TCA_CAKE_TIN_STATS_MAX: _bindgen_ty_147 = 26;
pub type _bindgen_ty_147 = ffi::c_uint;
pub const CAKE_FLOW_NONE: _bindgen_ty_148 = 0;
pub const CAKE_FLOW_SRC_IP: _bindgen_ty_148 = 1;
pub const CAKE_FLOW_DST_IP: _bindgen_ty_148 = 2;
pub const CAKE_FLOW_HOSTS: _bindgen_ty_148 = 3;
pub const CAKE_FLOW_FLOWS: _bindgen_ty_148 = 4;
pub const CAKE_FLOW_DUAL_SRC: _bindgen_ty_148 = 5;
pub const CAKE_FLOW_DUAL_DST: _bindgen_ty_148 = 6;
pub const CAKE_FLOW_TRIPLE: _bindgen_ty_148 = 7;
pub const CAKE_FLOW_MAX: _bindgen_ty_148 = 8;
pub type _bindgen_ty_148 = ffi::c_uint;
pub const CAKE_DIFFSERV_DIFFSERV3: _bindgen_ty_149 = 0;
pub const CAKE_DIFFSERV_DIFFSERV4: _bindgen_ty_149 = 1;
pub const CAKE_DIFFSERV_DIFFSERV8: _bindgen_ty_149 = 2;
pub const CAKE_DIFFSERV_BESTEFFORT: _bindgen_ty_149 = 3;
pub const CAKE_DIFFSERV_PRECEDENCE: _bindgen_ty_149 = 4;
pub const CAKE_DIFFSERV_MAX: _bindgen_ty_149 = 5;
pub type _bindgen_ty_149 = ffi::c_uint;
pub const CAKE_ACK_NONE: _bindgen_ty_150 = 0;
pub const CAKE_ACK_FILTER: _bindgen_ty_150 = 1;
pub const CAKE_ACK_AGGRESSIVE: _bindgen_ty_150 = 2;
pub const CAKE_ACK_MAX: _bindgen_ty_150 = 3;
pub type _bindgen_ty_150 = ffi::c_uint;
pub const CAKE_ATM_NONE: _bindgen_ty_151 = 0;
pub const CAKE_ATM_ATM: _bindgen_ty_151 = 1;
pub const CAKE_ATM_PTM: _bindgen_ty_151 = 2;
pub const CAKE_ATM_MAX: _bindgen_ty_151 = 3;
pub type _bindgen_ty_151 = ffi::c_uint;
pub const TC_TAPRIO_CMD_SET_GATES: _bindgen_ty_152 = 0;
pub const TC_TAPRIO_CMD_SET_AND_HOLD: _bindgen_ty_152 = 1;
pub const TC_TAPRIO_CMD_SET_AND_RELEASE: _bindgen_ty_152 = 2;
pub type _bindgen_ty_152 = ffi::c_uint;
pub const TCA_TAPRIO_SCHED_ENTRY_UNSPEC: _bindgen_ty_153 = 0;
pub const TCA_TAPRIO_SCHED_ENTRY_INDEX: _bindgen_ty_153 = 1;
pub const TCA_TAPRIO_SCHED_ENTRY_CMD: _bindgen_ty_153 = 2;
pub const TCA_TAPRIO_SCHED_ENTRY_GATE_MASK: _bindgen_ty_153 = 3;
pub const TCA_TAPRIO_SCHED_ENTRY_INTERVAL: _bindgen_ty_153 = 4;
pub const __TCA_TAPRIO_SCHED_ENTRY_MAX: _bindgen_ty_153 = 5;
pub type _bindgen_ty_153 = ffi::c_uint;
pub const TCA_TAPRIO_SCHED_UNSPEC: _bindgen_ty_154 = 0;
pub const TCA_TAPRIO_SCHED_ENTRY: _bindgen_ty_154 = 1;
pub const __TCA_TAPRIO_SCHED_MAX: _bindgen_ty_154 = 2;
pub type _bindgen_ty_154 = ffi::c_uint;
pub const TCA_TAPRIO_TC_ENTRY_UNSPEC: _bindgen_ty_155 = 0;
pub const TCA_TAPRIO_TC_ENTRY_INDEX: _bindgen_ty_155 = 1;
pub const TCA_TAPRIO_TC_ENTRY_MAX_SDU: _bindgen_ty_155 = 2;
pub const TCA_TAPRIO_TC_ENTRY_FP: _bindgen_ty_155 = 3;
pub const __TCA_TAPRIO_TC_ENTRY_CNT: _bindgen_ty_155 = 4;
pub const TCA_TAPRIO_TC_ENTRY_MAX: _bindgen_ty_155 = 3;
pub type _bindgen_ty_155 = ffi::c_uint;
pub const TCA_TAPRIO_OFFLOAD_STATS_PAD: _bindgen_ty_156 = 1;
pub const TCA_TAPRIO_OFFLOAD_STATS_WINDOW_DROPS: _bindgen_ty_156 = 2;
pub const TCA_TAPRIO_OFFLOAD_STATS_TX_OVERRUNS: _bindgen_ty_156 = 3;
pub const __TCA_TAPRIO_OFFLOAD_STATS_CNT: _bindgen_ty_156 = 4;
pub const TCA_TAPRIO_OFFLOAD_STATS_MAX: _bindgen_ty_156 = 3;
pub type _bindgen_ty_156 = ffi::c_uint;
pub const TCA_TAPRIO_ATTR_UNSPEC: _bindgen_ty_157 = 0;
pub const TCA_TAPRIO_ATTR_PRIOMAP: _bindgen_ty_157 = 1;
pub const TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST: _bindgen_ty_157 = 2;
pub const TCA_TAPRIO_ATTR_SCHED_BASE_TIME: _bindgen_ty_157 = 3;
pub const TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY: _bindgen_ty_157 = 4;
pub const TCA_TAPRIO_ATTR_SCHED_CLOCKID: _bindgen_ty_157 = 5;
pub const TCA_TAPRIO_PAD: _bindgen_ty_157 = 6;
pub const TCA_TAPRIO_ATTR_PAD: _bindgen_ty_157 = 6;
pub const TCA_TAPRIO_ATTR_ADMIN_SCHED: _bindgen_ty_157 = 7;
pub const TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME: _bindgen_ty_157 = 8;
pub const TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION: _bindgen_ty_157 = 9;
pub const TCA_TAPRIO_ATTR_FLAGS: _bindgen_ty_157 = 10;
pub const TCA_TAPRIO_ATTR_TXTIME_DELAY: _bindgen_ty_157 = 11;
pub const TCA_TAPRIO_ATTR_TC_ENTRY: _bindgen_ty_157 = 12;
pub const __TCA_TAPRIO_ATTR_MAX: _bindgen_ty_157 = 13;
pub type _bindgen_ty_157 = ffi::c_uint;
pub const TCA_ETS_UNSPEC: _bindgen_ty_158 = 0;
pub const TCA_ETS_NBANDS: _bindgen_ty_158 = 1;
pub const TCA_ETS_NSTRICT: _bindgen_ty_158 = 2;
pub const TCA_ETS_QUANTA: _bindgen_ty_158 = 3;
pub const TCA_ETS_QUANTA_BAND: _bindgen_ty_158 = 4;
pub const TCA_ETS_PRIOMAP: _bindgen_ty_158 = 5;
pub const TCA_ETS_PRIOMAP_BAND: _bindgen_ty_158 = 6;
pub const __TCA_ETS_MAX: _bindgen_ty_158 = 7;
pub type _bindgen_ty_158 = ffi::c_uint;
pub const tc_dualpi2_drop_overload_TC_DUALPI2_DROP_OVERLOAD_OVERFLOW: tc_dualpi2_drop_overload = 0;
pub const tc_dualpi2_drop_overload_TC_DUALPI2_DROP_OVERLOAD_DROP: tc_dualpi2_drop_overload = 1;
pub const tc_dualpi2_drop_overload___TCA_DUALPI2_DROP_OVERLOAD_MAX: tc_dualpi2_drop_overload = 2;
pub type tc_dualpi2_drop_overload = ffi::c_uint;
pub const tc_dualpi2_drop_early_TC_DUALPI2_DROP_EARLY_DROP_DEQUEUE: tc_dualpi2_drop_early = 0;
pub const tc_dualpi2_drop_early_TC_DUALPI2_DROP_EARLY_DROP_ENQUEUE: tc_dualpi2_drop_early = 1;
pub const tc_dualpi2_drop_early___TCA_DUALPI2_DROP_EARLY_MAX: tc_dualpi2_drop_early = 2;
pub type tc_dualpi2_drop_early = ffi::c_uint;
pub const tc_dualpi2_ecn_mask_TC_DUALPI2_ECN_MASK_L4S_ECT: tc_dualpi2_ecn_mask = 1;
pub const tc_dualpi2_ecn_mask_TC_DUALPI2_ECN_MASK_CLA_ECT: tc_dualpi2_ecn_mask = 2;
pub const tc_dualpi2_ecn_mask_TC_DUALPI2_ECN_MASK_ANY_ECT: tc_dualpi2_ecn_mask = 3;
pub const tc_dualpi2_ecn_mask___TCA_DUALPI2_ECN_MASK_MAX: tc_dualpi2_ecn_mask = 4;
pub type tc_dualpi2_ecn_mask = ffi::c_uint;
pub const tc_dualpi2_split_gso_TC_DUALPI2_SPLIT_GSO_NO_SPLIT_GSO: tc_dualpi2_split_gso = 0;
pub const tc_dualpi2_split_gso_TC_DUALPI2_SPLIT_GSO_SPLIT_GSO: tc_dualpi2_split_gso = 1;
pub const tc_dualpi2_split_gso___TCA_DUALPI2_SPLIT_GSO_MAX: tc_dualpi2_split_gso = 2;
pub type tc_dualpi2_split_gso = ffi::c_uint;
pub const TCA_DUALPI2_UNSPEC: _bindgen_ty_159 = 0;
pub const TCA_DUALPI2_LIMIT: _bindgen_ty_159 = 1;
pub const TCA_DUALPI2_MEMORY_LIMIT: _bindgen_ty_159 = 2;
pub const TCA_DUALPI2_TARGET: _bindgen_ty_159 = 3;
pub const TCA_DUALPI2_TUPDATE: _bindgen_ty_159 = 4;
pub const TCA_DUALPI2_ALPHA: _bindgen_ty_159 = 5;
pub const TCA_DUALPI2_BETA: _bindgen_ty_159 = 6;
pub const TCA_DUALPI2_STEP_THRESH_PKTS: _bindgen_ty_159 = 7;
pub const TCA_DUALPI2_STEP_THRESH_US: _bindgen_ty_159 = 8;
pub const TCA_DUALPI2_MIN_QLEN_STEP: _bindgen_ty_159 = 9;
pub const TCA_DUALPI2_COUPLING: _bindgen_ty_159 = 10;
pub const TCA_DUALPI2_DROP_OVERLOAD: _bindgen_ty_159 = 11;
pub const TCA_DUALPI2_DROP_EARLY: _bindgen_ty_159 = 12;
pub const TCA_DUALPI2_C_PROTECTION: _bindgen_ty_159 = 13;
pub const TCA_DUALPI2_ECN_MASK: _bindgen_ty_159 = 14;
pub const TCA_DUALPI2_SPLIT_GSO: _bindgen_ty_159 = 15;
pub const TCA_DUALPI2_PAD: _bindgen_ty_159 = 16;
pub const __TCA_DUALPI2_MAX: _bindgen_ty_159 = 17;
pub type _bindgen_ty_159 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_dualpi2_xstats {
    pub prob: __u32,
    pub delay_c: __u32,
    pub delay_l: __u32,
    pub packets_in_c: __u32,
    pub packets_in_l: __u32,
    pub maxq: __u32,
    pub ecn_mark: __u32,
    pub step_marks: __u32,
    pub credit: __s32,
    pub memory_used: __u32,
    pub max_memory_used: __u32,
    pub memory_limit: __u32,
}
pub const TCA_ACT_UNSPEC: _bindgen_ty_160 = 0;
pub const TCA_ACT_KIND: _bindgen_ty_160 = 1;
pub const TCA_ACT_OPTIONS: _bindgen_ty_160 = 2;
pub const TCA_ACT_INDEX: _bindgen_ty_160 = 3;
pub const TCA_ACT_STATS: _bindgen_ty_160 = 4;
pub const TCA_ACT_PAD: _bindgen_ty_160 = 5;
pub const TCA_ACT_COOKIE: _bindgen_ty_160 = 6;
pub const TCA_ACT_FLAGS: _bindgen_ty_160 = 7;
pub const TCA_ACT_HW_STATS: _bindgen_ty_160 = 8;
pub const TCA_ACT_USED_HW_STATS: _bindgen_ty_160 = 9;
pub const TCA_ACT_IN_HW_COUNT: _bindgen_ty_160 = 10;
pub const __TCA_ACT_MAX: _bindgen_ty_160 = 11;
pub type _bindgen_ty_160 = ffi::c_uint;
pub const tca_id_TCA_ID_UNSPEC: tca_id = 0;
pub const tca_id_TCA_ID_POLICE: tca_id = 1;
pub const tca_id_TCA_ID_GACT: tca_id = 5;
pub const tca_id_TCA_ID_IPT: tca_id = 6;
pub const tca_id_TCA_ID_PEDIT: tca_id = 7;
pub const tca_id_TCA_ID_MIRRED: tca_id = 8;
pub const tca_id_TCA_ID_NAT: tca_id = 9;
pub const tca_id_TCA_ID_XT: tca_id = 10;
pub const tca_id_TCA_ID_SKBEDIT: tca_id = 11;
pub const tca_id_TCA_ID_VLAN: tca_id = 12;
pub const tca_id_TCA_ID_BPF: tca_id = 13;
pub const tca_id_TCA_ID_CONNMARK: tca_id = 14;
pub const tca_id_TCA_ID_SKBMOD: tca_id = 15;
pub const tca_id_TCA_ID_CSUM: tca_id = 16;
pub const tca_id_TCA_ID_TUNNEL_KEY: tca_id = 17;
pub const tca_id_TCA_ID_SIMP: tca_id = 22;
pub const tca_id_TCA_ID_IFE: tca_id = 25;
pub const tca_id_TCA_ID_SAMPLE: tca_id = 26;
pub const tca_id_TCA_ID_CTINFO: tca_id = 27;
pub const tca_id_TCA_ID_MPLS: tca_id = 28;
pub const tca_id_TCA_ID_CT: tca_id = 29;
pub const tca_id_TCA_ID_GATE: tca_id = 30;
pub const tca_id___TCA_ID_MAX: tca_id = 255;
pub type tca_id = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_police {
    pub index: __u32,
    pub action: ffi::c_int,
    pub limit: __u32,
    pub burst: __u32,
    pub mtu: __u32,
    pub rate: tc_ratespec,
    pub peakrate: tc_ratespec,
    pub refcnt: ffi::c_int,
    pub bindcnt: ffi::c_int,
    pub capab: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_t {
    pub install: __u64,
    pub lastuse: __u64,
    pub expires: __u64,
    pub firstuse: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cnt {
    pub refcnt: ffi::c_int,
    pub bindcnt: ffi::c_int,
}
pub const TCA_POLICE_UNSPEC: _bindgen_ty_161 = 0;
pub const TCA_POLICE_TBF: _bindgen_ty_161 = 1;
pub const TCA_POLICE_RATE: _bindgen_ty_161 = 2;
pub const TCA_POLICE_PEAKRATE: _bindgen_ty_161 = 3;
pub const TCA_POLICE_AVRATE: _bindgen_ty_161 = 4;
pub const TCA_POLICE_RESULT: _bindgen_ty_161 = 5;
pub const TCA_POLICE_TM: _bindgen_ty_161 = 6;
pub const TCA_POLICE_PAD: _bindgen_ty_161 = 7;
pub const TCA_POLICE_RATE64: _bindgen_ty_161 = 8;
pub const TCA_POLICE_PEAKRATE64: _bindgen_ty_161 = 9;
pub const TCA_POLICE_PKTRATE64: _bindgen_ty_161 = 10;
pub const TCA_POLICE_PKTBURST64: _bindgen_ty_161 = 11;
pub const __TCA_POLICE_MAX: _bindgen_ty_161 = 12;
pub type _bindgen_ty_161 = ffi::c_uint;
pub const TCA_U32_UNSPEC: _bindgen_ty_162 = 0;
pub const TCA_U32_CLASSID: _bindgen_ty_162 = 1;
pub const TCA_U32_HASH: _bindgen_ty_162 = 2;
pub const TCA_U32_LINK: _bindgen_ty_162 = 3;
pub const TCA_U32_DIVISOR: _bindgen_ty_162 = 4;
pub const TCA_U32_SEL: _bindgen_ty_162 = 5;
pub const TCA_U32_POLICE: _bindgen_ty_162 = 6;
pub const TCA_U32_ACT: _bindgen_ty_162 = 7;
pub const TCA_U32_INDEV: _bindgen_ty_162 = 8;
pub const TCA_U32_PCNT: _bindgen_ty_162 = 9;
pub const TCA_U32_MARK: _bindgen_ty_162 = 10;
pub const TCA_U32_FLAGS: _bindgen_ty_162 = 11;
pub const TCA_U32_PAD: _bindgen_ty_162 = 12;
pub const __TCA_U32_MAX: _bindgen_ty_162 = 13;
pub type _bindgen_ty_162 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_key {
    pub mask: __be32,
    pub val: __be32,
    pub off: ffi::c_int,
    pub offmask: ffi::c_int,
}
#[repr(C)]
pub struct tc_u32_sel {
    pub __bindgen_anon_1: tc_u32_sel__bindgen_ty_1,
    pub keys: __IncompleteArrayField<tc_u32_key>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tc_u32_sel__bindgen_ty_1 {
    pub __bindgen_anon_1: tc_u32_sel__bindgen_ty_1__bindgen_ty_1,
    pub hdr: tc_u32_sel__bindgen_ty_1_tc_u32_sel_hdr,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_sel__bindgen_ty_1__bindgen_ty_1 {
    pub flags: ffi::c_uchar,
    pub offshift: ffi::c_uchar,
    pub nkeys: ffi::c_uchar,
    pub offmask: __be16,
    pub off: __u16,
    pub offoff: ffi::c_short,
    pub hoff: ffi::c_short,
    pub hmask: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_sel__bindgen_ty_1_tc_u32_sel_hdr {
    pub flags: ffi::c_uchar,
    pub offshift: ffi::c_uchar,
    pub nkeys: ffi::c_uchar,
    pub offmask: __be16,
    pub off: __u16,
    pub offoff: ffi::c_short,
    pub hoff: ffi::c_short,
    pub hmask: __be32,
}
impl Default for tc_u32_sel__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tc_u32_sel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_mark {
    pub val: __u32,
    pub mask: __u32,
    pub success: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct tc_u32_pcnt {
    pub rcnt: __u64,
    pub rhit: __u64,
    pub kcnts: __IncompleteArrayField<__u64>,
}
pub const TCA_ROUTE4_UNSPEC: _bindgen_ty_163 = 0;
pub const TCA_ROUTE4_CLASSID: _bindgen_ty_163 = 1;
pub const TCA_ROUTE4_TO: _bindgen_ty_163 = 2;
pub const TCA_ROUTE4_FROM: _bindgen_ty_163 = 3;
pub const TCA_ROUTE4_IIF: _bindgen_ty_163 = 4;
pub const TCA_ROUTE4_POLICE: _bindgen_ty_163 = 5;
pub const TCA_ROUTE4_ACT: _bindgen_ty_163 = 6;
pub const __TCA_ROUTE4_MAX: _bindgen_ty_163 = 7;
pub type _bindgen_ty_163 = ffi::c_uint;
pub const TCA_FW_UNSPEC: _bindgen_ty_164 = 0;
pub const TCA_FW_CLASSID: _bindgen_ty_164 = 1;
pub const TCA_FW_POLICE: _bindgen_ty_164 = 2;
pub const TCA_FW_INDEV: _bindgen_ty_164 = 3;
pub const TCA_FW_ACT: _bindgen_ty_164 = 4;
pub const TCA_FW_MASK: _bindgen_ty_164 = 5;
pub const __TCA_FW_MAX: _bindgen_ty_164 = 6;
pub type _bindgen_ty_164 = ffi::c_uint;
pub const FLOW_KEY_SRC: _bindgen_ty_165 = 0;
pub const FLOW_KEY_DST: _bindgen_ty_165 = 1;
pub const FLOW_KEY_PROTO: _bindgen_ty_165 = 2;
pub const FLOW_KEY_PROTO_SRC: _bindgen_ty_165 = 3;
pub const FLOW_KEY_PROTO_DST: _bindgen_ty_165 = 4;
pub const FLOW_KEY_IIF: _bindgen_ty_165 = 5;
pub const FLOW_KEY_PRIORITY: _bindgen_ty_165 = 6;
pub const FLOW_KEY_MARK: _bindgen_ty_165 = 7;
pub const FLOW_KEY_NFCT: _bindgen_ty_165 = 8;
pub const FLOW_KEY_NFCT_SRC: _bindgen_ty_165 = 9;
pub const FLOW_KEY_NFCT_DST: _bindgen_ty_165 = 10;
pub const FLOW_KEY_NFCT_PROTO_SRC: _bindgen_ty_165 = 11;
pub const FLOW_KEY_NFCT_PROTO_DST: _bindgen_ty_165 = 12;
pub const FLOW_KEY_RTCLASSID: _bindgen_ty_165 = 13;
pub const FLOW_KEY_SKUID: _bindgen_ty_165 = 14;
pub const FLOW_KEY_SKGID: _bindgen_ty_165 = 15;
pub const FLOW_KEY_VLAN_TAG: _bindgen_ty_165 = 16;
pub const FLOW_KEY_RXHASH: _bindgen_ty_165 = 17;
pub const __FLOW_KEY_MAX: _bindgen_ty_165 = 18;
pub type _bindgen_ty_165 = ffi::c_uint;
pub const FLOW_MODE_MAP: _bindgen_ty_166 = 0;
pub const FLOW_MODE_HASH: _bindgen_ty_166 = 1;
pub type _bindgen_ty_166 = ffi::c_uint;
pub const TCA_FLOW_UNSPEC: _bindgen_ty_167 = 0;
pub const TCA_FLOW_KEYS: _bindgen_ty_167 = 1;
pub const TCA_FLOW_MODE: _bindgen_ty_167 = 2;
pub const TCA_FLOW_BASECLASS: _bindgen_ty_167 = 3;
pub const TCA_FLOW_RSHIFT: _bindgen_ty_167 = 4;
pub const TCA_FLOW_ADDEND: _bindgen_ty_167 = 5;
pub const TCA_FLOW_MASK: _bindgen_ty_167 = 6;
pub const TCA_FLOW_XOR: _bindgen_ty_167 = 7;
pub const TCA_FLOW_DIVISOR: _bindgen_ty_167 = 8;
pub const TCA_FLOW_ACT: _bindgen_ty_167 = 9;
pub const TCA_FLOW_POLICE: _bindgen_ty_167 = 10;
pub const TCA_FLOW_EMATCHES: _bindgen_ty_167 = 11;
pub const TCA_FLOW_PERTURB: _bindgen_ty_167 = 12;
pub const __TCA_FLOW_MAX: _bindgen_ty_167 = 13;
pub type _bindgen_ty_167 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_basic_pcnt {
    pub rcnt: __u64,
    pub rhit: __u64,
}
pub const TCA_BASIC_UNSPEC: _bindgen_ty_168 = 0;
pub const TCA_BASIC_CLASSID: _bindgen_ty_168 = 1;
pub const TCA_BASIC_EMATCHES: _bindgen_ty_168 = 2;
pub const TCA_BASIC_ACT: _bindgen_ty_168 = 3;
pub const TCA_BASIC_POLICE: _bindgen_ty_168 = 4;
pub const TCA_BASIC_PCNT: _bindgen_ty_168 = 5;
pub const TCA_BASIC_PAD: _bindgen_ty_168 = 6;
pub const __TCA_BASIC_MAX: _bindgen_ty_168 = 7;
pub type _bindgen_ty_168 = ffi::c_uint;
pub const TCA_CGROUP_UNSPEC: _bindgen_ty_169 = 0;
pub const TCA_CGROUP_ACT: _bindgen_ty_169 = 1;
pub const TCA_CGROUP_POLICE: _bindgen_ty_169 = 2;
pub const TCA_CGROUP_EMATCHES: _bindgen_ty_169 = 3;
pub const __TCA_CGROUP_MAX: _bindgen_ty_169 = 4;
pub type _bindgen_ty_169 = ffi::c_uint;
pub const TCA_BPF_UNSPEC: _bindgen_ty_170 = 0;
pub const TCA_BPF_ACT: _bindgen_ty_170 = 1;
pub const TCA_BPF_POLICE: _bindgen_ty_170 = 2;
pub const TCA_BPF_CLASSID: _bindgen_ty_170 = 3;
pub const TCA_BPF_OPS_LEN: _bindgen_ty_170 = 4;
pub const TCA_BPF_OPS: _bindgen_ty_170 = 5;
pub const TCA_BPF_FD: _bindgen_ty_170 = 6;
pub const TCA_BPF_NAME: _bindgen_ty_170 = 7;
pub const TCA_BPF_FLAGS: _bindgen_ty_170 = 8;
pub const TCA_BPF_FLAGS_GEN: _bindgen_ty_170 = 9;
pub const TCA_BPF_TAG: _bindgen_ty_170 = 10;
pub const TCA_BPF_ID: _bindgen_ty_170 = 11;
pub const __TCA_BPF_MAX: _bindgen_ty_170 = 12;
pub type _bindgen_ty_170 = ffi::c_uint;
pub const TCA_FLOWER_UNSPEC: _bindgen_ty_171 = 0;
pub const TCA_FLOWER_CLASSID: _bindgen_ty_171 = 1;
pub const TCA_FLOWER_INDEV: _bindgen_ty_171 = 2;
pub const TCA_FLOWER_ACT: _bindgen_ty_171 = 3;
pub const TCA_FLOWER_KEY_ETH_DST: _bindgen_ty_171 = 4;
pub const TCA_FLOWER_KEY_ETH_DST_MASK: _bindgen_ty_171 = 5;
pub const TCA_FLOWER_KEY_ETH_SRC: _bindgen_ty_171 = 6;
pub const TCA_FLOWER_KEY_ETH_SRC_MASK: _bindgen_ty_171 = 7;
pub const TCA_FLOWER_KEY_ETH_TYPE: _bindgen_ty_171 = 8;
pub const TCA_FLOWER_KEY_IP_PROTO: _bindgen_ty_171 = 9;
pub const TCA_FLOWER_KEY_IPV4_SRC: _bindgen_ty_171 = 10;
pub const TCA_FLOWER_KEY_IPV4_SRC_MASK: _bindgen_ty_171 = 11;
pub const TCA_FLOWER_KEY_IPV4_DST: _bindgen_ty_171 = 12;
pub const TCA_FLOWER_KEY_IPV4_DST_MASK: _bindgen_ty_171 = 13;
pub const TCA_FLOWER_KEY_IPV6_SRC: _bindgen_ty_171 = 14;
pub const TCA_FLOWER_KEY_IPV6_SRC_MASK: _bindgen_ty_171 = 15;
pub const TCA_FLOWER_KEY_IPV6_DST: _bindgen_ty_171 = 16;
pub const TCA_FLOWER_KEY_IPV6_DST_MASK: _bindgen_ty_171 = 17;
pub const TCA_FLOWER_KEY_TCP_SRC: _bindgen_ty_171 = 18;
pub const TCA_FLOWER_KEY_TCP_DST: _bindgen_ty_171 = 19;
pub const TCA_FLOWER_KEY_UDP_SRC: _bindgen_ty_171 = 20;
pub const TCA_FLOWER_KEY_UDP_DST: _bindgen_ty_171 = 21;
pub const TCA_FLOWER_FLAGS: _bindgen_ty_171 = 22;
pub const TCA_FLOWER_KEY_VLAN_ID: _bindgen_ty_171 = 23;
pub const TCA_FLOWER_KEY_VLAN_PRIO: _bindgen_ty_171 = 24;
pub const TCA_FLOWER_KEY_VLAN_ETH_TYPE: _bindgen_ty_171 = 25;
pub const TCA_FLOWER_KEY_ENC_KEY_ID: _bindgen_ty_171 = 26;
pub const TCA_FLOWER_KEY_ENC_IPV4_SRC: _bindgen_ty_171 = 27;
pub const TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK: _bindgen_ty_171 = 28;
pub const TCA_FLOWER_KEY_ENC_IPV4_DST: _bindgen_ty_171 = 29;
pub const TCA_FLOWER_KEY_ENC_IPV4_DST_MASK: _bindgen_ty_171 = 30;
pub const TCA_FLOWER_KEY_ENC_IPV6_SRC: _bindgen_ty_171 = 31;
pub const TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK: _bindgen_ty_171 = 32;
pub const TCA_FLOWER_KEY_ENC_IPV6_DST: _bindgen_ty_171 = 33;
pub const TCA_FLOWER_KEY_ENC_IPV6_DST_MASK: _bindgen_ty_171 = 34;
pub const TCA_FLOWER_KEY_TCP_SRC_MASK: _bindgen_ty_171 = 35;
pub const TCA_FLOWER_KEY_TCP_DST_MASK: _bindgen_ty_171 = 36;
pub const TCA_FLOWER_KEY_UDP_SRC_MASK: _bindgen_ty_171 = 37;
pub const TCA_FLOWER_KEY_UDP_DST_MASK: _bindgen_ty_171 = 38;
pub const TCA_FLOWER_KEY_SCTP_SRC_MASK: _bindgen_ty_171 = 39;
pub const TCA_FLOWER_KEY_SCTP_DST_MASK: _bindgen_ty_171 = 40;
pub const TCA_FLOWER_KEY_SCTP_SRC: _bindgen_ty_171 = 41;
pub const TCA_FLOWER_KEY_SCTP_DST: _bindgen_ty_171 = 42;
pub const TCA_FLOWER_KEY_ENC_UDP_SRC_PORT: _bindgen_ty_171 = 43;
pub const TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK: _bindgen_ty_171 = 44;
pub const TCA_FLOWER_KEY_ENC_UDP_DST_PORT: _bindgen_ty_171 = 45;
pub const TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK: _bindgen_ty_171 = 46;
pub const TCA_FLOWER_KEY_FLAGS: _bindgen_ty_171 = 47;
pub const TCA_FLOWER_KEY_FLAGS_MASK: _bindgen_ty_171 = 48;
pub const TCA_FLOWER_KEY_ICMPV4_CODE: _bindgen_ty_171 = 49;
pub const TCA_FLOWER_KEY_ICMPV4_CODE_MASK: _bindgen_ty_171 = 50;
pub const TCA_FLOWER_KEY_ICMPV4_TYPE: _bindgen_ty_171 = 51;
pub const TCA_FLOWER_KEY_ICMPV4_TYPE_MASK: _bindgen_ty_171 = 52;
pub const TCA_FLOWER_KEY_ICMPV6_CODE: _bindgen_ty_171 = 53;
pub const TCA_FLOWER_KEY_ICMPV6_CODE_MASK: _bindgen_ty_171 = 54;
pub const TCA_FLOWER_KEY_ICMPV6_TYPE: _bindgen_ty_171 = 55;
pub const TCA_FLOWER_KEY_ICMPV6_TYPE_MASK: _bindgen_ty_171 = 56;
pub const TCA_FLOWER_KEY_ARP_SIP: _bindgen_ty_171 = 57;
pub const TCA_FLOWER_KEY_ARP_SIP_MASK: _bindgen_ty_171 = 58;
pub const TCA_FLOWER_KEY_ARP_TIP: _bindgen_ty_171 = 59;
pub const TCA_FLOWER_KEY_ARP_TIP_MASK: _bindgen_ty_171 = 60;
pub const TCA_FLOWER_KEY_ARP_OP: _bindgen_ty_171 = 61;
pub const TCA_FLOWER_KEY_ARP_OP_MASK: _bindgen_ty_171 = 62;
pub const TCA_FLOWER_KEY_ARP_SHA: _bindgen_ty_171 = 63;
pub const TCA_FLOWER_KEY_ARP_SHA_MASK: _bindgen_ty_171 = 64;
pub const TCA_FLOWER_KEY_ARP_THA: _bindgen_ty_171 = 65;
pub const TCA_FLOWER_KEY_ARP_THA_MASK: _bindgen_ty_171 = 66;
pub const TCA_FLOWER_KEY_MPLS_TTL: _bindgen_ty_171 = 67;
pub const TCA_FLOWER_KEY_MPLS_BOS: _bindgen_ty_171 = 68;
pub const TCA_FLOWER_KEY_MPLS_TC: _bindgen_ty_171 = 69;
pub const TCA_FLOWER_KEY_MPLS_LABEL: _bindgen_ty_171 = 70;
pub const TCA_FLOWER_KEY_TCP_FLAGS: _bindgen_ty_171 = 71;
pub const TCA_FLOWER_KEY_TCP_FLAGS_MASK: _bindgen_ty_171 = 72;
pub const TCA_FLOWER_KEY_IP_TOS: _bindgen_ty_171 = 73;
pub const TCA_FLOWER_KEY_IP_TOS_MASK: _bindgen_ty_171 = 74;
pub const TCA_FLOWER_KEY_IP_TTL: _bindgen_ty_171 = 75;
pub const TCA_FLOWER_KEY_IP_TTL_MASK: _bindgen_ty_171 = 76;
pub const TCA_FLOWER_KEY_CVLAN_ID: _bindgen_ty_171 = 77;
pub const TCA_FLOWER_KEY_CVLAN_PRIO: _bindgen_ty_171 = 78;
pub const TCA_FLOWER_KEY_CVLAN_ETH_TYPE: _bindgen_ty_171 = 79;
pub const TCA_FLOWER_KEY_ENC_IP_TOS: _bindgen_ty_171 = 80;
pub const TCA_FLOWER_KEY_ENC_IP_TOS_MASK: _bindgen_ty_171 = 81;
pub const TCA_FLOWER_KEY_ENC_IP_TTL: _bindgen_ty_171 = 82;
pub const TCA_FLOWER_KEY_ENC_IP_TTL_MASK: _bindgen_ty_171 = 83;
pub const TCA_FLOWER_KEY_ENC_OPTS: _bindgen_ty_171 = 84;
pub const TCA_FLOWER_KEY_ENC_OPTS_MASK: _bindgen_ty_171 = 85;
pub const TCA_FLOWER_IN_HW_COUNT: _bindgen_ty_171 = 86;
pub const TCA_FLOWER_KEY_PORT_SRC_MIN: _bindgen_ty_171 = 87;
pub const TCA_FLOWER_KEY_PORT_SRC_MAX: _bindgen_ty_171 = 88;
pub const TCA_FLOWER_KEY_PORT_DST_MIN: _bindgen_ty_171 = 89;
pub const TCA_FLOWER_KEY_PORT_DST_MAX: _bindgen_ty_171 = 90;
pub const TCA_FLOWER_KEY_CT_STATE: _bindgen_ty_171 = 91;
pub const TCA_FLOWER_KEY_CT_STATE_MASK: _bindgen_ty_171 = 92;
pub const TCA_FLOWER_KEY_CT_ZONE: _bindgen_ty_171 = 93;
pub const TCA_FLOWER_KEY_CT_ZONE_MASK: _bindgen_ty_171 = 94;
pub const TCA_FLOWER_KEY_CT_MARK: _bindgen_ty_171 = 95;
pub const TCA_FLOWER_KEY_CT_MARK_MASK: _bindgen_ty_171 = 96;
pub const TCA_FLOWER_KEY_CT_LABELS: _bindgen_ty_171 = 97;
pub const TCA_FLOWER_KEY_CT_LABELS_MASK: _bindgen_ty_171 = 98;
pub const TCA_FLOWER_KEY_MPLS_OPTS: _bindgen_ty_171 = 99;
pub const TCA_FLOWER_KEY_HASH: _bindgen_ty_171 = 100;
pub const TCA_FLOWER_KEY_HASH_MASK: _bindgen_ty_171 = 101;
pub const TCA_FLOWER_KEY_NUM_OF_VLANS: _bindgen_ty_171 = 102;
pub const TCA_FLOWER_KEY_PPPOE_SID: _bindgen_ty_171 = 103;
pub const TCA_FLOWER_KEY_PPP_PROTO: _bindgen_ty_171 = 104;
pub const TCA_FLOWER_KEY_L2TPV3_SID: _bindgen_ty_171 = 105;
pub const TCA_FLOWER_L2_MISS: _bindgen_ty_171 = 106;
pub const TCA_FLOWER_KEY_CFM: _bindgen_ty_171 = 107;
pub const TCA_FLOWER_KEY_SPI: _bindgen_ty_171 = 108;
pub const TCA_FLOWER_KEY_SPI_MASK: _bindgen_ty_171 = 109;
pub const TCA_FLOWER_KEY_ENC_FLAGS: _bindgen_ty_171 = 110;
pub const TCA_FLOWER_KEY_ENC_FLAGS_MASK: _bindgen_ty_171 = 111;
pub const __TCA_FLOWER_MAX: _bindgen_ty_171 = 112;
pub type _bindgen_ty_171 = ffi::c_uint;
pub const TCA_FLOWER_KEY_CT_FLAGS_NEW: _bindgen_ty_172 = 1;
pub const TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED: _bindgen_ty_172 = 2;
pub const TCA_FLOWER_KEY_CT_FLAGS_RELATED: _bindgen_ty_172 = 4;
pub const TCA_FLOWER_KEY_CT_FLAGS_TRACKED: _bindgen_ty_172 = 8;
pub const TCA_FLOWER_KEY_CT_FLAGS_INVALID: _bindgen_ty_172 = 16;
pub const TCA_FLOWER_KEY_CT_FLAGS_REPLY: _bindgen_ty_172 = 32;
pub const __TCA_FLOWER_KEY_CT_FLAGS_MAX: _bindgen_ty_172 = 33;
pub type _bindgen_ty_172 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPTS_UNSPEC: _bindgen_ty_173 = 0;
pub const TCA_FLOWER_KEY_ENC_OPTS_GENEVE: _bindgen_ty_173 = 1;
pub const TCA_FLOWER_KEY_ENC_OPTS_VXLAN: _bindgen_ty_173 = 2;
pub const TCA_FLOWER_KEY_ENC_OPTS_ERSPAN: _bindgen_ty_173 = 3;
pub const TCA_FLOWER_KEY_ENC_OPTS_GTP: _bindgen_ty_173 = 4;
pub const TCA_FLOWER_KEY_ENC_OPTS_PFCP: _bindgen_ty_173 = 5;
pub const __TCA_FLOWER_KEY_ENC_OPTS_MAX: _bindgen_ty_173 = 6;
pub type _bindgen_ty_173 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC: _bindgen_ty_174 = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS: _bindgen_ty_174 = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE: _bindgen_ty_174 = 2;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA: _bindgen_ty_174 = 3;
pub const __TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX: _bindgen_ty_174 = 4;
pub type _bindgen_ty_174 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_VXLAN_UNSPEC: _bindgen_ty_175 = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP: _bindgen_ty_175 = 1;
pub const __TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX: _bindgen_ty_175 = 2;
pub type _bindgen_ty_175 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_UNSPEC: _bindgen_ty_176 = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER: _bindgen_ty_176 = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX: _bindgen_ty_176 = 2;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR: _bindgen_ty_176 = 3;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID: _bindgen_ty_176 = 4;
pub const __TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX: _bindgen_ty_176 = 5;
pub type _bindgen_ty_176 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_UNSPEC: _bindgen_ty_177 = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE: _bindgen_ty_177 = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_QFI: _bindgen_ty_177 = 2;
pub const __TCA_FLOWER_KEY_ENC_OPT_GTP_MAX: _bindgen_ty_177 = 3;
pub type _bindgen_ty_177 = ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_PFCP_UNSPEC: _bindgen_ty_178 = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_PFCP_TYPE: _bindgen_ty_178 = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_PFCP_SEID: _bindgen_ty_178 = 2;
pub const __TCA_FLOWER_KEY_ENC_OPT_PFCP_MAX: _bindgen_ty_178 = 3;
pub type _bindgen_ty_178 = ffi::c_uint;
pub const TCA_FLOWER_KEY_MPLS_OPTS_UNSPEC: _bindgen_ty_179 = 0;
pub const TCA_FLOWER_KEY_MPLS_OPTS_LSE: _bindgen_ty_179 = 1;
pub const __TCA_FLOWER_KEY_MPLS_OPTS_MAX: _bindgen_ty_179 = 2;
pub type _bindgen_ty_179 = ffi::c_uint;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_UNSPEC: _bindgen_ty_180 = 0;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH: _bindgen_ty_180 = 1;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL: _bindgen_ty_180 = 2;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS: _bindgen_ty_180 = 3;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_TC: _bindgen_ty_180 = 4;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL: _bindgen_ty_180 = 5;
pub const __TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX: _bindgen_ty_180 = 6;
pub type _bindgen_ty_180 = ffi::c_uint;
pub const TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT: _bindgen_ty_181 = 1;
pub const TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST: _bindgen_ty_181 = 2;
pub const TCA_FLOWER_KEY_FLAGS_TUNNEL_CSUM: _bindgen_ty_181 = 4;
pub const TCA_FLOWER_KEY_FLAGS_TUNNEL_DONT_FRAGMENT: _bindgen_ty_181 = 8;
pub const TCA_FLOWER_KEY_FLAGS_TUNNEL_OAM: _bindgen_ty_181 = 16;
pub const TCA_FLOWER_KEY_FLAGS_TUNNEL_CRIT_OPT: _bindgen_ty_181 = 32;
pub const __TCA_FLOWER_KEY_FLAGS_MAX: _bindgen_ty_181 = 33;
pub type _bindgen_ty_181 = ffi::c_uint;
pub const TCA_FLOWER_KEY_CFM_OPT_UNSPEC: _bindgen_ty_182 = 0;
pub const TCA_FLOWER_KEY_CFM_MD_LEVEL: _bindgen_ty_182 = 1;
pub const TCA_FLOWER_KEY_CFM_OPCODE: _bindgen_ty_182 = 2;
pub const __TCA_FLOWER_KEY_CFM_OPT_MAX: _bindgen_ty_182 = 3;
pub type _bindgen_ty_182 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_matchall_pcnt {
    pub rhit: __u64,
}
pub const TCA_MATCHALL_UNSPEC: _bindgen_ty_183 = 0;
pub const TCA_MATCHALL_CLASSID: _bindgen_ty_183 = 1;
pub const TCA_MATCHALL_ACT: _bindgen_ty_183 = 2;
pub const TCA_MATCHALL_FLAGS: _bindgen_ty_183 = 3;
pub const TCA_MATCHALL_PCNT: _bindgen_ty_183 = 4;
pub const TCA_MATCHALL_PAD: _bindgen_ty_183 = 5;
pub const __TCA_MATCHALL_MAX: _bindgen_ty_183 = 6;
pub type _bindgen_ty_183 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_ematch_tree_hdr {
    pub nmatches: __u16,
    pub progid: __u16,
}
pub const TCA_EMATCH_TREE_UNSPEC: _bindgen_ty_184 = 0;
pub const TCA_EMATCH_TREE_HDR: _bindgen_ty_184 = 1;
pub const TCA_EMATCH_TREE_LIST: _bindgen_ty_184 = 2;
pub const __TCA_EMATCH_TREE_MAX: _bindgen_ty_184 = 3;
pub type _bindgen_ty_184 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_ematch_hdr {
    pub matchid: __u16,
    pub kind: __u16,
    pub flags: __u16,
    pub pad: __u16,
}
pub const TCF_LAYER_LINK: _bindgen_ty_185 = 0;
pub const TCF_LAYER_NETWORK: _bindgen_ty_185 = 1;
pub const TCF_LAYER_TRANSPORT: _bindgen_ty_185 = 2;
pub const __TCF_LAYER_MAX: _bindgen_ty_185 = 3;
pub type _bindgen_ty_185 = ffi::c_uint;
pub const TCF_EM_PROG_TC: _bindgen_ty_186 = 0;
pub type _bindgen_ty_186 = ffi::c_uint;
pub const TCF_EM_OPND_EQ: _bindgen_ty_187 = 0;
pub const TCF_EM_OPND_GT: _bindgen_ty_187 = 1;
pub const TCF_EM_OPND_LT: _bindgen_ty_187 = 2;
pub type _bindgen_ty_187 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_control {
    pub thoff: u16_,
    pub addr_type: u16_,
    pub flags: u32_,
}
pub const flow_dissector_ctrl_flags_FLOW_DIS_IS_FRAGMENT: flow_dissector_ctrl_flags = 1;
pub const flow_dissector_ctrl_flags_FLOW_DIS_FIRST_FRAG: flow_dissector_ctrl_flags = 2;
pub const flow_dissector_ctrl_flags_FLOW_DIS_F_TUNNEL_CSUM: flow_dissector_ctrl_flags = 4;
pub const flow_dissector_ctrl_flags_FLOW_DIS_F_TUNNEL_DONT_FRAGMENT: flow_dissector_ctrl_flags = 8;
pub const flow_dissector_ctrl_flags_FLOW_DIS_F_TUNNEL_OAM: flow_dissector_ctrl_flags = 16;
pub const flow_dissector_ctrl_flags_FLOW_DIS_F_TUNNEL_CRIT_OPT: flow_dissector_ctrl_flags = 32;
pub const flow_dissector_ctrl_flags_FLOW_DIS_ENCAPSULATION: flow_dissector_ctrl_flags = 64;
pub type flow_dissector_ctrl_flags = ffi::c_uint;
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_GOOD: flow_dissect_ret = 0;
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_BAD: flow_dissect_ret = 1;
pub const flow_dissect_ret_FLOW_DISSECT_RET_PROTO_AGAIN: flow_dissect_ret = 2;
pub const flow_dissect_ret_FLOW_DISSECT_RET_IPPROTO_AGAIN: flow_dissect_ret = 3;
pub const flow_dissect_ret_FLOW_DISSECT_RET_CONTINUE: flow_dissect_ret = 4;
pub type flow_dissect_ret = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_basic {
    pub n_proto: __be16,
    pub ip_proto: u8_,
    pub padding: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tags {
    pub flow_label: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_vlan {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1,
    pub vlan_tpid: __be16,
    pub vlan_eth_type: __be16,
    pub padding: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1,
    pub vlan_tci: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn vlan_id(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_id(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_id_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_id_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_dei(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_dei(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_dei_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_dei_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_priority(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_priority(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_priority_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_priority_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vlan_id: u16_,
        vlan_dei: u16_,
        vlan_priority: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let vlan_id: u16 = unsafe { ::core::mem::transmute(vlan_id) };
            vlan_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vlan_dei: u16 = unsafe { ::core::mem::transmute(vlan_dei) };
            vlan_dei as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let vlan_priority: u16 = unsafe { ::core::mem::transmute(vlan_priority) };
            vlan_priority as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for flow_dissector_key_vlan__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_vlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_mpls_lse {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl flow_dissector_mpls_lse {
    #[inline]
    pub fn mpls_ttl(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_ttl(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_ttl_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_ttl_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_bos(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_bos(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_bos_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_bos_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_tc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_tc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_tc_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_tc_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_label(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_label(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_label_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_label_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mpls_ttl: u32_,
        mpls_bos: u32_,
        mpls_tc: u32_,
        mpls_label: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mpls_ttl: u32 = unsafe { ::core::mem::transmute(mpls_ttl) };
            mpls_ttl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mpls_bos: u32 = unsafe { ::core::mem::transmute(mpls_bos) };
            mpls_bos as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mpls_tc: u32 = unsafe { ::core::mem::transmute(mpls_tc) };
            mpls_tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let mpls_label: u32 = unsafe { ::core::mem::transmute(mpls_label) };
            mpls_label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_mpls {
    pub ls: [flow_dissector_mpls_lse; 7usize],
    pub used_lses: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_enc_opts {
    pub data: [u8_; 255usize],
    pub len: u8_,
    pub dst_opt_type: u32_,
}
impl Default for flow_dissector_key_enc_opts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_keyid {
    pub keyid: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ipv4_addrs {
    pub src: __be32,
    pub dst: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ipv6_addrs {
    pub src: in6_addr,
    pub dst: in6_addr,
}
impl Default for flow_dissector_key_ipv6_addrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tipc {
    pub key: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_addrs {
    pub __bindgen_anon_1: flow_dissector_key_addrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_addrs__bindgen_ty_1 {
    pub v4addrs: flow_dissector_key_ipv4_addrs,
    pub v6addrs: flow_dissector_key_ipv6_addrs,
    pub tipckey: flow_dissector_key_tipc,
}
impl Default for flow_dissector_key_addrs__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_addrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_arp {
    pub sip: __u32,
    pub tip: __u32,
    pub op: __u8,
    pub sha: [ffi::c_uchar; 6usize],
    pub tha: [ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports {
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports__bindgen_ty_1 {
    pub ports: __be32,
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1 {
    pub src: __be16,
    pub dst: __be16,
}
impl Default for flow_dissector_key_ports__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range {
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports_range__bindgen_ty_1 {
    pub tp: flow_dissector_key_ports,
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    pub tp_min: flow_dissector_key_ports,
    pub tp_max: flow_dissector_key_ports,
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports_range {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp {
    pub __bindgen_anon_1: flow_dissector_key_icmp__bindgen_ty_1,
    pub id: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp__bindgen_ty_1 {
    pub type_: u8_,
    pub code: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_eth_addrs {
    pub dst: [ffi::c_uchar; 6usize],
    pub src: [ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tcp {
    pub flags: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ip {
    pub tos: __u8,
    pub ttl: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_meta {
    pub ingress_ifindex: ffi::c_int,
    pub ingress_iftype: u16_,
    pub l2_miss: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ct {
    pub ct_state: u16_,
    pub ct_zone: u16_,
    pub ct_mark: u32_,
    pub ct_labels: [u32_; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_hash {
    pub hash: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_num_of_vlans {
    pub num_of_vlans: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_pppoe {
    pub session_id: __be16,
    pub ppp_proto: __be16,
    pub type_: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_l2tpv3 {
    pub session_id: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ipsec {
    pub spi: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_cfm {
    pub mdl_ver: u8_,
    pub opcode: u8_,
}
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CONTROL: flow_dissector_key_id = 0;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_BASIC: flow_dissector_key_id = 1;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV4_ADDRS: flow_dissector_key_id = 2;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV6_ADDRS: flow_dissector_key_id = 3;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS: flow_dissector_key_id = 4;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS_RANGE: flow_dissector_key_id = 5;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ICMP: flow_dissector_key_id = 6;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ETH_ADDRS: flow_dissector_key_id = 7;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TIPC: flow_dissector_key_id = 8;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ARP: flow_dissector_key_id = 9;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_VLAN: flow_dissector_key_id = 10;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_FLOW_LABEL: flow_dissector_key_id = 11;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_GRE_KEYID: flow_dissector_key_id = 12;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS_ENTROPY: flow_dissector_key_id = 13;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_KEYID: flow_dissector_key_id = 14;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS: flow_dissector_key_id = 15;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS: flow_dissector_key_id = 16;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_CONTROL: flow_dissector_key_id = 17;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_PORTS: flow_dissector_key_id = 18;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS: flow_dissector_key_id = 19;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TCP: flow_dissector_key_id = 20;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IP: flow_dissector_key_id = 21;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CVLAN: flow_dissector_key_id = 22;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IP: flow_dissector_key_id = 23;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_OPTS: flow_dissector_key_id = 24;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_META: flow_dissector_key_id = 25;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CT: flow_dissector_key_id = 26;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_HASH: flow_dissector_key_id = 27;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_NUM_OF_VLANS: flow_dissector_key_id = 28;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PPPOE: flow_dissector_key_id = 29;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_L2TPV3: flow_dissector_key_id = 30;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CFM: flow_dissector_key_id = 31;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPSEC: flow_dissector_key_id = 32;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MAX: flow_dissector_key_id = 33;
pub type flow_dissector_key_id = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key {
    pub key_id: flow_dissector_key_id,
    pub offset: usize,
}
impl Default for flow_dissector_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector {
    pub used_keys: ffi::c_ulonglong,
    pub offset: [ffi::c_ushort; 33usize],
}
impl Default for flow_dissector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_basic {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct flow_keys {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
    pub tags: flow_dissector_key_tags,
    pub vlan: flow_dissector_key_vlan,
    pub cvlan: flow_dissector_key_vlan,
    pub keyid: flow_dissector_key_keyid,
    pub ports: flow_dissector_key_ports,
    pub icmp: flow_dissector_key_icmp,
    pub addrs: flow_dissector_key_addrs,
}
impl Default for flow_keys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_digest {
    pub data: [u8_; 16usize],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_dissector {
    pub flow_keys: *mut bpf_flow_keys,
    pub skb: *const sk_buff,
    pub data: *const ffi::c_void,
    pub data_end: *const ffi::c_void,
}
impl Default for bpf_flow_dissector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_pkt {
    pub spkt_family: ffi::c_ushort,
    pub spkt_device: [ffi::c_uchar; 14usize],
    pub spkt_protocol: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_ll {
    pub sll_family: ffi::c_ushort,
    pub sll_protocol: __be16,
    pub sll_ifindex: ffi::c_int,
    pub sll_hatype: ffi::c_ushort,
    pub sll_pkttype: ffi::c_uchar,
    pub sll_halen: ffi::c_uchar,
    pub sll_addr: [ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats {
    pub tp_packets: ffi::c_uint,
    pub tp_drops: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats_v3 {
    pub tp_packets: ffi::c_uint,
    pub tp_drops: ffi::c_uint,
    pub tp_freeze_q_cnt: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_rollover_stats {
    pub tp_all: __u64,
    pub tp_huge: __u64,
    pub tp_failed: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_stats_u {
    pub stats1: tpacket_stats,
    pub stats3: tpacket_stats_v3,
}
impl Default for tpacket_stats_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_auxdata {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr {
    pub tp_status: ffi::c_ulong,
    pub tp_len: ffi::c_uint,
    pub tp_snaplen: ffi::c_uint,
    pub tp_mac: ffi::c_ushort,
    pub tp_net: ffi::c_ushort,
    pub tp_sec: ffi::c_uint,
    pub tp_usec: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket2_hdr {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: [__u8; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr_variant1 {
    pub tp_rxhash: __u32,
    pub tp_vlan_tci: __u32,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket3_hdr {
    pub tp_next_offset: __u32,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_snaplen: __u32,
    pub tp_len: __u32,
    pub tp_status: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub __bindgen_anon_1: tpacket3_hdr__bindgen_ty_1,
    pub tp_padding: [__u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket3_hdr__bindgen_ty_1 {
    pub hv1: tpacket_hdr_variant1,
}
impl Default for tpacket3_hdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tpacket3_hdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_bd_ts {
    pub ts_sec: ffi::c_uint,
    pub __bindgen_anon_1: tpacket_bd_ts__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_ts__bindgen_ty_1 {
    pub ts_usec: ffi::c_uint,
    pub ts_nsec: ffi::c_uint,
}
impl Default for tpacket_bd_ts__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tpacket_bd_ts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_hdr_v1 {
    pub block_status: __u32,
    pub num_pkts: __u32,
    pub offset_to_first_pkt: __u32,
    pub blk_len: __u32,
    pub seq_num: __u64,
    pub ts_first_pkt: tpacket_bd_ts,
    pub ts_last_pkt: tpacket_bd_ts,
}
impl Default for tpacket_hdr_v1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_header_u {
    pub bh1: tpacket_hdr_v1,
}
impl Default for tpacket_bd_header_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_block_desc {
    pub version: __u32,
    pub offset_to_priv: __u32,
    pub hdr: tpacket_bd_header_u,
}
impl Default for tpacket_block_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tpacket_versions_TPACKET_V1: tpacket_versions = 0;
pub const tpacket_versions_TPACKET_V2: tpacket_versions = 1;
pub const tpacket_versions_TPACKET_V3: tpacket_versions = 2;
pub type tpacket_versions = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req {
    pub tp_block_size: ffi::c_uint,
    pub tp_block_nr: ffi::c_uint,
    pub tp_frame_size: ffi::c_uint,
    pub tp_frame_nr: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req3 {
    pub tp_block_size: ffi::c_uint,
    pub tp_block_nr: ffi::c_uint,
    pub tp_frame_size: ffi::c_uint,
    pub tp_frame_nr: ffi::c_uint,
    pub tp_retire_blk_tov: ffi::c_uint,
    pub tp_sizeof_priv: ffi::c_uint,
    pub tp_feature_req_word: ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_req_u {
    pub req: tpacket_req,
    pub req3: tpacket_req3,
}
impl Default for tpacket_req_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct packet_mreq {
    pub mr_ifindex: ffi::c_int,
    pub mr_type: ffi::c_ushort,
    pub mr_alen: ffi::c_ushort,
    pub mr_address: [ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fanout_args {
    pub id: __u16,
    pub type_flags: __u16,
    pub max_num_members: __u32,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: ffi::c_int,
    pub flowic_iif: ffi::c_int,
    pub flowic_l3mdev: ffi::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_multipath_hash: __u32,
    pub flowic_tun_key: flowi_tunnel,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub type_: __u8,
}
impl Default for flowi_uli {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
impl Default for flowi4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
impl Default for flowi6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
}
impl Default for flowi__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flowi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const ip_conntrack_info_IP_CT_ESTABLISHED: ip_conntrack_info = 0;
pub const ip_conntrack_info_IP_CT_RELATED: ip_conntrack_info = 1;
pub const ip_conntrack_info_IP_CT_NEW: ip_conntrack_info = 2;
pub const ip_conntrack_info_IP_CT_IS_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_ESTABLISHED_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_RELATED_REPLY: ip_conntrack_info = 4;
pub const ip_conntrack_info_IP_CT_NUMBER: ip_conntrack_info = 5;
pub const ip_conntrack_info_IP_CT_UNTRACKED: ip_conntrack_info = 7;
pub type ip_conntrack_info = ffi::c_uint;
pub const ip_conntrack_status_IPS_EXPECTED_BIT: ip_conntrack_status = 0;
pub const ip_conntrack_status_IPS_EXPECTED: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY_BIT: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED_BIT: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_CONFIRMED_BIT: ip_conntrack_status = 3;
pub const ip_conntrack_status_IPS_CONFIRMED: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_SRC_NAT_BIT: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_SRC_NAT: ip_conntrack_status = 16;
pub const ip_conntrack_status_IPS_DST_NAT_BIT: ip_conntrack_status = 5;
pub const ip_conntrack_status_IPS_DST_NAT: ip_conntrack_status = 32;
pub const ip_conntrack_status_IPS_NAT_MASK: ip_conntrack_status = 48;
pub const ip_conntrack_status_IPS_SEQ_ADJUST_BIT: ip_conntrack_status = 6;
pub const ip_conntrack_status_IPS_SEQ_ADJUST: ip_conntrack_status = 64;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE_BIT: ip_conntrack_status = 7;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE: ip_conntrack_status = 128;
pub const ip_conntrack_status_IPS_DST_NAT_DONE_BIT: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_DST_NAT_DONE: ip_conntrack_status = 256;
pub const ip_conntrack_status_IPS_NAT_DONE_MASK: ip_conntrack_status = 384;
pub const ip_conntrack_status_IPS_DYING_BIT: ip_conntrack_status = 9;
pub const ip_conntrack_status_IPS_DYING: ip_conntrack_status = 512;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT_BIT: ip_conntrack_status = 10;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT: ip_conntrack_status = 1024;
pub const ip_conntrack_status_IPS_TEMPLATE_BIT: ip_conntrack_status = 11;
pub const ip_conntrack_status_IPS_TEMPLATE: ip_conntrack_status = 2048;
pub const ip_conntrack_status_IPS_UNTRACKED_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_UNTRACKED: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_NAT_CLASH_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_NAT_CLASH: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_HELPER_BIT: ip_conntrack_status = 13;
pub const ip_conntrack_status_IPS_HELPER: ip_conntrack_status = 8192;
pub const ip_conntrack_status_IPS_OFFLOAD_BIT: ip_conntrack_status = 14;
pub const ip_conntrack_status_IPS_OFFLOAD: ip_conntrack_status = 16384;
pub const ip_conntrack_status_IPS_HW_OFFLOAD_BIT: ip_conntrack_status = 15;
pub const ip_conntrack_status_IPS_HW_OFFLOAD: ip_conntrack_status = 32768;
pub const ip_conntrack_status_IPS_UNCHANGEABLE_MASK: ip_conntrack_status = 56313;
pub const ip_conntrack_status___IPS_MAX_BIT: ip_conntrack_status = 16;
pub type ip_conntrack_status = ffi::c_uint;
pub const ip_conntrack_events_IPCT_NEW: ip_conntrack_events = 0;
pub const ip_conntrack_events_IPCT_RELATED: ip_conntrack_events = 1;
pub const ip_conntrack_events_IPCT_DESTROY: ip_conntrack_events = 2;
pub const ip_conntrack_events_IPCT_REPLY: ip_conntrack_events = 3;
pub const ip_conntrack_events_IPCT_ASSURED: ip_conntrack_events = 4;
pub const ip_conntrack_events_IPCT_PROTOINFO: ip_conntrack_events = 5;
pub const ip_conntrack_events_IPCT_HELPER: ip_conntrack_events = 6;
pub const ip_conntrack_events_IPCT_MARK: ip_conntrack_events = 7;
pub const ip_conntrack_events_IPCT_SEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_NATSEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_SECMARK: ip_conntrack_events = 9;
pub const ip_conntrack_events_IPCT_LABEL: ip_conntrack_events = 10;
pub const ip_conntrack_events_IPCT_SYNPROXY: ip_conntrack_events = 11;
pub const ip_conntrack_events___IPCT_MAX: ip_conntrack_events = 12;
pub type ip_conntrack_events = ffi::c_uint;
pub const ip_conntrack_expect_events_IPEXP_NEW: ip_conntrack_expect_events = 0;
pub const ip_conntrack_expect_events_IPEXP_DESTROY: ip_conntrack_expect_events = 1;
pub type ip_conntrack_expect_events = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: ffi::c_uint,
    pub invalid: ffi::c_uint,
    pub insert: ffi::c_uint,
    pub insert_failed: ffi::c_uint,
    pub clash_resolve: ffi::c_uint,
    pub drop: ffi::c_uint,
    pub early_drop: ffi::c_uint,
    pub error: ffi::c_uint,
    pub expect_new: ffi::c_uint,
    pub expect_create: ffi::c_uint,
    pub expect_delete: ffi::c_uint,
    pub search_restart: ffi::c_uint,
    pub chaintoolong: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack {
    pub use_: refcount_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}

pub const skb_drop_reason_SKB_NOT_DROPPED_YET: skb_drop_reason = 0;
pub const skb_drop_reason_SKB_CONSUMED: skb_drop_reason = 1;
pub const skb_drop_reason_SKB_DROP_REASON_NOT_SPECIFIED: skb_drop_reason = 2;
pub const skb_drop_reason_SKB_DROP_REASON_NO_SOCKET: skb_drop_reason = 3;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_CLOSE: skb_drop_reason = 4;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_FILTER: skb_drop_reason = 5;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_RCVBUFF: skb_drop_reason = 6;
pub const skb_drop_reason_SKB_DROP_REASON_UNIX_DISCONNECT: skb_drop_reason = 7;
pub const skb_drop_reason_SKB_DROP_REASON_UNIX_SKIP_OOB: skb_drop_reason = 8;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_SMALL: skb_drop_reason = 9;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CSUM: skb_drop_reason = 10;
pub const skb_drop_reason_SKB_DROP_REASON_UDP_CSUM: skb_drop_reason = 11;
pub const skb_drop_reason_SKB_DROP_REASON_NETFILTER_DROP: skb_drop_reason = 12;
pub const skb_drop_reason_SKB_DROP_REASON_OTHERHOST: skb_drop_reason = 13;
pub const skb_drop_reason_SKB_DROP_REASON_IP_CSUM: skb_drop_reason = 14;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INHDR: skb_drop_reason = 15;
pub const skb_drop_reason_SKB_DROP_REASON_IP_RPFILTER: skb_drop_reason = 16;
pub const skb_drop_reason_SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST: skb_drop_reason = 17;
pub const skb_drop_reason_SKB_DROP_REASON_XFRM_POLICY: skb_drop_reason = 18;
pub const skb_drop_reason_SKB_DROP_REASON_IP_NOPROTO: skb_drop_reason = 19;
pub const skb_drop_reason_SKB_DROP_REASON_PROTO_MEM: skb_drop_reason = 20;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AUTH_HDR: skb_drop_reason = 21;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5NOTFOUND: skb_drop_reason = 22;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5UNEXPECTED: skb_drop_reason = 23;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5FAILURE: skb_drop_reason = 24;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AONOTFOUND: skb_drop_reason = 25;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOUNEXPECTED: skb_drop_reason = 26;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOKEYNOTFOUND: skb_drop_reason = 27;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOFAILURE: skb_drop_reason = 28;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_BACKLOG: skb_drop_reason = 29;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FLAGS: skb_drop_reason = 30;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ABORT_ON_DATA: skb_drop_reason = 31;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ZEROWINDOW: skb_drop_reason = 32;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_DATA: skb_drop_reason = 33;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OVERWINDOW: skb_drop_reason = 34;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFOMERGE: skb_drop_reason = 35;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_PAWS: skb_drop_reason = 36;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_PAWS_ACK: skb_drop_reason = 37;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_TW_PAWS: skb_drop_reason = 38;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_TSECR: skb_drop_reason = 39;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_LISTEN_OVERFLOW: skb_drop_reason = 40;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_SEQUENCE: skb_drop_reason = 41;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SEQUENCE: skb_drop_reason = 42;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_END_SEQUENCE: skb_drop_reason = 43;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_ACK_SEQUENCE: skb_drop_reason = 44;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RESET: skb_drop_reason = 45;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SYN: skb_drop_reason = 46;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CLOSE: skb_drop_reason = 47;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FASTOPEN: skb_drop_reason = 48;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_ACK: skb_drop_reason = 49;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_TOO_OLD_ACK: skb_drop_reason = 50;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ACK_UNSENT_DATA: skb_drop_reason = 51;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE: skb_drop_reason = 52;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_DROP: skb_drop_reason = 53;
pub const skb_drop_reason_SKB_DROP_REASON_IP_OUTNOROUTES: skb_drop_reason = 54;
pub const skb_drop_reason_SKB_DROP_REASON_BPF_CGROUP_EGRESS: skb_drop_reason = 55;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6DISABLED: skb_drop_reason = 56;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_CREATEFAIL: skb_drop_reason = 57;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_FAILED: skb_drop_reason = 58;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_QUEUEFULL: skb_drop_reason = 59;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_DEAD: skb_drop_reason = 60;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_HH_FILLFAIL: skb_drop_reason = 61;
pub const skb_drop_reason_SKB_DROP_REASON_TC_EGRESS: skb_drop_reason = 62;
pub const skb_drop_reason_SKB_DROP_REASON_SECURITY_HOOK: skb_drop_reason = 63;
pub const skb_drop_reason_SKB_DROP_REASON_QDISC_DROP: skb_drop_reason = 64;
pub const skb_drop_reason_SKB_DROP_REASON_QDISC_OVERLIMIT: skb_drop_reason = 65;
pub const skb_drop_reason_SKB_DROP_REASON_QDISC_CONGESTED: skb_drop_reason = 66;
pub const skb_drop_reason_SKB_DROP_REASON_CAKE_FLOOD: skb_drop_reason = 67;
pub const skb_drop_reason_SKB_DROP_REASON_FQ_BAND_LIMIT: skb_drop_reason = 68;
pub const skb_drop_reason_SKB_DROP_REASON_FQ_HORIZON_LIMIT: skb_drop_reason = 69;
pub const skb_drop_reason_SKB_DROP_REASON_FQ_FLOW_LIMIT: skb_drop_reason = 70;
pub const skb_drop_reason_SKB_DROP_REASON_CPU_BACKLOG: skb_drop_reason = 71;
pub const skb_drop_reason_SKB_DROP_REASON_XDP: skb_drop_reason = 72;
pub const skb_drop_reason_SKB_DROP_REASON_TC_INGRESS: skb_drop_reason = 73;
pub const skb_drop_reason_SKB_DROP_REASON_UNHANDLED_PROTO: skb_drop_reason = 74;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_CSUM: skb_drop_reason = 75;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_GSO_SEG: skb_drop_reason = 76;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_UCOPY_FAULT: skb_drop_reason = 77;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_HDR: skb_drop_reason = 78;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_READY: skb_drop_reason = 79;
pub const skb_drop_reason_SKB_DROP_REASON_FULL_RING: skb_drop_reason = 80;
pub const skb_drop_reason_SKB_DROP_REASON_NOMEM: skb_drop_reason = 81;
pub const skb_drop_reason_SKB_DROP_REASON_HDR_TRUNC: skb_drop_reason = 82;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_FILTER: skb_drop_reason = 83;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_TXFILTER: skb_drop_reason = 84;
pub const skb_drop_reason_SKB_DROP_REASON_ICMP_CSUM: skb_drop_reason = 85;
pub const skb_drop_reason_SKB_DROP_REASON_INVALID_PROTO: skb_drop_reason = 86;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INADDRERRORS: skb_drop_reason = 87;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INNOROUTES: skb_drop_reason = 88;
pub const skb_drop_reason_SKB_DROP_REASON_IP_LOCAL_SOURCE: skb_drop_reason = 89;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INVALID_SOURCE: skb_drop_reason = 90;
pub const skb_drop_reason_SKB_DROP_REASON_IP_LOCALNET: skb_drop_reason = 91;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INVALID_DEST: skb_drop_reason = 92;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_BIG: skb_drop_reason = 93;
pub const skb_drop_reason_SKB_DROP_REASON_DUP_FRAG: skb_drop_reason = 94;
pub const skb_drop_reason_SKB_DROP_REASON_FRAG_REASM_TIMEOUT: skb_drop_reason = 95;
pub const skb_drop_reason_SKB_DROP_REASON_FRAG_TOO_FAR: skb_drop_reason = 96;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MINTTL: skb_drop_reason = 97;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_BAD_EXTHDR: skb_drop_reason = 98;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_FRAG: skb_drop_reason = 99;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT: skb_drop_reason = 100;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_BAD_CODE: skb_drop_reason = 101;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS: skb_drop_reason = 102;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST: skb_drop_reason = 103;
pub const skb_drop_reason_SKB_DROP_REASON_QUEUE_PURGE: skb_drop_reason = 104;
pub const skb_drop_reason_SKB_DROP_REASON_TC_COOKIE_ERROR: skb_drop_reason = 105;
pub const skb_drop_reason_SKB_DROP_REASON_PACKET_SOCK_ERROR: skb_drop_reason = 106;
pub const skb_drop_reason_SKB_DROP_REASON_TC_CHAIN_NOTFOUND: skb_drop_reason = 107;
pub const skb_drop_reason_SKB_DROP_REASON_TC_RECLASSIFY_LOOP: skb_drop_reason = 108;
pub const skb_drop_reason_SKB_DROP_REASON_VXLAN_INVALID_HDR: skb_drop_reason = 109;
pub const skb_drop_reason_SKB_DROP_REASON_VXLAN_VNI_NOT_FOUND: skb_drop_reason = 110;
pub const skb_drop_reason_SKB_DROP_REASON_MAC_INVALID_SOURCE: skb_drop_reason = 111;
pub const skb_drop_reason_SKB_DROP_REASON_VXLAN_ENTRY_EXISTS: skb_drop_reason = 112;
pub const skb_drop_reason_SKB_DROP_REASON_NO_TX_TARGET: skb_drop_reason = 113;
pub const skb_drop_reason_SKB_DROP_REASON_IP_TUNNEL_ECN: skb_drop_reason = 114;
pub const skb_drop_reason_SKB_DROP_REASON_TUNNEL_TXINFO: skb_drop_reason = 115;
pub const skb_drop_reason_SKB_DROP_REASON_LOCAL_MAC: skb_drop_reason = 116;
pub const skb_drop_reason_SKB_DROP_REASON_ARP_PVLAN_DISABLE: skb_drop_reason = 117;
pub const skb_drop_reason_SKB_DROP_REASON_MAC_IEEE_MAC_CONTROL: skb_drop_reason = 118;
pub const skb_drop_reason_SKB_DROP_REASON_BRIDGE_INGRESS_STP_STATE: skb_drop_reason = 119;
pub const skb_drop_reason_SKB_DROP_REASON_CAN_RX_INVALID_FRAME: skb_drop_reason = 120;
pub const skb_drop_reason_SKB_DROP_REASON_CANFD_RX_INVALID_FRAME: skb_drop_reason = 121;
pub const skb_drop_reason_SKB_DROP_REASON_CANXL_RX_INVALID_FRAME: skb_drop_reason = 122;
pub const skb_drop_reason_SKB_DROP_REASON_PFMEMALLOC: skb_drop_reason = 123;
pub const skb_drop_reason_SKB_DROP_REASON_DUALPI2_STEP_DROP: skb_drop_reason = 124;
pub const skb_drop_reason_SKB_DROP_REASON_MAX: skb_drop_reason = 125;
pub const skb_drop_reason_SKB_DROP_REASON_SUBSYS_MASK: skb_drop_reason = 4294901760;
pub type skb_drop_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netmem_desc {
    pub _flags: ffi::c_ulong,
    pub pp_magic: ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ffi::c_ulong,
    pub dma_addr: ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for netmem_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const net_iov_type_NET_IOV_DMABUF: net_iov_type = 0;
pub const net_iov_type_NET_IOV_IOURING: net_iov_type = 1;
pub const net_iov_type_NET_IOV_MAX: net_iov_type = 18446744073709551615;
pub type net_iov_type = ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_iov {
    pub __bindgen_anon_1: net_iov__bindgen_ty_1,
    pub owner: *mut net_iov_area,
    pub type_: net_iov_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_iov__bindgen_ty_1 {
    pub desc: netmem_desc,
    pub __bindgen_anon_1: net_iov__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_iov__bindgen_ty_1__bindgen_ty_1 {
    pub _flags: ffi::c_ulong,
    pub pp_magic: ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ffi::c_ulong,
    pub dma_addr: ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for net_iov__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for net_iov__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for net_iov {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_iov_area {
    pub niovs: *mut net_iov,
    pub num_niovs: usize,
    pub base_virtual: ffi::c_ulong,
}
impl Default for net_iov_area {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type netmem_ref = ffi::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct napi_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_bridge_info {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub frag_max_size: __u16,
    pub physinif: ffi::c_int,
    pub physoutdev: *mut net_device,
    pub __bindgen_anon_1: nf_bridge_info__bindgen_ty_2,
}
pub const nf_bridge_info_BRNF_PROTO_UNCHANGED: nf_bridge_info__bindgen_ty_1 = 0;
pub const nf_bridge_info_BRNF_PROTO_8021Q: nf_bridge_info__bindgen_ty_1 = 1;
pub const nf_bridge_info_BRNF_PROTO_PPPOE: nf_bridge_info__bindgen_ty_1 = 2;
pub type nf_bridge_info__bindgen_ty_1 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_bridge_info__bindgen_ty_2 {
    pub ipv4_daddr: __be32,
    pub ipv6_daddr: in6_addr,
    pub neigh_header: [ffi::c_char; 8usize],
}
impl Default for nf_bridge_info__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nf_bridge_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl nf_bridge_info {
    #[inline]
    pub fn orig_proto(&self) -> nf_bridge_info__bindgen_ty_1 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_orig_proto(&mut self, val: nf_bridge_info__bindgen_ty_1) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn orig_proto_raw(this: *const Self) -> nf_bridge_info__bindgen_ty_1 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_orig_proto_raw(this: *mut Self, val: nf_bridge_info__bindgen_ty_1) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkt_otherhost(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_otherhost(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_otherhost_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_otherhost_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_prerouting(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_prerouting(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_prerouting_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_in_prerouting_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bridged_dnat(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bridged_dnat(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bridged_dnat_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bridged_dnat_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sabotage_in_done(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sabotage_in_done(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sabotage_in_done_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sabotage_in_done_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        orig_proto: nf_bridge_info__bindgen_ty_1,
        pkt_otherhost: u8_,
        in_prerouting: u8_,
        bridged_dnat: u8_,
        sabotage_in_done: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let orig_proto: u32 = unsafe { ::core::mem::transmute(orig_proto) };
            orig_proto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pkt_otherhost: u8 = unsafe { ::core::mem::transmute(pkt_otherhost) };
            pkt_otherhost as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_prerouting: u8 = unsafe { ::core::mem::transmute(in_prerouting) };
            in_prerouting as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bridged_dnat: u8 = unsafe { ::core::mem::transmute(bridged_dnat) };
            bridged_dnat as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sabotage_in_done: u8 = unsafe { ::core::mem::transmute(sabotage_in_done) };
            sabotage_in_done as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff_head__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1__bindgen_ty_1,
    pub list: sk_buff_head__bindgen_ty_1_sk_buff_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1_sk_buff_list {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1_sk_buff_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct skb_frag {
    pub netmem: netmem_ref,
    pub len: ffi::c_uint,
    pub offset: ffi::c_uint,
}
pub type skb_frag_t = skb_frag;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_hwtstamps {
    pub __bindgen_anon_1: skb_shared_hwtstamps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_hwtstamps__bindgen_ty_1 {
    pub hwtstamp: ktime_t,
    pub netdev_data: *mut ffi::c_void,
}
impl Default for skb_shared_hwtstamps__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for skb_shared_hwtstamps {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SKBTX_HW_TSTAMP_NOBPF: _bindgen_ty_188 = 1;
pub const SKBTX_SW_TSTAMP: _bindgen_ty_188 = 2;
pub const SKBTX_IN_PROGRESS: _bindgen_ty_188 = 4;
pub const SKBTX_COMPLETION_TSTAMP: _bindgen_ty_188 = 8;
pub const SKBTX_HW_TSTAMP_NETDEV: _bindgen_ty_188 = 32;
pub const SKBTX_SCHED_TSTAMP: _bindgen_ty_188 = 64;
pub const SKBTX_BPF: _bindgen_ty_188 = 128;
pub type _bindgen_ty_188 = ffi::c_uint;
pub const SKBFL_ZEROCOPY_ENABLE: _bindgen_ty_189 = 1;
pub const SKBFL_SHARED_FRAG: _bindgen_ty_189 = 2;
pub const SKBFL_PURE_ZEROCOPY: _bindgen_ty_189 = 4;
pub const SKBFL_DONT_ORPHAN: _bindgen_ty_189 = 8;
pub const SKBFL_MANAGED_FRAG_REFS: _bindgen_ty_189 = 16;
pub type _bindgen_ty_189 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info_ops {
    pub complete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ubuf_info, zerocopy_success: bool_),
    >,
    pub link_skb: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, uarg: *mut ubuf_info) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info {
    pub ops: *const ubuf_info_ops,
    pub refcnt: refcount_t,
    pub flags: u8_,
}
impl Default for ubuf_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc {
    pub ubuf: ubuf_info,
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1,
    pub mmp: ubuf_info_msgzc_mmpin,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ubuf_info_msgzc__bindgen_ty_1 {
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    pub desc: ffi::c_ulong,
    pub ctx: *mut ffi::c_void,
}
impl Default for ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    pub id: u32_,
    pub len: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bytelen: u32_,
}
impl ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn zerocopy(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_zerocopy(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zerocopy_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_zerocopy_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(zerocopy: u16_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zerocopy: u16 = unsafe { ::core::mem::transmute(zerocopy) };
            zerocopy as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for ubuf_info_msgzc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc_mmpin {
    pub user: *mut user_struct,
    pub num_pg: ffi::c_uint,
}
impl Default for ubuf_info_msgzc_mmpin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ubuf_info_msgzc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xsk_tx_metadata_compl {
    pub tx_timestamp: *mut __u64,
}
impl Default for xsk_tx_metadata_compl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_info {
    pub flags: __u8,
    pub meta_len: __u8,
    pub nr_frags: __u8,
    pub tx_flags: __u8,
    pub gso_size: ffi::c_ushort,
    pub gso_segs: ffi::c_ushort,
    pub frag_list: *mut sk_buff,
    pub __bindgen_anon_1: skb_shared_info__bindgen_ty_1,
    pub gso_type: ffi::c_uint,
    pub tskey: u32_,
    pub dataref: atomic_t,
    pub __bindgen_anon_2: skb_shared_info__bindgen_ty_2,
    pub frags: [skb_frag_t; 17usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_info__bindgen_ty_1 {
    pub hwtstamps: skb_shared_hwtstamps,
    pub xsk_meta: xsk_tx_metadata_compl,
}
impl Default for skb_shared_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_info__bindgen_ty_2 {
    pub __bindgen_anon_1: skb_shared_info__bindgen_ty_2__bindgen_ty_1,
    pub destructor_arg: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct skb_shared_info__bindgen_ty_2__bindgen_ty_1 {
    pub xdp_frags_size: u32_,
    pub xdp_frags_truesize: u32_,
}
impl Default for skb_shared_info__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for skb_shared_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SKB_FCLONE_UNAVAILABLE: _bindgen_ty_190 = 0;
pub const SKB_FCLONE_ORIG: _bindgen_ty_190 = 1;
pub const SKB_FCLONE_CLONE: _bindgen_ty_190 = 2;
pub type _bindgen_ty_190 = ffi::c_uint;
pub const SKB_GSO_TCPV4: _bindgen_ty_191 = 1;
pub const SKB_GSO_DODGY: _bindgen_ty_191 = 2;
pub const SKB_GSO_TCP_ECN: _bindgen_ty_191 = 4;
pub const SKB_GSO_TCP_FIXEDID: _bindgen_ty_191 = 8;
pub const SKB_GSO_TCPV6: _bindgen_ty_191 = 16;
pub const SKB_GSO_FCOE: _bindgen_ty_191 = 32;
pub const SKB_GSO_GRE: _bindgen_ty_191 = 64;
pub const SKB_GSO_GRE_CSUM: _bindgen_ty_191 = 128;
pub const SKB_GSO_IPXIP4: _bindgen_ty_191 = 256;
pub const SKB_GSO_IPXIP6: _bindgen_ty_191 = 512;
pub const SKB_GSO_UDP_TUNNEL: _bindgen_ty_191 = 1024;
pub const SKB_GSO_UDP_TUNNEL_CSUM: _bindgen_ty_191 = 2048;
pub const SKB_GSO_PARTIAL: _bindgen_ty_191 = 4096;
pub const SKB_GSO_TUNNEL_REMCSUM: _bindgen_ty_191 = 8192;
pub const SKB_GSO_SCTP: _bindgen_ty_191 = 16384;
pub const SKB_GSO_ESP: _bindgen_ty_191 = 32768;
pub const SKB_GSO_UDP: _bindgen_ty_191 = 65536;
pub const SKB_GSO_UDP_L4: _bindgen_ty_191 = 131072;
pub const SKB_GSO_FRAGLIST: _bindgen_ty_191 = 262144;
pub const SKB_GSO_TCP_ACCECN: _bindgen_ty_191 = 524288;
pub type _bindgen_ty_191 = ffi::c_uint;
pub type sk_buff_data_t = ffi::c_uint;
pub const skb_tstamp_type_SKB_CLOCK_REALTIME: skb_tstamp_type = 0;
pub const skb_tstamp_type_SKB_CLOCK_MONOTONIC: skb_tstamp_type = 1;
pub const skb_tstamp_type_SKB_CLOCK_TAI: skb_tstamp_type = 2;
pub const skb_tstamp_type___SKB_CLOCK_MAX: skb_tstamp_type = 2;
pub type skb_tstamp_type = ffi::c_uint;
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub sk: *mut sock,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub cb: [ffi::c_char; 48usize],
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub _nfct: ffi::c_ulong,
    pub len: ffi::c_uint,
    pub data_len: ffi::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub active_extensions: __u8,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut ffi::c_uchar,
    pub data: *mut ffi::c_uchar,
    pub truesize: ffi::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    pub ll_node: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: ffi::c_ulong,
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
}
impl Default for sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_3__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    pub _sk_redir: ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_3__bindgen_ty_1 {
    pub _skb_refdst: ffi::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
impl Default for sk_buff__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: __BindgenUnionField<sk_buff__bindgen_ty_4__bindgen_ty_1>,
    pub headers: __BindgenUnionField<sk_buff__bindgen_ty_4__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 14usize],
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __mono_tc_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub tc_index: __u16,
    pub alloc_cpu: u16_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: ffi::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3 {
    pub napi_id: ffi::c_uint,
    pub sender_cpu: ffi::c_uint,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_df_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_df_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_pending_confirm_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dst_pending_confirm_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_summed_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ip_summed_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ooo_okay_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ooo_okay_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        dst_pending_confirm: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tstamp_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tstamp_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tstamp_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tstamp_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_at_ingress_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tc_at_ingress_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_skip_classify_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tc_skip_classify_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remcsum_offload_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remcsum_offload_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_complete_sw_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_complete_sw_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_level_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_level_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_protocol_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_protocol_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_hash_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_hash_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sw_hash_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sw_hash_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wifi_acked_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wifi_acked_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wifi_acked_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wifi_acked_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_fcs_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_fcs_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encapsulation_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encapsulation_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encap_hdr_csum_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encap_hdr_csum_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ndisc_nodetype_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                17usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ndisc_nodetype_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipvs_property_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ipvs_property_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn redirected_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_redirected_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slow_gro_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slow_gro_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unreadable(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unreadable(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unreadable_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_unreadable_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        tstamp_type: __u8,
        tc_at_ingress: __u8,
        tc_skip_classify: __u8,
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        inner_protocol_type: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        redirected: __u8,
        slow_gro: __u8,
        unreadable: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tstamp_type: u8 = unsafe { ::core::mem::transmute(tstamp_type) };
            tstamp_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unreadable: u8 = unsafe { ::core::mem::transmute(unreadable) };
            unreadable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __mono_tc_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub tc_index: __u16,
    pub alloc_cpu: u16_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: ffi::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3 {
    pub napi_id: ffi::c_uint,
    pub sender_cpu: ffi::c_uint,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_df_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_df_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_pending_confirm_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dst_pending_confirm_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_summed_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ip_summed_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ooo_okay_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ooo_okay_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        dst_pending_confirm: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tstamp_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tstamp_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tstamp_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tstamp_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_at_ingress_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tc_at_ingress_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_skip_classify_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tc_skip_classify_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remcsum_offload_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remcsum_offload_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_complete_sw_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_complete_sw_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_level_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_level_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_protocol_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_protocol_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_hash_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_hash_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sw_hash_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sw_hash_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wifi_acked_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wifi_acked_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wifi_acked_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wifi_acked_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_fcs_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_fcs_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encapsulation_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encapsulation_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encap_hdr_csum_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encap_hdr_csum_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_csum_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ndisc_nodetype_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                17usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ndisc_nodetype_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipvs_property_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ipvs_property_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn redirected_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_redirected_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slow_gro_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slow_gro_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unreadable(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unreadable(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unreadable_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_unreadable_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        tstamp_type: __u8,
        tc_at_ingress: __u8,
        tc_skip_classify: __u8,
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        inner_protocol_type: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        redirected: __u8,
        slow_gro: __u8,
        unreadable: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tstamp_type: u8 = unsafe { ::core::mem::transmute(tstamp_type) };
            tstamp_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unreadable: u8 = unsafe { ::core::mem::transmute(unreadable) };
            unreadable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for sk_buff__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cloned_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cloned_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nohdr_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_nohdr_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fclone_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_fclone_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn peeked_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_peeked_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn head_frag_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_head_frag_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pfmemalloc_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pfmemalloc_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pp_recycle(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pp_recycle(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pp_recycle_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pp_recycle_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
        pp_recycle: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pp_recycle: u8 = unsafe { ::core::mem::transmute(pp_recycle) };
            pp_recycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_entry {
    _unused: [u8; 0],
}

#[repr(C)]
pub struct sk_buff_fclones {
    pub skb1: sk_buff,
    pub skb2: sk_buff,
    pub fclone_ref: refcount_t,
}
impl Default for sk_buff_fclones {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_seq_state {
    pub lower_offset: __u32,
    pub upper_offset: __u32,
    pub frag_idx: __u32,
    pub stepped_offset: __u32,
    pub root_skb: *mut sk_buff,
    pub cur_skb: *mut sk_buff,
    pub frag_data: *mut __u8,
    pub frag_off: __u32,
}
impl Default for skb_seq_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const pkt_hash_types_PKT_HASH_TYPE_NONE: pkt_hash_types = 0;
pub const pkt_hash_types_PKT_HASH_TYPE_L2: pkt_hash_types = 1;
pub const pkt_hash_types_PKT_HASH_TYPE_L3: pkt_hash_types = 2;
pub const pkt_hash_types_PKT_HASH_TYPE_L4: pkt_hash_types = 3;
pub type pkt_hash_types = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_devmem_dmabuf_binding {
    _unused: [u8; 0],
}

pub const skb_ext_id_SKB_EXT_BRIDGE_NF: skb_ext_id = 0;
pub const skb_ext_id_SKB_EXT_SEC_PATH: skb_ext_id = 1;
pub const skb_ext_id_SKB_EXT_NUM: skb_ext_id = 2;
pub type skb_ext_id = ffi::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 2usize],
    pub chunks: u8_,
    pub __bindgen_padding_0: u8,
    pub data: __IncompleteArrayField<ffi::c_char>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sec_path {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockptr_t {
    pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockptr_t__bindgen_ty_1 {
    pub kernel: *mut ffi::c_void,
    pub user: *mut ffi::c_void,
}
impl Default for sockptr_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sockptr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sockptr_t {
    #[inline]
    pub fn is_kernel(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_kernel(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_kernel_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_kernel_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
            is_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const socket_state_SS_FREE: socket_state = 0;
pub const socket_state_SS_UNCONNECTED: socket_state = 1;
pub const socket_state_SS_CONNECTING: socket_state = 2;
pub const socket_state_SS_CONNECTED: socket_state = 3;
pub const socket_state_SS_DISCONNECTING: socket_state = 4;
pub type socket_state = ffi::c_uint;
pub const socket_flags_SOCKWQ_ASYNC_NOSPACE: socket_flags = 0;
pub const socket_flags_SOCKWQ_ASYNC_WAITDATA: socket_flags = 1;
pub const socket_flags_SOCK_NOSPACE: socket_flags = 2;
pub const socket_flags_SOCK_SUPPORT_ZC: socket_flags = 3;
pub const socket_flags_SOCK_CUSTOM_SOCKOPT: socket_flags = 4;
pub type socket_flags = ffi::c_uint;
pub const sock_type_SOCK_STREAM: sock_type = 1;
pub const sock_type_SOCK_DGRAM: sock_type = 2;
pub const sock_type_SOCK_RAW: sock_type = 3;
pub const sock_type_SOCK_RDM: sock_type = 4;
pub const sock_type_SOCK_SEQPACKET: sock_type = 5;
pub const sock_type_SOCK_DCCP: sock_type = 6;
pub const sock_type_SOCK_PACKET: sock_type = 10;
pub type sock_type = ffi::c_uint;
pub const sock_shutdown_cmd_SHUT_RD: sock_shutdown_cmd = 0;
pub const sock_shutdown_cmd_SHUT_WR: sock_shutdown_cmd = 1;
pub const sock_shutdown_cmd_SHUT_RDWR: sock_shutdown_cmd = 2;
pub type sock_shutdown_cmd = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for socket_wq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state,
    pub type_: ffi::c_short,
    pub flags: ffi::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub __bindgen_padding_0: [u64; 3usize],
    pub wq: socket_wq,
}
impl Default for socket {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut ffi::c_char,
    pub data: *mut ffi::c_void,
}
impl Default for read_descriptor_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for read_descriptor_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: ffi::c_uint,
        arg4: usize,
    ) -> ffi::c_int,
>;
pub type skb_read_actor_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ffi::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto_ops {
    pub family: ffi::c_int,
    pub owner: *mut module,
    pub release: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> ffi::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            myaddr: *mut sockaddr,
            sockaddr_len: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            vaddr: *mut sockaddr,
            sockaddr_len: ffi::c_int,
            flags: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(sock1: *mut socket, sock2: *mut socket) -> ffi::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            newsock: *mut socket,
            arg: *mut proto_accept_arg,
        ) -> ffi::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            addr: *mut sockaddr,
            peer: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            wait: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, cmd: ffi::c_uint, arg: ffi::c_ulong) -> ffi::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, cmd: ffi::c_uint, arg: ffi::c_ulong) -> ffi::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            userstamp: *mut ffi::c_void,
            timeval: bool_,
            time32: bool_,
        ) -> ffi::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, len: ffi::c_int) -> ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, flags: ffi::c_int) -> ffi::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: ffi::c_int,
            optname: ffi::c_int,
            optval: sockptr_t,
            optlen: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: ffi::c_int,
            optname: ffi::c_int,
            optval: *mut ffi::c_char,
            optlen: *mut ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, sock: *mut socket)>,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, m: *mut msghdr, total_len: usize) -> ffi::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
            flags: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            vma: *mut vm_area_struct,
        ) -> ffi::c_int,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            ppos: *mut loff_t,
            pipe: *mut pipe_inode_info,
            len: usize,
            flags: ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket)>,
    pub set_peek_off:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, val: ffi::c_int) -> ffi::c_int>,
    pub peek_len: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> ffi::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            desc: *mut read_descriptor_t,
            recv_actor: sk_read_actor_t,
        ) -> ffi::c_int,
    >,
    pub read_skb: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, recv_actor: skb_read_actor_t) -> ffi::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, size: usize) -> ffi::c_int,
    >,
    pub set_rcvlowat:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, val: ffi::c_int) -> ffi::c_int>,
}
impl Default for proto_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_proto_family {
    pub family: ffi::c_int,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sock: *mut socket,
            protocol: ffi::c_int,
            kern: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub owner: *mut module,
}
impl Default for net_proto_family {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SOCK_WAKE_IO: _bindgen_ty_192 = 0;
pub const SOCK_WAKE_WAITD: _bindgen_ty_192 = 1;
pub const SOCK_WAKE_SPACE: _bindgen_ty_192 = 2;
pub const SOCK_WAKE_URG: _bindgen_ty_192 = 3;
pub type _bindgen_ty_192 = ffi::c_uint;

pub const kernel_read_file_id_READING_UNKNOWN: kernel_read_file_id = 0;
pub const kernel_read_file_id_READING_FIRMWARE: kernel_read_file_id = 1;
pub const kernel_read_file_id_READING_MODULE: kernel_read_file_id = 2;
pub const kernel_read_file_id_READING_KEXEC_IMAGE: kernel_read_file_id = 3;
pub const kernel_read_file_id_READING_KEXEC_INITRAMFS: kernel_read_file_id = 4;
pub const kernel_read_file_id_READING_POLICY: kernel_read_file_id = 5;
pub const kernel_read_file_id_READING_X509_CERTIFICATE: kernel_read_file_id = 6;
pub const kernel_read_file_id_READING_MAX_ID: kernel_read_file_id = 7;
pub type kernel_read_file_id = ffi::c_uint;

pub const bpf_cond_pseudo_jmp_BPF_MAY_GOTO: bpf_cond_pseudo_jmp = 0;
pub type bpf_cond_pseudo_jmp = ffi::c_uint;
pub const BPF_REG_0: _bindgen_ty_193 = 0;
pub const BPF_REG_1: _bindgen_ty_193 = 1;
pub const BPF_REG_2: _bindgen_ty_193 = 2;
pub const BPF_REG_3: _bindgen_ty_193 = 3;
pub const BPF_REG_4: _bindgen_ty_193 = 4;
pub const BPF_REG_5: _bindgen_ty_193 = 5;
pub const BPF_REG_6: _bindgen_ty_193 = 6;
pub const BPF_REG_7: _bindgen_ty_193 = 7;
pub const BPF_REG_8: _bindgen_ty_193 = 8;
pub const BPF_REG_9: _bindgen_ty_193 = 9;
pub const BPF_REG_10: _bindgen_ty_193 = 10;
pub const __MAX_BPF_REG: _bindgen_ty_193 = 11;
pub type _bindgen_ty_193 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub off: __s16,
    pub imm: __s32,
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_reg_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dst_reg_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_reg_raw(this: *const Self) -> __u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_src_reg_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_lpm_trie_key {
    pub prefixlen: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_lpm_trie_key_hdr {
    pub prefixlen: __u32,
}
#[repr(C)]
pub struct bpf_lpm_trie_key_u8 {
    pub __bindgen_anon_1: bpf_lpm_trie_key_u8__bindgen_ty_1,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_lpm_trie_key_u8__bindgen_ty_1 {
    pub hdr: bpf_lpm_trie_key_hdr,
    pub prefixlen: __u32,
}
impl Default for bpf_lpm_trie_key_u8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_lpm_trie_key_u8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_cgroup_storage_key {
    pub cgroup_inode_id: __u64,
    pub attach_type: __u32,
}
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ORDER_UNSPEC: bpf_cgroup_iter_order = 0;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_SELF_ONLY: bpf_cgroup_iter_order = 1;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_PRE: bpf_cgroup_iter_order = 2;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_POST: bpf_cgroup_iter_order = 3;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ANCESTORS_UP: bpf_cgroup_iter_order = 4;
pub type bpf_cgroup_iter_order = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter_link_info {
    pub map: bpf_iter_link_info__bindgen_ty_1,
    pub cgroup: bpf_iter_link_info__bindgen_ty_2,
    pub task: bpf_iter_link_info__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_1 {
    pub map_fd: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_2 {
    pub order: bpf_cgroup_iter_order,
    pub cgroup_fd: __u32,
    pub cgroup_id: __u64,
}
impl Default for bpf_iter_link_info__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_3 {
    pub tid: __u32,
    pub pid: __u32,
    pub pid_fd: __u32,
}
impl Default for bpf_iter_link_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_cmd_BPF_MAP_CREATE: bpf_cmd = 0;
pub const bpf_cmd_BPF_MAP_LOOKUP_ELEM: bpf_cmd = 1;
pub const bpf_cmd_BPF_MAP_UPDATE_ELEM: bpf_cmd = 2;
pub const bpf_cmd_BPF_MAP_DELETE_ELEM: bpf_cmd = 3;
pub const bpf_cmd_BPF_MAP_GET_NEXT_KEY: bpf_cmd = 4;
pub const bpf_cmd_BPF_PROG_LOAD: bpf_cmd = 5;
pub const bpf_cmd_BPF_OBJ_PIN: bpf_cmd = 6;
pub const bpf_cmd_BPF_OBJ_GET: bpf_cmd = 7;
pub const bpf_cmd_BPF_PROG_ATTACH: bpf_cmd = 8;
pub const bpf_cmd_BPF_PROG_DETACH: bpf_cmd = 9;
pub const bpf_cmd_BPF_PROG_TEST_RUN: bpf_cmd = 10;
pub const bpf_cmd_BPF_PROG_RUN: bpf_cmd = 10;
pub const bpf_cmd_BPF_PROG_GET_NEXT_ID: bpf_cmd = 11;
pub const bpf_cmd_BPF_MAP_GET_NEXT_ID: bpf_cmd = 12;
pub const bpf_cmd_BPF_PROG_GET_FD_BY_ID: bpf_cmd = 13;
pub const bpf_cmd_BPF_MAP_GET_FD_BY_ID: bpf_cmd = 14;
pub const bpf_cmd_BPF_OBJ_GET_INFO_BY_FD: bpf_cmd = 15;
pub const bpf_cmd_BPF_PROG_QUERY: bpf_cmd = 16;
pub const bpf_cmd_BPF_RAW_TRACEPOINT_OPEN: bpf_cmd = 17;
pub const bpf_cmd_BPF_BTF_LOAD: bpf_cmd = 18;
pub const bpf_cmd_BPF_BTF_GET_FD_BY_ID: bpf_cmd = 19;
pub const bpf_cmd_BPF_TASK_FD_QUERY: bpf_cmd = 20;
pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_ELEM: bpf_cmd = 21;
pub const bpf_cmd_BPF_MAP_FREEZE: bpf_cmd = 22;
pub const bpf_cmd_BPF_BTF_GET_NEXT_ID: bpf_cmd = 23;
pub const bpf_cmd_BPF_MAP_LOOKUP_BATCH: bpf_cmd = 24;
pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_BATCH: bpf_cmd = 25;
pub const bpf_cmd_BPF_MAP_UPDATE_BATCH: bpf_cmd = 26;
pub const bpf_cmd_BPF_MAP_DELETE_BATCH: bpf_cmd = 27;
pub const bpf_cmd_BPF_LINK_CREATE: bpf_cmd = 28;
pub const bpf_cmd_BPF_LINK_UPDATE: bpf_cmd = 29;
pub const bpf_cmd_BPF_LINK_GET_FD_BY_ID: bpf_cmd = 30;
pub const bpf_cmd_BPF_LINK_GET_NEXT_ID: bpf_cmd = 31;
pub const bpf_cmd_BPF_ENABLE_STATS: bpf_cmd = 32;
pub const bpf_cmd_BPF_ITER_CREATE: bpf_cmd = 33;
pub const bpf_cmd_BPF_LINK_DETACH: bpf_cmd = 34;
pub const bpf_cmd_BPF_PROG_BIND_MAP: bpf_cmd = 35;
pub const bpf_cmd_BPF_TOKEN_CREATE: bpf_cmd = 36;
pub const bpf_cmd_BPF_PROG_STREAM_READ_BY_FD: bpf_cmd = 37;
pub const bpf_cmd___MAX_BPF_CMD: bpf_cmd = 38;
pub type bpf_cmd = ffi::c_uint;
pub const bpf_map_type_BPF_MAP_TYPE_UNSPEC: bpf_map_type = 0;
pub const bpf_map_type_BPF_MAP_TYPE_HASH: bpf_map_type = 1;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY: bpf_map_type = 2;
pub const bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY: bpf_map_type = 3;
pub const bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY: bpf_map_type = 4;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH: bpf_map_type = 5;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY: bpf_map_type = 6;
pub const bpf_map_type_BPF_MAP_TYPE_STACK_TRACE: bpf_map_type = 7;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY: bpf_map_type = 8;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_HASH: bpf_map_type = 9;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH: bpf_map_type = 10;
pub const bpf_map_type_BPF_MAP_TYPE_LPM_TRIE: bpf_map_type = 11;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS: bpf_map_type = 12;
pub const bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS: bpf_map_type = 13;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP: bpf_map_type = 14;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKMAP: bpf_map_type = 15;
pub const bpf_map_type_BPF_MAP_TYPE_CPUMAP: bpf_map_type = 16;
pub const bpf_map_type_BPF_MAP_TYPE_XSKMAP: bpf_map_type = 17;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKHASH: bpf_map_type = 18;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED: bpf_map_type = 19;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE: bpf_map_type = 19;
pub const bpf_map_type_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: bpf_map_type = 20;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED: bpf_map_type = 21;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: bpf_map_type = 21;
pub const bpf_map_type_BPF_MAP_TYPE_QUEUE: bpf_map_type = 22;
pub const bpf_map_type_BPF_MAP_TYPE_STACK: bpf_map_type = 23;
pub const bpf_map_type_BPF_MAP_TYPE_SK_STORAGE: bpf_map_type = 24;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP_HASH: bpf_map_type = 25;
pub const bpf_map_type_BPF_MAP_TYPE_STRUCT_OPS: bpf_map_type = 26;
pub const bpf_map_type_BPF_MAP_TYPE_RINGBUF: bpf_map_type = 27;
pub const bpf_map_type_BPF_MAP_TYPE_INODE_STORAGE: bpf_map_type = 28;
pub const bpf_map_type_BPF_MAP_TYPE_TASK_STORAGE: bpf_map_type = 29;
pub const bpf_map_type_BPF_MAP_TYPE_BLOOM_FILTER: bpf_map_type = 30;
pub const bpf_map_type_BPF_MAP_TYPE_USER_RINGBUF: bpf_map_type = 31;
pub const bpf_map_type_BPF_MAP_TYPE_CGRP_STORAGE: bpf_map_type = 32;
pub const bpf_map_type_BPF_MAP_TYPE_ARENA: bpf_map_type = 33;
pub const bpf_map_type___MAX_BPF_MAP_TYPE: bpf_map_type = 34;
pub type bpf_map_type = ffi::c_uint;
pub const bpf_prog_type_BPF_PROG_TYPE_UNSPEC: bpf_prog_type = 0;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER: bpf_prog_type = 1;
pub const bpf_prog_type_BPF_PROG_TYPE_KPROBE: bpf_prog_type = 2;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS: bpf_prog_type = 3;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT: bpf_prog_type = 4;
pub const bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT: bpf_prog_type = 5;
pub const bpf_prog_type_BPF_PROG_TYPE_XDP: bpf_prog_type = 6;
pub const bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT: bpf_prog_type = 7;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB: bpf_prog_type = 8;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK: bpf_prog_type = 9;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_IN: bpf_prog_type = 10;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_OUT: bpf_prog_type = 11;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT: bpf_prog_type = 12;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS: bpf_prog_type = 13;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_SKB: bpf_prog_type = 14;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE: bpf_prog_type = 15;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_MSG: bpf_prog_type = 16;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT: bpf_prog_type = 17;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK_ADDR: bpf_prog_type = 18;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_SEG6LOCAL: bpf_prog_type = 19;
pub const bpf_prog_type_BPF_PROG_TYPE_LIRC_MODE2: bpf_prog_type = 20;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_REUSEPORT: bpf_prog_type = 21;
pub const bpf_prog_type_BPF_PROG_TYPE_FLOW_DISSECTOR: bpf_prog_type = 22;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SYSCTL: bpf_prog_type = 23;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: bpf_prog_type = 24;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCKOPT: bpf_prog_type = 25;
pub const bpf_prog_type_BPF_PROG_TYPE_TRACING: bpf_prog_type = 26;
pub const bpf_prog_type_BPF_PROG_TYPE_STRUCT_OPS: bpf_prog_type = 27;
pub const bpf_prog_type_BPF_PROG_TYPE_EXT: bpf_prog_type = 28;
pub const bpf_prog_type_BPF_PROG_TYPE_LSM: bpf_prog_type = 29;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_LOOKUP: bpf_prog_type = 30;
pub const bpf_prog_type_BPF_PROG_TYPE_SYSCALL: bpf_prog_type = 31;
pub const bpf_prog_type_BPF_PROG_TYPE_NETFILTER: bpf_prog_type = 32;
pub const bpf_prog_type___MAX_BPF_PROG_TYPE: bpf_prog_type = 33;
pub type bpf_prog_type = ffi::c_uint;
pub const bpf_attach_type_BPF_CGROUP_INET_INGRESS: bpf_attach_type = 0;
pub const bpf_attach_type_BPF_CGROUP_INET_EGRESS: bpf_attach_type = 1;
pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE: bpf_attach_type = 2;
pub const bpf_attach_type_BPF_CGROUP_SOCK_OPS: bpf_attach_type = 3;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_PARSER: bpf_attach_type = 4;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT: bpf_attach_type = 5;
pub const bpf_attach_type_BPF_CGROUP_DEVICE: bpf_attach_type = 6;
pub const bpf_attach_type_BPF_SK_MSG_VERDICT: bpf_attach_type = 7;
pub const bpf_attach_type_BPF_CGROUP_INET4_BIND: bpf_attach_type = 8;
pub const bpf_attach_type_BPF_CGROUP_INET6_BIND: bpf_attach_type = 9;
pub const bpf_attach_type_BPF_CGROUP_INET4_CONNECT: bpf_attach_type = 10;
pub const bpf_attach_type_BPF_CGROUP_INET6_CONNECT: bpf_attach_type = 11;
pub const bpf_attach_type_BPF_CGROUP_INET4_POST_BIND: bpf_attach_type = 12;
pub const bpf_attach_type_BPF_CGROUP_INET6_POST_BIND: bpf_attach_type = 13;
pub const bpf_attach_type_BPF_CGROUP_UDP4_SENDMSG: bpf_attach_type = 14;
pub const bpf_attach_type_BPF_CGROUP_UDP6_SENDMSG: bpf_attach_type = 15;
pub const bpf_attach_type_BPF_LIRC_MODE2: bpf_attach_type = 16;
pub const bpf_attach_type_BPF_FLOW_DISSECTOR: bpf_attach_type = 17;
pub const bpf_attach_type_BPF_CGROUP_SYSCTL: bpf_attach_type = 18;
pub const bpf_attach_type_BPF_CGROUP_UDP4_RECVMSG: bpf_attach_type = 19;
pub const bpf_attach_type_BPF_CGROUP_UDP6_RECVMSG: bpf_attach_type = 20;
pub const bpf_attach_type_BPF_CGROUP_GETSOCKOPT: bpf_attach_type = 21;
pub const bpf_attach_type_BPF_CGROUP_SETSOCKOPT: bpf_attach_type = 22;
pub const bpf_attach_type_BPF_TRACE_RAW_TP: bpf_attach_type = 23;
pub const bpf_attach_type_BPF_TRACE_FENTRY: bpf_attach_type = 24;
pub const bpf_attach_type_BPF_TRACE_FEXIT: bpf_attach_type = 25;
pub const bpf_attach_type_BPF_MODIFY_RETURN: bpf_attach_type = 26;
pub const bpf_attach_type_BPF_LSM_MAC: bpf_attach_type = 27;
pub const bpf_attach_type_BPF_TRACE_ITER: bpf_attach_type = 28;
pub const bpf_attach_type_BPF_CGROUP_INET4_GETPEERNAME: bpf_attach_type = 29;
pub const bpf_attach_type_BPF_CGROUP_INET6_GETPEERNAME: bpf_attach_type = 30;
pub const bpf_attach_type_BPF_CGROUP_INET4_GETSOCKNAME: bpf_attach_type = 31;
pub const bpf_attach_type_BPF_CGROUP_INET6_GETSOCKNAME: bpf_attach_type = 32;
pub const bpf_attach_type_BPF_XDP_DEVMAP: bpf_attach_type = 33;
pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_RELEASE: bpf_attach_type = 34;
pub const bpf_attach_type_BPF_XDP_CPUMAP: bpf_attach_type = 35;
pub const bpf_attach_type_BPF_SK_LOOKUP: bpf_attach_type = 36;
pub const bpf_attach_type_BPF_XDP: bpf_attach_type = 37;
pub const bpf_attach_type_BPF_SK_SKB_VERDICT: bpf_attach_type = 38;
pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT: bpf_attach_type = 39;
pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT_OR_MIGRATE: bpf_attach_type = 40;
pub const bpf_attach_type_BPF_PERF_EVENT: bpf_attach_type = 41;
pub const bpf_attach_type_BPF_TRACE_KPROBE_MULTI: bpf_attach_type = 42;
pub const bpf_attach_type_BPF_LSM_CGROUP: bpf_attach_type = 43;
pub const bpf_attach_type_BPF_STRUCT_OPS: bpf_attach_type = 44;
pub const bpf_attach_type_BPF_NETFILTER: bpf_attach_type = 45;
pub const bpf_attach_type_BPF_TCX_INGRESS: bpf_attach_type = 46;
pub const bpf_attach_type_BPF_TCX_EGRESS: bpf_attach_type = 47;
pub const bpf_attach_type_BPF_TRACE_UPROBE_MULTI: bpf_attach_type = 48;
pub const bpf_attach_type_BPF_CGROUP_UNIX_CONNECT: bpf_attach_type = 49;
pub const bpf_attach_type_BPF_CGROUP_UNIX_SENDMSG: bpf_attach_type = 50;
pub const bpf_attach_type_BPF_CGROUP_UNIX_RECVMSG: bpf_attach_type = 51;
pub const bpf_attach_type_BPF_CGROUP_UNIX_GETPEERNAME: bpf_attach_type = 52;
pub const bpf_attach_type_BPF_CGROUP_UNIX_GETSOCKNAME: bpf_attach_type = 53;
pub const bpf_attach_type_BPF_NETKIT_PRIMARY: bpf_attach_type = 54;
pub const bpf_attach_type_BPF_NETKIT_PEER: bpf_attach_type = 55;
pub const bpf_attach_type_BPF_TRACE_KPROBE_SESSION: bpf_attach_type = 56;
pub const bpf_attach_type_BPF_TRACE_UPROBE_SESSION: bpf_attach_type = 57;
pub const bpf_attach_type___MAX_BPF_ATTACH_TYPE: bpf_attach_type = 58;
pub type bpf_attach_type = ffi::c_uint;
pub const bpf_link_type_BPF_LINK_TYPE_UNSPEC: bpf_link_type = 0;
pub const bpf_link_type_BPF_LINK_TYPE_RAW_TRACEPOINT: bpf_link_type = 1;
pub const bpf_link_type_BPF_LINK_TYPE_TRACING: bpf_link_type = 2;
pub const bpf_link_type_BPF_LINK_TYPE_CGROUP: bpf_link_type = 3;
pub const bpf_link_type_BPF_LINK_TYPE_ITER: bpf_link_type = 4;
pub const bpf_link_type_BPF_LINK_TYPE_NETNS: bpf_link_type = 5;
pub const bpf_link_type_BPF_LINK_TYPE_XDP: bpf_link_type = 6;
pub const bpf_link_type_BPF_LINK_TYPE_PERF_EVENT: bpf_link_type = 7;
pub const bpf_link_type_BPF_LINK_TYPE_KPROBE_MULTI: bpf_link_type = 8;
pub const bpf_link_type_BPF_LINK_TYPE_STRUCT_OPS: bpf_link_type = 9;
pub const bpf_link_type_BPF_LINK_TYPE_NETFILTER: bpf_link_type = 10;
pub const bpf_link_type_BPF_LINK_TYPE_TCX: bpf_link_type = 11;
pub const bpf_link_type_BPF_LINK_TYPE_UPROBE_MULTI: bpf_link_type = 12;
pub const bpf_link_type_BPF_LINK_TYPE_NETKIT: bpf_link_type = 13;
pub const bpf_link_type_BPF_LINK_TYPE_SOCKMAP: bpf_link_type = 14;
pub const bpf_link_type___MAX_BPF_LINK_TYPE: bpf_link_type = 15;
pub type bpf_link_type = ffi::c_uint;
pub const bpf_perf_event_type_BPF_PERF_EVENT_UNSPEC: bpf_perf_event_type = 0;
pub const bpf_perf_event_type_BPF_PERF_EVENT_UPROBE: bpf_perf_event_type = 1;
pub const bpf_perf_event_type_BPF_PERF_EVENT_URETPROBE: bpf_perf_event_type = 2;
pub const bpf_perf_event_type_BPF_PERF_EVENT_KPROBE: bpf_perf_event_type = 3;
pub const bpf_perf_event_type_BPF_PERF_EVENT_KRETPROBE: bpf_perf_event_type = 4;
pub const bpf_perf_event_type_BPF_PERF_EVENT_TRACEPOINT: bpf_perf_event_type = 5;
pub const bpf_perf_event_type_BPF_PERF_EVENT_EVENT: bpf_perf_event_type = 6;
pub type bpf_perf_event_type = ffi::c_uint;
pub const BPF_F_KPROBE_MULTI_RETURN: _bindgen_ty_194 = 1;
pub type _bindgen_ty_194 = ffi::c_uint;
pub const BPF_F_UPROBE_MULTI_RETURN: _bindgen_ty_195 = 1;
pub type _bindgen_ty_195 = ffi::c_uint;
pub const bpf_addr_space_cast_BPF_ADDR_SPACE_CAST: bpf_addr_space_cast = 1;
pub type bpf_addr_space_cast = ffi::c_uint;
pub const BPF_ANY: _bindgen_ty_196 = 0;
pub const BPF_NOEXIST: _bindgen_ty_196 = 1;
pub const BPF_EXIST: _bindgen_ty_196 = 2;
pub const BPF_F_LOCK: _bindgen_ty_196 = 4;
pub type _bindgen_ty_196 = ffi::c_uint;
pub const BPF_F_NO_PREALLOC: _bindgen_ty_197 = 1;
pub const BPF_F_NO_COMMON_LRU: _bindgen_ty_197 = 2;
pub const BPF_F_NUMA_NODE: _bindgen_ty_197 = 4;
pub const BPF_F_RDONLY: _bindgen_ty_197 = 8;
pub const BPF_F_WRONLY: _bindgen_ty_197 = 16;
pub const BPF_F_STACK_BUILD_ID: _bindgen_ty_197 = 32;
pub const BPF_F_ZERO_SEED: _bindgen_ty_197 = 64;
pub const BPF_F_RDONLY_PROG: _bindgen_ty_197 = 128;
pub const BPF_F_WRONLY_PROG: _bindgen_ty_197 = 256;
pub const BPF_F_CLONE: _bindgen_ty_197 = 512;
pub const BPF_F_MMAPABLE: _bindgen_ty_197 = 1024;
pub const BPF_F_PRESERVE_ELEMS: _bindgen_ty_197 = 2048;
pub const BPF_F_INNER_MAP: _bindgen_ty_197 = 4096;
pub const BPF_F_LINK: _bindgen_ty_197 = 8192;
pub const BPF_F_PATH_FD: _bindgen_ty_197 = 16384;
pub const BPF_F_VTYPE_BTF_OBJ_FD: _bindgen_ty_197 = 32768;
pub const BPF_F_TOKEN_FD: _bindgen_ty_197 = 65536;
pub const BPF_F_SEGV_ON_FAULT: _bindgen_ty_197 = 131072;
pub const BPF_F_NO_USER_CONV: _bindgen_ty_197 = 262144;
pub type _bindgen_ty_197 = ffi::c_uint;
pub const bpf_stats_type_BPF_STATS_RUN_TIME: bpf_stats_type = 0;
pub type bpf_stats_type = ffi::c_uint;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_EMPTY: bpf_stack_build_id_status = 0;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_VALID: bpf_stack_build_id_status = 1;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_IP: bpf_stack_build_id_status = 2;
pub type bpf_stack_build_id_status = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stack_build_id {
    pub status: __s32,
    pub build_id: [ffi::c_uchar; 20usize],
    pub __bindgen_anon_1: bpf_stack_build_id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_stack_build_id__bindgen_ty_1 {
    pub offset: __u64,
    pub ip: __u64,
}
impl Default for bpf_stack_build_id__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_stack_build_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BPF_STREAM_STDOUT: _bindgen_ty_198 = 1;
pub const BPF_STREAM_STDERR: _bindgen_ty_198 = 2;
pub type _bindgen_ty_198 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub batch: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_5,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_6,
    pub test: bpf_attr__bindgen_ty_7,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_8,
    pub info: bpf_attr__bindgen_ty_9,
    pub query: bpf_attr__bindgen_ty_10,
    pub raw_tracepoint: bpf_attr__bindgen_ty_11,
    pub __bindgen_anon_7: bpf_attr__bindgen_ty_12,
    pub task_fd_query: bpf_attr__bindgen_ty_13,
    pub link_create: bpf_attr__bindgen_ty_14,
    pub link_update: bpf_attr__bindgen_ty_15,
    pub link_detach: bpf_attr__bindgen_ty_16,
    pub enable_stats: bpf_attr__bindgen_ty_17,
    pub iter_create: bpf_attr__bindgen_ty_18,
    pub prog_bind_map: bpf_attr__bindgen_ty_19,
    pub token_create: bpf_attr__bindgen_ty_20,
    pub prog_stream_read: bpf_attr__bindgen_ty_21,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [ffi::c_char; 16usize],
    pub map_ifindex: __u32,
    pub btf_fd: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub map_extra: __u64,
    pub value_type_btf_obj_fd: __s32,
    pub map_token_fd: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
}
impl Default for bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_3 {
    pub in_batch: __u64,
    pub out_batch: __u64,
    pub keys: __u64,
    pub values: __u64,
    pub count: __u32,
    pub map_fd: __u32,
    pub elem_flags: __u64,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_4 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [ffi::c_char; 16usize],
    pub prog_ifindex: __u32,
    pub expected_attach_type: __u32,
    pub prog_btf_fd: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub func_info_cnt: __u32,
    pub line_info_rec_size: __u32,
    pub line_info: __u64,
    pub line_info_cnt: __u32,
    pub attach_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_4__bindgen_ty_1,
    pub core_relo_cnt: __u32,
    pub fd_array: __u64,
    pub core_relos: __u64,
    pub core_relo_rec_size: __u32,
    pub log_true_size: __u32,
    pub prog_token_fd: __s32,
    pub fd_array_cnt: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    pub attach_prog_fd: __u32,
    pub attach_btf_obj_fd: __u32,
}
impl Default for bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_5 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
    pub file_flags: __u32,
    pub path_fd: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_6 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_6__bindgen_ty_1,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
    pub replace_bpf_fd: __u32,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_6__bindgen_ty_2,
    pub expected_revision: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_6__bindgen_ty_1 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
}
impl Default for bpf_attr__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_6__bindgen_ty_2 {
    pub relative_fd: __u32,
    pub relative_id: __u32,
}
impl Default for bpf_attr__bindgen_ty_6__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_7 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
    pub ctx_size_in: __u32,
    pub ctx_size_out: __u32,
    pub ctx_in: __u64,
    pub ctx_out: __u64,
    pub flags: __u32,
    pub cpu: __u32,
    pub batch_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_8 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_8__bindgen_ty_1,
    pub next_id: __u32,
    pub open_flags: __u32,
    pub fd_by_id_token_fd: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    pub btf_id: __u32,
    pub link_id: __u32,
}
impl Default for bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_9 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_10 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_10__bindgen_ty_1,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_10__bindgen_ty_2,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub prog_attach_flags: __u64,
    pub link_ids: __u64,
    pub link_attach_flags: __u64,
    pub revision: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_10__bindgen_ty_1 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
}
impl Default for bpf_attr__bindgen_ty_10__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_10__bindgen_ty_2 {
    pub prog_cnt: __u32,
    pub count: __u32,
}
impl Default for bpf_attr__bindgen_ty_10__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_attr__bindgen_ty_10 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_11 {
    pub name: __u64,
    pub prog_fd: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cookie: __u64,
}
impl bpf_attr__bindgen_ty_11 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_12 {
    pub btf: __u64,
    pub btf_log_buf: __u64,
    pub btf_size: __u32,
    pub btf_log_size: __u32,
    pub btf_log_level: __u32,
    pub btf_log_true_size: __u32,
    pub btf_flags: __u32,
    pub btf_token_fd: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_13 {
    pub pid: __u32,
    pub fd: __u32,
    pub flags: __u32,
    pub buf_len: __u32,
    pub buf: __u64,
    pub prog_id: __u32,
    pub fd_type: __u32,
    pub probe_offset: __u64,
    pub probe_addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_14__bindgen_ty_2,
    pub attach_type: __u32,
    pub flags: __u32,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_14__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub prog_fd: __u32,
    pub map_fd: __u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_3 {
    pub target_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1,
    pub perf_event: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2,
    pub kprobe_multi: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3,
    pub tracing: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4,
    pub netfilter: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5,
    pub tcx: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6,
    pub uprobe_multi: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_7,
    pub netkit: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8,
    pub cgroup: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1 {
    pub iter_info: __u64,
    pub iter_info_len: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2 {
    pub bpf_cookie: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3 {
    pub flags: __u32,
    pub cnt: __u32,
    pub syms: __u64,
    pub addrs: __u64,
    pub cookies: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4 {
    pub target_btf_id: __u32,
    pub cookie: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5 {
    pub pf: __u32,
    pub hooknum: __u32,
    pub priority: __s32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6__bindgen_ty_1,
    pub expected_revision: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6__bindgen_ty_1 {
    pub relative_fd: __u32,
    pub relative_id: __u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_7 {
    pub path: __u64,
    pub offsets: __u64,
    pub ref_ctr_offsets: __u64,
    pub cookies: __u64,
    pub cnt: __u32,
    pub flags: __u32,
    pub pid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8__bindgen_ty_1,
    pub expected_revision: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8__bindgen_ty_1 {
    pub relative_fd: __u32,
    pub relative_id: __u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9__bindgen_ty_1,
    pub expected_revision: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9__bindgen_ty_1 {
    pub relative_fd: __u32,
    pub relative_id: __u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_15 {
    pub link_fd: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_15__bindgen_ty_1,
    pub flags: __u32,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_15__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_15__bindgen_ty_1 {
    pub new_prog_fd: __u32,
    pub new_map_fd: __u32,
}
impl Default for bpf_attr__bindgen_ty_15__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_15__bindgen_ty_2 {
    pub old_prog_fd: __u32,
    pub old_map_fd: __u32,
}
impl Default for bpf_attr__bindgen_ty_15__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_attr__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_16 {
    pub link_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_17 {
    pub type_: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_18 {
    pub link_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_19 {
    pub prog_fd: __u32,
    pub map_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_20 {
    pub flags: __u32,
    pub bpffs_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_21 {
    pub stream_buf: __u64,
    pub stream_buf_len: __u32,
    pub stream_id: __u32,
    pub prog_fd: __u32,
}
impl Default for bpf_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_func_id_BPF_FUNC_unspec: bpf_func_id = 0;
pub const bpf_func_id_BPF_FUNC_map_lookup_elem: bpf_func_id = 1;
pub const bpf_func_id_BPF_FUNC_map_update_elem: bpf_func_id = 2;
pub const bpf_func_id_BPF_FUNC_map_delete_elem: bpf_func_id = 3;
pub const bpf_func_id_BPF_FUNC_probe_read: bpf_func_id = 4;
pub const bpf_func_id_BPF_FUNC_ktime_get_ns: bpf_func_id = 5;
pub const bpf_func_id_BPF_FUNC_trace_printk: bpf_func_id = 6;
pub const bpf_func_id_BPF_FUNC_get_prandom_u32: bpf_func_id = 7;
pub const bpf_func_id_BPF_FUNC_get_smp_processor_id: bpf_func_id = 8;
pub const bpf_func_id_BPF_FUNC_skb_store_bytes: bpf_func_id = 9;
pub const bpf_func_id_BPF_FUNC_l3_csum_replace: bpf_func_id = 10;
pub const bpf_func_id_BPF_FUNC_l4_csum_replace: bpf_func_id = 11;
pub const bpf_func_id_BPF_FUNC_tail_call: bpf_func_id = 12;
pub const bpf_func_id_BPF_FUNC_clone_redirect: bpf_func_id = 13;
pub const bpf_func_id_BPF_FUNC_get_current_pid_tgid: bpf_func_id = 14;
pub const bpf_func_id_BPF_FUNC_get_current_uid_gid: bpf_func_id = 15;
pub const bpf_func_id_BPF_FUNC_get_current_comm: bpf_func_id = 16;
pub const bpf_func_id_BPF_FUNC_get_cgroup_classid: bpf_func_id = 17;
pub const bpf_func_id_BPF_FUNC_skb_vlan_push: bpf_func_id = 18;
pub const bpf_func_id_BPF_FUNC_skb_vlan_pop: bpf_func_id = 19;
pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_key: bpf_func_id = 20;
pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_key: bpf_func_id = 21;
pub const bpf_func_id_BPF_FUNC_perf_event_read: bpf_func_id = 22;
pub const bpf_func_id_BPF_FUNC_redirect: bpf_func_id = 23;
pub const bpf_func_id_BPF_FUNC_get_route_realm: bpf_func_id = 24;
pub const bpf_func_id_BPF_FUNC_perf_event_output: bpf_func_id = 25;
pub const bpf_func_id_BPF_FUNC_skb_load_bytes: bpf_func_id = 26;
pub const bpf_func_id_BPF_FUNC_get_stackid: bpf_func_id = 27;
pub const bpf_func_id_BPF_FUNC_csum_diff: bpf_func_id = 28;
pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_opt: bpf_func_id = 29;
pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_opt: bpf_func_id = 30;
pub const bpf_func_id_BPF_FUNC_skb_change_proto: bpf_func_id = 31;
pub const bpf_func_id_BPF_FUNC_skb_change_type: bpf_func_id = 32;
pub const bpf_func_id_BPF_FUNC_skb_under_cgroup: bpf_func_id = 33;
pub const bpf_func_id_BPF_FUNC_get_hash_recalc: bpf_func_id = 34;
pub const bpf_func_id_BPF_FUNC_get_current_task: bpf_func_id = 35;
pub const bpf_func_id_BPF_FUNC_probe_write_user: bpf_func_id = 36;
pub const bpf_func_id_BPF_FUNC_current_task_under_cgroup: bpf_func_id = 37;
pub const bpf_func_id_BPF_FUNC_skb_change_tail: bpf_func_id = 38;
pub const bpf_func_id_BPF_FUNC_skb_pull_data: bpf_func_id = 39;
pub const bpf_func_id_BPF_FUNC_csum_update: bpf_func_id = 40;
pub const bpf_func_id_BPF_FUNC_set_hash_invalid: bpf_func_id = 41;
pub const bpf_func_id_BPF_FUNC_get_numa_node_id: bpf_func_id = 42;
pub const bpf_func_id_BPF_FUNC_skb_change_head: bpf_func_id = 43;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_head: bpf_func_id = 44;
pub const bpf_func_id_BPF_FUNC_probe_read_str: bpf_func_id = 45;
pub const bpf_func_id_BPF_FUNC_get_socket_cookie: bpf_func_id = 46;
pub const bpf_func_id_BPF_FUNC_get_socket_uid: bpf_func_id = 47;
pub const bpf_func_id_BPF_FUNC_set_hash: bpf_func_id = 48;
pub const bpf_func_id_BPF_FUNC_setsockopt: bpf_func_id = 49;
pub const bpf_func_id_BPF_FUNC_skb_adjust_room: bpf_func_id = 50;
pub const bpf_func_id_BPF_FUNC_redirect_map: bpf_func_id = 51;
pub const bpf_func_id_BPF_FUNC_sk_redirect_map: bpf_func_id = 52;
pub const bpf_func_id_BPF_FUNC_sock_map_update: bpf_func_id = 53;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_meta: bpf_func_id = 54;
pub const bpf_func_id_BPF_FUNC_perf_event_read_value: bpf_func_id = 55;
pub const bpf_func_id_BPF_FUNC_perf_prog_read_value: bpf_func_id = 56;
pub const bpf_func_id_BPF_FUNC_getsockopt: bpf_func_id = 57;
pub const bpf_func_id_BPF_FUNC_override_return: bpf_func_id = 58;
pub const bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set: bpf_func_id = 59;
pub const bpf_func_id_BPF_FUNC_msg_redirect_map: bpf_func_id = 60;
pub const bpf_func_id_BPF_FUNC_msg_apply_bytes: bpf_func_id = 61;
pub const bpf_func_id_BPF_FUNC_msg_cork_bytes: bpf_func_id = 62;
pub const bpf_func_id_BPF_FUNC_msg_pull_data: bpf_func_id = 63;
pub const bpf_func_id_BPF_FUNC_bind: bpf_func_id = 64;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_tail: bpf_func_id = 65;
pub const bpf_func_id_BPF_FUNC_skb_get_xfrm_state: bpf_func_id = 66;
pub const bpf_func_id_BPF_FUNC_get_stack: bpf_func_id = 67;
pub const bpf_func_id_BPF_FUNC_skb_load_bytes_relative: bpf_func_id = 68;
pub const bpf_func_id_BPF_FUNC_fib_lookup: bpf_func_id = 69;
pub const bpf_func_id_BPF_FUNC_sock_hash_update: bpf_func_id = 70;
pub const bpf_func_id_BPF_FUNC_msg_redirect_hash: bpf_func_id = 71;
pub const bpf_func_id_BPF_FUNC_sk_redirect_hash: bpf_func_id = 72;
pub const bpf_func_id_BPF_FUNC_lwt_push_encap: bpf_func_id = 73;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_store_bytes: bpf_func_id = 74;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_adjust_srh: bpf_func_id = 75;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_action: bpf_func_id = 76;
pub const bpf_func_id_BPF_FUNC_rc_repeat: bpf_func_id = 77;
pub const bpf_func_id_BPF_FUNC_rc_keydown: bpf_func_id = 78;
pub const bpf_func_id_BPF_FUNC_skb_cgroup_id: bpf_func_id = 79;
pub const bpf_func_id_BPF_FUNC_get_current_cgroup_id: bpf_func_id = 80;
pub const bpf_func_id_BPF_FUNC_get_local_storage: bpf_func_id = 81;
pub const bpf_func_id_BPF_FUNC_sk_select_reuseport: bpf_func_id = 82;
pub const bpf_func_id_BPF_FUNC_skb_ancestor_cgroup_id: bpf_func_id = 83;
pub const bpf_func_id_BPF_FUNC_sk_lookup_tcp: bpf_func_id = 84;
pub const bpf_func_id_BPF_FUNC_sk_lookup_udp: bpf_func_id = 85;
pub const bpf_func_id_BPF_FUNC_sk_release: bpf_func_id = 86;
pub const bpf_func_id_BPF_FUNC_map_push_elem: bpf_func_id = 87;
pub const bpf_func_id_BPF_FUNC_map_pop_elem: bpf_func_id = 88;
pub const bpf_func_id_BPF_FUNC_map_peek_elem: bpf_func_id = 89;
pub const bpf_func_id_BPF_FUNC_msg_push_data: bpf_func_id = 90;
pub const bpf_func_id_BPF_FUNC_msg_pop_data: bpf_func_id = 91;
pub const bpf_func_id_BPF_FUNC_rc_pointer_rel: bpf_func_id = 92;
pub const bpf_func_id_BPF_FUNC_spin_lock: bpf_func_id = 93;
pub const bpf_func_id_BPF_FUNC_spin_unlock: bpf_func_id = 94;
pub const bpf_func_id_BPF_FUNC_sk_fullsock: bpf_func_id = 95;
pub const bpf_func_id_BPF_FUNC_tcp_sock: bpf_func_id = 96;
pub const bpf_func_id_BPF_FUNC_skb_ecn_set_ce: bpf_func_id = 97;
pub const bpf_func_id_BPF_FUNC_get_listener_sock: bpf_func_id = 98;
pub const bpf_func_id_BPF_FUNC_skc_lookup_tcp: bpf_func_id = 99;
pub const bpf_func_id_BPF_FUNC_tcp_check_syncookie: bpf_func_id = 100;
pub const bpf_func_id_BPF_FUNC_sysctl_get_name: bpf_func_id = 101;
pub const bpf_func_id_BPF_FUNC_sysctl_get_current_value: bpf_func_id = 102;
pub const bpf_func_id_BPF_FUNC_sysctl_get_new_value: bpf_func_id = 103;
pub const bpf_func_id_BPF_FUNC_sysctl_set_new_value: bpf_func_id = 104;
pub const bpf_func_id_BPF_FUNC_strtol: bpf_func_id = 105;
pub const bpf_func_id_BPF_FUNC_strtoul: bpf_func_id = 106;
pub const bpf_func_id_BPF_FUNC_sk_storage_get: bpf_func_id = 107;
pub const bpf_func_id_BPF_FUNC_sk_storage_delete: bpf_func_id = 108;
pub const bpf_func_id_BPF_FUNC_send_signal: bpf_func_id = 109;
pub const bpf_func_id_BPF_FUNC_tcp_gen_syncookie: bpf_func_id = 110;
pub const bpf_func_id_BPF_FUNC_skb_output: bpf_func_id = 111;
pub const bpf_func_id_BPF_FUNC_probe_read_user: bpf_func_id = 112;
pub const bpf_func_id_BPF_FUNC_probe_read_kernel: bpf_func_id = 113;
pub const bpf_func_id_BPF_FUNC_probe_read_user_str: bpf_func_id = 114;
pub const bpf_func_id_BPF_FUNC_probe_read_kernel_str: bpf_func_id = 115;
pub const bpf_func_id_BPF_FUNC_tcp_send_ack: bpf_func_id = 116;
pub const bpf_func_id_BPF_FUNC_send_signal_thread: bpf_func_id = 117;
pub const bpf_func_id_BPF_FUNC_jiffies64: bpf_func_id = 118;
pub const bpf_func_id_BPF_FUNC_read_branch_records: bpf_func_id = 119;
pub const bpf_func_id_BPF_FUNC_get_ns_current_pid_tgid: bpf_func_id = 120;
pub const bpf_func_id_BPF_FUNC_xdp_output: bpf_func_id = 121;
pub const bpf_func_id_BPF_FUNC_get_netns_cookie: bpf_func_id = 122;
pub const bpf_func_id_BPF_FUNC_get_current_ancestor_cgroup_id: bpf_func_id = 123;
pub const bpf_func_id_BPF_FUNC_sk_assign: bpf_func_id = 124;
pub const bpf_func_id_BPF_FUNC_ktime_get_boot_ns: bpf_func_id = 125;
pub const bpf_func_id_BPF_FUNC_seq_printf: bpf_func_id = 126;
pub const bpf_func_id_BPF_FUNC_seq_write: bpf_func_id = 127;
pub const bpf_func_id_BPF_FUNC_sk_cgroup_id: bpf_func_id = 128;
pub const bpf_func_id_BPF_FUNC_sk_ancestor_cgroup_id: bpf_func_id = 129;
pub const bpf_func_id_BPF_FUNC_ringbuf_output: bpf_func_id = 130;
pub const bpf_func_id_BPF_FUNC_ringbuf_reserve: bpf_func_id = 131;
pub const bpf_func_id_BPF_FUNC_ringbuf_submit: bpf_func_id = 132;
pub const bpf_func_id_BPF_FUNC_ringbuf_discard: bpf_func_id = 133;
pub const bpf_func_id_BPF_FUNC_ringbuf_query: bpf_func_id = 134;
pub const bpf_func_id_BPF_FUNC_csum_level: bpf_func_id = 135;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp6_sock: bpf_func_id = 136;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_sock: bpf_func_id = 137;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_timewait_sock: bpf_func_id = 138;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_request_sock: bpf_func_id = 139;
pub const bpf_func_id_BPF_FUNC_skc_to_udp6_sock: bpf_func_id = 140;
pub const bpf_func_id_BPF_FUNC_get_task_stack: bpf_func_id = 141;
pub const bpf_func_id_BPF_FUNC_load_hdr_opt: bpf_func_id = 142;
pub const bpf_func_id_BPF_FUNC_store_hdr_opt: bpf_func_id = 143;
pub const bpf_func_id_BPF_FUNC_reserve_hdr_opt: bpf_func_id = 144;
pub const bpf_func_id_BPF_FUNC_inode_storage_get: bpf_func_id = 145;
pub const bpf_func_id_BPF_FUNC_inode_storage_delete: bpf_func_id = 146;
pub const bpf_func_id_BPF_FUNC_d_path: bpf_func_id = 147;
pub const bpf_func_id_BPF_FUNC_copy_from_user: bpf_func_id = 148;
pub const bpf_func_id_BPF_FUNC_snprintf_btf: bpf_func_id = 149;
pub const bpf_func_id_BPF_FUNC_seq_printf_btf: bpf_func_id = 150;
pub const bpf_func_id_BPF_FUNC_skb_cgroup_classid: bpf_func_id = 151;
pub const bpf_func_id_BPF_FUNC_redirect_neigh: bpf_func_id = 152;
pub const bpf_func_id_BPF_FUNC_per_cpu_ptr: bpf_func_id = 153;
pub const bpf_func_id_BPF_FUNC_this_cpu_ptr: bpf_func_id = 154;
pub const bpf_func_id_BPF_FUNC_redirect_peer: bpf_func_id = 155;
pub const bpf_func_id_BPF_FUNC_task_storage_get: bpf_func_id = 156;
pub const bpf_func_id_BPF_FUNC_task_storage_delete: bpf_func_id = 157;
pub const bpf_func_id_BPF_FUNC_get_current_task_btf: bpf_func_id = 158;
pub const bpf_func_id_BPF_FUNC_bprm_opts_set: bpf_func_id = 159;
pub const bpf_func_id_BPF_FUNC_ktime_get_coarse_ns: bpf_func_id = 160;
pub const bpf_func_id_BPF_FUNC_ima_inode_hash: bpf_func_id = 161;
pub const bpf_func_id_BPF_FUNC_sock_from_file: bpf_func_id = 162;
pub const bpf_func_id_BPF_FUNC_check_mtu: bpf_func_id = 163;
pub const bpf_func_id_BPF_FUNC_for_each_map_elem: bpf_func_id = 164;
pub const bpf_func_id_BPF_FUNC_snprintf: bpf_func_id = 165;
pub const bpf_func_id_BPF_FUNC_sys_bpf: bpf_func_id = 166;
pub const bpf_func_id_BPF_FUNC_btf_find_by_name_kind: bpf_func_id = 167;
pub const bpf_func_id_BPF_FUNC_sys_close: bpf_func_id = 168;
pub const bpf_func_id_BPF_FUNC_timer_init: bpf_func_id = 169;
pub const bpf_func_id_BPF_FUNC_timer_set_callback: bpf_func_id = 170;
pub const bpf_func_id_BPF_FUNC_timer_start: bpf_func_id = 171;
pub const bpf_func_id_BPF_FUNC_timer_cancel: bpf_func_id = 172;
pub const bpf_func_id_BPF_FUNC_get_func_ip: bpf_func_id = 173;
pub const bpf_func_id_BPF_FUNC_get_attach_cookie: bpf_func_id = 174;
pub const bpf_func_id_BPF_FUNC_task_pt_regs: bpf_func_id = 175;
pub const bpf_func_id_BPF_FUNC_get_branch_snapshot: bpf_func_id = 176;
pub const bpf_func_id_BPF_FUNC_trace_vprintk: bpf_func_id = 177;
pub const bpf_func_id_BPF_FUNC_skc_to_unix_sock: bpf_func_id = 178;
pub const bpf_func_id_BPF_FUNC_kallsyms_lookup_name: bpf_func_id = 179;
pub const bpf_func_id_BPF_FUNC_find_vma: bpf_func_id = 180;
pub const bpf_func_id_BPF_FUNC_loop: bpf_func_id = 181;
pub const bpf_func_id_BPF_FUNC_strncmp: bpf_func_id = 182;
pub const bpf_func_id_BPF_FUNC_get_func_arg: bpf_func_id = 183;
pub const bpf_func_id_BPF_FUNC_get_func_ret: bpf_func_id = 184;
pub const bpf_func_id_BPF_FUNC_get_func_arg_cnt: bpf_func_id = 185;
pub const bpf_func_id_BPF_FUNC_get_retval: bpf_func_id = 186;
pub const bpf_func_id_BPF_FUNC_set_retval: bpf_func_id = 187;
pub const bpf_func_id_BPF_FUNC_xdp_get_buff_len: bpf_func_id = 188;
pub const bpf_func_id_BPF_FUNC_xdp_load_bytes: bpf_func_id = 189;
pub const bpf_func_id_BPF_FUNC_xdp_store_bytes: bpf_func_id = 190;
pub const bpf_func_id_BPF_FUNC_copy_from_user_task: bpf_func_id = 191;
pub const bpf_func_id_BPF_FUNC_skb_set_tstamp: bpf_func_id = 192;
pub const bpf_func_id_BPF_FUNC_ima_file_hash: bpf_func_id = 193;
pub const bpf_func_id_BPF_FUNC_kptr_xchg: bpf_func_id = 194;
pub const bpf_func_id_BPF_FUNC_map_lookup_percpu_elem: bpf_func_id = 195;
pub const bpf_func_id_BPF_FUNC_skc_to_mptcp_sock: bpf_func_id = 196;
pub const bpf_func_id_BPF_FUNC_dynptr_from_mem: bpf_func_id = 197;
pub const bpf_func_id_BPF_FUNC_ringbuf_reserve_dynptr: bpf_func_id = 198;
pub const bpf_func_id_BPF_FUNC_ringbuf_submit_dynptr: bpf_func_id = 199;
pub const bpf_func_id_BPF_FUNC_ringbuf_discard_dynptr: bpf_func_id = 200;
pub const bpf_func_id_BPF_FUNC_dynptr_read: bpf_func_id = 201;
pub const bpf_func_id_BPF_FUNC_dynptr_write: bpf_func_id = 202;
pub const bpf_func_id_BPF_FUNC_dynptr_data: bpf_func_id = 203;
pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv4: bpf_func_id = 204;
pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv6: bpf_func_id = 205;
pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv4: bpf_func_id = 206;
pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv6: bpf_func_id = 207;
pub const bpf_func_id_BPF_FUNC_ktime_get_tai_ns: bpf_func_id = 208;
pub const bpf_func_id_BPF_FUNC_user_ringbuf_drain: bpf_func_id = 209;
pub const bpf_func_id_BPF_FUNC_cgrp_storage_get: bpf_func_id = 210;
pub const bpf_func_id_BPF_FUNC_cgrp_storage_delete: bpf_func_id = 211;
pub const bpf_func_id___BPF_FUNC_MAX_ID: bpf_func_id = 212;
pub type bpf_func_id = ffi::c_uint;
pub const BPF_F_RECOMPUTE_CSUM: _bindgen_ty_199 = 1;
pub const BPF_F_INVALIDATE_HASH: _bindgen_ty_199 = 2;
pub type _bindgen_ty_199 = ffi::c_uint;
pub const BPF_F_HDR_FIELD_MASK: _bindgen_ty_200 = 15;
pub type _bindgen_ty_200 = ffi::c_uint;
pub const BPF_F_PSEUDO_HDR: _bindgen_ty_201 = 16;
pub const BPF_F_MARK_MANGLED_0: _bindgen_ty_201 = 32;
pub const BPF_F_MARK_ENFORCE: _bindgen_ty_201 = 64;
pub const BPF_F_IPV6: _bindgen_ty_201 = 128;
pub type _bindgen_ty_201 = ffi::c_uint;
pub const BPF_F_TUNINFO_IPV6: _bindgen_ty_202 = 1;
pub type _bindgen_ty_202 = ffi::c_uint;
pub const BPF_F_SKIP_FIELD_MASK: _bindgen_ty_203 = 255;
pub const BPF_F_USER_STACK: _bindgen_ty_203 = 256;
pub const BPF_F_FAST_STACK_CMP: _bindgen_ty_203 = 512;
pub const BPF_F_REUSE_STACKID: _bindgen_ty_203 = 1024;
pub const BPF_F_USER_BUILD_ID: _bindgen_ty_203 = 2048;
pub type _bindgen_ty_203 = ffi::c_uint;
pub const BPF_F_ZERO_CSUM_TX: _bindgen_ty_204 = 2;
pub const BPF_F_DONT_FRAGMENT: _bindgen_ty_204 = 4;
pub const BPF_F_SEQ_NUMBER: _bindgen_ty_204 = 8;
pub const BPF_F_NO_TUNNEL_KEY: _bindgen_ty_204 = 16;
pub type _bindgen_ty_204 = ffi::c_uint;
pub const BPF_F_TUNINFO_FLAGS: _bindgen_ty_205 = 16;
pub type _bindgen_ty_205 = ffi::c_uint;
pub const BPF_F_INDEX_MASK: _bindgen_ty_206 = 4294967295;
pub const BPF_F_CURRENT_CPU: _bindgen_ty_206 = 4294967295;
pub const BPF_F_CTXLEN_MASK: _bindgen_ty_206 = 4503595332403200;
pub type _bindgen_ty_206 = ffi::c_ulong;
pub const BPF_F_CURRENT_NETNS: _bindgen_ty_207 = -1;
pub type _bindgen_ty_207 = ffi::c_int;
pub const BPF_CSUM_LEVEL_QUERY: _bindgen_ty_208 = 0;
pub const BPF_CSUM_LEVEL_INC: _bindgen_ty_208 = 1;
pub const BPF_CSUM_LEVEL_DEC: _bindgen_ty_208 = 2;
pub const BPF_CSUM_LEVEL_RESET: _bindgen_ty_208 = 3;
pub type _bindgen_ty_208 = ffi::c_uint;
pub const BPF_F_ADJ_ROOM_FIXED_GSO: _bindgen_ty_209 = 1;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: _bindgen_ty_209 = 2;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: _bindgen_ty_209 = 4;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_GRE: _bindgen_ty_209 = 8;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_UDP: _bindgen_ty_209 = 16;
pub const BPF_F_ADJ_ROOM_NO_CSUM_RESET: _bindgen_ty_209 = 32;
pub const BPF_F_ADJ_ROOM_ENCAP_L2_ETH: _bindgen_ty_209 = 64;
pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV4: _bindgen_ty_209 = 128;
pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV6: _bindgen_ty_209 = 256;
pub type _bindgen_ty_209 = ffi::c_uint;
pub const BPF_ADJ_ROOM_ENCAP_L2_MASK: _bindgen_ty_210 = 255;
pub const BPF_ADJ_ROOM_ENCAP_L2_SHIFT: _bindgen_ty_210 = 56;
pub type _bindgen_ty_210 = ffi::c_uint;
pub const BPF_F_SYSCTL_BASE_NAME: _bindgen_ty_211 = 1;
pub type _bindgen_ty_211 = ffi::c_uint;
pub const BPF_LOCAL_STORAGE_GET_F_CREATE: _bindgen_ty_212 = 1;
pub const BPF_SK_STORAGE_GET_F_CREATE: _bindgen_ty_212 = 1;
pub type _bindgen_ty_212 = ffi::c_uint;
pub const BPF_F_GET_BRANCH_RECORDS_SIZE: _bindgen_ty_213 = 1;
pub type _bindgen_ty_213 = ffi::c_uint;
pub const BPF_RB_NO_WAKEUP: _bindgen_ty_214 = 1;
pub const BPF_RB_FORCE_WAKEUP: _bindgen_ty_214 = 2;
pub type _bindgen_ty_214 = ffi::c_uint;
pub const BPF_RB_AVAIL_DATA: _bindgen_ty_215 = 0;
pub const BPF_RB_RING_SIZE: _bindgen_ty_215 = 1;
pub const BPF_RB_CONS_POS: _bindgen_ty_215 = 2;
pub const BPF_RB_PROD_POS: _bindgen_ty_215 = 3;
pub type _bindgen_ty_215 = ffi::c_uint;
pub const BPF_RINGBUF_BUSY_BIT: _bindgen_ty_216 = 2147483648;
pub const BPF_RINGBUF_DISCARD_BIT: _bindgen_ty_216 = 1073741824;
pub const BPF_RINGBUF_HDR_SZ: _bindgen_ty_216 = 8;
pub type _bindgen_ty_216 = ffi::c_uint;
pub const BPF_SK_LOOKUP_F_REPLACE: _bindgen_ty_217 = 1;
pub const BPF_SK_LOOKUP_F_NO_REUSEPORT: _bindgen_ty_217 = 2;
pub type _bindgen_ty_217 = ffi::c_uint;
pub const bpf_adj_room_mode_BPF_ADJ_ROOM_NET: bpf_adj_room_mode = 0;
pub const bpf_adj_room_mode_BPF_ADJ_ROOM_MAC: bpf_adj_room_mode = 1;
pub type bpf_adj_room_mode = ffi::c_uint;
pub const bpf_hdr_start_off_BPF_HDR_START_MAC: bpf_hdr_start_off = 0;
pub const bpf_hdr_start_off_BPF_HDR_START_NET: bpf_hdr_start_off = 1;
pub type bpf_hdr_start_off = ffi::c_uint;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6: bpf_lwt_encap_mode = 0;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6_INLINE: bpf_lwt_encap_mode = 1;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_IP: bpf_lwt_encap_mode = 2;
pub type bpf_lwt_encap_mode = ffi::c_uint;
pub const BPF_F_BPRM_SECUREEXEC: _bindgen_ty_218 = 1;
pub type _bindgen_ty_218 = ffi::c_uint;
pub const BPF_F_INGRESS: _bindgen_ty_219 = 1;
pub const BPF_F_BROADCAST: _bindgen_ty_219 = 8;
pub const BPF_F_EXCLUDE_INGRESS: _bindgen_ty_219 = 16;
pub type _bindgen_ty_219 = ffi::c_uint;
pub const BPF_SKB_TSTAMP_UNSPEC: _bindgen_ty_220 = 0;
pub const BPF_SKB_TSTAMP_DELIVERY_MONO: _bindgen_ty_220 = 1;
pub const BPF_SKB_CLOCK_REALTIME: _bindgen_ty_220 = 0;
pub const BPF_SKB_CLOCK_MONOTONIC: _bindgen_ty_220 = 1;
pub const BPF_SKB_CLOCK_TAI: _bindgen_ty_220 = 2;
pub type _bindgen_ty_220 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sk_buff {
    pub len: __u32,
    pub pkt_type: __u32,
    pub mark: __u32,
    pub queue_mapping: __u32,
    pub protocol: __u32,
    pub vlan_present: __u32,
    pub vlan_tci: __u32,
    pub vlan_proto: __u32,
    pub priority: __u32,
    pub ingress_ifindex: __u32,
    pub ifindex: __u32,
    pub tc_index: __u32,
    pub cb: [__u32; 5usize],
    pub hash: __u32,
    pub tc_classid: __u32,
    pub data: __u32,
    pub data_end: __u32,
    pub napi_id: __u32,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub data_meta: __u32,
    pub __bindgen_anon_1: __sk_buff__bindgen_ty_1,
    pub tstamp: __u64,
    pub wire_len: __u32,
    pub gso_segs: __u32,
    pub __bindgen_anon_2: __sk_buff__bindgen_ty_2,
    pub gso_size: __u32,
    pub tstamp_type: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hwtstamp: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_1 {
    pub flow_keys: *mut bpf_flow_keys,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for __sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl __sk_buff__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for __sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl __sk_buff__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for __sk_buff {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl __sk_buff {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tunnel_key {
    pub tunnel_id: __u32,
    pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __u8,
    pub tunnel_ttl: __u8,
    pub __bindgen_anon_2: bpf_tunnel_key__bindgen_ty_2,
    pub tunnel_label: __u32,
    pub __bindgen_anon_3: bpf_tunnel_key__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
}
impl Default for bpf_tunnel_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_2 {
    pub tunnel_ext: __u16,
    pub tunnel_flags: __be16,
}
impl Default for bpf_tunnel_key__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_3 {
    pub local_ipv4: __u32,
    pub local_ipv6: [__u32; 4usize],
}
impl Default for bpf_tunnel_key__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_tunnel_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_xfrm_state {
    pub reqid: __u32,
    pub spi: __u32,
    pub family: __u16,
    pub ext: __u16,
    pub __bindgen_anon_1: bpf_xfrm_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_xfrm_state__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
}
impl Default for bpf_xfrm_state__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_xfrm_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_ret_code_BPF_OK: bpf_ret_code = 0;
pub const bpf_ret_code_BPF_DROP: bpf_ret_code = 2;
pub const bpf_ret_code_BPF_REDIRECT: bpf_ret_code = 7;
pub const bpf_ret_code_BPF_LWT_REROUTE: bpf_ret_code = 128;
pub const bpf_ret_code_BPF_FLOW_DISSECTOR_CONTINUE: bpf_ret_code = 129;
pub type bpf_ret_code = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock {
    pub bound_dev_if: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub mark: __u32,
    pub priority: __u32,
    pub src_ip4: __u32,
    pub src_ip6: [__u32; 4usize],
    pub src_port: __u32,
    pub dst_port: __be16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub dst_ip4: __u32,
    pub dst_ip6: [__u32; 4usize],
    pub state: __u32,
    pub rx_queue_mapping: __s32,
}
impl bpf_sock {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_tcp_sock {
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub dsack_dups: __u32,
    pub delivered: __u32,
    pub delivered_ce: __u32,
    pub icsk_retransmits: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_tuple {
    pub __bindgen_anon_1: bpf_sock_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_tuple__bindgen_ty_1 {
    pub ipv4: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub saddr: __be32,
    pub daddr: __be32,
    pub sport: __be16,
    pub dport: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
    pub saddr: [__be32; 4usize],
    pub daddr: [__be32; 4usize],
    pub sport: __be16,
    pub dport: __be16,
}
impl Default for bpf_sock_tuple__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_sock_tuple {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tcx_action_base_TCX_NEXT: tcx_action_base = -1;
pub const tcx_action_base_TCX_PASS: tcx_action_base = 0;
pub const tcx_action_base_TCX_DROP: tcx_action_base = 2;
pub const tcx_action_base_TCX_REDIRECT: tcx_action_base = 7;
pub type tcx_action_base = ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_xdp_sock {
    pub queue_id: __u32,
}
pub const xdp_action_XDP_ABORTED: xdp_action = 0;
pub const xdp_action_XDP_DROP: xdp_action = 1;
pub const xdp_action_XDP_PASS: xdp_action = 2;
pub const xdp_action_XDP_TX: xdp_action = 3;
pub const xdp_action_XDP_REDIRECT: xdp_action = 4;
pub type xdp_action = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xdp_md {
    pub data: __u32,
    pub data_end: __u32,
    pub data_meta: __u32,
    pub ingress_ifindex: __u32,
    pub rx_queue_index: __u32,
    pub egress_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_devmap_val {
    pub ifindex: __u32,
    pub bpf_prog: bpf_devmap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_devmap_val__bindgen_ty_1 {
    pub fd: ffi::c_int,
    pub id: __u32,
}
impl Default for bpf_devmap_val__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_devmap_val {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cpumap_val {
    pub qsize: __u32,
    pub bpf_prog: bpf_cpumap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cpumap_val__bindgen_ty_1 {
    pub fd: ffi::c_int,
    pub id: __u32,
}
impl Default for bpf_cpumap_val__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_cpumap_val {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const sk_action_SK_DROP: sk_action = 0;
pub const sk_action_SK_PASS: sk_action = 1;
pub type sk_action = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_msg_md {
    pub __bindgen_anon_1: sk_msg_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_msg_md__bindgen_ty_2,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub size: __u32,
    pub __bindgen_anon_3: sk_msg_md__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_1 {
    pub data: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_msg_md__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_msg_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_2 {
    pub data_end: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_msg_md__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_msg_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_3 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_msg_md__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_msg_md__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for sk_msg_md {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_reuseport_md {
    pub __bindgen_anon_1: sk_reuseport_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_reuseport_md__bindgen_ty_2,
    pub len: __u32,
    pub eth_protocol: __u32,
    pub ip_protocol: __u32,
    pub bind_inany: __u32,
    pub hash: __u32,
    pub __bindgen_anon_3: sk_reuseport_md__bindgen_ty_3,
    pub __bindgen_anon_4: sk_reuseport_md__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_1 {
    pub data: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_reuseport_md__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_reuseport_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_2 {
    pub data_end: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_reuseport_md__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_reuseport_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_3 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_reuseport_md__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_reuseport_md__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_4 {
    pub migrating_sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for sk_reuseport_md__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_reuseport_md__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for sk_reuseport_md {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_info {
    pub type_: __u32,
    pub id: __u32,
    pub tag: [__u8; 8usize],
    pub jited_prog_len: __u32,
    pub xlated_prog_len: __u32,
    pub jited_prog_insns: __u64,
    pub xlated_prog_insns: __u64,
    pub load_time: __u64,
    pub created_by_uid: __u32,
    pub nr_map_ids: __u32,
    pub map_ids: __u64,
    pub name: [ffi::c_char; 16usize],
    pub ifindex: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub netns_dev: __u64,
    pub netns_ino: __u64,
    pub nr_jited_ksyms: __u32,
    pub nr_jited_func_lens: __u32,
    pub jited_ksyms: __u64,
    pub jited_func_lens: __u64,
    pub btf_id: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub nr_func_info: __u32,
    pub nr_line_info: __u32,
    pub line_info: __u64,
    pub jited_line_info: __u64,
    pub nr_jited_line_info: __u32,
    pub line_info_rec_size: __u32,
    pub jited_line_info_rec_size: __u32,
    pub nr_prog_tags: __u32,
    pub prog_tags: __u64,
    pub run_time_ns: __u64,
    pub run_cnt: __u64,
    pub recursion_misses: __u64,
    pub verified_insns: __u32,
    pub attach_btf_obj_id: __u32,
    pub attach_btf_id: __u32,
}
impl bpf_prog_info {
    #[inline]
    pub fn gpl_compatible(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gpl_compatible_raw(this: *const Self) -> __u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gpl_compatible_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpl_compatible: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpl_compatible: u32 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_map_info {
    pub type_: __u32,
    pub id: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub name: [ffi::c_char; 16usize],
    pub ifindex: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub netns_dev: __u64,
    pub netns_ino: __u64,
    pub btf_id: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub btf_vmlinux_id: __u32,
    pub map_extra: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_btf_info {
    pub btf: __u64,
    pub btf_size: __u32,
    pub id: __u32,
    pub name: __u64,
    pub name_len: __u32,
    pub kernel_btf: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info {
    pub type_: __u32,
    pub id: __u32,
    pub prog_id: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1 {
    pub raw_tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_1,
    pub tracing: bpf_link_info__bindgen_ty_1__bindgen_ty_2,
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_3,
    pub iter: bpf_link_info__bindgen_ty_1__bindgen_ty_4,
    pub netns: bpf_link_info__bindgen_ty_1__bindgen_ty_5,
    pub xdp: bpf_link_info__bindgen_ty_1__bindgen_ty_6,
    pub struct_ops: bpf_link_info__bindgen_ty_1__bindgen_ty_7,
    pub netfilter: bpf_link_info__bindgen_ty_1__bindgen_ty_8,
    pub kprobe_multi: bpf_link_info__bindgen_ty_1__bindgen_ty_9,
    pub uprobe_multi: bpf_link_info__bindgen_ty_1__bindgen_ty_10,
    pub perf_event: bpf_link_info__bindgen_ty_1__bindgen_ty_11,
    pub tcx: bpf_link_info__bindgen_ty_1__bindgen_ty_12,
    pub netkit: bpf_link_info__bindgen_ty_1__bindgen_ty_13,
    pub sockmap: bpf_link_info__bindgen_ty_1__bindgen_ty_14,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub tp_name: __u64,
    pub tp_name_len: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cookie: __u64,
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub attach_type: __u32,
    pub target_obj_id: __u32,
    pub target_btf_id: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cookie: __u64,
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub cgroup_id: __u64,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_name: __u64,
    pub target_name_len: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub map: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub map_id: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    pub task: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    pub cgroup_id: __u64,
    pub order: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    pub tid: __u32,
    pub pid: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub netns_ino: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub ifindex: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_7 {
    pub map_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_8 {
    pub pf: __u32,
    pub hooknum: __u32,
    pub priority: __s32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_9 {
    pub addrs: __u64,
    pub count: __u32,
    pub flags: __u32,
    pub missed: __u64,
    pub cookies: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_10 {
    pub path: __u64,
    pub offsets: __u64,
    pub ref_ctr_offsets: __u64,
    pub cookies: __u64,
    pub path_size: __u32,
    pub count: __u32,
    pub flags: __u32,
    pub pid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_11 {
    pub type_: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1 {
    pub uprobe: bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_1,
    pub kprobe: bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_2,
    pub tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_3,
    pub event: bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_1 {
    pub file_name: __u64,
    pub name_len: __u32,
    pub offset: __u32,
    pub cookie: __u64,
    pub ref_ctr_offset: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_2 {
    pub func_name: __u64,
    pub name_len: __u32,
    pub offset: __u32,
    pub addr: __u64,
    pub missed: __u64,
    pub cookie: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_3 {
    pub tp_name: __u64,
    pub name_len: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cookie: __u64,
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_4 {
    pub config: __u64,
    pub type_: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cookie: __u64,
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_11 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_12 {
    pub ifindex: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_13 {
    pub ifindex: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_14 {
    pub map_id: __u32,
    pub attach_type: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_link_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_token_info {
    pub allowed_cmds: __u64,
    pub allowed_maps: __u64,
    pub allowed_progs: __u64,
    pub allowed_attachs: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_addr {
    pub user_family: __u32,
    pub user_ip4: __u32,
    pub user_ip6: [__u32; 4usize],
    pub user_port: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub msg_src_ip4: __u32,
    pub msg_src_ip6: [__u32; 4usize],
    pub __bindgen_anon_1: bpf_sock_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_addr__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sock_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sock_addr__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sock_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_ops {
    pub op: __u32,
    pub __bindgen_anon_1: bpf_sock_ops__bindgen_ty_1,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub is_fullsock: __u32,
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub bpf_sock_ops_cb_flags: __u32,
    pub state: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub sk_txhash: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub __bindgen_anon_2: bpf_sock_ops__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_sock_ops__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_sock_ops__bindgen_ty_4,
    pub skb_len: __u32,
    pub skb_tcp_flags: __u32,
    pub skb_hwtstamp: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_1 {
    pub args: [__u32; 4usize],
    pub reply: __u32,
    pub replylong: [__u32; 4usize],
}
impl Default for bpf_sock_ops__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sock_ops__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sock_ops__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_3 {
    pub skb_data: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sock_ops__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sock_ops__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_4 {
    pub skb_data_end: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sock_ops__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sock_ops__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sock_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BPF_SOCK_OPS_RTO_CB_FLAG: _bindgen_ty_221 = 1;
pub const BPF_SOCK_OPS_RETRANS_CB_FLAG: _bindgen_ty_221 = 2;
pub const BPF_SOCK_OPS_STATE_CB_FLAG: _bindgen_ty_221 = 4;
pub const BPF_SOCK_OPS_RTT_CB_FLAG: _bindgen_ty_221 = 8;
pub const BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: _bindgen_ty_221 = 16;
pub const BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: _bindgen_ty_221 = 32;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: _bindgen_ty_221 = 64;
pub const BPF_SOCK_OPS_ALL_CB_FLAGS: _bindgen_ty_221 = 127;
pub type _bindgen_ty_221 = ffi::c_uint;
pub const SK_BPF_CB_TX_TIMESTAMPING: _bindgen_ty_222 = 1;
pub const SK_BPF_CB_MASK: _bindgen_ty_222 = 1;
pub type _bindgen_ty_222 = ffi::c_uint;
pub const BPF_SOCK_OPS_VOID: _bindgen_ty_223 = 0;
pub const BPF_SOCK_OPS_TIMEOUT_INIT: _bindgen_ty_223 = 1;
pub const BPF_SOCK_OPS_RWND_INIT: _bindgen_ty_223 = 2;
pub const BPF_SOCK_OPS_TCP_CONNECT_CB: _bindgen_ty_223 = 3;
pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: _bindgen_ty_223 = 4;
pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: _bindgen_ty_223 = 5;
pub const BPF_SOCK_OPS_NEEDS_ECN: _bindgen_ty_223 = 6;
pub const BPF_SOCK_OPS_BASE_RTT: _bindgen_ty_223 = 7;
pub const BPF_SOCK_OPS_RTO_CB: _bindgen_ty_223 = 8;
pub const BPF_SOCK_OPS_RETRANS_CB: _bindgen_ty_223 = 9;
pub const BPF_SOCK_OPS_STATE_CB: _bindgen_ty_223 = 10;
pub const BPF_SOCK_OPS_TCP_LISTEN_CB: _bindgen_ty_223 = 11;
pub const BPF_SOCK_OPS_RTT_CB: _bindgen_ty_223 = 12;
pub const BPF_SOCK_OPS_PARSE_HDR_OPT_CB: _bindgen_ty_223 = 13;
pub const BPF_SOCK_OPS_HDR_OPT_LEN_CB: _bindgen_ty_223 = 14;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB: _bindgen_ty_223 = 15;
pub const BPF_SOCK_OPS_TSTAMP_SCHED_CB: _bindgen_ty_223 = 16;
pub const BPF_SOCK_OPS_TSTAMP_SND_SW_CB: _bindgen_ty_223 = 17;
pub const BPF_SOCK_OPS_TSTAMP_SND_HW_CB: _bindgen_ty_223 = 18;
pub const BPF_SOCK_OPS_TSTAMP_ACK_CB: _bindgen_ty_223 = 19;
pub const BPF_SOCK_OPS_TSTAMP_SENDMSG_CB: _bindgen_ty_223 = 20;
pub type _bindgen_ty_223 = ffi::c_uint;
pub const BPF_TCP_ESTABLISHED: _bindgen_ty_224 = 1;
pub const BPF_TCP_SYN_SENT: _bindgen_ty_224 = 2;
pub const BPF_TCP_SYN_RECV: _bindgen_ty_224 = 3;
pub const BPF_TCP_FIN_WAIT1: _bindgen_ty_224 = 4;
pub const BPF_TCP_FIN_WAIT2: _bindgen_ty_224 = 5;
pub const BPF_TCP_TIME_WAIT: _bindgen_ty_224 = 6;
pub const BPF_TCP_CLOSE: _bindgen_ty_224 = 7;
pub const BPF_TCP_CLOSE_WAIT: _bindgen_ty_224 = 8;
pub const BPF_TCP_LAST_ACK: _bindgen_ty_224 = 9;
pub const BPF_TCP_LISTEN: _bindgen_ty_224 = 10;
pub const BPF_TCP_CLOSING: _bindgen_ty_224 = 11;
pub const BPF_TCP_NEW_SYN_RECV: _bindgen_ty_224 = 12;
pub const BPF_TCP_BOUND_INACTIVE: _bindgen_ty_224 = 13;
pub const BPF_TCP_MAX_STATES: _bindgen_ty_224 = 14;
pub type _bindgen_ty_224 = ffi::c_uint;
pub const TCP_BPF_IW: _bindgen_ty_225 = 1001;
pub const TCP_BPF_SNDCWND_CLAMP: _bindgen_ty_225 = 1002;
pub const TCP_BPF_DELACK_MAX: _bindgen_ty_225 = 1003;
pub const TCP_BPF_RTO_MIN: _bindgen_ty_225 = 1004;
pub const TCP_BPF_SYN: _bindgen_ty_225 = 1005;
pub const TCP_BPF_SYN_IP: _bindgen_ty_225 = 1006;
pub const TCP_BPF_SYN_MAC: _bindgen_ty_225 = 1007;
pub const TCP_BPF_SOCK_OPS_CB_FLAGS: _bindgen_ty_225 = 1008;
pub const SK_BPF_CB_FLAGS: _bindgen_ty_225 = 1009;
pub type _bindgen_ty_225 = ffi::c_uint;
pub const BPF_LOAD_HDR_OPT_TCP_SYN: _bindgen_ty_226 = 1;
pub type _bindgen_ty_226 = ffi::c_uint;
pub const BPF_WRITE_HDR_TCP_CURRENT_MSS: _bindgen_ty_227 = 1;
pub const BPF_WRITE_HDR_TCP_SYNACK_COOKIE: _bindgen_ty_227 = 2;
pub type _bindgen_ty_227 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_perf_event_value {
    pub counter: __u64,
    pub enabled: __u64,
    pub running: __u64,
}
pub const BPF_DEVCG_ACC_MKNOD: _bindgen_ty_228 = 1;
pub const BPF_DEVCG_ACC_READ: _bindgen_ty_228 = 2;
pub const BPF_DEVCG_ACC_WRITE: _bindgen_ty_228 = 4;
pub type _bindgen_ty_228 = ffi::c_uint;
pub const BPF_DEVCG_DEV_BLOCK: _bindgen_ty_229 = 1;
pub const BPF_DEVCG_DEV_CHAR: _bindgen_ty_229 = 2;
pub type _bindgen_ty_229 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_cgroup_dev_ctx {
    pub access_type: __u32,
    pub major: __u32,
    pub minor: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_raw_tracepoint_args {
    pub args: __IncompleteArrayField<__u64>,
}
pub const BPF_FIB_LOOKUP_DIRECT: _bindgen_ty_230 = 1;
pub const BPF_FIB_LOOKUP_OUTPUT: _bindgen_ty_230 = 2;
pub const BPF_FIB_LOOKUP_SKIP_NEIGH: _bindgen_ty_230 = 4;
pub const BPF_FIB_LOOKUP_TBID: _bindgen_ty_230 = 8;
pub const BPF_FIB_LOOKUP_SRC: _bindgen_ty_230 = 16;
pub const BPF_FIB_LOOKUP_MARK: _bindgen_ty_230 = 32;
pub type _bindgen_ty_230 = ffi::c_uint;
pub const BPF_FIB_LKUP_RET_SUCCESS: _bindgen_ty_231 = 0;
pub const BPF_FIB_LKUP_RET_BLACKHOLE: _bindgen_ty_231 = 1;
pub const BPF_FIB_LKUP_RET_UNREACHABLE: _bindgen_ty_231 = 2;
pub const BPF_FIB_LKUP_RET_PROHIBIT: _bindgen_ty_231 = 3;
pub const BPF_FIB_LKUP_RET_NOT_FWDED: _bindgen_ty_231 = 4;
pub const BPF_FIB_LKUP_RET_FWD_DISABLED: _bindgen_ty_231 = 5;
pub const BPF_FIB_LKUP_RET_UNSUPP_LWT: _bindgen_ty_231 = 6;
pub const BPF_FIB_LKUP_RET_NO_NEIGH: _bindgen_ty_231 = 7;
pub const BPF_FIB_LKUP_RET_FRAG_NEEDED: _bindgen_ty_231 = 8;
pub const BPF_FIB_LKUP_RET_NO_SRC_ADDR: _bindgen_ty_231 = 9;
pub type _bindgen_ty_231 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_fib_lookup {
    pub family: __u8,
    pub l4_protocol: __u8,
    pub sport: __be16,
    pub dport: __be16,
    pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_1,
    pub ifindex: __u32,
    pub __bindgen_anon_2: bpf_fib_lookup__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_fib_lookup__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_fib_lookup__bindgen_ty_4,
    pub __bindgen_anon_5: bpf_fib_lookup__bindgen_ty_5,
    pub __bindgen_anon_6: bpf_fib_lookup__bindgen_ty_6,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_1 {
    pub tot_len: __u16,
    pub mtu_result: __u16,
}
impl Default for bpf_fib_lookup__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_2 {
    pub tos: __u8,
    pub flowinfo: __be32,
    pub rt_metric: __u32,
}
impl Default for bpf_fib_lookup__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_3 {
    pub ipv4_src: __be32,
    pub ipv6_src: [__u32; 4usize],
}
impl Default for bpf_fib_lookup__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_4 {
    pub ipv4_dst: __be32,
    pub ipv6_dst: [__u32; 4usize],
}
impl Default for bpf_fib_lookup__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_5 {
    pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1,
    pub tbid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1 {
    pub h_vlan_proto: __be16,
    pub h_vlan_TCI: __be16,
}
impl Default for bpf_fib_lookup__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_6 {
    pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_fib_lookup__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_fib_lookup__bindgen_ty_6__bindgen_ty_1 {
    pub mark: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_fib_lookup__bindgen_ty_6__bindgen_ty_2 {
    pub smac: [__u8; 6usize],
    pub dmac: [__u8; 6usize],
}
impl Default for bpf_fib_lookup__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_fib_lookup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_redir_neigh {
    pub nh_family: __u32,
    pub __bindgen_anon_1: bpf_redir_neigh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_redir_neigh__bindgen_ty_1 {
    pub ipv4_nh: __be32,
    pub ipv6_nh: [__u32; 4usize],
}
impl Default for bpf_redir_neigh__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_redir_neigh {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_check_mtu_flags_BPF_MTU_CHK_SEGS: bpf_check_mtu_flags = 1;
pub type bpf_check_mtu_flags = ffi::c_uint;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SUCCESS: bpf_check_mtu_ret = 0;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_FRAG_NEEDED: bpf_check_mtu_ret = 1;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SEGS_TOOBIG: bpf_check_mtu_ret = 2;
pub type bpf_check_mtu_ret = ffi::c_uint;
pub const bpf_task_fd_type_BPF_FD_TYPE_RAW_TRACEPOINT: bpf_task_fd_type = 0;
pub const bpf_task_fd_type_BPF_FD_TYPE_TRACEPOINT: bpf_task_fd_type = 1;
pub const bpf_task_fd_type_BPF_FD_TYPE_KPROBE: bpf_task_fd_type = 2;
pub const bpf_task_fd_type_BPF_FD_TYPE_KRETPROBE: bpf_task_fd_type = 3;
pub const bpf_task_fd_type_BPF_FD_TYPE_UPROBE: bpf_task_fd_type = 4;
pub const bpf_task_fd_type_BPF_FD_TYPE_URETPROBE: bpf_task_fd_type = 5;
pub type bpf_task_fd_type = ffi::c_uint;
pub const BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: _bindgen_ty_232 = 1;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: _bindgen_ty_232 = 2;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: _bindgen_ty_232 = 4;
pub type _bindgen_ty_232 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_keys {
    pub nhoff: __u16,
    pub thoff: __u16,
    pub addr_proto: __u16,
    pub is_frag: __u8,
    pub is_first_frag: __u8,
    pub is_encap: __u8,
    pub ip_proto: __u8,
    pub n_proto: __be16,
    pub sport: __be16,
    pub dport: __be16,
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1,
    pub flags: __u32,
    pub flow_label: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_flow_keys__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_flow_keys__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
    pub ipv4_src: __be32,
    pub ipv4_dst: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
    pub ipv6_src: [__u32; 4usize],
    pub ipv6_dst: [__u32; 4usize],
}
impl Default for bpf_flow_keys__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_flow_keys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_info {
    pub insn_off: __u32,
    pub type_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_line_info {
    pub insn_off: __u32,
    pub file_name_off: __u32,
    pub line_off: __u32,
    pub line_col: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_spin_lock {
    pub val: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_timer {
    pub __opaque: [__u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_wq {
    pub __opaque: [__u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_dynptr {
    pub __opaque: [__u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_list_head {
    pub __opaque: [__u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_list_node {
    pub __opaque: [__u64; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_rb_root {
    pub __opaque: [__u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_rb_node {
    pub __opaque: [__u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_refcount {
    pub __opaque: [__u32; 1usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sysctl {
    pub write: __u32,
    pub file_pos: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sockopt {
    pub __bindgen_anon_1: bpf_sockopt__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_sockopt__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_sockopt__bindgen_ty_3,
    pub level: __s32,
    pub optname: __s32,
    pub optlen: __s32,
    pub retval: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sockopt__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sockopt__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_2 {
    pub optval: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sockopt__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sockopt__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_3 {
    pub optval_end: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sockopt__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sockopt__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sockopt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_pidns_info {
    pub pid: __u32,
    pub tgid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sk_lookup {
    pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1,
    pub family: __u32,
    pub protocol: __u32,
    pub remote_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub remote_port: __be16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub local_ip4: __u32,
    pub local_ip6: [__u32; 4usize],
    pub local_port: __u32,
    pub ingress_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sk_lookup__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1,
    pub cookie: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sk_lookup__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_sk_lookup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_sk_lookup {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_ptr {
    pub ptr: *mut ffi::c_void,
    pub type_id: __u32,
    pub flags: __u32,
}
impl Default for btf_ptr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BTF_F_COMPACT: _bindgen_ty_233 = 1;
pub const BTF_F_NONAME: _bindgen_ty_233 = 2;
pub const BTF_F_PTR_RAW: _bindgen_ty_233 = 4;
pub const BTF_F_ZERO: _bindgen_ty_233 = 8;
pub type _bindgen_ty_233 = ffi::c_uint;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_OFFSET: bpf_core_relo_kind = 0;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_SIZE: bpf_core_relo_kind = 1;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_EXISTS: bpf_core_relo_kind = 2;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_SIGNED: bpf_core_relo_kind = 3;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_LSHIFT_U64: bpf_core_relo_kind = 4;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_RSHIFT_U64: bpf_core_relo_kind = 5;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_LOCAL: bpf_core_relo_kind = 6;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_TARGET: bpf_core_relo_kind = 7;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_EXISTS: bpf_core_relo_kind = 8;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_SIZE: bpf_core_relo_kind = 9;
pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_EXISTS: bpf_core_relo_kind = 10;
pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_VALUE: bpf_core_relo_kind = 11;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_MATCHES: bpf_core_relo_kind = 12;
pub type bpf_core_relo_kind = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_core_relo {
    pub insn_off: __u32,
    pub type_id: __u32,
    pub access_str_off: __u32,
    pub kind: bpf_core_relo_kind,
}
impl Default for bpf_core_relo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BPF_F_TIMER_ABS: _bindgen_ty_234 = 1;
pub const BPF_F_TIMER_CPU_PIN: _bindgen_ty_234 = 2;
pub type _bindgen_ty_234 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_iter_num {
    pub __opaque: [__u64; 1usize],
}
pub const bpf_kfunc_flags_BPF_F_PAD_ZEROS: bpf_kfunc_flags = 1;
pub type bpf_kfunc_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_filter {
    pub code: __u16,
    pub jt: __u8,
    pub jf: __u8,
    pub k: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_fprog {
    pub len: ffi::c_ushort,
    pub filter: *mut sock_filter,
}
impl Default for sock_fprog {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type bpfptr_t = sockptr_t;

#[repr(C)]
#[derive(Default)]
pub struct btf_id_set {
    pub cnt: u32_,
    pub ids: __IncompleteArrayField<u32_>,
}
#[repr(C)]
#[derive(Default)]
pub struct btf_id_set8 {
    pub cnt: u32_,
    pub flags: u32_,
    pub pairs: __IncompleteArrayField<btf_id_set8__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_id_set8__bindgen_ty_1 {
    pub id: u32_,
    pub flags: u32_,
}
pub const BTF_SOCK_TYPE_INET: _bindgen_ty_235 = 0;
pub const BTF_SOCK_TYPE_INET_CONN: _bindgen_ty_235 = 1;
pub const BTF_SOCK_TYPE_INET_REQ: _bindgen_ty_235 = 2;
pub const BTF_SOCK_TYPE_INET_TW: _bindgen_ty_235 = 3;
pub const BTF_SOCK_TYPE_REQ: _bindgen_ty_235 = 4;
pub const BTF_SOCK_TYPE_SOCK: _bindgen_ty_235 = 5;
pub const BTF_SOCK_TYPE_SOCK_COMMON: _bindgen_ty_235 = 6;
pub const BTF_SOCK_TYPE_TCP: _bindgen_ty_235 = 7;
pub const BTF_SOCK_TYPE_TCP_REQ: _bindgen_ty_235 = 8;
pub const BTF_SOCK_TYPE_TCP_TW: _bindgen_ty_235 = 9;
pub const BTF_SOCK_TYPE_TCP6: _bindgen_ty_235 = 10;
pub const BTF_SOCK_TYPE_UDP: _bindgen_ty_235 = 11;
pub const BTF_SOCK_TYPE_UDP6: _bindgen_ty_235 = 12;
pub const BTF_SOCK_TYPE_UNIX: _bindgen_ty_235 = 13;
pub const BTF_SOCK_TYPE_MPTCP: _bindgen_ty_235 = 14;
pub const BTF_SOCK_TYPE_SOCKET: _bindgen_ty_235 = 15;
pub const MAX_BTF_SOCK_TYPE: _bindgen_ty_235 = 16;
pub type _bindgen_ty_235 = ffi::c_uint;

pub const BTF_TRACING_TYPE_TASK: _bindgen_ty_236 = 0;
pub const BTF_TRACING_TYPE_FILE: _bindgen_ty_236 = 1;
pub const BTF_TRACING_TYPE_VMA: _bindgen_ty_236 = 2;
pub const MAX_BTF_TRACING_TYPE: _bindgen_ty_236 = 3;
pub type _bindgen_ty_236 = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_header {
    pub magic: __u16,
    pub version: __u8,
    pub flags: __u8,
    pub hdr_len: __u32,
    pub type_off: __u32,
    pub type_len: __u32,
    pub str_off: __u32,
    pub str_len: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_type {
    pub name_off: __u32,
    pub info: __u32,
    pub __bindgen_anon_1: btf_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_type__bindgen_ty_1 {
    pub size: __u32,
    pub type_: __u32,
}
impl Default for btf_type__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btf_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BTF_KIND_UNKN: _bindgen_ty_237 = 0;
pub const BTF_KIND_INT: _bindgen_ty_237 = 1;
pub const BTF_KIND_PTR: _bindgen_ty_237 = 2;
pub const BTF_KIND_ARRAY: _bindgen_ty_237 = 3;
pub const BTF_KIND_STRUCT: _bindgen_ty_237 = 4;
pub const BTF_KIND_UNION: _bindgen_ty_237 = 5;
pub const BTF_KIND_ENUM: _bindgen_ty_237 = 6;
pub const BTF_KIND_FWD: _bindgen_ty_237 = 7;
pub const BTF_KIND_TYPEDEF: _bindgen_ty_237 = 8;
pub const BTF_KIND_VOLATILE: _bindgen_ty_237 = 9;
pub const BTF_KIND_CONST: _bindgen_ty_237 = 10;
pub const BTF_KIND_RESTRICT: _bindgen_ty_237 = 11;
pub const BTF_KIND_FUNC: _bindgen_ty_237 = 12;
pub const BTF_KIND_FUNC_PROTO: _bindgen_ty_237 = 13;
pub const BTF_KIND_VAR: _bindgen_ty_237 = 14;
pub const BTF_KIND_DATASEC: _bindgen_ty_237 = 15;
pub const BTF_KIND_FLOAT: _bindgen_ty_237 = 16;
pub const BTF_KIND_DECL_TAG: _bindgen_ty_237 = 17;
pub const BTF_KIND_TYPE_TAG: _bindgen_ty_237 = 18;
pub const BTF_KIND_ENUM64: _bindgen_ty_237 = 19;
pub const NR_BTF_KINDS: _bindgen_ty_237 = 20;
pub const BTF_KIND_MAX: _bindgen_ty_237 = 19;
pub type _bindgen_ty_237 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_enum {
    pub name_off: __u32,
    pub val: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_array {
    pub type_: __u32,
    pub index_type: __u32,
    pub nelems: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_member {
    pub name_off: __u32,
    pub type_: __u32,
    pub offset: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_param {
    pub name_off: __u32,
    pub type_: __u32,
}
pub const BTF_VAR_STATIC: _bindgen_ty_238 = 0;
pub const BTF_VAR_GLOBAL_ALLOCATED: _bindgen_ty_238 = 1;
pub const BTF_VAR_GLOBAL_EXTERN: _bindgen_ty_238 = 2;
pub type _bindgen_ty_238 = ffi::c_uint;
pub const btf_func_linkage_BTF_FUNC_STATIC: btf_func_linkage = 0;
pub const btf_func_linkage_BTF_FUNC_GLOBAL: btf_func_linkage = 1;
pub const btf_func_linkage_BTF_FUNC_EXTERN: btf_func_linkage = 2;
pub type btf_func_linkage = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_var {
    pub linkage: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_var_secinfo {
    pub type_: __u32,
    pub offset: __u32,
    pub size: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_decl_tag {
    pub component_idx: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_enum64 {
    pub name_off: __u32,
    pub val_lo32: __u32,
    pub val_hi32: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_show {
    _unused: [u8; 0],
}
pub type btf_kfunc_filter_t = ::core::option::Option<
    unsafe extern "C" fn(prog: *const bpf_prog, kfunc_id: u32_) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_kfunc_id_set {
    pub owner: *mut module,
    pub set: *mut btf_id_set8,
    pub filter: btf_kfunc_filter_t,
}
impl Default for btf_kfunc_id_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_id_dtor_kfunc {
    pub btf_id: u32_,
    pub kfunc_btf_id: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_struct_meta {
    pub btf_id: u32_,
    pub record: *mut btf_record,
}
impl Default for btf_struct_meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btf_struct_metas {
    pub cnt: u32_,
    pub types: __IncompleteArrayField<btf_struct_meta>,
}
impl Default for btf_struct_metas {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_log {
    _unused: [u8; 0],
}
pub const btf_field_iter_kind_BTF_FIELD_ITER_IDS: btf_field_iter_kind = 0;
pub const btf_field_iter_kind_BTF_FIELD_ITER_STRS: btf_field_iter_kind = 1;
pub type btf_field_iter_kind = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_field_desc {
    pub t_off_cnt: ffi::c_int,
    pub t_offs: [ffi::c_int; 2usize],
    pub m_sz: ffi::c_int,
    pub m_off_cnt: ffi::c_int,
    pub m_offs: [ffi::c_int; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_field_iter {
    pub desc: btf_field_desc,
    pub p: *mut ffi::c_void,
    pub m_idx: ffi::c_int,
    pub off_idx: ffi::c_int,
    pub vlen: ffi::c_int,
}
impl Default for btf_field_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const class_rcu_tasks_trace_is_conditional: bool_ = false;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_rcu_tasks_trace_t {
    pub lock: *mut ffi::c_void,
}
impl Default for class_rcu_tasks_trace_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [ffi::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub __bindgen_padding_0: u32,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
    pub ac_btime64: __u64,
    pub compact_count: __u64,
    pub compact_delay_total: __u64,
    pub ac_tgid: __u32,
    pub ac_tgetime: __u64,
    pub ac_exe_dev: __u64,
    pub ac_exe_inode: __u64,
    pub wpcopy_count: __u64,
    pub wpcopy_delay_total: __u64,
    pub irq_count: __u64,
    pub irq_delay_total: __u64,
    pub cpu_delay_max: __u64,
    pub cpu_delay_min: __u64,
    pub blkio_delay_max: __u64,
    pub blkio_delay_min: __u64,
    pub swapin_delay_max: __u64,
    pub swapin_delay_min: __u64,
    pub freepages_delay_max: __u64,
    pub freepages_delay_min: __u64,
    pub thrashing_delay_max: __u64,
    pub thrashing_delay_min: __u64,
    pub compact_delay_max: __u64,
    pub compact_delay_min: __u64,
    pub wpcopy_delay_max: __u64,
    pub wpcopy_delay_min: __u64,
    pub irq_delay_max: __u64,
    pub irq_delay_min: __u64,
}
pub const TASKSTATS_CMD_UNSPEC: _bindgen_ty_239 = 0;
pub const TASKSTATS_CMD_GET: _bindgen_ty_239 = 1;
pub const TASKSTATS_CMD_NEW: _bindgen_ty_239 = 2;
pub const __TASKSTATS_CMD_MAX: _bindgen_ty_239 = 3;
pub type _bindgen_ty_239 = ffi::c_uint;
pub const TASKSTATS_TYPE_UNSPEC: _bindgen_ty_240 = 0;
pub const TASKSTATS_TYPE_PID: _bindgen_ty_240 = 1;
pub const TASKSTATS_TYPE_TGID: _bindgen_ty_240 = 2;
pub const TASKSTATS_TYPE_STATS: _bindgen_ty_240 = 3;
pub const TASKSTATS_TYPE_AGGR_PID: _bindgen_ty_240 = 4;
pub const TASKSTATS_TYPE_AGGR_TGID: _bindgen_ty_240 = 5;
pub const TASKSTATS_TYPE_NULL: _bindgen_ty_240 = 6;
pub const __TASKSTATS_TYPE_MAX: _bindgen_ty_240 = 7;
pub type _bindgen_ty_240 = ffi::c_uint;
pub const TASKSTATS_CMD_ATTR_UNSPEC: _bindgen_ty_241 = 0;
pub const TASKSTATS_CMD_ATTR_PID: _bindgen_ty_241 = 1;
pub const TASKSTATS_CMD_ATTR_TGID: _bindgen_ty_241 = 2;
pub const TASKSTATS_CMD_ATTR_REGISTER_CPUMASK: _bindgen_ty_241 = 3;
pub const TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK: _bindgen_ty_241 = 4;
pub const __TASKSTATS_CMD_ATTR_MAX: _bindgen_ty_241 = 5;
pub type _bindgen_ty_241 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroupstats {
    pub nr_sleeping: __u64,
    pub nr_running: __u64,
    pub nr_stopped: __u64,
    pub nr_uninterruptible: __u64,
    pub nr_io_wait: __u64,
}
pub const CGROUPSTATS_CMD_UNSPEC: _bindgen_ty_242 = 3;
pub const CGROUPSTATS_CMD_GET: _bindgen_ty_242 = 4;
pub const CGROUPSTATS_CMD_NEW: _bindgen_ty_242 = 5;
pub const __CGROUPSTATS_CMD_MAX: _bindgen_ty_242 = 6;
pub type _bindgen_ty_242 = ffi::c_uint;
pub const CGROUPSTATS_TYPE_UNSPEC: _bindgen_ty_243 = 0;
pub const CGROUPSTATS_TYPE_CGROUP_STATS: _bindgen_ty_243 = 1;
pub const __CGROUPSTATS_TYPE_MAX: _bindgen_ty_243 = 2;
pub type _bindgen_ty_243 = ffi::c_uint;
pub const CGROUPSTATS_CMD_ATTR_UNSPEC: _bindgen_ty_244 = 0;
pub const CGROUPSTATS_CMD_ATTR_FD: _bindgen_ty_244 = 1;
pub const __CGROUPSTATS_CMD_ATTR_MAX: _bindgen_ty_244 = 2;
pub type _bindgen_ty_244 = ffi::c_uint;
pub const string_size_units_STRING_UNITS_10: string_size_units = 0;
pub const string_size_units_STRING_UNITS_2: string_size_units = 1;
pub const string_size_units_STRING_UNITS_MASK: string_size_units = 1;
pub const string_size_units_STRING_UNITS_NO_SPACE: string_size_units = 1073741824;
pub const string_size_units_STRING_UNITS_NO_BYTES: string_size_units = 2147483648;
pub type string_size_units = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut ffi::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: ffi::c_int,
    pub file: *const file,
    pub private: *mut ffi::c_void,
}
impl Default for seq_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub stop: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut ffi::c_void)>,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            m: *mut seq_file,
            v: *mut ffi::c_void,
            pos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_ns_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ns_common {
    pub stashed: *mut dentry,
    pub ops: *const proc_ns_operations,
    pub inum: ffi::c_uint,
    pub count: refcount_t,
}
impl Default for ns_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uts_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsproxy {
    pub count: refcount_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
impl Default for nsproxy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsset {
    pub flags: ffi::c_uint,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub cred: *const cred,
}
impl Default for nsset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uid_gid_map__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub nr_extents: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_2 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
impl Default for uid_gid_map__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uid_gid_map__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uid_gid_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ucount_type_UCOUNT_USER_NAMESPACES: ucount_type = 0;
pub const ucount_type_UCOUNT_PID_NAMESPACES: ucount_type = 1;
pub const ucount_type_UCOUNT_UTS_NAMESPACES: ucount_type = 2;
pub const ucount_type_UCOUNT_IPC_NAMESPACES: ucount_type = 3;
pub const ucount_type_UCOUNT_NET_NAMESPACES: ucount_type = 4;
pub const ucount_type_UCOUNT_MNT_NAMESPACES: ucount_type = 5;
pub const ucount_type_UCOUNT_CGROUP_NAMESPACES: ucount_type = 6;
pub const ucount_type_UCOUNT_TIME_NAMESPACES: ucount_type = 7;
pub const ucount_type_UCOUNT_INOTIFY_INSTANCES: ucount_type = 8;
pub const ucount_type_UCOUNT_INOTIFY_WATCHES: ucount_type = 9;
pub const ucount_type_UCOUNT_COUNTS: ucount_type = 10;
pub type ucount_type = ffi::c_uint;
pub const rlimit_type_UCOUNT_RLIMIT_NPROC: rlimit_type = 0;
pub const rlimit_type_UCOUNT_RLIMIT_MSGQUEUE: rlimit_type = 1;
pub const rlimit_type_UCOUNT_RLIMIT_SIGPENDING: rlimit_type = 2;
pub const rlimit_type_UCOUNT_RLIMIT_MEMLOCK: rlimit_type = 3;
pub const rlimit_type_UCOUNT_RLIMIT_COUNTS: rlimit_type = 4;
pub type rlimit_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucounts {
    pub node: hlist_nulls_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub rcu: callback_head,
    pub count: rcuref_t,
    pub ucount: [atomic_long_t; 10usize],
    pub rlimit: [atomic_long_t; 4usize],
}
impl Default for ucounts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const cpu_usage_stat_CPUTIME_USER: cpu_usage_stat = 0;
pub const cpu_usage_stat_CPUTIME_NICE: cpu_usage_stat = 1;
pub const cpu_usage_stat_CPUTIME_SYSTEM: cpu_usage_stat = 2;
pub const cpu_usage_stat_CPUTIME_SOFTIRQ: cpu_usage_stat = 3;
pub const cpu_usage_stat_CPUTIME_IRQ: cpu_usage_stat = 4;
pub const cpu_usage_stat_CPUTIME_IDLE: cpu_usage_stat = 5;
pub const cpu_usage_stat_CPUTIME_IOWAIT: cpu_usage_stat = 6;
pub const cpu_usage_stat_CPUTIME_STEAL: cpu_usage_stat = 7;
pub const cpu_usage_stat_CPUTIME_GUEST: cpu_usage_stat = 8;
pub const cpu_usage_stat_CPUTIME_GUEST_NICE: cpu_usage_stat = 9;
pub const cpu_usage_stat_NR_STATS: cpu_usage_stat = 10;
pub type cpu_usage_stat = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cpustat {
    pub cpustat: [u64_; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_stat {
    pub irqs_sum: ffi::c_ulong,
    pub softirqs: [ffi::c_uint; 10usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local64_t {
    pub a: local_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_t {
    pub v: local64_t,
}
pub const cgroup_bpf_attach_type_CGROUP_BPF_ATTACH_TYPE_INVALID: cgroup_bpf_attach_type = -1;
pub const cgroup_bpf_attach_type_CGROUP_INET_INGRESS: cgroup_bpf_attach_type = 0;
pub const cgroup_bpf_attach_type_CGROUP_INET_EGRESS: cgroup_bpf_attach_type = 1;
pub const cgroup_bpf_attach_type_CGROUP_INET_SOCK_CREATE: cgroup_bpf_attach_type = 2;
pub const cgroup_bpf_attach_type_CGROUP_SOCK_OPS: cgroup_bpf_attach_type = 3;
pub const cgroup_bpf_attach_type_CGROUP_DEVICE: cgroup_bpf_attach_type = 4;
pub const cgroup_bpf_attach_type_CGROUP_INET4_BIND: cgroup_bpf_attach_type = 5;
pub const cgroup_bpf_attach_type_CGROUP_INET6_BIND: cgroup_bpf_attach_type = 6;
pub const cgroup_bpf_attach_type_CGROUP_INET4_CONNECT: cgroup_bpf_attach_type = 7;
pub const cgroup_bpf_attach_type_CGROUP_INET6_CONNECT: cgroup_bpf_attach_type = 8;
pub const cgroup_bpf_attach_type_CGROUP_UNIX_CONNECT: cgroup_bpf_attach_type = 9;
pub const cgroup_bpf_attach_type_CGROUP_INET4_POST_BIND: cgroup_bpf_attach_type = 10;
pub const cgroup_bpf_attach_type_CGROUP_INET6_POST_BIND: cgroup_bpf_attach_type = 11;
pub const cgroup_bpf_attach_type_CGROUP_UDP4_SENDMSG: cgroup_bpf_attach_type = 12;
pub const cgroup_bpf_attach_type_CGROUP_UDP6_SENDMSG: cgroup_bpf_attach_type = 13;
pub const cgroup_bpf_attach_type_CGROUP_UNIX_SENDMSG: cgroup_bpf_attach_type = 14;
pub const cgroup_bpf_attach_type_CGROUP_SYSCTL: cgroup_bpf_attach_type = 15;
pub const cgroup_bpf_attach_type_CGROUP_UDP4_RECVMSG: cgroup_bpf_attach_type = 16;
pub const cgroup_bpf_attach_type_CGROUP_UDP6_RECVMSG: cgroup_bpf_attach_type = 17;
pub const cgroup_bpf_attach_type_CGROUP_UNIX_RECVMSG: cgroup_bpf_attach_type = 18;
pub const cgroup_bpf_attach_type_CGROUP_GETSOCKOPT: cgroup_bpf_attach_type = 19;
pub const cgroup_bpf_attach_type_CGROUP_SETSOCKOPT: cgroup_bpf_attach_type = 20;
pub const cgroup_bpf_attach_type_CGROUP_INET4_GETPEERNAME: cgroup_bpf_attach_type = 21;
pub const cgroup_bpf_attach_type_CGROUP_INET6_GETPEERNAME: cgroup_bpf_attach_type = 22;
pub const cgroup_bpf_attach_type_CGROUP_UNIX_GETPEERNAME: cgroup_bpf_attach_type = 23;
pub const cgroup_bpf_attach_type_CGROUP_INET4_GETSOCKNAME: cgroup_bpf_attach_type = 24;
pub const cgroup_bpf_attach_type_CGROUP_INET6_GETSOCKNAME: cgroup_bpf_attach_type = 25;
pub const cgroup_bpf_attach_type_CGROUP_UNIX_GETSOCKNAME: cgroup_bpf_attach_type = 26;
pub const cgroup_bpf_attach_type_CGROUP_INET_SOCK_RELEASE: cgroup_bpf_attach_type = 27;
pub const cgroup_bpf_attach_type_CGROUP_LSM_START: cgroup_bpf_attach_type = 28;
pub const cgroup_bpf_attach_type_CGROUP_LSM_END: cgroup_bpf_attach_type = 27;
pub const cgroup_bpf_attach_type_MAX_CGROUP_BPF_ATTACH_TYPE: cgroup_bpf_attach_type = 28;
pub type cgroup_bpf_attach_type = ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_bpf {
    pub effective: [*mut bpf_prog_array; 28usize],
    pub progs: [hlist_head; 28usize],
    pub flags: [u8_; 28usize],
    pub revisions: [u64_; 28usize],
    pub storages: list_head,
    pub inactive: *mut bpf_prog_array,
    pub refcnt: percpu_ref,
    pub release_work: work_struct,
}
impl Default for cgroup_bpf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type kthread_work_func_t =
    ::core::option::Option<unsafe extern "C" fn(work: *mut kthread_work)>;

pub const KTW_FREEZABLE: _bindgen_ty_245 = 1;
pub type _bindgen_ty_245 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_worker {
    pub flags: ffi::c_uint,
    pub lock: raw_spinlock_t,
    pub work_list: list_head,
    pub delayed_work_list: list_head,
    pub task: *mut task_struct,
    pub current_work: *mut kthread_work,
}
impl Default for kthread_worker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_work {
    pub node: list_head,
    pub func: kthread_work_func_t,
    pub worker: *mut kthread_worker,
    pub canceling: ffi::c_int,
}
impl Default for kthread_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_delayed_work {
    pub work: kthread_work,
    pub timer: timer_list,
}
impl Default for kthread_delayed_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct psi_group {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_taskset {
    _unused: [u8; 0],
}
pub const cgroup_subsys_id_cpuset_cgrp_id: cgroup_subsys_id = 0;
pub const cgroup_subsys_id_cpu_cgrp_id: cgroup_subsys_id = 1;
pub const cgroup_subsys_id_cpuacct_cgrp_id: cgroup_subsys_id = 2;
pub const cgroup_subsys_id_io_cgrp_id: cgroup_subsys_id = 3;
pub const cgroup_subsys_id_memory_cgrp_id: cgroup_subsys_id = 4;
pub const cgroup_subsys_id_devices_cgrp_id: cgroup_subsys_id = 5;
pub const cgroup_subsys_id_freezer_cgrp_id: cgroup_subsys_id = 6;
pub const cgroup_subsys_id_net_cls_cgrp_id: cgroup_subsys_id = 7;
pub const cgroup_subsys_id_perf_event_cgrp_id: cgroup_subsys_id = 8;
pub const cgroup_subsys_id_net_prio_cgrp_id: cgroup_subsys_id = 9;
pub const cgroup_subsys_id_hugetlb_cgrp_id: cgroup_subsys_id = 10;
pub const cgroup_subsys_id_pids_cgrp_id: cgroup_subsys_id = 11;
pub const cgroup_subsys_id_CGROUP_SUBSYS_COUNT: cgroup_subsys_id = 12;
pub type cgroup_subsys_id = ffi::c_uint;
pub const CSS_NO_REF: _bindgen_ty_246 = 1;
pub const CSS_ONLINE: _bindgen_ty_246 = 2;
pub const CSS_RELEASED: _bindgen_ty_246 = 4;
pub const CSS_VISIBLE: _bindgen_ty_246 = 8;
pub const CSS_DYING: _bindgen_ty_246 = 16;
pub type _bindgen_ty_246 = ffi::c_uint;
pub const CGRP_NOTIFY_ON_RELEASE: _bindgen_ty_247 = 0;
pub const CGRP_CPUSET_CLONE_CHILDREN: _bindgen_ty_247 = 1;
pub const CGRP_FREEZE: _bindgen_ty_247 = 2;
pub const CGRP_FROZEN: _bindgen_ty_247 = 3;
pub type _bindgen_ty_247 = ffi::c_uint;
pub const CGRP_ROOT_NOPREFIX: _bindgen_ty_248 = 2;
pub const CGRP_ROOT_XATTR: _bindgen_ty_248 = 4;
pub const CGRP_ROOT_NS_DELEGATE: _bindgen_ty_248 = 8;
pub const CGRP_ROOT_FAVOR_DYNMODS: _bindgen_ty_248 = 16;
pub const CGRP_ROOT_CPUSET_V2_MODE: _bindgen_ty_248 = 65536;
pub const CGRP_ROOT_MEMORY_LOCAL_EVENTS: _bindgen_ty_248 = 131072;
pub const CGRP_ROOT_MEMORY_RECURSIVE_PROT: _bindgen_ty_248 = 262144;
pub const CGRP_ROOT_MEMORY_HUGETLB_ACCOUNTING: _bindgen_ty_248 = 524288;
pub const CGRP_ROOT_PIDS_LOCAL_EVENTS: _bindgen_ty_248 = 1048576;
pub type _bindgen_ty_248 = ffi::c_uint;
pub const CFTYPE_ONLY_ON_ROOT: _bindgen_ty_249 = 1;
pub const CFTYPE_NOT_ON_ROOT: _bindgen_ty_249 = 2;
pub const CFTYPE_NS_DELEGATABLE: _bindgen_ty_249 = 4;
pub const CFTYPE_NO_PREFIX: _bindgen_ty_249 = 8;
pub const CFTYPE_WORLD_WRITABLE: _bindgen_ty_249 = 16;
pub const CFTYPE_DEBUG: _bindgen_ty_249 = 32;
pub const __CFTYPE_ONLY_ON_DFL: _bindgen_ty_249 = 65536;
pub const __CFTYPE_NOT_ON_DFL: _bindgen_ty_249 = 131072;
pub const __CFTYPE_ADDED: _bindgen_ty_249 = 262144;
pub type _bindgen_ty_249 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: ffi::c_ulong,
    pub notify_timer: timer_list,
}
impl Default for cgroup_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub rstat_cpu: *mut css_rstat_cpu,
    pub sibling: list_head,
    pub children: list_head,
    pub id: ffi::c_int,
    pub flags: ffi::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
    pub nr_descendants: ffi::c_int,
    pub rstat_flush_next: *mut cgroup_subsys_state,
}
impl Default for cgroup_subsys_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 12usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: ffi::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 12usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_src_preload_node: list_head,
    pub mg_dst_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
impl Default for css_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
    pub ntime: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_rstat_cpu {
    pub updated_children: *mut cgroup_subsys_state,
    pub updated_next: *mut cgroup_subsys_state,
    pub lnode: llist_node,
    pub owner: *mut cgroup_subsys_state,
}
impl Default for css_rstat_cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup_rstat_base_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub subtree_bstat: cgroup_base_stat,
    pub last_subtree_bstat: cgroup_base_stat,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: bool_,
    pub nr_frozen_descendants: ffi::c_int,
    pub nr_frozen_tasks: ffi::c_int,
}
#[repr(C)]
#[repr(align(64))]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: ffi::c_ulong,
    pub level: ffi::c_int,
    pub max_depth: ffi::c_int,
    pub nr_descendants: ffi::c_int,
    pub nr_dying_descendants: ffi::c_int,
    pub max_descendants: ffi::c_int,
    pub nr_populated_csets: ffi::c_int,
    pub nr_populated_domain_children: ffi::c_int,
    pub nr_populated_threaded_children: ffi::c_int,
    pub nr_threaded_children: ffi::c_int,
    pub kill_seq: ffi::c_uint,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub psi_files: __IncompleteArrayField<cgroup_file>,
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 12usize],
    pub nr_dying_subsys: [ffi::c_int; 12usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 12usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_base_cpu: *mut cgroup_rstat_base_cpu,
    pub _pad_: cacheline_padding,
    pub last_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: *mut psi_group,
    pub bpf: cgroup_bpf,
    pub freezer: cgroup_freezer_state,
    pub bpf_cgrp_storage: *mut bpf_local_storage,
    pub ancestors: __IncompleteArrayField<*mut cgroup>,
}
impl Default for cgroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: ffi::c_uint,
    pub hierarchy_id: ffi::c_int,
    pub root_list: list_head,
    pub rcu: callback_head,
    pub __bindgen_padding_0: [u64; 2usize],
    pub cgrp: cgroup,
    pub cgrp_ancestor_storage: *mut cgroup,
    pub nr_cgrps: atomic_t,
    pub flags: ffi::c_uint,
    pub release_agent_path: [ffi::c_char; 4096usize],
    pub name: [ffi::c_char; 64usize],
}
impl Default for cgroup_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cftype {
    pub name: [ffi::c_char; 64usize],
    pub private: ffi::c_ulong,
    pub max_write_len: usize,
    pub flags: ffi::c_uint,
    pub file_offset: ffi::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void)>,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: u64_,
        ) -> ffi::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: s64,
        ) -> ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            nbytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub lockdep_key: lock_class_key,
}
impl Default for cftype {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(parent_css: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online:
        ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state) -> ffi::c_int>,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_killed: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cpu: ffi::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> ffi::c_int,
    >,
    pub css_local_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> ffi::c_int,
    >,
    pub can_attach:
        ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset) -> ffi::c_int>,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
    pub can_fork: ::core::option::Option<
        unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set) -> ffi::c_int,
    >,
    pub cancel_fork:
        ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(root_css: *mut cgroup_subsys_state)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub id: ffi::c_int,
    pub name: *const ffi::c_char,
    pub legacy_name: *const ffi::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: ffi::c_uint,
    pub rstat_ss_lock: spinlock_t,
    pub lhead: *mut llist_head,
}
impl Default for cgroup_subsys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn early_init_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_early_init_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn implicit_on_dfl_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_implicit_on_dfl_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn threaded_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_threaded_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_of_peak {
    pub value: ffi::c_ulong,
    pub list: list_head,
}
impl Default for cgroup_of_peak {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_cgroup_data {
    pub cgroup: *mut cgroup,
    pub classid: u32_,
    pub prioidx: u16_,
}
impl Default for sock_cgroup_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const css_task_iter_flags_CSS_TASK_ITER_PROCS: css_task_iter_flags = 1;
pub const css_task_iter_flags_CSS_TASK_ITER_THREADED: css_task_iter_flags = 2;
pub const css_task_iter_flags_CSS_TASK_ITER_SKIPPED: css_task_iter_flags = 65536;
pub type css_task_iter_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_task_iter {
    pub ss: *mut cgroup_subsys,
    pub flags: ffi::c_uint,
    pub cset_pos: *mut list_head,
    pub cset_head: *mut list_head,
    pub tcset_pos: *mut list_head,
    pub tcset_head: *mut list_head,
    pub task_pos: *mut list_head,
    pub cur_tasks_head: *mut list_head,
    pub cur_cset: *mut css_set,
    pub cur_dcset: *mut css_set,
    pub cur_task: *mut task_struct,
    pub iters_node: list_head,
}
impl Default for css_task_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const cgroup_lifetime_events_CGROUP_LIFETIME_ONLINE: cgroup_lifetime_events = 0;
pub const cgroup_lifetime_events_CGROUP_LIFETIME_OFFLINE: cgroup_lifetime_events = 1;
pub type cgroup_lifetime_events = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_namespace {
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
impl Default for cgroup_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[repr(align(64))]
pub struct page_counter {
    pub usage: atomic_long_t,
    pub failcnt: ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub _pad1_: cacheline_padding,
    pub emin: ffi::c_ulong,
    pub min_usage: atomic_long_t,
    pub children_min_usage: atomic_long_t,
    pub elow: ffi::c_ulong,
    pub low_usage: atomic_long_t,
    pub children_low_usage: atomic_long_t,
    pub watermark: ffi::c_ulong,
    pub local_watermark: ffi::c_ulong,
    pub _pad2_: cacheline_padding,
    pub protection_support: bool_,
    pub track_failcnt: bool_,
    pub min: ffi::c_ulong,
    pub low: ffi::c_ulong,
    pub high: ffi::c_ulong,
    pub max: ffi::c_ulong,
    pub parent: *mut page_counter,
}
impl Default for page_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct eventfd_ctx {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmpressure {
    pub scanned: ffi::c_ulong,
    pub reclaimed: ffi::c_ulong,
    pub tree_scanned: ffi::c_ulong,
    pub tree_reclaimed: ffi::c_ulong,
    pub sr_lock: spinlock_t,
    pub events: list_head,
    pub events_lock: mutex,
    pub work: work_struct,
}
impl Default for vmpressure {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_global {
    pub events: percpu_counter,
    pub period: ffi::c_uint,
    pub sequence: seqcount_t,
}
impl Default for fprop_global {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: ffi::c_uint,
    pub lock: raw_spinlock_t,
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const wb_state_WB_registered: wb_state = 0;
pub const wb_state_WB_writeback_running: wb_state = 1;
pub const wb_state_WB_has_dirty_io: wb_state = 2;
pub const wb_state_WB_start_all: wb_state = 3;
pub type wb_state = ffi::c_uint;
pub const wb_stat_item_WB_RECLAIMABLE: wb_stat_item = 0;
pub const wb_stat_item_WB_WRITEBACK: wb_stat_item = 1;
pub const wb_stat_item_WB_DIRTIED: wb_stat_item = 2;
pub const wb_stat_item_WB_WRITTEN: wb_stat_item = 3;
pub const wb_stat_item_NR_WB_STAT_ITEMS: wb_stat_item = 4;
pub type wb_stat_item = ffi::c_uint;
pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 5;
pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 6;
pub const wb_reason_WB_REASON_FOREIGN_FLUSH: wb_reason = 7;
pub const wb_reason_WB_REASON_MAX: wb_reason = 8;
pub type wb_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_completion {
    pub cnt: atomic_t,
    pub waitq: *mut wait_queue_head_t,
}
impl Default for wb_completion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: ffi::c_ulong,
    pub last_old_flush: ffi::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub writeback_inodes: atomic_t,
    pub stat: [percpu_counter; 4usize],
    pub bw_time_stamp: ffi::c_ulong,
    pub dirtied_stamp: ffi::c_ulong,
    pub written_stamp: ffi::c_ulong,
    pub write_bandwidth: ffi::c_ulong,
    pub avg_write_bandwidth: ffi::c_ulong,
    pub dirty_ratelimit: ffi::c_ulong,
    pub balanced_dirty_ratelimit: ffi::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: ffi::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub bw_dwork: delayed_work,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub b_attached: list_head,
    pub offline_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
}
impl Default for bdi_writeback__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bdi_writeback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: ffi::c_ulong,
    pub io_pages: ffi::c_ulong,
    pub refcnt: kref,
    pub capabilities: ffi::c_uint,
    pub min_ratio: ffi::c_uint,
    pub max_ratio: ffi::c_uint,
    pub max_prop_frac: ffi::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub last_bdp_sleep: ffi::c_ulong,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: xarray,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [ffi::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
impl Default for backing_dev_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct wb_lock_cookie {
    pub locked: bool_,
    pub flags: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio_batch {
    pub nr: ffi::c_uchar,
    pub i: ffi::c_uchar,
    pub percpu_pvec_drained: bool_,
    pub folios: [*mut folio; 31usize],
}
impl Default for folio_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const writeback_sync_modes_WB_SYNC_NONE: writeback_sync_modes = 0;
pub const writeback_sync_modes_WB_SYNC_ALL: writeback_sync_modes = 1;
pub type writeback_sync_modes = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: ffi::c_long,
    pub pages_skipped: ffi::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fbatch: folio_batch,
    pub index: ffi::c_ulong,
    pub saved_err: ffi::c_int,
    pub wb: *mut bdi_writeback,
    pub inode: *mut inode,
    pub wb_id: ffi::c_int,
    pub wb_lcand_id: ffi::c_int,
    pub wb_tcand_id: ffi::c_int,
    pub wb_bytes: usize,
    pub wb_lcand_bytes: usize,
    pub wb_tcand_bytes: usize,
}
impl Default for writeback_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_kupdate_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_kupdate_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn for_background(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_background_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_background_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tagged_writepages_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tagged_writepages_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn range_cyclic_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_range_cyclic_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn for_sync(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_sync_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_sync_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unpinned_netfs_wb(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unpinned_netfs_wb(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unpinned_netfs_wb_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unpinned_netfs_wb_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_cgroup_owner_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_cgroup_owner_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: ffi::c_uint,
        for_background: ffi::c_uint,
        tagged_writepages: ffi::c_uint,
        range_cyclic: ffi::c_uint,
        for_sync: ffi::c_uint,
        unpinned_netfs_wb: ffi::c_uint,
        no_cgroup_owner: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unpinned_netfs_wb: u32 = unsafe { ::core::mem::transmute(unpinned_netfs_wb) };
            unpinned_netfs_wb as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_domain {
    pub lock: spinlock_t,
    pub completions: fprop_global,
    pub period_timer: timer_list,
    pub period_time: ffi::c_ulong,
    pub dirty_limit_tstamp: ffi::c_ulong,
    pub dirty_limit: ffi::c_ulong,
}
impl Default for wb_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirty_throttle_control {
    pub dom: *mut wb_domain,
    pub gdtc: *mut dirty_throttle_control,
    pub wb: *mut bdi_writeback,
    pub wb_completions: *mut fprop_local_percpu,
    pub avail: ffi::c_ulong,
    pub dirty: ffi::c_ulong,
    pub thresh: ffi::c_ulong,
    pub bg_thresh: ffi::c_ulong,
    pub limit: ffi::c_ulong,
    pub wb_dirty: ffi::c_ulong,
    pub wb_thresh: ffi::c_ulong,
    pub wb_bg_thresh: ffi::c_ulong,
    pub pos_ratio: ffi::c_ulong,
    pub freerun: bool_,
    pub dirty_exceeded: bool_,
}
impl Default for dirty_throttle_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type writepage_t = ::core::option::Option<
    unsafe extern "C" fn(
        folio: *mut folio,
        wbc: *mut writeback_control,
        data: *mut ffi::c_void,
    ) -> ffi::c_int,
>;

pub const memcg_stat_item_MEMCG_SWAP: memcg_stat_item = 47;
pub const memcg_stat_item_MEMCG_SOCK: memcg_stat_item = 48;
pub const memcg_stat_item_MEMCG_PERCPU_B: memcg_stat_item = 49;
pub const memcg_stat_item_MEMCG_VMALLOC: memcg_stat_item = 50;
pub const memcg_stat_item_MEMCG_KMEM: memcg_stat_item = 51;
pub const memcg_stat_item_MEMCG_ZSWAP_B: memcg_stat_item = 52;
pub const memcg_stat_item_MEMCG_ZSWAPPED: memcg_stat_item = 53;
pub const memcg_stat_item_MEMCG_NR_STAT: memcg_stat_item = 54;
pub type memcg_stat_item = ffi::c_uint;
pub const memcg_memory_event_MEMCG_LOW: memcg_memory_event = 0;
pub const memcg_memory_event_MEMCG_HIGH: memcg_memory_event = 1;
pub const memcg_memory_event_MEMCG_MAX: memcg_memory_event = 2;
pub const memcg_memory_event_MEMCG_OOM: memcg_memory_event = 3;
pub const memcg_memory_event_MEMCG_OOM_KILL: memcg_memory_event = 4;
pub const memcg_memory_event_MEMCG_OOM_GROUP_KILL: memcg_memory_event = 5;
pub const memcg_memory_event_MEMCG_SWAP_HIGH: memcg_memory_event = 6;
pub const memcg_memory_event_MEMCG_SWAP_MAX: memcg_memory_event = 7;
pub const memcg_memory_event_MEMCG_SWAP_FAIL: memcg_memory_event = 8;
pub const memcg_memory_event_MEMCG_NR_MEMORY_EVENTS: memcg_memory_event = 9;
pub type memcg_memory_event = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_reclaim_cookie {
    pub pgdat: *mut pg_data_t,
    pub generation: ffi::c_int,
}
impl Default for mem_cgroup_reclaim_cookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_cgroup_id {
    pub id: ffi::c_int,
    pub ref_: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats_percpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg1_events_percpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec_stats_percpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_reclaim_iter {
    pub position: *mut mem_cgroup,
    pub generation: atomic_t,
}
impl Default for mem_cgroup_reclaim_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup_per_node {
    pub memcg: *mut mem_cgroup,
    pub lruvec_stats_percpu: *mut lruvec_stats_percpu,
    pub lruvec_stats: *mut lruvec_stats,
    pub shrinker_info: *mut shrinker_info,
    pub __bindgen_padding_0: [u64; 4usize],
    pub _pad1_: cacheline_padding,
    pub lruvec: lruvec,
    pub __bindgen_padding_1: [u64; 6usize],
    pub _pad2_: cacheline_padding,
    pub lru_zone_size: [[ffi::c_ulong; 5usize]; 3usize],
    pub iter: mem_cgroup_reclaim_iter,
}
impl Default for mem_cgroup_per_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_threshold {
    pub eventfd: *mut eventfd_ctx,
    pub threshold: ffi::c_ulong,
}
impl Default for mem_cgroup_threshold {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct mem_cgroup_threshold_ary {
    pub current_threshold: ffi::c_int,
    pub size: ffi::c_uint,
    pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
}
impl Default for mem_cgroup_threshold_ary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_thresholds {
    pub primary: *mut mem_cgroup_threshold_ary,
    pub spare: *mut mem_cgroup_threshold_ary,
}
impl Default for mem_cgroup_thresholds {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_cgwb_frn {
    pub bdi_id: u64_,
    pub memcg_id: ffi::c_int,
    pub at: u64_,
    pub done: wb_completion,
}
impl Default for memcg_cgwb_frn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obj_cgroup {
    pub refcnt: percpu_ref,
    pub memcg: *mut mem_cgroup,
    pub nr_charged_bytes: atomic_t,
    pub __bindgen_anon_1: obj_cgroup__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obj_cgroup__bindgen_ty_1 {
    pub list: list_head,
    pub rcu: callback_head,
}
impl Default for obj_cgroup__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for obj_cgroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup {
    pub css: cgroup_subsys_state,
    pub id: mem_cgroup_id,
    pub __bindgen_padding_0: [u64; 5usize],
    pub memory: page_counter,
    pub __bindgen_anon_1: mem_cgroup__bindgen_ty_1,
    pub memory_peaks: list_head,
    pub swap_peaks: list_head,
    pub peaks_lock: spinlock_t,
    pub high_work: work_struct,
    pub vmpressure: vmpressure,
    pub oom_group: bool_,
    pub swappiness: ffi::c_int,
    pub events_file: cgroup_file,
    pub events_local_file: cgroup_file,
    pub swap_events_file: cgroup_file,
    pub vmstats: *mut memcg_vmstats,
    pub memory_events: [atomic_long_t; 9usize],
    pub memory_events_local: [atomic_long_t; 9usize],
    pub socket_pressure: u64_,
    pub kmemcg_id: ffi::c_int,
    pub objcg: *mut obj_cgroup,
    pub orig_objcg: *mut obj_cgroup,
    pub objcg_list: list_head,
    pub vmstats_percpu: *mut memcg_vmstats_percpu,
    pub cgwb_list: list_head,
    pub cgwb_domain: wb_domain,
    pub cgwb_frn: [memcg_cgwb_frn; 4usize],
    pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup__bindgen_ty_1 {
    pub swap: __BindgenUnionField<page_counter>,
    pub memsw: __BindgenUnionField<page_counter>,
    pub bindgen_union_field: [u8; 192usize],
}
impl Default for mem_cgroup__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mem_cgroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const page_memcg_data_flags_MEMCG_DATA_OBJEXTS: page_memcg_data_flags = 1;
pub const page_memcg_data_flags_MEMCG_DATA_KMEM: page_memcg_data_flags = 2;
pub const page_memcg_data_flags___NR_MEMCG_DATA_FLAGS: page_memcg_data_flags = 4;
pub type page_memcg_data_flags = ffi::c_uint;
pub const objext_flags_OBJEXTS_ALLOC_FAIL: objext_flags = 4;
pub const objext_flags___NR_OBJEXTS_FLAGS: objext_flags = 8;
pub type objext_flags = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct slabobj_ext {
    pub objcg: *mut obj_cgroup,
}
impl Default for slabobj_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rqspinlock {
    pub __bindgen_anon_1: rqspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rqspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub locked: u32_,
}
impl Default for rqspinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rqspinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_res_spin_lock {
    pub val: u32_,
}
pub type rqspinlock_t = qspinlock;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rqspinlock_held {
    pub cnt: ffi::c_int,
    pub locks: [*mut ffi::c_void; 31usize],
}
impl Default for rqspinlock_held {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_arena {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_mem_alloc {
    _unused: [u8; 0],
}

pub type bpf_callback_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: u64_, arg2: u64_, arg3: u64_, arg4: u64_, arg5: u64_) -> u64_,
>;
pub type bpf_iter_init_seq_priv_t = ::core::option::Option<
    unsafe extern "C" fn(private_data: *mut ffi::c_void, aux: *mut bpf_iter_aux_info) -> ffi::c_int,
>;
pub type bpf_iter_fini_seq_priv_t =
    ::core::option::Option<unsafe extern "C" fn(private_data: *mut ffi::c_void)>;
pub type bpf_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ffi::c_void, arg2: *const bpf_insn) -> ffi::c_uint,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_seq_info {
    pub seq_ops: *const seq_operations,
    pub init_seq_private: bpf_iter_init_seq_priv_t,
    pub fini_seq_private: bpf_iter_fini_seq_priv_t,
    pub seq_priv_size: u32_,
}
impl Default for bpf_iter_seq_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map_ops {
    pub map_alloc_check:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> ffi::c_int>,
    pub map_alloc:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> *mut bpf_map>,
    pub map_release:
        ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map, map_file: *mut file)>,
    pub map_free: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut ffi::c_void,
            next_key: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub map_release_uref: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_lookup_elem_sys_only: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut ffi::c_void) -> *mut ffi::c_void,
    >,
    pub map_lookup_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> ffi::c_int,
    >,
    pub map_lookup_and_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut ffi::c_void,
            value: *mut ffi::c_void,
            flags: u64_,
        ) -> ffi::c_int,
    >,
    pub map_lookup_and_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> ffi::c_int,
    >,
    pub map_update_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            map_file: *mut file,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> ffi::c_int,
    >,
    pub map_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> ffi::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut ffi::c_void) -> *mut ffi::c_void,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut ffi::c_void,
            value: *mut ffi::c_void,
            flags: u64_,
        ) -> ffi::c_long,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut ffi::c_void) -> ffi::c_long,
    >,
    pub map_push_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            value: *mut ffi::c_void,
            flags: u64_,
        ) -> ffi::c_long,
    >,
    pub map_pop_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut ffi::c_void) -> ffi::c_long,
    >,
    pub map_peek_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut ffi::c_void) -> ffi::c_long,
    >,
    pub map_lookup_percpu_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut ffi::c_void,
            cpu: u32_,
        ) -> *mut ffi::c_void,
    >,
    pub map_fd_get_ptr: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            map_file: *mut file,
            fd: ffi::c_int,
        ) -> *mut ffi::c_void,
    >,
    pub map_fd_put_ptr: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, ptr: *mut ffi::c_void, need_defer: bool_),
    >,
    pub map_gen_lookup: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, insn_buf: *mut bpf_insn) -> ffi::c_int,
    >,
    pub map_fd_sys_lookup_elem:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut ffi::c_void) -> u32_>,
    pub map_seq_show_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut ffi::c_void, m: *mut seq_file),
    >,
    pub map_check_btf: ::core::option::Option<
        unsafe extern "C" fn(
            map: *const bpf_map,
            btf: *const btf,
            key_type: *const btf_type,
            value_type: *const btf_type,
        ) -> ffi::c_int,
    >,
    pub map_poke_track: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, aux: *mut bpf_prog_aux) -> ffi::c_int,
    >,
    pub map_poke_untrack:
        ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map, aux: *mut bpf_prog_aux)>,
    pub map_poke_run: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: u32_, old: *mut bpf_prog, new: *mut bpf_prog),
    >,
    pub map_direct_value_addr: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: *mut u64_, off: u32_) -> ffi::c_int,
    >,
    pub map_direct_value_meta: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: u64_, off: *mut u32_) -> ffi::c_int,
    >,
    pub map_mmap: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, vma: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub map_poll: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            filp: *mut file,
            pts: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub map_get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filep: *mut file,
            addr: ffi::c_ulong,
            len: ffi::c_ulong,
            pgoff: ffi::c_ulong,
            flags: ffi::c_ulong,
        ) -> ffi::c_ulong,
    >,
    pub map_local_storage_charge: ::core::option::Option<
        unsafe extern "C" fn(
            smap: *mut bpf_local_storage_map,
            owner: *mut ffi::c_void,
            size: u32_,
        ) -> ffi::c_int,
    >,
    pub map_local_storage_uncharge: ::core::option::Option<
        unsafe extern "C" fn(smap: *mut bpf_local_storage_map, owner: *mut ffi::c_void, size: u32_),
    >,
    pub map_owner_storage_ptr: ::core::option::Option<
        unsafe extern "C" fn(owner: *mut ffi::c_void) -> *mut *mut bpf_local_storage,
    >,
    pub map_redirect: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: u64_, flags: u64_) -> ffi::c_long,
    >,
    pub map_meta_equal: ::core::option::Option<
        unsafe extern "C" fn(meta0: *const bpf_map, meta1: *const bpf_map) -> bool_,
    >,
    pub map_set_for_each_callback_args: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            caller: *mut bpf_func_state,
            callee: *mut bpf_func_state,
        ) -> ffi::c_int,
    >,
    pub map_for_each_callback: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            callback_fn: bpf_callback_t,
            callback_ctx: *mut ffi::c_void,
            flags: u64_,
        ) -> ffi::c_long,
    >,
    pub map_mem_usage: ::core::option::Option<unsafe extern "C" fn(map: *const bpf_map) -> u64_>,
    pub map_btf_id: *mut ffi::c_int,
    pub iter_seq_info: *const bpf_iter_seq_info,
}
impl Default for bpf_map_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BTF_FIELDS_MAX: _bindgen_ty_250 = 11;
pub type _bindgen_ty_250 = ffi::c_uint;
pub const btf_field_type_BPF_SPIN_LOCK: btf_field_type = 1;
pub const btf_field_type_BPF_TIMER: btf_field_type = 2;
pub const btf_field_type_BPF_KPTR_UNREF: btf_field_type = 4;
pub const btf_field_type_BPF_KPTR_REF: btf_field_type = 8;
pub const btf_field_type_BPF_KPTR_PERCPU: btf_field_type = 16;
pub const btf_field_type_BPF_KPTR: btf_field_type = 28;
pub const btf_field_type_BPF_LIST_HEAD: btf_field_type = 32;
pub const btf_field_type_BPF_LIST_NODE: btf_field_type = 64;
pub const btf_field_type_BPF_RB_ROOT: btf_field_type = 128;
pub const btf_field_type_BPF_RB_NODE: btf_field_type = 256;
pub const btf_field_type_BPF_GRAPH_NODE: btf_field_type = 320;
pub const btf_field_type_BPF_GRAPH_ROOT: btf_field_type = 160;
pub const btf_field_type_BPF_REFCOUNT: btf_field_type = 512;
pub const btf_field_type_BPF_WORKQUEUE: btf_field_type = 1024;
pub const btf_field_type_BPF_UPTR: btf_field_type = 2048;
pub const btf_field_type_BPF_RES_SPIN_LOCK: btf_field_type = 4096;
pub type btf_field_type = ffi::c_uint;
pub const bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_SHARED: bpf_cgroup_storage_type = 0;
pub const bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_PERCPU: bpf_cgroup_storage_type = 1;
pub const bpf_cgroup_storage_type___BPF_CGROUP_STORAGE_MAX: bpf_cgroup_storage_type = 2;
pub type bpf_cgroup_storage_type = ffi::c_uint;
pub type btf_dtor_kfunc_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_field_kptr {
    pub btf: *mut btf,
    pub module: *mut module,
    pub dtor: btf_dtor_kfunc_t,
    pub btf_id: u32_,
}
impl Default for btf_field_kptr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_field_graph_root {
    pub btf: *mut btf,
    pub value_btf_id: u32_,
    pub node_offset: u32_,
    pub value_rec: *mut btf_record,
}
impl Default for btf_field_graph_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_field {
    pub offset: u32_,
    pub size: u32_,
    pub type_: btf_field_type,
    pub __bindgen_anon_1: btf_field__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_field__bindgen_ty_1 {
    pub kptr: btf_field_kptr,
    pub graph_root: btf_field_graph_root,
}
impl Default for btf_field__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btf_field {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btf_record {
    pub cnt: u32_,
    pub field_mask: u32_,
    pub spin_lock_off: ffi::c_int,
    pub res_spin_lock_off: ffi::c_int,
    pub timer_off: ffi::c_int,
    pub wq_off: ffi::c_int,
    pub refcount_off: ffi::c_int,
    pub fields: __IncompleteArrayField<btf_field>,
}
impl Default for btf_record {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_rb_node_kern {
    pub rb_node: rb_node,
    pub owner: *mut ffi::c_void,
}
impl Default for bpf_rb_node_kern {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_list_node_kern {
    pub list_head: list_head,
    pub owner: *mut ffi::c_void,
}
impl Default for bpf_list_node_kern {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map_owner {
    pub type_: bpf_prog_type,
    pub jited: bool_,
    pub xdp_has_frags: bool_,
    pub storage_cookie: [u64_; 2usize],
    pub attach_func_proto: *const btf_type,
}
impl Default for bpf_map_owner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map {
    pub ops: *const bpf_map_ops,
    pub inner_map_meta: *mut bpf_map,
    pub security: *mut ffi::c_void,
    pub map_type: bpf_map_type,
    pub key_size: u32_,
    pub value_size: u32_,
    pub max_entries: u32_,
    pub map_extra: u64_,
    pub map_flags: u32_,
    pub id: u32_,
    pub record: *mut btf_record,
    pub numa_node: ffi::c_int,
    pub btf_key_type_id: u32_,
    pub btf_value_type_id: u32_,
    pub btf_vmlinux_value_type_id: u32_,
    pub btf: *mut btf,
    pub objcg: *mut obj_cgroup,
    pub name: [ffi::c_char; 16usize],
    pub freeze_mutex: mutex,
    pub refcnt: atomic64_t,
    pub usercnt: atomic64_t,
    pub __bindgen_anon_1: bpf_map__bindgen_ty_1,
    pub writecnt: atomic64_t,
    pub owner_lock: spinlock_t,
    pub owner: *mut bpf_map_owner,
    pub bypass_spec_v1: bool_,
    pub frozen: bool_,
    pub free_after_mult_rcu_gp: bool_,
    pub free_after_rcu_gp: bool_,
    pub sleepable_refcnt: atomic64_t,
    pub elem_count: *mut s64,
    pub cookie: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_map__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
}
impl Default for bpf_map__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_offload_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_map_dev_ops {
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut ffi::c_void,
            next_key: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut ffi::c_void,
            value: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut ffi::c_void,
            value: *mut ffi::c_void,
            flags: u64_,
        ) -> ffi::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_offloaded_map, key: *mut ffi::c_void) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_offloaded_map {
    pub map: bpf_map,
    pub netdev: *mut net_device,
    pub dev_ops: *const bpf_map_dev_ops,
    pub dev_priv: *mut ffi::c_void,
    pub offloads: list_head,
}
impl Default for bpf_offloaded_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const bpf_type_flag_PTR_MAYBE_NULL: bpf_type_flag = 256;
pub const bpf_type_flag_MEM_RDONLY: bpf_type_flag = 512;
pub const bpf_type_flag_MEM_RINGBUF: bpf_type_flag = 1024;
pub const bpf_type_flag_MEM_USER: bpf_type_flag = 2048;
pub const bpf_type_flag_MEM_PERCPU: bpf_type_flag = 4096;
pub const bpf_type_flag_OBJ_RELEASE: bpf_type_flag = 8192;
pub const bpf_type_flag_PTR_UNTRUSTED: bpf_type_flag = 16384;
pub const bpf_type_flag_MEM_UNINIT: bpf_type_flag = 32768;
pub const bpf_type_flag_DYNPTR_TYPE_LOCAL: bpf_type_flag = 65536;
pub const bpf_type_flag_DYNPTR_TYPE_RINGBUF: bpf_type_flag = 131072;
pub const bpf_type_flag_MEM_FIXED_SIZE: bpf_type_flag = 262144;
pub const bpf_type_flag_MEM_ALLOC: bpf_type_flag = 524288;
pub const bpf_type_flag_PTR_TRUSTED: bpf_type_flag = 1048576;
pub const bpf_type_flag_MEM_RCU: bpf_type_flag = 2097152;
pub const bpf_type_flag_NON_OWN_REF: bpf_type_flag = 4194304;
pub const bpf_type_flag_DYNPTR_TYPE_SKB: bpf_type_flag = 8388608;
pub const bpf_type_flag_DYNPTR_TYPE_XDP: bpf_type_flag = 16777216;
pub const bpf_type_flag_MEM_ALIGNED: bpf_type_flag = 33554432;
pub const bpf_type_flag_MEM_WRITE: bpf_type_flag = 67108864;
pub const bpf_type_flag___BPF_TYPE_FLAG_MAX: bpf_type_flag = 67108865;
pub const bpf_type_flag___BPF_TYPE_LAST_FLAG: bpf_type_flag = 67108864;
pub type bpf_type_flag = ffi::c_uint;
pub const bpf_arg_type_ARG_DONTCARE: bpf_arg_type = 0;
pub const bpf_arg_type_ARG_CONST_MAP_PTR: bpf_arg_type = 1;
pub const bpf_arg_type_ARG_PTR_TO_MAP_KEY: bpf_arg_type = 2;
pub const bpf_arg_type_ARG_PTR_TO_MAP_VALUE: bpf_arg_type = 3;
pub const bpf_arg_type_ARG_PTR_TO_MEM: bpf_arg_type = 4;
pub const bpf_arg_type_ARG_PTR_TO_ARENA: bpf_arg_type = 5;
pub const bpf_arg_type_ARG_CONST_SIZE: bpf_arg_type = 6;
pub const bpf_arg_type_ARG_CONST_SIZE_OR_ZERO: bpf_arg_type = 7;
pub const bpf_arg_type_ARG_PTR_TO_CTX: bpf_arg_type = 8;
pub const bpf_arg_type_ARG_ANYTHING: bpf_arg_type = 9;
pub const bpf_arg_type_ARG_PTR_TO_SPIN_LOCK: bpf_arg_type = 10;
pub const bpf_arg_type_ARG_PTR_TO_SOCK_COMMON: bpf_arg_type = 11;
pub const bpf_arg_type_ARG_PTR_TO_SOCKET: bpf_arg_type = 12;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID: bpf_arg_type = 13;
pub const bpf_arg_type_ARG_PTR_TO_RINGBUF_MEM: bpf_arg_type = 14;
pub const bpf_arg_type_ARG_CONST_ALLOC_SIZE_OR_ZERO: bpf_arg_type = 15;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID_SOCK_COMMON: bpf_arg_type = 16;
pub const bpf_arg_type_ARG_PTR_TO_PERCPU_BTF_ID: bpf_arg_type = 17;
pub const bpf_arg_type_ARG_PTR_TO_FUNC: bpf_arg_type = 18;
pub const bpf_arg_type_ARG_PTR_TO_STACK: bpf_arg_type = 19;
pub const bpf_arg_type_ARG_PTR_TO_CONST_STR: bpf_arg_type = 20;
pub const bpf_arg_type_ARG_PTR_TO_TIMER: bpf_arg_type = 21;
pub const bpf_arg_type_ARG_KPTR_XCHG_DEST: bpf_arg_type = 22;
pub const bpf_arg_type_ARG_PTR_TO_DYNPTR: bpf_arg_type = 23;
pub const bpf_arg_type___BPF_ARG_TYPE_MAX: bpf_arg_type = 24;
pub const bpf_arg_type_ARG_PTR_TO_MAP_VALUE_OR_NULL: bpf_arg_type = 259;
pub const bpf_arg_type_ARG_PTR_TO_MEM_OR_NULL: bpf_arg_type = 260;
pub const bpf_arg_type_ARG_PTR_TO_CTX_OR_NULL: bpf_arg_type = 264;
pub const bpf_arg_type_ARG_PTR_TO_SOCKET_OR_NULL: bpf_arg_type = 268;
pub const bpf_arg_type_ARG_PTR_TO_STACK_OR_NULL: bpf_arg_type = 275;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID_OR_NULL: bpf_arg_type = 269;
pub const bpf_arg_type_ARG_PTR_TO_UNINIT_MEM: bpf_arg_type = 67141636;
pub const bpf_arg_type_ARG_PTR_TO_FIXED_SIZE_MEM: bpf_arg_type = 262148;
pub const bpf_arg_type___BPF_ARG_TYPE_LIMIT: bpf_arg_type = 134217727;
pub type bpf_arg_type = ffi::c_uint;
pub const bpf_return_type_RET_INTEGER: bpf_return_type = 0;
pub const bpf_return_type_RET_VOID: bpf_return_type = 1;
pub const bpf_return_type_RET_PTR_TO_MAP_VALUE: bpf_return_type = 2;
pub const bpf_return_type_RET_PTR_TO_SOCKET: bpf_return_type = 3;
pub const bpf_return_type_RET_PTR_TO_TCP_SOCK: bpf_return_type = 4;
pub const bpf_return_type_RET_PTR_TO_SOCK_COMMON: bpf_return_type = 5;
pub const bpf_return_type_RET_PTR_TO_MEM: bpf_return_type = 6;
pub const bpf_return_type_RET_PTR_TO_MEM_OR_BTF_ID: bpf_return_type = 7;
pub const bpf_return_type_RET_PTR_TO_BTF_ID: bpf_return_type = 8;
pub const bpf_return_type___BPF_RET_TYPE_MAX: bpf_return_type = 9;
pub const bpf_return_type_RET_PTR_TO_MAP_VALUE_OR_NULL: bpf_return_type = 258;
pub const bpf_return_type_RET_PTR_TO_SOCKET_OR_NULL: bpf_return_type = 259;
pub const bpf_return_type_RET_PTR_TO_TCP_SOCK_OR_NULL: bpf_return_type = 260;
pub const bpf_return_type_RET_PTR_TO_SOCK_COMMON_OR_NULL: bpf_return_type = 261;
pub const bpf_return_type_RET_PTR_TO_RINGBUF_MEM_OR_NULL: bpf_return_type = 1286;
pub const bpf_return_type_RET_PTR_TO_DYNPTR_MEM_OR_NULL: bpf_return_type = 262;
pub const bpf_return_type_RET_PTR_TO_BTF_ID_OR_NULL: bpf_return_type = 264;
pub const bpf_return_type_RET_PTR_TO_BTF_ID_TRUSTED: bpf_return_type = 1048584;
pub const bpf_return_type___BPF_RET_TYPE_LIMIT: bpf_return_type = 134217727;
pub type bpf_return_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(r1: u64_, r2: u64_, r3: u64_, r4: u64_, r5: u64_) -> u64_,
    >,
    pub gpl_only: bool_,
    pub pkt_access: bool_,
    pub might_sleep: bool_,
    pub allow_fastcall: bool_,
    pub ret_type: bpf_return_type,
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2,
    pub ret_btf_id: *mut ffi::c_int,
    pub allowed: ::core::option::Option<unsafe extern "C" fn(prog: *const bpf_prog) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1__bindgen_ty_1,
    pub arg_type: [bpf_arg_type; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    pub arg1_type: bpf_arg_type,
    pub arg2_type: bpf_arg_type,
    pub arg3_type: bpf_arg_type,
    pub arg4_type: bpf_arg_type,
    pub arg5_type: bpf_arg_type,
}
impl Default for bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_func_proto__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_2 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_2__bindgen_ty_1,
    pub arg_btf_id: [*mut u32_; 5usize],
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2__bindgen_ty_2,
    pub arg_size: [usize; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    pub arg1_btf_id: *mut u32_,
    pub arg2_btf_id: *mut u32_,
    pub arg3_btf_id: *mut u32_,
    pub arg4_btf_id: *mut u32_,
    pub arg5_btf_id: *mut u32_,
}
impl Default for bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_2 {
    pub arg1_size: usize,
    pub arg2_size: usize,
    pub arg3_size: usize,
    pub arg4_size: usize,
    pub arg5_size: usize,
}
impl Default for bpf_func_proto__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_func_proto {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_context {
    _unused: [u8; 0],
}
pub const bpf_access_type_BPF_READ: bpf_access_type = 1;
pub const bpf_access_type_BPF_WRITE: bpf_access_type = 2;
pub type bpf_access_type = ffi::c_uint;
pub const bpf_reg_type_NOT_INIT: bpf_reg_type = 0;
pub const bpf_reg_type_SCALAR_VALUE: bpf_reg_type = 1;
pub const bpf_reg_type_PTR_TO_CTX: bpf_reg_type = 2;
pub const bpf_reg_type_CONST_PTR_TO_MAP: bpf_reg_type = 3;
pub const bpf_reg_type_PTR_TO_MAP_VALUE: bpf_reg_type = 4;
pub const bpf_reg_type_PTR_TO_MAP_KEY: bpf_reg_type = 5;
pub const bpf_reg_type_PTR_TO_STACK: bpf_reg_type = 6;
pub const bpf_reg_type_PTR_TO_PACKET_META: bpf_reg_type = 7;
pub const bpf_reg_type_PTR_TO_PACKET: bpf_reg_type = 8;
pub const bpf_reg_type_PTR_TO_PACKET_END: bpf_reg_type = 9;
pub const bpf_reg_type_PTR_TO_FLOW_KEYS: bpf_reg_type = 10;
pub const bpf_reg_type_PTR_TO_SOCKET: bpf_reg_type = 11;
pub const bpf_reg_type_PTR_TO_SOCK_COMMON: bpf_reg_type = 12;
pub const bpf_reg_type_PTR_TO_TCP_SOCK: bpf_reg_type = 13;
pub const bpf_reg_type_PTR_TO_TP_BUFFER: bpf_reg_type = 14;
pub const bpf_reg_type_PTR_TO_XDP_SOCK: bpf_reg_type = 15;
pub const bpf_reg_type_PTR_TO_BTF_ID: bpf_reg_type = 16;
pub const bpf_reg_type_PTR_TO_MEM: bpf_reg_type = 17;
pub const bpf_reg_type_PTR_TO_ARENA: bpf_reg_type = 18;
pub const bpf_reg_type_PTR_TO_BUF: bpf_reg_type = 19;
pub const bpf_reg_type_PTR_TO_FUNC: bpf_reg_type = 20;
pub const bpf_reg_type_CONST_PTR_TO_DYNPTR: bpf_reg_type = 21;
pub const bpf_reg_type___BPF_REG_TYPE_MAX: bpf_reg_type = 22;
pub const bpf_reg_type_PTR_TO_MAP_VALUE_OR_NULL: bpf_reg_type = 260;
pub const bpf_reg_type_PTR_TO_SOCKET_OR_NULL: bpf_reg_type = 267;
pub const bpf_reg_type_PTR_TO_SOCK_COMMON_OR_NULL: bpf_reg_type = 268;
pub const bpf_reg_type_PTR_TO_TCP_SOCK_OR_NULL: bpf_reg_type = 269;
pub const bpf_reg_type_PTR_TO_BTF_ID_OR_NULL: bpf_reg_type = 272;
pub const bpf_reg_type___BPF_REG_TYPE_LIMIT: bpf_reg_type = 134217727;
pub type bpf_reg_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux {
    pub reg_type: bpf_reg_type,
    pub is_ldsx: bool_,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1,
    pub log: *mut bpf_verifier_log,
    pub is_retval: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_access_aux__bindgen_ty_1 {
    pub ctx_field_size: ffi::c_int,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
    pub ref_obj_id: u32_,
}
impl Default for bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_insn_access_aux__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_insn_access_aux {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_ops {
    pub test_run: ::core::option::Option<
        unsafe extern "C" fn(
            prog: *mut bpf_prog,
            kattr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_reg_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_verifier_ops {
    pub get_func_proto: ::core::option::Option<
        unsafe extern "C" fn(func_id: bpf_func_id, prog: *const bpf_prog) -> *const bpf_func_proto,
    >,
    pub is_valid_access: ::core::option::Option<
        unsafe extern "C" fn(
            off: ffi::c_int,
            size: ffi::c_int,
            type_: bpf_access_type,
            prog: *const bpf_prog,
            info: *mut bpf_insn_access_aux,
        ) -> bool_,
    >,
    pub gen_prologue: ::core::option::Option<
        unsafe extern "C" fn(
            insn: *mut bpf_insn,
            direct_write: bool_,
            prog: *const bpf_prog,
        ) -> ffi::c_int,
    >,
    pub gen_epilogue: ::core::option::Option<
        unsafe extern "C" fn(
            insn: *mut bpf_insn,
            prog: *const bpf_prog,
            ctx_stack_off: s16,
        ) -> ffi::c_int,
    >,
    pub gen_ld_abs: ::core::option::Option<
        unsafe extern "C" fn(orig: *const bpf_insn, insn_buf: *mut bpf_insn) -> ffi::c_int,
    >,
    pub convert_ctx_access: ::core::option::Option<
        unsafe extern "C" fn(
            type_: bpf_access_type,
            src: *const bpf_insn,
            dst: *mut bpf_insn,
            prog: *mut bpf_prog,
            target_size: *mut u32_,
        ) -> u32_,
    >,
    pub btf_struct_access: ::core::option::Option<
        unsafe extern "C" fn(
            log: *mut bpf_verifier_log,
            reg: *const bpf_reg_state,
            off: ffi::c_int,
            size: ffi::c_int,
        ) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_offload_ops {
    pub insn_hook: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            insn_idx: ffi::c_int,
            prev_insn_idx: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub finalize:
        ::core::option::Option<unsafe extern "C" fn(env: *mut bpf_verifier_env) -> ffi::c_int>,
    pub replace_insn: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            off: u32_,
            insn: *mut bpf_insn,
        ) -> ffi::c_int,
    >,
    pub remove_insns: ::core::option::Option<
        unsafe extern "C" fn(env: *mut bpf_verifier_env, off: u32_, cnt: u32_) -> ffi::c_int,
    >,
    pub prepare: ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog) -> ffi::c_int>,
    pub translate: ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog) -> ffi::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_offload {
    pub prog: *mut bpf_prog,
    pub netdev: *mut net_device,
    pub offdev: *mut bpf_offload_dev,
    pub dev_priv: *mut ffi::c_void,
    pub offloads: list_head,
    pub dev_state: bool_,
    pub opt_failed: bool_,
    pub jited_image: *mut ffi::c_void,
    pub jited_len: u32_,
}
impl Default for bpf_prog_offload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_func_model {
    pub ret_size: u8_,
    pub ret_flags: u8_,
    pub nr_args: u8_,
    pub arg_size: [u8_; 12usize],
    pub arg_flags: [u8_; 12usize],
}
pub const BPF_MAX_TRAMP_LINKS: _bindgen_ty_251 = 38;
pub type _bindgen_ty_251 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_links {
    pub links: [*mut bpf_tramp_link; 38usize],
    pub nr_links: ffi::c_int,
}
impl Default for bpf_tramp_links {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type bpf_trampoline_enter_t = ::core::option::Option<
    unsafe extern "C" fn(prog: *mut bpf_prog, run_ctx: *mut bpf_tramp_run_ctx) -> u64_,
>;
pub type bpf_trampoline_exit_t = ::core::option::Option<
    unsafe extern "C" fn(prog: *mut bpf_prog, start: u64_, run_ctx: *mut bpf_tramp_run_ctx),
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_ksym {
    pub start: ffi::c_ulong,
    pub end: ffi::c_ulong,
    pub name: [ffi::c_char; 512usize],
    pub lnode: list_head,
    pub tnode: latch_tree_node,
    pub prog: bool_,
}
impl Default for bpf_ksym {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_tramp_prog_type_BPF_TRAMP_FENTRY: bpf_tramp_prog_type = 0;
pub const bpf_tramp_prog_type_BPF_TRAMP_FEXIT: bpf_tramp_prog_type = 1;
pub const bpf_tramp_prog_type_BPF_TRAMP_MODIFY_RETURN: bpf_tramp_prog_type = 2;
pub const bpf_tramp_prog_type_BPF_TRAMP_MAX: bpf_tramp_prog_type = 3;
pub const bpf_tramp_prog_type_BPF_TRAMP_REPLACE: bpf_tramp_prog_type = 4;
pub type bpf_tramp_prog_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_image {
    pub image: *mut ffi::c_void,
    pub size: ffi::c_int,
    pub ksym: bpf_ksym,
    pub pcref: percpu_ref,
    pub ip_after_call: *mut ffi::c_void,
    pub ip_epilogue: *mut ffi::c_void,
    pub __bindgen_anon_1: bpf_tramp_image__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tramp_image__bindgen_ty_1 {
    pub rcu: callback_head,
    pub work: work_struct,
}
impl Default for bpf_tramp_image__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_tramp_image {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline {
    pub hlist: hlist_node,
    pub fops: *mut ftrace_ops,
    pub mutex: mutex,
    pub refcnt: refcount_t,
    pub flags: u32_,
    pub key: u64_,
    pub func: bpf_trampoline__bindgen_ty_1,
    pub extension_prog: *mut bpf_prog,
    pub progs_hlist: [hlist_head; 3usize],
    pub progs_cnt: [ffi::c_int; 3usize],
    pub cur_image: *mut bpf_tramp_image,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline__bindgen_ty_1 {
    pub model: btf_func_model,
    pub addr: *mut ffi::c_void,
    pub ftrace_managed: bool_,
}
impl Default for bpf_trampoline__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_trampoline {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attach_target_info {
    pub fmodel: btf_func_model,
    pub tgt_addr: ffi::c_long,
    pub tgt_mod: *mut module,
    pub tgt_name: *const ffi::c_char,
    pub tgt_type: *const btf_type,
}
impl Default for bpf_attach_target_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dispatcher_prog {
    pub prog: *mut bpf_prog,
    pub users: refcount_t,
}
impl Default for bpf_dispatcher_prog {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dispatcher {
    pub mutex: mutex,
    pub func: *mut ffi::c_void,
    pub progs: [bpf_dispatcher_prog; 48usize],
    pub num_progs: ffi::c_int,
    pub image: *mut ffi::c_void,
    pub rw_image: *mut ffi::c_void,
    pub image_off: u32_,
    pub ksym: bpf_ksym,
}
impl Default for bpf_dispatcher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dynptr_kern {
    pub data: *mut ffi::c_void,
    pub size: u32_,
    pub offset: u32_,
}
impl Default for bpf_dynptr_kern {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_INVALID: bpf_dynptr_type = 0;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_LOCAL: bpf_dynptr_type = 1;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_RINGBUF: bpf_dynptr_type = 2;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_SKB: bpf_dynptr_type = 3;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_XDP: bpf_dynptr_type = 4;
pub type bpf_dynptr_type = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_info_aux {
    pub linkage: u16_,
    pub unreliable: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl bpf_func_info_aux {
    #[inline]
    pub fn called(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_called(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn called_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_called_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn verified(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_verified(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn verified_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_verified_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(called: bool_, verified: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let called: u8 = unsafe { ::core::mem::transmute(called) };
            called as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let verified: u8 = unsafe { ::core::mem::transmute(verified) };
            verified as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const bpf_jit_poke_reason_BPF_POKE_REASON_TAIL_CALL: bpf_jit_poke_reason = 0;
pub type bpf_jit_poke_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor {
    pub tailcall_target: *mut ffi::c_void,
    pub tailcall_bypass: *mut ffi::c_void,
    pub bypass_addr: *mut ffi::c_void,
    pub aux: *mut ffi::c_void,
    pub __bindgen_anon_1: bpf_jit_poke_descriptor__bindgen_ty_1,
    pub tailcall_target_stable: bool_,
    pub adj_off: u8_,
    pub reason: u16_,
    pub insn_idx: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_jit_poke_descriptor__bindgen_ty_1 {
    pub tail_call: bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub map: *mut bpf_map,
    pub key: u32_,
}
impl Default for bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_jit_poke_descriptor__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_jit_poke_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_ctx_arg_aux {
    pub offset: u32_,
    pub reg_type: bpf_reg_type,
    pub btf: *mut btf,
    pub btf_id: u32_,
    pub ref_obj_id: u32_,
    pub refcounted: bool_,
}
impl Default for bpf_ctx_arg_aux {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_mod_pair {
    pub btf: *mut btf,
    pub module: *mut module,
}
impl Default for btf_mod_pair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_kfunc_desc_tab {
    _unused: [u8; 0],
}
pub const bpf_stream_id_BPF_STDOUT: bpf_stream_id = 1;
pub const bpf_stream_id_BPF_STDERR: bpf_stream_id = 2;
pub type bpf_stream_id = ffi::c_uint;
#[repr(C)]
pub struct bpf_stream_elem {
    pub node: llist_node,
    pub total_len: ffi::c_int,
    pub consumed_len: ffi::c_int,
    pub str_: __IncompleteArrayField<ffi::c_char>,
}
impl Default for bpf_stream_elem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BPF_STREAM_MAX_CAPACITY: _bindgen_ty_252 = 100000;
pub type _bindgen_ty_252 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stream {
    pub capacity: atomic_t,
    pub log: llist_head,
    pub lock: mutex,
    pub backlog_head: *mut llist_node,
    pub backlog_tail: *mut llist_node,
}
impl Default for bpf_stream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stream_stage {
    pub log: llist_head,
    pub len: ffi::c_int,
}
impl Default for bpf_stream_stage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    pub refcnt: atomic64_t,
    pub used_map_cnt: u32_,
    pub used_btf_cnt: u32_,
    pub max_ctx_offset: u32_,
    pub max_pkt_offset: u32_,
    pub max_tp_access: u32_,
    pub stack_depth: u32_,
    pub id: u32_,
    pub func_cnt: u32_,
    pub real_func_cnt: u32_,
    pub func_idx: u32_,
    pub attach_btf_id: u32_,
    pub attach_st_ops_member_off: u32_,
    pub ctx_arg_info_size: u32_,
    pub max_rdonly_access: u32_,
    pub max_rdwr_access: u32_,
    pub attach_btf: *mut btf,
    pub ctx_arg_info: *mut bpf_ctx_arg_aux,
    pub priv_stack_ptr: *mut ffi::c_void,
    pub dst_mutex: mutex,
    pub dst_prog: *mut bpf_prog,
    pub dst_trampoline: *mut bpf_trampoline,
    pub saved_dst_prog_type: bpf_prog_type,
    pub saved_dst_attach_type: bpf_attach_type,
    pub verifier_zext: bool_,
    pub dev_bound: bool_,
    pub offload_requested: bool_,
    pub attach_btf_trace: bool_,
    pub attach_tracing_prog: bool_,
    pub func_proto_unreliable: bool_,
    pub tail_call_reachable: bool_,
    pub xdp_has_frags: bool_,
    pub exception_cb: bool_,
    pub exception_boundary: bool_,
    pub is_extended: bool_,
    pub jits_use_priv_stack: bool_,
    pub priv_stack_requested: bool_,
    pub changes_pkt_data: bool_,
    pub might_sleep: bool_,
    pub prog_array_member_cnt: u64_,
    pub ext_mutex: mutex,
    pub arena: *mut bpf_arena,
    pub recursion_detected: ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog)>,
    pub attach_func_proto: *const btf_type,
    pub attach_func_name: *const ffi::c_char,
    pub func: *mut *mut bpf_prog,
    pub jit_data: *mut ffi::c_void,
    pub poke_tab: *mut bpf_jit_poke_descriptor,
    pub kfunc_tab: *mut bpf_kfunc_desc_tab,
    pub kfunc_btf_tab: *mut bpf_kfunc_btf_tab,
    pub size_poke_tab: u32_,
    pub ksym: bpf_ksym,
    pub ops: *const bpf_prog_ops,
    pub st_ops: *const bpf_struct_ops,
    pub used_maps: *mut *mut bpf_map,
    pub used_maps_mutex: mutex,
    pub used_btfs: *mut btf_mod_pair,
    pub prog: *mut bpf_prog,
    pub user: *mut user_struct,
    pub load_time: u64_,
    pub verified_insns: u32_,
    pub cgroup_atype: ffi::c_int,
    pub cgroup_storage: [*mut bpf_map; 2usize],
    pub name: [ffi::c_char; 16usize],
    pub bpf_exception_cb: ::core::option::Option<
        unsafe extern "C" fn(cookie: u64_, sp: u64_, bp: u64_, arg1: u64_, arg2: u64_) -> u64_,
    >,
    pub security: *mut ffi::c_void,
    pub token: *mut bpf_token,
    pub offload: *mut bpf_prog_offload,
    pub btf: *mut btf,
    pub func_info: *mut bpf_func_info,
    pub func_info_aux: *mut bpf_func_info_aux,
    pub linfo: *mut bpf_line_info,
    pub jited_linfo: *mut *mut ffi::c_void,
    pub func_info_cnt: u32_,
    pub nr_linfo: u32_,
    pub linfo_idx: u32_,
    pub mod_: *mut module,
    pub num_exentries: u32_,
    pub extable: *mut exception_table_entry,
    pub __bindgen_anon_1: bpf_prog_aux__bindgen_ty_1,
    pub stream: [bpf_stream; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_aux__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
}
impl Default for bpf_prog_aux__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_prog_aux {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bpf_prog {
    pub pages: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub type_: bpf_prog_type,
    pub expected_attach_type: bpf_attach_type,
    pub len: u32_,
    pub jited_len: u32_,
    pub tag: [u8_; 8usize],
    pub stats: *mut bpf_prog_stats,
    pub active: *mut ffi::c_int,
    pub bpf_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const ffi::c_void, insn: *const bpf_insn) -> ffi::c_uint,
    >,
    pub aux: *mut bpf_prog_aux,
    pub orig_prog: *mut sock_fprog_kern,
    pub __bindgen_anon_1: bpf_prog__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_prog__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 0usize],
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_insns: bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub insns: __IncompleteArrayField<sock_filter>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Default)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_insnsi: bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub insnsi: __IncompleteArrayField<bpf_insn>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
impl Default for bpf_prog__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_prog {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_prog {
    #[inline]
    pub fn jited(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jited(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jited_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_jited_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jit_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jit_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jit_requested_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_jit_requested_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gpl_compatible(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gpl_compatible_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_gpl_compatible_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cb_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cb_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cb_access_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cb_access_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_needed(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dst_needed(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_needed_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_dst_needed_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blinding_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinding_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blinding_requested_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_blinding_requested_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blinded(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinded(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blinded_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_blinded_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_func(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_func(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_func_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_is_func_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn kprobe_override(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kprobe_override(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn kprobe_override_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_kprobe_override_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_callchain_buf(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_has_callchain_buf(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_callchain_buf_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_has_callchain_buf_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enforce_expected_attach_type(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enforce_expected_attach_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enforce_expected_attach_type_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_enforce_expected_attach_type_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn call_get_stack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_stack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn call_get_stack_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_call_get_stack_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn call_get_func_ip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_func_ip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn call_get_func_ip_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_call_get_func_ip_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tstamp_type_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_type_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tstamp_type_access_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_tstamp_type_access_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sleepable(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sleepable(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sleepable_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_sleepable_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        jited: u16_,
        jit_requested: u16_,
        gpl_compatible: u16_,
        cb_access: u16_,
        dst_needed: u16_,
        blinding_requested: u16_,
        blinded: u16_,
        is_func: u16_,
        kprobe_override: u16_,
        has_callchain_buf: u16_,
        enforce_expected_attach_type: u16_,
        call_get_stack: u16_,
        call_get_func_ip: u16_,
        tstamp_type_access: u16_,
        sleepable: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let jited: u16 = unsafe { ::core::mem::transmute(jited) };
            jited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jit_requested: u16 = unsafe { ::core::mem::transmute(jit_requested) };
            jit_requested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gpl_compatible: u16 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cb_access: u16 = unsafe { ::core::mem::transmute(cb_access) };
            cb_access as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_needed: u16 = unsafe { ::core::mem::transmute(dst_needed) };
            dst_needed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blinding_requested: u16 = unsafe { ::core::mem::transmute(blinding_requested) };
            blinding_requested as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let blinded: u16 = unsafe { ::core::mem::transmute(blinded) };
            blinded as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_func: u16 = unsafe { ::core::mem::transmute(is_func) };
            is_func as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let kprobe_override: u16 = unsafe { ::core::mem::transmute(kprobe_override) };
            kprobe_override as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_callchain_buf: u16 = unsafe { ::core::mem::transmute(has_callchain_buf) };
            has_callchain_buf as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enforce_expected_attach_type: u16 =
                unsafe { ::core::mem::transmute(enforce_expected_attach_type) };
            enforce_expected_attach_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let call_get_stack: u16 = unsafe { ::core::mem::transmute(call_get_stack) };
            call_get_stack as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let call_get_func_ip: u16 = unsafe { ::core::mem::transmute(call_get_func_ip) };
            call_get_func_ip as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tstamp_type_access: u16 = unsafe { ::core::mem::transmute(tstamp_type_access) };
            tstamp_type_access as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sleepable: u16 = unsafe { ::core::mem::transmute(sleepable) };
            sleepable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_array_aux {
    pub poke_progs: list_head,
    pub map: *mut bpf_map,
    pub poke_mutex: mutex,
    pub work: work_struct,
}
impl Default for bpf_array_aux {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link {
    pub refcnt: atomic64_t,
    pub id: u32_,
    pub type_: bpf_link_type,
    pub ops: *const bpf_link_ops,
    pub prog: *mut bpf_prog,
    pub flags: u32_,
    pub attach_type: bpf_attach_type,
    pub __bindgen_anon_1: bpf_link__bindgen_ty_1,
    pub sleepable: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link__bindgen_ty_1 {
    pub rcu: callback_head,
    pub work: work_struct,
}
impl Default for bpf_link__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_ops {
    pub release: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link)>,
    pub dealloc: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link)>,
    pub dealloc_deferred: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link)>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link) -> ffi::c_int>,
    pub update_prog: ::core::option::Option<
        unsafe extern "C" fn(
            link: *mut bpf_link,
            new_prog: *mut bpf_prog,
            old_prog: *mut bpf_prog,
        ) -> ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(link: *const bpf_link, seq: *mut seq_file)>,
    pub fill_link_info: ::core::option::Option<
        unsafe extern "C" fn(link: *const bpf_link, info: *mut bpf_link_info) -> ffi::c_int,
    >,
    pub update_map: ::core::option::Option<
        unsafe extern "C" fn(
            link: *mut bpf_link,
            new_map: *mut bpf_map,
            old_map: *mut bpf_map,
        ) -> ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(file: *mut file, pts: *mut poll_table_struct) -> __poll_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_link {
    pub link: bpf_link,
    pub tramp_hlist: hlist_node,
    pub cookie: u64_,
}
impl Default for bpf_tramp_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_shim_tramp_link {
    pub link: bpf_tramp_link,
    pub trampoline: *mut bpf_trampoline,
}
impl Default for bpf_shim_tramp_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tracing_link {
    pub link: bpf_tramp_link,
    pub trampoline: *mut bpf_trampoline,
    pub tgt_prog: *mut bpf_prog,
}
impl Default for bpf_tracing_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_raw_tp_link {
    pub link: bpf_link,
    pub btp: *mut bpf_raw_event_map,
    pub cookie: u64_,
}
impl Default for bpf_raw_tp_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_primer {
    pub link: *mut bpf_link,
    pub file: *mut file,
    pub fd: ffi::c_int,
    pub id: u32_,
}
impl Default for bpf_link_primer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_mount_opts {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub mode: umode_t,
    pub delegate_cmds: u64_,
    pub delegate_maps: u64_,
    pub delegate_progs: u64_,
    pub delegate_attachs: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_token {
    pub work: work_struct,
    pub refcnt: atomic64_t,
    pub userns: *mut user_namespace,
    pub allowed_cmds: u64_,
    pub allowed_maps: u64_,
    pub allowed_progs: u64_,
    pub allowed_attachs: u64_,
    pub security: *mut ffi::c_void,
}
impl Default for bpf_token {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops {
    pub verifier_ops: *const bpf_verifier_ops,
    pub init: ::core::option::Option<unsafe extern "C" fn(btf: *mut btf) -> ffi::c_int>,
    pub check_member: ::core::option::Option<
        unsafe extern "C" fn(
            t: *const btf_type,
            member: *const btf_member,
            prog: *const bpf_prog,
        ) -> ffi::c_int,
    >,
    pub init_member: ::core::option::Option<
        unsafe extern "C" fn(
            t: *const btf_type,
            member: *const btf_member,
            kdata: *mut ffi::c_void,
            udata: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub reg: ::core::option::Option<
        unsafe extern "C" fn(kdata: *mut ffi::c_void, link: *mut bpf_link) -> ffi::c_int,
    >,
    pub unreg:
        ::core::option::Option<unsafe extern "C" fn(kdata: *mut ffi::c_void, link: *mut bpf_link)>,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            kdata: *mut ffi::c_void,
            old_kdata: *mut ffi::c_void,
            link: *mut bpf_link,
        ) -> ffi::c_int,
    >,
    pub validate:
        ::core::option::Option<unsafe extern "C" fn(kdata: *mut ffi::c_void) -> ffi::c_int>,
    pub cfi_stubs: *mut ffi::c_void,
    pub owner: *mut module,
    pub name: *const ffi::c_char,
    pub func_models: [btf_func_model; 64usize],
}
impl Default for bpf_struct_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops_arg_info {
    pub info: *mut bpf_ctx_arg_aux,
    pub cnt: u32_,
}
impl Default for bpf_struct_ops_arg_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops_desc {
    pub st_ops: *mut bpf_struct_ops,
    pub type_: *const btf_type,
    pub value_type: *const btf_type,
    pub type_id: u32_,
    pub value_id: u32_,
    pub arg_info: *mut bpf_struct_ops_arg_info,
}
impl Default for bpf_struct_ops_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bpf_struct_ops_state_BPF_STRUCT_OPS_STATE_INIT: bpf_struct_ops_state = 0;
pub const bpf_struct_ops_state_BPF_STRUCT_OPS_STATE_INUSE: bpf_struct_ops_state = 1;
pub const bpf_struct_ops_state_BPF_STRUCT_OPS_STATE_TOBEFREE: bpf_struct_ops_state = 2;
pub const bpf_struct_ops_state_BPF_STRUCT_OPS_STATE_READY: bpf_struct_ops_state = 3;
pub type bpf_struct_ops_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops_common_value {
    pub refcnt: refcount_t,
    pub state: bpf_struct_ops_state,
}
impl Default for bpf_struct_ops_common_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
pub struct bpf_array {
    pub map: bpf_map,
    pub elem_size: u32_,
    pub index_mask: u32_,
    pub aux: *mut bpf_array_aux,
    pub __bindgen_anon_1: bpf_array__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_array__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<bpf_array__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<bpf_array__bindgen_ty_1__bindgen_ty_2>,
    pub __bindgen_anon_3: __BindgenUnionField<bpf_array__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 0usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_value: bpf_array__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub value: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_ptrs: bpf_array__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub ptrs: __IncompleteArrayField<*mut ffi::c_void>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
impl Default for bpf_array__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_3 {
    pub __empty_pptrs: bpf_array__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub pptrs: __IncompleteArrayField<*mut ffi::c_void>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_array__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {}
impl Default for bpf_array__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_array__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BPF_MAX_LOOPS: _bindgen_ty_253 = 8388608;
pub const BPF_MAX_TIMED_LOOPS: _bindgen_ty_253 = 65535;
pub type _bindgen_ty_253 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_event_entry {
    pub event: *mut perf_event,
    pub perf_file: *mut file,
    pub map_file: *mut file,
    pub rcu: callback_head,
}
impl Default for bpf_event_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type bpf_ctx_copy_t = ::core::option::Option<
    unsafe extern "C" fn(
        dst: *mut ffi::c_void,
        src: *const ffi::c_void,
        off: ffi::c_ulong,
        len: ffi::c_ulong,
    ) -> ffi::c_ulong,
>;
pub type bpf_convert_ctx_access_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: bpf_access_type,
        src: *const bpf_insn,
        dst: *mut bpf_insn,
        prog: *mut bpf_prog,
        target_size: *mut u32_,
    ) -> u32_,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_array_item {
    pub prog: *mut bpf_prog,
    pub __bindgen_anon_1: bpf_prog_array_item__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_array_item__bindgen_ty_1 {
    pub cgroup_storage: [*mut bpf_cgroup_storage; 2usize],
    pub bpf_cookie: u64_,
}
impl Default for bpf_prog_array_item__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_prog_array_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bpf_prog_array {
    pub rcu: callback_head,
    pub items: __IncompleteArrayField<bpf_prog_array_item>,
}
impl Default for bpf_prog_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bpf_empty_prog_array {
    pub hdr: bpf_prog_array,
    pub null_prog: *mut bpf_prog,
}
impl Default for bpf_empty_prog_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_run_ctx {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cg_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub prog_item: *const bpf_prog_array_item,
    pub retval: ffi::c_int,
}
impl Default for bpf_cg_run_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_trace_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub bpf_cookie: u64_,
    pub is_uprobe: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub bpf_cookie: u64_,
    pub saved_run_ctx: *mut bpf_run_ctx,
}
impl Default for bpf_tramp_run_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bpf_prog_run_fn = ::core::option::Option<
    unsafe extern "C" fn(prog: *const bpf_prog, ctx: *const ffi::c_void) -> u32_,
>;

pub const bpf_iter_task_type_BPF_TASK_ITER_ALL: bpf_iter_task_type = 0;
pub const bpf_iter_task_type_BPF_TASK_ITER_TID: bpf_iter_task_type = 1;
pub const bpf_iter_task_type_BPF_TASK_ITER_TGID: bpf_iter_task_type = 2;
pub type bpf_iter_task_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info {
    pub map: *mut bpf_map,
    pub cgroup: bpf_iter_aux_info__bindgen_ty_1,
    pub task: bpf_iter_aux_info__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_1 {
    pub start: *mut cgroup,
    pub order: bpf_cgroup_iter_order,
}
impl Default for bpf_iter_aux_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_2 {
    pub type_: bpf_iter_task_type,
    pub pid: u32_,
}
impl Default for bpf_iter_aux_info__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bpf_iter_aux_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bpf_iter_attach_target_t = ::core::option::Option<
    unsafe extern "C" fn(
        prog: *mut bpf_prog,
        linfo: *mut bpf_iter_link_info,
        aux: *mut bpf_iter_aux_info,
    ) -> ffi::c_int,
>;
pub type bpf_iter_detach_target_t =
    ::core::option::Option<unsafe extern "C" fn(aux: *mut bpf_iter_aux_info)>;
pub type bpf_iter_show_fdinfo_t =
    ::core::option::Option<unsafe extern "C" fn(aux: *const bpf_iter_aux_info, seq: *mut seq_file)>;
pub type bpf_iter_fill_link_info_t = ::core::option::Option<
    unsafe extern "C" fn(aux: *const bpf_iter_aux_info, info: *mut bpf_link_info) -> ffi::c_int,
>;
pub type bpf_iter_get_func_proto_t = ::core::option::Option<
    unsafe extern "C" fn(func_id: bpf_func_id, prog: *const bpf_prog) -> *const bpf_func_proto,
>;
pub const bpf_iter_feature_BPF_ITER_RESCHED: bpf_iter_feature = 1;
pub type bpf_iter_feature = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_reg {
    pub target: *const ffi::c_char,
    pub attach_target: bpf_iter_attach_target_t,
    pub detach_target: bpf_iter_detach_target_t,
    pub show_fdinfo: bpf_iter_show_fdinfo_t,
    pub fill_link_info: bpf_iter_fill_link_info_t,
    pub get_func_proto: bpf_iter_get_func_proto_t,
    pub ctx_arg_info_size: u32_,
    pub feature: u32_,
    pub ctx_arg_info: [bpf_ctx_arg_aux; 2usize],
    pub seq_info: *const bpf_iter_seq_info,
}
impl Default for bpf_iter_reg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_meta {
    pub __bindgen_anon_1: bpf_iter_meta__bindgen_ty_1,
    pub session_id: u64_,
    pub seq_num: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter_meta__bindgen_ty_1 {
    pub seq: *mut seq_file,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_iter_meta__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_iter_meta__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_iter_meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter__bpf_map_elem {
    pub __bindgen_anon_1: bpf_iter__bpf_map_elem__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_iter__bpf_map_elem__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_iter__bpf_map_elem__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_iter__bpf_map_elem__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_1 {
    pub meta: *mut bpf_iter_meta,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_2 {
    pub map: *mut bpf_map,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_3 {
    pub key: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_4 {
    pub value: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_iter__bpf_map_elem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dtab_netdev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cpu_map_entry {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_core_ctx {
    pub log: *mut bpf_verifier_log,
    pub btf: *const btf,
}
impl Default for bpf_core_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_reuseport_kern {
    pub skb: *mut sk_buff,
    pub sk: *mut sock,
    pub selected_sk: *mut sock,
    pub migrating_sk: *mut sock,
    pub data_end: *mut ffi::c_void,
    pub hash: u32_,
    pub reuseport_id: u32_,
    pub bind_inany: bool_,
}
impl Default for sk_reuseport_kern {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const bpf_text_poke_type_BPF_MOD_CALL: bpf_text_poke_type = 0;
pub const bpf_text_poke_type_BPF_MOD_JUMP: bpf_text_poke_type = 1;
pub type bpf_text_poke_type = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_bprintf_buffers {
    pub bin_args: [ffi::c_char; 512usize],
    pub buf: [ffi::c_char; 1024usize],
}
impl Default for bpf_bprintf_buffers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_bprintf_data {
    pub bin_args: *mut u32_,
    pub buf: *mut ffi::c_char,
    pub get_bin_args: bool_,
    pub get_buf: bool_,
}
impl Default for bpf_bprintf_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_key {
    pub key: *mut key,
    pub has_ref: bool_,
}
impl Default for bpf_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct lsm_ctx {
    pub id: __u64,
    pub flags: __u64,
    pub len: __u64,
    pub ctx_len: __u64,
    pub ctx: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lsm_prop_selinux {
    pub secid: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smack_known {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lsm_prop_smack {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aa_label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm_prop_apparmor {
    pub label: *mut aa_label,
}
impl Default for lsm_prop_apparmor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lsm_prop_bpf {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msg_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_sec_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    _unused: [u8; 0],
}
pub type fs_value_type = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_notification {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_krule {
    _unused: [u8; 0],
}
pub const lsm_event_LSM_POLICY_CHANGE: lsm_event = 0;
pub type lsm_event = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dm_verity_digest {
    pub alg: *const ffi::c_char,
    pub digest: *const u8_,
    pub digest_len: usize,
}
impl Default for dm_verity_digest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const lsm_integrity_type_LSM_INT_DMVERITY_SIG_VALID: lsm_integrity_type = 0;
pub const lsm_integrity_type_LSM_INT_DMVERITY_ROOTHASH: lsm_integrity_type = 1;
pub const lsm_integrity_type_LSM_INT_FSVERITY_BUILTINSIG_VALID: lsm_integrity_type = 2;
pub type lsm_integrity_type = ffi::c_uint;
pub const lockdown_reason_LOCKDOWN_NONE: lockdown_reason = 0;
pub const lockdown_reason_LOCKDOWN_MODULE_SIGNATURE: lockdown_reason = 1;
pub const lockdown_reason_LOCKDOWN_DEV_MEM: lockdown_reason = 2;
pub const lockdown_reason_LOCKDOWN_EFI_TEST: lockdown_reason = 3;
pub const lockdown_reason_LOCKDOWN_KEXEC: lockdown_reason = 4;
pub const lockdown_reason_LOCKDOWN_HIBERNATION: lockdown_reason = 5;
pub const lockdown_reason_LOCKDOWN_PCI_ACCESS: lockdown_reason = 6;
pub const lockdown_reason_LOCKDOWN_IOPORT: lockdown_reason = 7;
pub const lockdown_reason_LOCKDOWN_MSR: lockdown_reason = 8;
pub const lockdown_reason_LOCKDOWN_ACPI_TABLES: lockdown_reason = 9;
pub const lockdown_reason_LOCKDOWN_DEVICE_TREE: lockdown_reason = 10;
pub const lockdown_reason_LOCKDOWN_PCMCIA_CIS: lockdown_reason = 11;
pub const lockdown_reason_LOCKDOWN_TIOCSSERIAL: lockdown_reason = 12;
pub const lockdown_reason_LOCKDOWN_MODULE_PARAMETERS: lockdown_reason = 13;
pub const lockdown_reason_LOCKDOWN_MMIOTRACE: lockdown_reason = 14;
pub const lockdown_reason_LOCKDOWN_DEBUGFS: lockdown_reason = 15;
pub const lockdown_reason_LOCKDOWN_XMON_WR: lockdown_reason = 16;
pub const lockdown_reason_LOCKDOWN_BPF_WRITE_USER: lockdown_reason = 17;
pub const lockdown_reason_LOCKDOWN_DBG_WRITE_KERNEL: lockdown_reason = 18;
pub const lockdown_reason_LOCKDOWN_RTAS_ERROR_INJECTION: lockdown_reason = 19;
pub const lockdown_reason_LOCKDOWN_INTEGRITY_MAX: lockdown_reason = 20;
pub const lockdown_reason_LOCKDOWN_KCORE: lockdown_reason = 21;
pub const lockdown_reason_LOCKDOWN_KPROBES: lockdown_reason = 22;
pub const lockdown_reason_LOCKDOWN_BPF_READ_KERNEL: lockdown_reason = 23;
pub const lockdown_reason_LOCKDOWN_DBG_READ_KERNEL: lockdown_reason = 24;
pub const lockdown_reason_LOCKDOWN_PERF: lockdown_reason = 25;
pub const lockdown_reason_LOCKDOWN_TRACEFS: lockdown_reason = 26;
pub const lockdown_reason_LOCKDOWN_XMON_RW: lockdown_reason = 27;
pub const lockdown_reason_LOCKDOWN_XFRM_SECRET: lockdown_reason = 28;
pub const lockdown_reason_LOCKDOWN_CONFIDENTIALITY_MAX: lockdown_reason = 29;
pub type lockdown_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm_prop {
    pub selinux: lsm_prop_selinux,
    pub smack: lsm_prop_smack,
    pub apparmor: lsm_prop_apparmor,
    pub bpf: lsm_prop_bpf,
}
impl Default for lsm_prop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm_id {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_selector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_sec_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_association {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm_context {
    pub context: *mut ffi::c_char,
    pub len: u32_,
    pub id: ffi::c_int,
}
impl Default for lsm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_sock {
    _unused: [u8; 0],
}

pub type initxattrs = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        xattr_array: *const xattr,
        fs_data: *mut ffi::c_void,
    ) -> ffi::c_int,
>;
pub const kernel_load_data_id_LOADING_UNKNOWN: kernel_load_data_id = 0;
pub const kernel_load_data_id_LOADING_FIRMWARE: kernel_load_data_id = 1;
pub const kernel_load_data_id_LOADING_MODULE: kernel_load_data_id = 2;
pub const kernel_load_data_id_LOADING_KEXEC_IMAGE: kernel_load_data_id = 3;
pub const kernel_load_data_id_LOADING_KEXEC_INITRAMFS: kernel_load_data_id = 4;
pub const kernel_load_data_id_LOADING_POLICY: kernel_load_data_id = 5;
pub const kernel_load_data_id_LOADING_X509_CERTIFICATE: kernel_load_data_id = 6;
pub const kernel_load_data_id_LOADING_MAX_ID: kernel_load_data_id = 7;
pub type kernel_load_data_id = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_msghdr {
    pub msg_name: compat_uptr_t,
    pub msg_namelen: compat_int_t,
    pub msg_iov: compat_uptr_t,
    pub msg_iovlen: compat_size_t,
    pub msg_control: compat_uptr_t,
    pub msg_controllen: compat_size_t,
    pub msg_flags: compat_uint_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_mmsghdr {
    pub msg_hdr: compat_msghdr,
    pub msg_len: compat_uint_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_cmsghdr {
    pub cmsg_len: compat_size_t,
    pub cmsg_level: compat_int_t,
    pub cmsg_type: compat_int_t,
}
#[repr(C)]
pub struct compat_rtentry {
    pub rt_pad1: u32_,
    pub rt_dst: sockaddr,
    pub rt_gateway: sockaddr,
    pub rt_genmask: sockaddr,
    pub rt_flags: ffi::c_ushort,
    pub rt_pad2: ffi::c_short,
    pub rt_pad3: u32_,
    pub rt_tos: ffi::c_uchar,
    pub rt_class: ffi::c_uchar,
    pub rt_pad4: ffi::c_short,
    pub rt_metric: ffi::c_short,
    pub rt_dev: compat_uptr_t,
    pub rt_mtu: u32_,
    pub rt_window: u32_,
    pub rt_irtt: ffi::c_ushort,
}
impl Default for compat_rtentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_req {
    pub gr_interface: __u32,
    pub gr_group: __kernel_sockaddr_storage,
}
impl Default for compat_group_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_source_req {
    pub gsr_interface: __u32,
    pub gsr_group: __kernel_sockaddr_storage,
    pub gsr_source: __kernel_sockaddr_storage,
}
impl Default for compat_group_source_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct compat_group_filter {
    pub __bindgen_anon_1: compat_group_filter__bindgen_ty_1,
}
#[repr(C)]
pub struct compat_group_filter__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<compat_group_filter__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<compat_group_filter__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 67usize],
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_filter__bindgen_ty_1__bindgen_ty_1 {
    pub gf_interface_aux: __u32,
    pub gf_group_aux: __kernel_sockaddr_storage,
    pub gf_fmode_aux: __u32,
    pub gf_numsrc_aux: __u32,
    pub gf_slist: [__kernel_sockaddr_storage; 1usize],
}
impl Default for compat_group_filter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct compat_group_filter__bindgen_ty_1__bindgen_ty_2 {
    pub gf_interface: __u32,
    pub gf_group: __kernel_sockaddr_storage,
    pub gf_fmode: __u32,
    pub gf_numsrc: __u32,
    pub gf_slist_flex: __IncompleteArrayField<__kernel_sockaddr_storage>,
}
impl Default for compat_group_filter__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_group_filter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_group_filter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_creds {
    pub pid: u32_,
    pub uid: kuid_t,
    pub gid: kgid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct unix_edge {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_fp_list {
    pub count: ffi::c_short,
    pub count_unix: ffi::c_short,
    pub max: ffi::c_short,
    pub inflight: bool_,
    pub dead: bool_,
    pub vertices: list_head,
    pub edges: *mut unix_edge,
    pub user: *mut user_struct,
    pub fp: [*mut file; 253usize],
}
impl Default for scm_fp_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_cookie {
    pub pid: *mut pid,
    pub fp: *mut scm_fp_list,
    pub creds: scm_creds,
    pub secid: u32_,
}
impl Default for scm_cookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: ffi::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsgerr {
    pub error: ffi::c_int,
    pub msg: nlmsghdr,
}
pub const nlmsgerr_attrs_NLMSGERR_ATTR_UNUSED: nlmsgerr_attrs = 0;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MSG: nlmsgerr_attrs = 1;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_OFFS: nlmsgerr_attrs = 2;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_COOKIE: nlmsgerr_attrs = 3;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_POLICY: nlmsgerr_attrs = 4;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_TYPE: nlmsgerr_attrs = 5;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_NEST: nlmsgerr_attrs = 6;
pub const nlmsgerr_attrs___NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 7;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 6;
pub type nlmsgerr_attrs = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_pktinfo {
    pub group: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_req {
    pub nm_block_size: ffi::c_uint,
    pub nm_block_nr: ffi::c_uint,
    pub nm_frame_size: ffi::c_uint,
    pub nm_frame_nr: ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_hdr {
    pub nm_status: ffi::c_uint,
    pub nm_len: ffi::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
pub const NETLINK_UNCONNECTED: _bindgen_ty_254 = 0;
pub const NETLINK_CONNECTED: _bindgen_ty_254 = 1;
pub type _bindgen_ty_254 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_bitfield32 {
    pub value: __u32,
    pub selector: __u32,
}
pub const netlink_attribute_type_NL_ATTR_TYPE_INVALID: netlink_attribute_type = 0;
pub const netlink_attribute_type_NL_ATTR_TYPE_FLAG: netlink_attribute_type = 1;
pub const netlink_attribute_type_NL_ATTR_TYPE_U8: netlink_attribute_type = 2;
pub const netlink_attribute_type_NL_ATTR_TYPE_U16: netlink_attribute_type = 3;
pub const netlink_attribute_type_NL_ATTR_TYPE_U32: netlink_attribute_type = 4;
pub const netlink_attribute_type_NL_ATTR_TYPE_U64: netlink_attribute_type = 5;
pub const netlink_attribute_type_NL_ATTR_TYPE_S8: netlink_attribute_type = 6;
pub const netlink_attribute_type_NL_ATTR_TYPE_S16: netlink_attribute_type = 7;
pub const netlink_attribute_type_NL_ATTR_TYPE_S32: netlink_attribute_type = 8;
pub const netlink_attribute_type_NL_ATTR_TYPE_S64: netlink_attribute_type = 9;
pub const netlink_attribute_type_NL_ATTR_TYPE_BINARY: netlink_attribute_type = 10;
pub const netlink_attribute_type_NL_ATTR_TYPE_STRING: netlink_attribute_type = 11;
pub const netlink_attribute_type_NL_ATTR_TYPE_NUL_STRING: netlink_attribute_type = 12;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED: netlink_attribute_type = 13;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED_ARRAY: netlink_attribute_type = 14;
pub const netlink_attribute_type_NL_ATTR_TYPE_BITFIELD32: netlink_attribute_type = 15;
pub const netlink_attribute_type_NL_ATTR_TYPE_SINT: netlink_attribute_type = 16;
pub const netlink_attribute_type_NL_ATTR_TYPE_UINT: netlink_attribute_type = 17;
pub type netlink_attribute_type = ffi::c_uint;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_UNSPEC: netlink_policy_type_attr = 0;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_TYPE: netlink_policy_type_attr = 1;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_S: netlink_policy_type_attr = 2;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_S: netlink_policy_type_attr = 3;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_U: netlink_policy_type_attr = 4;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_U: netlink_policy_type_attr = 5;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_LENGTH: netlink_policy_type_attr = 6;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_LENGTH: netlink_policy_type_attr = 7;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_IDX: netlink_policy_type_attr = 8;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE: netlink_policy_type_attr = 9;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: netlink_policy_type_attr =
    10;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_PAD: netlink_policy_type_attr = 11;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MASK: netlink_policy_type_attr = 12;
pub const netlink_policy_type_attr___NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 13;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 12;
pub type netlink_policy_type_attr = ffi::c_uint;

pub const netlink_skb_flags_NETLINK_SKB_DST: netlink_skb_flags = 8;
pub type netlink_skb_flags = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_skb_parms {
    pub creds: scm_creds,
    pub portid: __u32,
    pub dst_group: __u32,
    pub flags: __u32,
    pub sk: *mut sock,
    pub nsid_is_set: bool_,
    pub nsid: ffi::c_int,
}
impl Default for netlink_skb_parms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netlink_kernel_cfg {
    pub groups: ffi::c_uint,
    pub flags: ffi::c_uint,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, group: ffi::c_int) -> ffi::c_int,
    >,
    pub unbind: ::core::option::Option<unsafe extern "C" fn(net: *mut net, group: ffi::c_int)>,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, groups: *mut ffi::c_ulong)>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const ffi::c_char,
    pub bad_attr: *const nlattr,
    pub policy: *mut nla_policy,
    pub miss_nest: *const nlattr,
    pub miss_type: u16_,
    pub cookie: [u8_; 8usize],
    pub cookie_len: u8_,
    pub _msg_buf: [ffi::c_char; 80usize],
}
impl Default for netlink_ext_ack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type netlink_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(dsk: *mut sock, skb: *mut sk_buff, data: *mut ffi::c_void) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, cb: *mut netlink_callback) -> ffi::c_int,
    >,
    pub done: ::core::option::Option<unsafe extern "C" fn(cb: *mut netlink_callback) -> ffi::c_int>,
    pub data: *mut ffi::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub answer_flags: u16_,
    pub min_dump_alloc: u32_,
    pub prev_seq: ffi::c_uint,
    pub seq: ffi::c_uint,
    pub flags: ffi::c_int,
    pub strict_check: bool_,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [ffi::c_long; 6usize],
}
impl Default for netlink_callback__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for netlink_callback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_notify {
    pub net: *mut net,
    pub portid: u32_,
    pub protocol: ffi::c_int,
}
impl Default for netlink_notify {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_dump_control {
    pub start:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut netlink_callback) -> ffi::c_int>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, arg1: *mut netlink_callback) -> ffi::c_int,
    >,
    pub done:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut netlink_callback) -> ffi::c_int>,
    pub extack: *mut netlink_ext_ack,
    pub data: *mut ffi::c_void,
    pub module: *mut module,
    pub min_dump_alloc: u32_,
    pub flags: ffi::c_int,
}
impl Default for netlink_dump_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_tap {
    pub dev: *mut net_device,
    pub module: *mut module,
    pub list: list_head,
}
impl Default for netlink_tap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_cmd {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertising: __u32,
    pub speed: __u16,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub transceiver: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub maxtxpkt: __u32,
    pub maxrxpkt: __u32,
    pub speed_hi: __u16,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub lp_advertising: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [ffi::c_char; 32usize],
    pub version: [ffi::c_char; 32usize],
    pub fw_version: [ffi::c_char; 32usize],
    pub bus_info: [ffi::c_char; 32usize],
    pub erom_version: [ffi::c_char; 32usize],
    pub reserved2: [ffi::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_value {
    pub cmd: __u32,
    pub data: __u32,
}
pub const tunable_id_ETHTOOL_ID_UNSPEC: tunable_id = 0;
pub const tunable_id_ETHTOOL_RX_COPYBREAK: tunable_id = 1;
pub const tunable_id_ETHTOOL_TX_COPYBREAK: tunable_id = 2;
pub const tunable_id_ETHTOOL_PFC_PREVENTION_TOUT: tunable_id = 3;
pub const tunable_id_ETHTOOL_TX_COPYBREAK_BUF_SIZE: tunable_id = 4;
pub const tunable_id___ETHTOOL_TUNABLE_COUNT: tunable_id = 5;
pub type tunable_id = ffi::c_uint;
pub const tunable_type_id_ETHTOOL_TUNABLE_UNSPEC: tunable_type_id = 0;
pub const tunable_type_id_ETHTOOL_TUNABLE_U8: tunable_type_id = 1;
pub const tunable_type_id_ETHTOOL_TUNABLE_U16: tunable_type_id = 2;
pub const tunable_type_id_ETHTOOL_TUNABLE_U32: tunable_type_id = 3;
pub const tunable_type_id_ETHTOOL_TUNABLE_U64: tunable_type_id = 4;
pub const tunable_type_id_ETHTOOL_TUNABLE_STRING: tunable_type_id = 5;
pub const tunable_type_id_ETHTOOL_TUNABLE_S8: tunable_type_id = 6;
pub const tunable_type_id_ETHTOOL_TUNABLE_S16: tunable_type_id = 7;
pub const tunable_type_id_ETHTOOL_TUNABLE_S32: tunable_type_id = 8;
pub const tunable_type_id_ETHTOOL_TUNABLE_S64: tunable_type_id = 9;
pub type tunable_type_id = ffi::c_uint;
#[repr(C)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut ffi::c_void>,
}
impl Default for ethtool_tunable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const phy_tunable_id_ETHTOOL_PHY_ID_UNSPEC: phy_tunable_id = 0;
pub const phy_tunable_id_ETHTOOL_PHY_DOWNSHIFT: phy_tunable_id = 1;
pub const phy_tunable_id_ETHTOOL_PHY_FAST_LINK_DOWN: phy_tunable_id = 2;
pub const phy_tunable_id_ETHTOOL_PHY_EDPD: phy_tunable_id = 3;
pub const phy_tunable_id___ETHTOOL_PHY_TUNABLE_COUNT: phy_tunable_id = 4;
pub type phy_tunable_id = ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_AUTONEG: ethtool_link_ext_state = 0;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE:
    ethtool_link_ext_state = 1;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH:
    ethtool_link_ext_state = 2;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY:
    ethtool_link_ext_state = 3;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_NO_CABLE: ethtool_link_ext_state = 4;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE: ethtool_link_ext_state = 5;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE: ethtool_link_ext_state = 6;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE:
    ethtool_link_ext_state = 7;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED:
    ethtool_link_ext_state = 8;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_OVERHEAT: ethtool_link_ext_state = 9;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_MODULE: ethtool_link_ext_state = 10;
pub type ethtool_link_ext_state = ffi::c_uint;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED:
    ethtool_link_ext_substate_autoneg = 1;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED:
    ethtool_link_ext_substate_autoneg = 2;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED : ethtool_link_ext_substate_autoneg = 3 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE : ethtool_link_ext_substate_autoneg = 4 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE : ethtool_link_ext_substate_autoneg = 5 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD:
    ethtool_link_ext_substate_autoneg = 6;
pub type ethtool_link_ext_substate_autoneg = ffi::c_uint;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED : ethtool_link_ext_substate_link_training = 1 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT : ethtool_link_ext_substate_link_training = 2 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY : ethtool_link_ext_substate_link_training = 3 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT:
    ethtool_link_ext_substate_link_training = 4;
pub type ethtool_link_ext_substate_link_training = ffi::c_uint;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 1 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 2 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS : ethtool_link_ext_substate_link_logical_mismatch = 3 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 4 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 5 ;
pub type ethtool_link_ext_substate_link_logical_mismatch = ffi::c_uint;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS : ethtool_link_ext_substate_bad_signal_integrity = 1 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE : ethtool_link_ext_substate_bad_signal_integrity = 2 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST : ethtool_link_ext_substate_bad_signal_integrity = 3 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS : ethtool_link_ext_substate_bad_signal_integrity = 4 ;
pub type ethtool_link_ext_substate_bad_signal_integrity = ffi::c_uint;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE:
    ethtool_link_ext_substate_cable_issue = 1;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE:
    ethtool_link_ext_substate_cable_issue = 2;
pub type ethtool_link_ext_substate_cable_issue = ffi::c_uint;
pub const ethtool_link_ext_substate_module_ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY:
    ethtool_link_ext_substate_module = 1;
pub type ethtool_link_ext_substate_module = ffi::c_uint;
pub const ethtool_stringset_ETH_SS_TEST: ethtool_stringset = 0;
pub const ethtool_stringset_ETH_SS_STATS: ethtool_stringset = 1;
pub const ethtool_stringset_ETH_SS_PRIV_FLAGS: ethtool_stringset = 2;
pub const ethtool_stringset_ETH_SS_NTUPLE_FILTERS: ethtool_stringset = 3;
pub const ethtool_stringset_ETH_SS_FEATURES: ethtool_stringset = 4;
pub const ethtool_stringset_ETH_SS_RSS_HASH_FUNCS: ethtool_stringset = 5;
pub const ethtool_stringset_ETH_SS_TUNABLES: ethtool_stringset = 6;
pub const ethtool_stringset_ETH_SS_PHY_STATS: ethtool_stringset = 7;
pub const ethtool_stringset_ETH_SS_PHY_TUNABLES: ethtool_stringset = 8;
pub const ethtool_stringset_ETH_SS_LINK_MODES: ethtool_stringset = 9;
pub const ethtool_stringset_ETH_SS_MSG_CLASSES: ethtool_stringset = 10;
pub const ethtool_stringset_ETH_SS_WOL_MODES: ethtool_stringset = 11;
pub const ethtool_stringset_ETH_SS_SOF_TIMESTAMPING: ethtool_stringset = 12;
pub const ethtool_stringset_ETH_SS_TS_TX_TYPES: ethtool_stringset = 13;
pub const ethtool_stringset_ETH_SS_TS_RX_FILTERS: ethtool_stringset = 14;
pub const ethtool_stringset_ETH_SS_UDP_TUNNEL_TYPES: ethtool_stringset = 15;
pub const ethtool_stringset_ETH_SS_STATS_STD: ethtool_stringset = 16;
pub const ethtool_stringset_ETH_SS_STATS_ETH_PHY: ethtool_stringset = 17;
pub const ethtool_stringset_ETH_SS_STATS_ETH_MAC: ethtool_stringset = 18;
pub const ethtool_stringset_ETH_SS_STATS_ETH_CTRL: ethtool_stringset = 19;
pub const ethtool_stringset_ETH_SS_STATS_RMON: ethtool_stringset = 20;
pub const ethtool_stringset_ETH_SS_STATS_PHY: ethtool_stringset = 21;
pub const ethtool_stringset_ETH_SS_TS_FLAGS: ethtool_stringset = 22;
pub const ethtool_stringset_ETH_SS_COUNT: ethtool_stringset = 23;
pub type ethtool_stringset = ffi::c_uint;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_AGGREGATE: ethtool_mac_stats_src = 0;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_EMAC: ethtool_mac_stats_src = 1;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_PMAC: ethtool_mac_stats_src = 2;
pub type ethtool_mac_stats_src = ffi::c_uint;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH:
    ethtool_module_power_mode_policy = 1;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO:
    ethtool_module_power_mode_policy = 2;
pub type ethtool_module_power_mode_policy = ffi::c_uint;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_LOW: ethtool_module_power_mode = 1;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_HIGH: ethtool_module_power_mode = 2;
pub type ethtool_module_power_mode = ffi::c_uint;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_ERROR_CONDITION:
    ethtool_c33_pse_ext_state = 1;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_MR_MPS_VALID:
    ethtool_c33_pse_ext_state = 2;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_MR_PSE_ENABLE:
    ethtool_c33_pse_ext_state = 3;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_OPTION_DETECT_TED:
    ethtool_c33_pse_ext_state = 4;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_OPTION_VPORT_LIM:
    ethtool_c33_pse_ext_state = 5;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_OVLD_DETECTED:
    ethtool_c33_pse_ext_state = 6;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_PD_DLL_POWER_TYPE:
    ethtool_c33_pse_ext_state = 7;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_POWER_NOT_AVAILABLE:
    ethtool_c33_pse_ext_state = 8;
pub const ethtool_c33_pse_ext_state_ETHTOOL_C33_PSE_EXT_STATE_SHORT_DETECTED:
    ethtool_c33_pse_ext_state = 9;
pub type ethtool_c33_pse_ext_state = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_mr_mps_valid_ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_MPS_VALID_DETECTED_UNDERLOAD : ethtool_c33_pse_ext_substate_mr_mps_valid = 1 ;
pub const ethtool_c33_pse_ext_substate_mr_mps_valid_ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_MPS_VALID_CONNECTION_OPEN : ethtool_c33_pse_ext_substate_mr_mps_valid = 2 ;
pub type ethtool_c33_pse_ext_substate_mr_mps_valid = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_NON_EXISTING_PORT : ethtool_c33_pse_ext_substate_error_condition = 1 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNDEFINED_PORT : ethtool_c33_pse_ext_substate_error_condition = 2 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_INTERNAL_HW_FAULT : ethtool_c33_pse_ext_substate_error_condition = 3 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_COMM_ERROR_AFTER_FORCE_ON : ethtool_c33_pse_ext_substate_error_condition = 4 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNKNOWN_PORT_STATUS : ethtool_c33_pse_ext_substate_error_condition = 5 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_TURN_OFF : ethtool_c33_pse_ext_substate_error_condition = 6 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_FORCE_SHUTDOWN : ethtool_c33_pse_ext_substate_error_condition = 7 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_CONFIG_CHANGE : ethtool_c33_pse_ext_substate_error_condition = 8 ;
pub const ethtool_c33_pse_ext_substate_error_condition_ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_DETECTED_OVER_TEMP : ethtool_c33_pse_ext_substate_error_condition = 9 ;
pub type ethtool_c33_pse_ext_substate_error_condition = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_mr_pse_enable_ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_PSE_ENABLE_DISABLE_PIN_ACTIVE : ethtool_c33_pse_ext_substate_mr_pse_enable = 1 ;
pub type ethtool_c33_pse_ext_substate_mr_pse_enable = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_option_detect_ted_ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_DET_IN_PROCESS : ethtool_c33_pse_ext_substate_option_detect_ted = 1 ;
pub const ethtool_c33_pse_ext_substate_option_detect_ted_ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_CONNECTION_CHECK_ERROR : ethtool_c33_pse_ext_substate_option_detect_ted = 2 ;
pub type ethtool_c33_pse_ext_substate_option_detect_ted = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_option_vport_lim_ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_HIGH_VOLTAGE : ethtool_c33_pse_ext_substate_option_vport_lim = 1 ;
pub const ethtool_c33_pse_ext_substate_option_vport_lim_ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_LOW_VOLTAGE : ethtool_c33_pse_ext_substate_option_vport_lim = 2 ;
pub const ethtool_c33_pse_ext_substate_option_vport_lim_ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_VOLTAGE_INJECTION : ethtool_c33_pse_ext_substate_option_vport_lim = 3 ;
pub type ethtool_c33_pse_ext_substate_option_vport_lim = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_ovld_detected_ETHTOOL_C33_PSE_EXT_SUBSTATE_OVLD_DETECTED_OVERLOAD : ethtool_c33_pse_ext_substate_ovld_detected = 1 ;
pub type ethtool_c33_pse_ext_substate_ovld_detected = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_power_not_available_ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_BUDGET_EXCEEDED : ethtool_c33_pse_ext_substate_power_not_available = 1 ;
pub const ethtool_c33_pse_ext_substate_power_not_available_ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PORT_PW_LIMIT_EXCEEDS_CONTROLLER_BUDGET : ethtool_c33_pse_ext_substate_power_not_available = 2 ;
pub const ethtool_c33_pse_ext_substate_power_not_available_ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PD_REQUEST_EXCEEDS_PORT_LIMIT : ethtool_c33_pse_ext_substate_power_not_available = 3 ;
pub const ethtool_c33_pse_ext_substate_power_not_available_ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_HW_PW_LIMIT : ethtool_c33_pse_ext_substate_power_not_available = 4 ;
pub type ethtool_c33_pse_ext_substate_power_not_available = ffi::c_uint;
pub const ethtool_c33_pse_ext_substate_short_detected_ETHTOOL_C33_PSE_EXT_SUBSTATE_SHORT_DETECTED_SHORT_CONDITION : ethtool_c33_pse_ext_substate_short_detected = 1 ;
pub type ethtool_c33_pse_ext_substate_short_detected = ffi::c_uint;
pub const ethtool_pse_types_ETHTOOL_PSE_UNKNOWN: ethtool_pse_types = 1;
pub const ethtool_pse_types_ETHTOOL_PSE_PODL: ethtool_pse_types = 2;
pub const ethtool_pse_types_ETHTOOL_PSE_C33: ethtool_pse_types = 4;
pub type ethtool_pse_types = ffi::c_uint;
pub const ethtool_c33_pse_admin_state_ETHTOOL_C33_PSE_ADMIN_STATE_UNKNOWN:
    ethtool_c33_pse_admin_state = 1;
pub const ethtool_c33_pse_admin_state_ETHTOOL_C33_PSE_ADMIN_STATE_DISABLED:
    ethtool_c33_pse_admin_state = 2;
pub const ethtool_c33_pse_admin_state_ETHTOOL_C33_PSE_ADMIN_STATE_ENABLED:
    ethtool_c33_pse_admin_state = 3;
pub type ethtool_c33_pse_admin_state = ffi::c_uint;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_UNKNOWN:
    ethtool_c33_pse_pw_d_status = 1;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_DISABLED:
    ethtool_c33_pse_pw_d_status = 2;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_SEARCHING:
    ethtool_c33_pse_pw_d_status = 3;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_DELIVERING:
    ethtool_c33_pse_pw_d_status = 4;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_TEST:
    ethtool_c33_pse_pw_d_status = 5;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_FAULT:
    ethtool_c33_pse_pw_d_status = 6;
pub const ethtool_c33_pse_pw_d_status_ETHTOOL_C33_PSE_PW_D_STATUS_OTHERFAULT:
    ethtool_c33_pse_pw_d_status = 7;
pub type ethtool_c33_pse_pw_d_status = ffi::c_uint;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN:
    ethtool_podl_pse_admin_state = 1;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED:
    ethtool_podl_pse_admin_state = 2;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED:
    ethtool_podl_pse_admin_state = 3;
pub type ethtool_podl_pse_admin_state = ffi::c_uint;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN:
    ethtool_podl_pse_pw_d_status = 1;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED:
    ethtool_podl_pse_pw_d_status = 2;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING:
    ethtool_podl_pse_pw_d_status = 3;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING:
    ethtool_podl_pse_pw_d_status = 4;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP:
    ethtool_podl_pse_pw_d_status = 5;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE:
    ethtool_podl_pse_pw_d_status = 6;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR:
    ethtool_podl_pse_pw_d_status = 7;
pub type ethtool_podl_pse_pw_d_status = ffi::c_uint;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_UNKNOWN: ethtool_mm_verify_status = 0;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_INITIAL: ethtool_mm_verify_status = 1;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_VERIFYING: ethtool_mm_verify_status = 2;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED: ethtool_mm_verify_status = 3;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_FAILED: ethtool_mm_verify_status = 4;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_DISABLED: ethtool_mm_verify_status = 5;
pub type ethtool_mm_verify_status = ffi::c_uint;
pub const ethtool_module_fw_flash_status_ETHTOOL_MODULE_FW_FLASH_STATUS_STARTED:
    ethtool_module_fw_flash_status = 1;
pub const ethtool_module_fw_flash_status_ETHTOOL_MODULE_FW_FLASH_STATUS_IN_PROGRESS:
    ethtool_module_fw_flash_status = 2;
pub const ethtool_module_fw_flash_status_ETHTOOL_MODULE_FW_FLASH_STATUS_COMPLETED:
    ethtool_module_fw_flash_status = 3;
pub const ethtool_module_fw_flash_status_ETHTOOL_MODULE_FW_FLASH_STATUS_ERROR:
    ethtool_module_fw_flash_status = 4;
pub type ethtool_module_fw_flash_status = ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_gstrings {
    pub cmd: __u32,
    pub string_set: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_sset_info {
    pub cmd: __u32,
    pub reserved: __u32,
    pub sset_mask: __u64,
    pub data: __IncompleteArrayField<__u32>,
}
pub const ethtool_test_flags_ETH_TEST_FL_OFFLINE: ethtool_test_flags = 1;
pub const ethtool_test_flags_ETH_TEST_FL_FAILED: ethtool_test_flags = 2;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB: ethtool_test_flags = 4;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB_DONE: ethtool_test_flags = 8;
pub type ethtool_test_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_perm_addr {
    pub cmd: __u32,
    pub size: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
pub const ethtool_flags_ETH_FLAG_TXVLAN: ethtool_flags = 128;
pub const ethtool_flags_ETH_FLAG_RXVLAN: ethtool_flags = 256;
pub const ethtool_flags_ETH_FLAG_LRO: ethtool_flags = 32768;
pub const ethtool_flags_ETH_FLAG_NTUPLE: ethtool_flags = 134217728;
pub const ethtool_flags_ETH_FLAG_RXHASH: ethtool_flags = 268435456;
pub type ethtool_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
}
impl Default for ethtool_flow_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [ffi::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
impl Default for ethtool_rx_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
}
impl Default for ethtool_rxnfc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rxnfc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_rxfh_indir {
    pub cmd: __u32,
    pub size: __u32,
    pub ring_index: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_rxfh {
    pub cmd: __u32,
    pub rss_context: __u32,
    pub indir_size: __u32,
    pub key_size: __u32,
    pub hfunc: __u8,
    pub input_xfrm: __u8,
    pub rsvd8: [__u8; 2usize],
    pub rsvd32: __u32,
    pub rss_config: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub m_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub vlan_tag: __u16,
    pub vlan_tag_mask: __u16,
    pub data: __u64,
    pub data_mask: __u64,
    pub action: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rx_ntuple_flow_spec__bindgen_ty_1 {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 72usize],
}
impl Default for ethtool_rx_ntuple_flow_spec__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rx_ntuple_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple {
    pub cmd: __u32,
    pub fs: ethtool_rx_ntuple_flow_spec,
}
impl Default for ethtool_rx_ntuple {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ethtool_flash_op_type_ETHTOOL_FLASH_ALL_REGIONS: ethtool_flash_op_type = 0;
pub type ethtool_flash_op_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [ffi::c_char; 128usize],
}
impl Default for ethtool_flash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_get_features_block {
    pub available: __u32,
    pub requested: __u32,
    pub active: __u32,
    pub never_changed: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_gfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_get_features_block>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_set_features_block {
    pub valid: __u32,
    pub requested: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_sfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_set_features_block>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_UNSUPPORTED__BIT: ethtool_sfeatures_retval_bits =
    0;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_WISH__BIT: ethtool_sfeatures_retval_bits = 1;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_COMPAT__BIT: ethtool_sfeatures_retval_bits = 2;
pub type ethtool_sfeatures_retval_bits = ffi::c_uint;
#[repr(C)]
pub struct ethtool_per_queue_op {
    pub cmd: __u32,
    pub sub_command: __u32,
    pub queue_mask: [__u32; 128usize],
    pub data: __IncompleteArrayField<ffi::c_char>,
}
impl Default for ethtool_per_queue_op {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
pub const ethtool_fec_config_bits_ETHTOOL_FEC_NONE_BIT: ethtool_fec_config_bits = 0;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_AUTO_BIT: ethtool_fec_config_bits = 1;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_OFF_BIT: ethtool_fec_config_bits = 2;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_RS_BIT: ethtool_fec_config_bits = 3;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_BASER_BIT: ethtool_fec_config_bits = 4;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_LLRS_BIT: ethtool_fec_config_bits = 5;
pub type ethtool_fec_config_bits = ffi::c_uint;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 0;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 1;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 2;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 3;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 4;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 5;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Autoneg_BIT:
    ethtool_link_mode_bit_indices = 6;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_TP_BIT: ethtool_link_mode_bit_indices = 7;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_AUI_BIT: ethtool_link_mode_bit_indices =
    8;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_MII_BIT: ethtool_link_mode_bit_indices =
    9;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FIBRE_BIT: ethtool_link_mode_bit_indices =
    10;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_BNC_BIT: ethtool_link_mode_bit_indices =
    11;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 12;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Pause_BIT: ethtool_link_mode_bit_indices =
    13;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Asym_Pause_BIT:
    ethtool_link_mode_bit_indices = 14;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 15;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Backplane_BIT:
    ethtool_link_mode_bit_indices = 16;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseKX_Full_BIT:
    ethtool_link_mode_bit_indices = 17;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT:
    ethtool_link_mode_bit_indices = 18;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 19;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseR_FEC_BIT:
    ethtool_link_mode_bit_indices = 20;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT:
    ethtool_link_mode_bit_indices = 21;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 22;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 23;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 24;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 25;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 26;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 27;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 28;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 29;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 30;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 31;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 32;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 33;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 34;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 35;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 36;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 37;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 38;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT:
    ethtool_link_mode_bit_indices = 39;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 40;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 41;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 42;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 43;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLR_Full_BIT:
    ethtool_link_mode_bit_indices = 44;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT:
    ethtool_link_mode_bit_indices = 45;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseER_Full_BIT:
    ethtool_link_mode_bit_indices = 46;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 47;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_5000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 48;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_NONE_BIT:
    ethtool_link_mode_bit_indices = 49;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_RS_BIT:
    ethtool_link_mode_bit_indices = 50;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_BASER_BIT:
    ethtool_link_mode_bit_indices = 51;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 52;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 53;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 54;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 55;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 56;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 57;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 58;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 59;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 60;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 61;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 62;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 63;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 64;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 65;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 66;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 67;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 68;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 69;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 70;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT:
    ethtool_link_mode_bit_indices = 71;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 72;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 73;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_LLRS_BIT:
    ethtool_link_mode_bit_indices = 74;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 75;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 76;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 77;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 78;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 79;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 80;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 81;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 82;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 83;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 84;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 85;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 86;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 87;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 88;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 89;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Half_BIT:
    ethtool_link_mode_bit_indices = 90;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Full_BIT:
    ethtool_link_mode_bit_indices = 91;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1L_Full_BIT:
    ethtool_link_mode_bit_indices = 92;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 93;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 94;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 95;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT:
    ethtool_link_mode_bit_indices = 96;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 97;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT:
    ethtool_link_mode_bit_indices = 98;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Full_BIT:
    ethtool_link_mode_bit_indices = 99;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Half_BIT:
    ethtool_link_mode_bit_indices = 100;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT:
    ethtool_link_mode_bit_indices = 101;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1BRR_Full_BIT:
    ethtool_link_mode_bit_indices = 102;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 103;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 104;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 105;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR_2_Full_BIT:
    ethtool_link_mode_bit_indices = 106;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 107;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseVR_Full_BIT:
    ethtool_link_mode_bit_indices = 108;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 109;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 110;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 111;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR2_2_Full_BIT:
    ethtool_link_mode_bit_indices = 112;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 113;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseVR2_Full_BIT:
    ethtool_link_mode_bit_indices = 114;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 115;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 116;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 117;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR4_2_Full_BIT:
    ethtool_link_mode_bit_indices = 118;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 119;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseVR4_Full_BIT:
    ethtool_link_mode_bit_indices = 120;
pub const ethtool_link_mode_bit_indices___ETHTOOL_LINK_MODE_MASK_NBITS:
    ethtool_link_mode_bit_indices = 121;
pub type ethtool_link_mode_bit_indices = ffi::c_uint;
pub const TCP_V4_FLOW: _bindgen_ty_255 = 1;
pub const UDP_V4_FLOW: _bindgen_ty_255 = 2;
pub const SCTP_V4_FLOW: _bindgen_ty_255 = 3;
pub const AH_ESP_V4_FLOW: _bindgen_ty_255 = 4;
pub const TCP_V6_FLOW: _bindgen_ty_255 = 5;
pub const UDP_V6_FLOW: _bindgen_ty_255 = 6;
pub const SCTP_V6_FLOW: _bindgen_ty_255 = 7;
pub const AH_ESP_V6_FLOW: _bindgen_ty_255 = 8;
pub const AH_V4_FLOW: _bindgen_ty_255 = 9;
pub const ESP_V4_FLOW: _bindgen_ty_255 = 10;
pub const AH_V6_FLOW: _bindgen_ty_255 = 11;
pub const ESP_V6_FLOW: _bindgen_ty_255 = 12;
pub const IPV4_USER_FLOW: _bindgen_ty_255 = 13;
pub const IP_USER_FLOW: _bindgen_ty_255 = 13;
pub const IPV6_USER_FLOW: _bindgen_ty_255 = 14;
pub const IPV4_FLOW: _bindgen_ty_255 = 16;
pub const IPV6_FLOW: _bindgen_ty_255 = 17;
pub const ETHER_FLOW: _bindgen_ty_255 = 18;
pub const GTPU_V4_FLOW: _bindgen_ty_255 = 19;
pub const GTPU_V6_FLOW: _bindgen_ty_255 = 20;
pub const GTPC_V4_FLOW: _bindgen_ty_255 = 21;
pub const GTPC_V6_FLOW: _bindgen_ty_255 = 22;
pub const GTPC_TEID_V4_FLOW: _bindgen_ty_255 = 23;
pub const GTPC_TEID_V6_FLOW: _bindgen_ty_255 = 24;
pub const GTPU_EH_V4_FLOW: _bindgen_ty_255 = 25;
pub const GTPU_EH_V6_FLOW: _bindgen_ty_255 = 26;
pub const GTPU_UL_V4_FLOW: _bindgen_ty_255 = 27;
pub const GTPU_UL_V6_FLOW: _bindgen_ty_255 = 28;
pub const GTPU_DL_V4_FLOW: _bindgen_ty_255 = 29;
pub const GTPU_DL_V6_FLOW: _bindgen_ty_255 = 30;
pub const __FLOW_TYPE_COUNT: _bindgen_ty_255 = 31;
pub type _bindgen_ty_255 = ffi::c_uint;
pub const ethtool_reset_flags_ETH_RESET_MGMT: ethtool_reset_flags = 1;
pub const ethtool_reset_flags_ETH_RESET_IRQ: ethtool_reset_flags = 2;
pub const ethtool_reset_flags_ETH_RESET_DMA: ethtool_reset_flags = 4;
pub const ethtool_reset_flags_ETH_RESET_FILTER: ethtool_reset_flags = 8;
pub const ethtool_reset_flags_ETH_RESET_OFFLOAD: ethtool_reset_flags = 16;
pub const ethtool_reset_flags_ETH_RESET_MAC: ethtool_reset_flags = 32;
pub const ethtool_reset_flags_ETH_RESET_PHY: ethtool_reset_flags = 64;
pub const ethtool_reset_flags_ETH_RESET_RAM: ethtool_reset_flags = 128;
pub const ethtool_reset_flags_ETH_RESET_AP: ethtool_reset_flags = 256;
pub const ethtool_reset_flags_ETH_RESET_DEDICATED: ethtool_reset_flags = 65535;
pub const ethtool_reset_flags_ETH_RESET_ALL: ethtool_reset_flags = 4294967295;
pub type ethtool_reset_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub master_slave_cfg: __u8,
    pub master_slave_state: __u8,
    pub rate_matching: __u8,
    pub reserved: [__u32; 7usize],
}
pub const phy_upstream_PHY_UPSTREAM_MAC: phy_upstream = 0;
pub const phy_upstream_PHY_UPSTREAM_PHY: phy_upstream = 1;
pub type phy_upstream = ffi::c_uint;
pub const ETHTOOL_UDP_TUNNEL_TYPE_VXLAN: _bindgen_ty_256 = 0;
pub const ETHTOOL_UDP_TUNNEL_TYPE_GENEVE: _bindgen_ty_256 = 1;
pub const ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE: _bindgen_ty_256 = 2;
pub const __ETHTOOL_UDP_TUNNEL_TYPE_CNT: _bindgen_ty_256 = 3;
pub const ETHTOOL_UDP_TUNNEL_TYPE_MAX: _bindgen_ty_256 = 2;
pub type _bindgen_ty_256 = ffi::c_uint;
pub const ethtool_header_flags_ETHTOOL_FLAG_COMPACT_BITSETS: ethtool_header_flags = 1;
pub const ethtool_header_flags_ETHTOOL_FLAG_OMIT_REPLY: ethtool_header_flags = 2;
pub const ethtool_header_flags_ETHTOOL_FLAG_STATS: ethtool_header_flags = 4;
pub type ethtool_header_flags = ffi::c_uint;
pub const ethtool_tcp_data_split_ETHTOOL_TCP_DATA_SPLIT_UNKNOWN: ethtool_tcp_data_split = 0;
pub const ethtool_tcp_data_split_ETHTOOL_TCP_DATA_SPLIT_DISABLED: ethtool_tcp_data_split = 1;
pub const ethtool_tcp_data_split_ETHTOOL_TCP_DATA_SPLIT_ENABLED: ethtool_tcp_data_split = 2;
pub type ethtool_tcp_data_split = ffi::c_uint;
pub const hwtstamp_source_HWTSTAMP_SOURCE_NETDEV: hwtstamp_source = 1;
pub const hwtstamp_source_HWTSTAMP_SOURCE_PHYLIB: hwtstamp_source = 2;
pub type hwtstamp_source = ffi::c_uint;
pub const ethtool_pse_event_ETHTOOL_PSE_EVENT_OVER_CURRENT: ethtool_pse_event = 1;
pub const ethtool_pse_event_ETHTOOL_PSE_EVENT_OVER_TEMP: ethtool_pse_event = 2;
pub const ethtool_pse_event_ETHTOOL_C33_PSE_EVENT_DETECTION: ethtool_pse_event = 4;
pub const ethtool_pse_event_ETHTOOL_C33_PSE_EVENT_CLASSIFICATION: ethtool_pse_event = 8;
pub const ethtool_pse_event_ETHTOOL_C33_PSE_EVENT_DISCONNECTION: ethtool_pse_event = 16;
pub const ethtool_pse_event_ETHTOOL_PSE_EVENT_OVER_BUDGET: ethtool_pse_event = 32;
pub const ethtool_pse_event_ETHTOOL_PSE_EVENT_SW_PW_CONTROL_ERROR: ethtool_pse_event = 64;
pub type ethtool_pse_event = ffi::c_uint;
pub const ETHTOOL_A_HEADER_UNSPEC: _bindgen_ty_257 = 0;
pub const ETHTOOL_A_HEADER_DEV_INDEX: _bindgen_ty_257 = 1;
pub const ETHTOOL_A_HEADER_DEV_NAME: _bindgen_ty_257 = 2;
pub const ETHTOOL_A_HEADER_FLAGS: _bindgen_ty_257 = 3;
pub const ETHTOOL_A_HEADER_PHY_INDEX: _bindgen_ty_257 = 4;
pub const __ETHTOOL_A_HEADER_CNT: _bindgen_ty_257 = 5;
pub const ETHTOOL_A_HEADER_MAX: _bindgen_ty_257 = 4;
pub type _bindgen_ty_257 = ffi::c_uint;
pub const ETHTOOL_A_BITSET_BIT_UNSPEC: _bindgen_ty_258 = 0;
pub const ETHTOOL_A_BITSET_BIT_INDEX: _bindgen_ty_258 = 1;
pub const ETHTOOL_A_BITSET_BIT_NAME: _bindgen_ty_258 = 2;
pub const ETHTOOL_A_BITSET_BIT_VALUE: _bindgen_ty_258 = 3;
pub const __ETHTOOL_A_BITSET_BIT_CNT: _bindgen_ty_258 = 4;
pub const ETHTOOL_A_BITSET_BIT_MAX: _bindgen_ty_258 = 3;
pub type _bindgen_ty_258 = ffi::c_uint;
pub const ETHTOOL_A_BITSET_BITS_UNSPEC: _bindgen_ty_259 = 0;
pub const ETHTOOL_A_BITSET_BITS_BIT: _bindgen_ty_259 = 1;
pub const __ETHTOOL_A_BITSET_BITS_CNT: _bindgen_ty_259 = 2;
pub const ETHTOOL_A_BITSET_BITS_MAX: _bindgen_ty_259 = 1;
pub type _bindgen_ty_259 = ffi::c_uint;
pub const ETHTOOL_A_BITSET_UNSPEC: _bindgen_ty_260 = 0;
pub const ETHTOOL_A_BITSET_NOMASK: _bindgen_ty_260 = 1;
pub const ETHTOOL_A_BITSET_SIZE: _bindgen_ty_260 = 2;
pub const ETHTOOL_A_BITSET_BITS: _bindgen_ty_260 = 3;
pub const ETHTOOL_A_BITSET_VALUE: _bindgen_ty_260 = 4;
pub const ETHTOOL_A_BITSET_MASK: _bindgen_ty_260 = 5;
pub const __ETHTOOL_A_BITSET_CNT: _bindgen_ty_260 = 6;
pub const ETHTOOL_A_BITSET_MAX: _bindgen_ty_260 = 5;
pub type _bindgen_ty_260 = ffi::c_uint;
pub const ETHTOOL_A_STRING_UNSPEC: _bindgen_ty_261 = 0;
pub const ETHTOOL_A_STRING_INDEX: _bindgen_ty_261 = 1;
pub const ETHTOOL_A_STRING_VALUE: _bindgen_ty_261 = 2;
pub const __ETHTOOL_A_STRING_CNT: _bindgen_ty_261 = 3;
pub const ETHTOOL_A_STRING_MAX: _bindgen_ty_261 = 2;
pub type _bindgen_ty_261 = ffi::c_uint;
pub const ETHTOOL_A_STRINGS_UNSPEC: _bindgen_ty_262 = 0;
pub const ETHTOOL_A_STRINGS_STRING: _bindgen_ty_262 = 1;
pub const __ETHTOOL_A_STRINGS_CNT: _bindgen_ty_262 = 2;
pub const ETHTOOL_A_STRINGS_MAX: _bindgen_ty_262 = 1;
pub type _bindgen_ty_262 = ffi::c_uint;
pub const ETHTOOL_A_STRINGSET_UNSPEC: _bindgen_ty_263 = 0;
pub const ETHTOOL_A_STRINGSET_ID: _bindgen_ty_263 = 1;
pub const ETHTOOL_A_STRINGSET_COUNT: _bindgen_ty_263 = 2;
pub const ETHTOOL_A_STRINGSET_STRINGS: _bindgen_ty_263 = 3;
pub const __ETHTOOL_A_STRINGSET_CNT: _bindgen_ty_263 = 4;
pub const ETHTOOL_A_STRINGSET_MAX: _bindgen_ty_263 = 3;
pub type _bindgen_ty_263 = ffi::c_uint;
pub const ETHTOOL_A_STRINGSETS_UNSPEC: _bindgen_ty_264 = 0;
pub const ETHTOOL_A_STRINGSETS_STRINGSET: _bindgen_ty_264 = 1;
pub const __ETHTOOL_A_STRINGSETS_CNT: _bindgen_ty_264 = 2;
pub const ETHTOOL_A_STRINGSETS_MAX: _bindgen_ty_264 = 1;
pub type _bindgen_ty_264 = ffi::c_uint;
pub const ETHTOOL_A_STRSET_UNSPEC: _bindgen_ty_265 = 0;
pub const ETHTOOL_A_STRSET_HEADER: _bindgen_ty_265 = 1;
pub const ETHTOOL_A_STRSET_STRINGSETS: _bindgen_ty_265 = 2;
pub const ETHTOOL_A_STRSET_COUNTS_ONLY: _bindgen_ty_265 = 3;
pub const __ETHTOOL_A_STRSET_CNT: _bindgen_ty_265 = 4;
pub const ETHTOOL_A_STRSET_MAX: _bindgen_ty_265 = 3;
pub type _bindgen_ty_265 = ffi::c_uint;
pub const ETHTOOL_A_PRIVFLAGS_UNSPEC: _bindgen_ty_266 = 0;
pub const ETHTOOL_A_PRIVFLAGS_HEADER: _bindgen_ty_266 = 1;
pub const ETHTOOL_A_PRIVFLAGS_FLAGS: _bindgen_ty_266 = 2;
pub const __ETHTOOL_A_PRIVFLAGS_CNT: _bindgen_ty_266 = 3;
pub const ETHTOOL_A_PRIVFLAGS_MAX: _bindgen_ty_266 = 2;
pub type _bindgen_ty_266 = ffi::c_uint;
pub const ETHTOOL_A_RINGS_UNSPEC: _bindgen_ty_267 = 0;
pub const ETHTOOL_A_RINGS_HEADER: _bindgen_ty_267 = 1;
pub const ETHTOOL_A_RINGS_RX_MAX: _bindgen_ty_267 = 2;
pub const ETHTOOL_A_RINGS_RX_MINI_MAX: _bindgen_ty_267 = 3;
pub const ETHTOOL_A_RINGS_RX_JUMBO_MAX: _bindgen_ty_267 = 4;
pub const ETHTOOL_A_RINGS_TX_MAX: _bindgen_ty_267 = 5;
pub const ETHTOOL_A_RINGS_RX: _bindgen_ty_267 = 6;
pub const ETHTOOL_A_RINGS_RX_MINI: _bindgen_ty_267 = 7;
pub const ETHTOOL_A_RINGS_RX_JUMBO: _bindgen_ty_267 = 8;
pub const ETHTOOL_A_RINGS_TX: _bindgen_ty_267 = 9;
pub const ETHTOOL_A_RINGS_RX_BUF_LEN: _bindgen_ty_267 = 10;
pub const ETHTOOL_A_RINGS_TCP_DATA_SPLIT: _bindgen_ty_267 = 11;
pub const ETHTOOL_A_RINGS_CQE_SIZE: _bindgen_ty_267 = 12;
pub const ETHTOOL_A_RINGS_TX_PUSH: _bindgen_ty_267 = 13;
pub const ETHTOOL_A_RINGS_RX_PUSH: _bindgen_ty_267 = 14;
pub const ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN: _bindgen_ty_267 = 15;
pub const ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX: _bindgen_ty_267 = 16;
pub const ETHTOOL_A_RINGS_HDS_THRESH: _bindgen_ty_267 = 17;
pub const ETHTOOL_A_RINGS_HDS_THRESH_MAX: _bindgen_ty_267 = 18;
pub const __ETHTOOL_A_RINGS_CNT: _bindgen_ty_267 = 19;
pub const ETHTOOL_A_RINGS_MAX: _bindgen_ty_267 = 18;
pub type _bindgen_ty_267 = ffi::c_uint;
pub const ETHTOOL_A_MM_STAT_UNSPEC: _bindgen_ty_268 = 0;
pub const ETHTOOL_A_MM_STAT_PAD: _bindgen_ty_268 = 1;
pub const ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS: _bindgen_ty_268 = 2;
pub const ETHTOOL_A_MM_STAT_SMD_ERRORS: _bindgen_ty_268 = 3;
pub const ETHTOOL_A_MM_STAT_REASSEMBLY_OK: _bindgen_ty_268 = 4;
pub const ETHTOOL_A_MM_STAT_RX_FRAG_COUNT: _bindgen_ty_268 = 5;
pub const ETHTOOL_A_MM_STAT_TX_FRAG_COUNT: _bindgen_ty_268 = 6;
pub const ETHTOOL_A_MM_STAT_HOLD_COUNT: _bindgen_ty_268 = 7;
pub const __ETHTOOL_A_MM_STAT_CNT: _bindgen_ty_268 = 8;
pub const ETHTOOL_A_MM_STAT_MAX: _bindgen_ty_268 = 7;
pub type _bindgen_ty_268 = ffi::c_uint;
pub const ETHTOOL_A_MM_UNSPEC: _bindgen_ty_269 = 0;
pub const ETHTOOL_A_MM_HEADER: _bindgen_ty_269 = 1;
pub const ETHTOOL_A_MM_PMAC_ENABLED: _bindgen_ty_269 = 2;
pub const ETHTOOL_A_MM_TX_ENABLED: _bindgen_ty_269 = 3;
pub const ETHTOOL_A_MM_TX_ACTIVE: _bindgen_ty_269 = 4;
pub const ETHTOOL_A_MM_TX_MIN_FRAG_SIZE: _bindgen_ty_269 = 5;
pub const ETHTOOL_A_MM_RX_MIN_FRAG_SIZE: _bindgen_ty_269 = 6;
pub const ETHTOOL_A_MM_VERIFY_ENABLED: _bindgen_ty_269 = 7;
pub const ETHTOOL_A_MM_VERIFY_STATUS: _bindgen_ty_269 = 8;
pub const ETHTOOL_A_MM_VERIFY_TIME: _bindgen_ty_269 = 9;
pub const ETHTOOL_A_MM_MAX_VERIFY_TIME: _bindgen_ty_269 = 10;
pub const ETHTOOL_A_MM_STATS: _bindgen_ty_269 = 11;
pub const __ETHTOOL_A_MM_CNT: _bindgen_ty_269 = 12;
pub const ETHTOOL_A_MM_MAX: _bindgen_ty_269 = 11;
pub type _bindgen_ty_269 = ffi::c_uint;
pub const ETHTOOL_A_LINKINFO_UNSPEC: _bindgen_ty_270 = 0;
pub const ETHTOOL_A_LINKINFO_HEADER: _bindgen_ty_270 = 1;
pub const ETHTOOL_A_LINKINFO_PORT: _bindgen_ty_270 = 2;
pub const ETHTOOL_A_LINKINFO_PHYADDR: _bindgen_ty_270 = 3;
pub const ETHTOOL_A_LINKINFO_TP_MDIX: _bindgen_ty_270 = 4;
pub const ETHTOOL_A_LINKINFO_TP_MDIX_CTRL: _bindgen_ty_270 = 5;
pub const ETHTOOL_A_LINKINFO_TRANSCEIVER: _bindgen_ty_270 = 6;
pub const __ETHTOOL_A_LINKINFO_CNT: _bindgen_ty_270 = 7;
pub const ETHTOOL_A_LINKINFO_MAX: _bindgen_ty_270 = 6;
pub type _bindgen_ty_270 = ffi::c_uint;
pub const ETHTOOL_A_LINKMODES_UNSPEC: _bindgen_ty_271 = 0;
pub const ETHTOOL_A_LINKMODES_HEADER: _bindgen_ty_271 = 1;
pub const ETHTOOL_A_LINKMODES_AUTONEG: _bindgen_ty_271 = 2;
pub const ETHTOOL_A_LINKMODES_OURS: _bindgen_ty_271 = 3;
pub const ETHTOOL_A_LINKMODES_PEER: _bindgen_ty_271 = 4;
pub const ETHTOOL_A_LINKMODES_SPEED: _bindgen_ty_271 = 5;
pub const ETHTOOL_A_LINKMODES_DUPLEX: _bindgen_ty_271 = 6;
pub const ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG: _bindgen_ty_271 = 7;
pub const ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE: _bindgen_ty_271 = 8;
pub const ETHTOOL_A_LINKMODES_LANES: _bindgen_ty_271 = 9;
pub const ETHTOOL_A_LINKMODES_RATE_MATCHING: _bindgen_ty_271 = 10;
pub const __ETHTOOL_A_LINKMODES_CNT: _bindgen_ty_271 = 11;
pub const ETHTOOL_A_LINKMODES_MAX: _bindgen_ty_271 = 10;
pub type _bindgen_ty_271 = ffi::c_uint;
pub const ETHTOOL_A_LINKSTATE_UNSPEC: _bindgen_ty_272 = 0;
pub const ETHTOOL_A_LINKSTATE_HEADER: _bindgen_ty_272 = 1;
pub const ETHTOOL_A_LINKSTATE_LINK: _bindgen_ty_272 = 2;
pub const ETHTOOL_A_LINKSTATE_SQI: _bindgen_ty_272 = 3;
pub const ETHTOOL_A_LINKSTATE_SQI_MAX: _bindgen_ty_272 = 4;
pub const ETHTOOL_A_LINKSTATE_EXT_STATE: _bindgen_ty_272 = 5;
pub const ETHTOOL_A_LINKSTATE_EXT_SUBSTATE: _bindgen_ty_272 = 6;
pub const ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT: _bindgen_ty_272 = 7;
pub const __ETHTOOL_A_LINKSTATE_CNT: _bindgen_ty_272 = 8;
pub const ETHTOOL_A_LINKSTATE_MAX: _bindgen_ty_272 = 7;
pub type _bindgen_ty_272 = ffi::c_uint;
pub const ETHTOOL_A_DEBUG_UNSPEC: _bindgen_ty_273 = 0;
pub const ETHTOOL_A_DEBUG_HEADER: _bindgen_ty_273 = 1;
pub const ETHTOOL_A_DEBUG_MSGMASK: _bindgen_ty_273 = 2;
pub const __ETHTOOL_A_DEBUG_CNT: _bindgen_ty_273 = 3;
pub const ETHTOOL_A_DEBUG_MAX: _bindgen_ty_273 = 2;
pub type _bindgen_ty_273 = ffi::c_uint;
pub const ETHTOOL_A_WOL_UNSPEC: _bindgen_ty_274 = 0;
pub const ETHTOOL_A_WOL_HEADER: _bindgen_ty_274 = 1;
pub const ETHTOOL_A_WOL_MODES: _bindgen_ty_274 = 2;
pub const ETHTOOL_A_WOL_SOPASS: _bindgen_ty_274 = 3;
pub const __ETHTOOL_A_WOL_CNT: _bindgen_ty_274 = 4;
pub const ETHTOOL_A_WOL_MAX: _bindgen_ty_274 = 3;
pub type _bindgen_ty_274 = ffi::c_uint;
pub const ETHTOOL_A_FEATURES_UNSPEC: _bindgen_ty_275 = 0;
pub const ETHTOOL_A_FEATURES_HEADER: _bindgen_ty_275 = 1;
pub const ETHTOOL_A_FEATURES_HW: _bindgen_ty_275 = 2;
pub const ETHTOOL_A_FEATURES_WANTED: _bindgen_ty_275 = 3;
pub const ETHTOOL_A_FEATURES_ACTIVE: _bindgen_ty_275 = 4;
pub const ETHTOOL_A_FEATURES_NOCHANGE: _bindgen_ty_275 = 5;
pub const __ETHTOOL_A_FEATURES_CNT: _bindgen_ty_275 = 6;
pub const ETHTOOL_A_FEATURES_MAX: _bindgen_ty_275 = 5;
pub type _bindgen_ty_275 = ffi::c_uint;
pub const ETHTOOL_A_CHANNELS_UNSPEC: _bindgen_ty_276 = 0;
pub const ETHTOOL_A_CHANNELS_HEADER: _bindgen_ty_276 = 1;
pub const ETHTOOL_A_CHANNELS_RX_MAX: _bindgen_ty_276 = 2;
pub const ETHTOOL_A_CHANNELS_TX_MAX: _bindgen_ty_276 = 3;
pub const ETHTOOL_A_CHANNELS_OTHER_MAX: _bindgen_ty_276 = 4;
pub const ETHTOOL_A_CHANNELS_COMBINED_MAX: _bindgen_ty_276 = 5;
pub const ETHTOOL_A_CHANNELS_RX_COUNT: _bindgen_ty_276 = 6;
pub const ETHTOOL_A_CHANNELS_TX_COUNT: _bindgen_ty_276 = 7;
pub const ETHTOOL_A_CHANNELS_OTHER_COUNT: _bindgen_ty_276 = 8;
pub const ETHTOOL_A_CHANNELS_COMBINED_COUNT: _bindgen_ty_276 = 9;
pub const __ETHTOOL_A_CHANNELS_CNT: _bindgen_ty_276 = 10;
pub const ETHTOOL_A_CHANNELS_MAX: _bindgen_ty_276 = 9;
pub type _bindgen_ty_276 = ffi::c_uint;
pub const ETHTOOL_A_IRQ_MODERATION_UNSPEC: _bindgen_ty_277 = 0;
pub const ETHTOOL_A_IRQ_MODERATION_USEC: _bindgen_ty_277 = 1;
pub const ETHTOOL_A_IRQ_MODERATION_PKTS: _bindgen_ty_277 = 2;
pub const ETHTOOL_A_IRQ_MODERATION_COMPS: _bindgen_ty_277 = 3;
pub const __ETHTOOL_A_IRQ_MODERATION_CNT: _bindgen_ty_277 = 4;
pub const ETHTOOL_A_IRQ_MODERATION_MAX: _bindgen_ty_277 = 3;
pub type _bindgen_ty_277 = ffi::c_uint;
pub const ETHTOOL_A_PROFILE_UNSPEC: _bindgen_ty_278 = 0;
pub const ETHTOOL_A_PROFILE_IRQ_MODERATION: _bindgen_ty_278 = 1;
pub const __ETHTOOL_A_PROFILE_CNT: _bindgen_ty_278 = 2;
pub const ETHTOOL_A_PROFILE_MAX: _bindgen_ty_278 = 1;
pub type _bindgen_ty_278 = ffi::c_uint;
pub const ETHTOOL_A_COALESCE_UNSPEC: _bindgen_ty_279 = 0;
pub const ETHTOOL_A_COALESCE_HEADER: _bindgen_ty_279 = 1;
pub const ETHTOOL_A_COALESCE_RX_USECS: _bindgen_ty_279 = 2;
pub const ETHTOOL_A_COALESCE_RX_MAX_FRAMES: _bindgen_ty_279 = 3;
pub const ETHTOOL_A_COALESCE_RX_USECS_IRQ: _bindgen_ty_279 = 4;
pub const ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ: _bindgen_ty_279 = 5;
pub const ETHTOOL_A_COALESCE_TX_USECS: _bindgen_ty_279 = 6;
pub const ETHTOOL_A_COALESCE_TX_MAX_FRAMES: _bindgen_ty_279 = 7;
pub const ETHTOOL_A_COALESCE_TX_USECS_IRQ: _bindgen_ty_279 = 8;
pub const ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ: _bindgen_ty_279 = 9;
pub const ETHTOOL_A_COALESCE_STATS_BLOCK_USECS: _bindgen_ty_279 = 10;
pub const ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX: _bindgen_ty_279 = 11;
pub const ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX: _bindgen_ty_279 = 12;
pub const ETHTOOL_A_COALESCE_PKT_RATE_LOW: _bindgen_ty_279 = 13;
pub const ETHTOOL_A_COALESCE_RX_USECS_LOW: _bindgen_ty_279 = 14;
pub const ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW: _bindgen_ty_279 = 15;
pub const ETHTOOL_A_COALESCE_TX_USECS_LOW: _bindgen_ty_279 = 16;
pub const ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW: _bindgen_ty_279 = 17;
pub const ETHTOOL_A_COALESCE_PKT_RATE_HIGH: _bindgen_ty_279 = 18;
pub const ETHTOOL_A_COALESCE_RX_USECS_HIGH: _bindgen_ty_279 = 19;
pub const ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH: _bindgen_ty_279 = 20;
pub const ETHTOOL_A_COALESCE_TX_USECS_HIGH: _bindgen_ty_279 = 21;
pub const ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH: _bindgen_ty_279 = 22;
pub const ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL: _bindgen_ty_279 = 23;
pub const ETHTOOL_A_COALESCE_USE_CQE_MODE_TX: _bindgen_ty_279 = 24;
pub const ETHTOOL_A_COALESCE_USE_CQE_MODE_RX: _bindgen_ty_279 = 25;
pub const ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES: _bindgen_ty_279 = 26;
pub const ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES: _bindgen_ty_279 = 27;
pub const ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS: _bindgen_ty_279 = 28;
pub const ETHTOOL_A_COALESCE_RX_PROFILE: _bindgen_ty_279 = 29;
pub const ETHTOOL_A_COALESCE_TX_PROFILE: _bindgen_ty_279 = 30;
pub const __ETHTOOL_A_COALESCE_CNT: _bindgen_ty_279 = 31;
pub const ETHTOOL_A_COALESCE_MAX: _bindgen_ty_279 = 30;
pub type _bindgen_ty_279 = ffi::c_uint;
pub const ETHTOOL_A_PAUSE_STAT_UNSPEC: _bindgen_ty_280 = 0;
pub const ETHTOOL_A_PAUSE_STAT_PAD: _bindgen_ty_280 = 1;
pub const ETHTOOL_A_PAUSE_STAT_TX_FRAMES: _bindgen_ty_280 = 2;
pub const ETHTOOL_A_PAUSE_STAT_RX_FRAMES: _bindgen_ty_280 = 3;
pub const __ETHTOOL_A_PAUSE_STAT_CNT: _bindgen_ty_280 = 4;
pub const ETHTOOL_A_PAUSE_STAT_MAX: _bindgen_ty_280 = 3;
pub type _bindgen_ty_280 = ffi::c_uint;
pub const ETHTOOL_A_PAUSE_UNSPEC: _bindgen_ty_281 = 0;
pub const ETHTOOL_A_PAUSE_HEADER: _bindgen_ty_281 = 1;
pub const ETHTOOL_A_PAUSE_AUTONEG: _bindgen_ty_281 = 2;
pub const ETHTOOL_A_PAUSE_RX: _bindgen_ty_281 = 3;
pub const ETHTOOL_A_PAUSE_TX: _bindgen_ty_281 = 4;
pub const ETHTOOL_A_PAUSE_STATS: _bindgen_ty_281 = 5;
pub const ETHTOOL_A_PAUSE_STATS_SRC: _bindgen_ty_281 = 6;
pub const __ETHTOOL_A_PAUSE_CNT: _bindgen_ty_281 = 7;
pub const ETHTOOL_A_PAUSE_MAX: _bindgen_ty_281 = 6;
pub type _bindgen_ty_281 = ffi::c_uint;
pub const ETHTOOL_A_EEE_UNSPEC: _bindgen_ty_282 = 0;
pub const ETHTOOL_A_EEE_HEADER: _bindgen_ty_282 = 1;
pub const ETHTOOL_A_EEE_MODES_OURS: _bindgen_ty_282 = 2;
pub const ETHTOOL_A_EEE_MODES_PEER: _bindgen_ty_282 = 3;
pub const ETHTOOL_A_EEE_ACTIVE: _bindgen_ty_282 = 4;
pub const ETHTOOL_A_EEE_ENABLED: _bindgen_ty_282 = 5;
pub const ETHTOOL_A_EEE_TX_LPI_ENABLED: _bindgen_ty_282 = 6;
pub const ETHTOOL_A_EEE_TX_LPI_TIMER: _bindgen_ty_282 = 7;
pub const __ETHTOOL_A_EEE_CNT: _bindgen_ty_282 = 8;
pub const ETHTOOL_A_EEE_MAX: _bindgen_ty_282 = 7;
pub type _bindgen_ty_282 = ffi::c_uint;
pub const ETHTOOL_A_TS_STAT_UNSPEC: _bindgen_ty_283 = 0;
pub const ETHTOOL_A_TS_STAT_TX_PKTS: _bindgen_ty_283 = 1;
pub const ETHTOOL_A_TS_STAT_TX_LOST: _bindgen_ty_283 = 2;
pub const ETHTOOL_A_TS_STAT_TX_ERR: _bindgen_ty_283 = 3;
pub const ETHTOOL_A_TS_STAT_TX_ONESTEP_PKTS_UNCONFIRMED: _bindgen_ty_283 = 4;
pub const __ETHTOOL_A_TS_STAT_CNT: _bindgen_ty_283 = 5;
pub const ETHTOOL_A_TS_STAT_MAX: _bindgen_ty_283 = 4;
pub type _bindgen_ty_283 = ffi::c_uint;
pub const ETHTOOL_A_TS_HWTSTAMP_PROVIDER_UNSPEC: _bindgen_ty_284 = 0;
pub const ETHTOOL_A_TS_HWTSTAMP_PROVIDER_INDEX: _bindgen_ty_284 = 1;
pub const ETHTOOL_A_TS_HWTSTAMP_PROVIDER_QUALIFIER: _bindgen_ty_284 = 2;
pub const __ETHTOOL_A_TS_HWTSTAMP_PROVIDER_CNT: _bindgen_ty_284 = 3;
pub const ETHTOOL_A_TS_HWTSTAMP_PROVIDER_MAX: _bindgen_ty_284 = 2;
pub type _bindgen_ty_284 = ffi::c_uint;
pub const ETHTOOL_A_TSINFO_UNSPEC: _bindgen_ty_285 = 0;
pub const ETHTOOL_A_TSINFO_HEADER: _bindgen_ty_285 = 1;
pub const ETHTOOL_A_TSINFO_TIMESTAMPING: _bindgen_ty_285 = 2;
pub const ETHTOOL_A_TSINFO_TX_TYPES: _bindgen_ty_285 = 3;
pub const ETHTOOL_A_TSINFO_RX_FILTERS: _bindgen_ty_285 = 4;
pub const ETHTOOL_A_TSINFO_PHC_INDEX: _bindgen_ty_285 = 5;
pub const ETHTOOL_A_TSINFO_STATS: _bindgen_ty_285 = 6;
pub const ETHTOOL_A_TSINFO_HWTSTAMP_PROVIDER: _bindgen_ty_285 = 7;
pub const ETHTOOL_A_TSINFO_HWTSTAMP_SOURCE: _bindgen_ty_285 = 8;
pub const ETHTOOL_A_TSINFO_HWTSTAMP_PHYINDEX: _bindgen_ty_285 = 9;
pub const __ETHTOOL_A_TSINFO_CNT: _bindgen_ty_285 = 10;
pub const ETHTOOL_A_TSINFO_MAX: _bindgen_ty_285 = 9;
pub type _bindgen_ty_285 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_RESULT_UNSPEC: _bindgen_ty_286 = 0;
pub const ETHTOOL_A_CABLE_RESULT_PAIR: _bindgen_ty_286 = 1;
pub const ETHTOOL_A_CABLE_RESULT_CODE: _bindgen_ty_286 = 2;
pub const ETHTOOL_A_CABLE_RESULT_SRC: _bindgen_ty_286 = 3;
pub const __ETHTOOL_A_CABLE_RESULT_CNT: _bindgen_ty_286 = 4;
pub const ETHTOOL_A_CABLE_RESULT_MAX: _bindgen_ty_286 = 3;
pub type _bindgen_ty_286 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC: _bindgen_ty_287 = 0;
pub const ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR: _bindgen_ty_287 = 1;
pub const ETHTOOL_A_CABLE_FAULT_LENGTH_CM: _bindgen_ty_287 = 2;
pub const ETHTOOL_A_CABLE_FAULT_LENGTH_SRC: _bindgen_ty_287 = 3;
pub const __ETHTOOL_A_CABLE_FAULT_LENGTH_CNT: _bindgen_ty_287 = 4;
pub const ETHTOOL_A_CABLE_FAULT_LENGTH_MAX: _bindgen_ty_287 = 3;
pub type _bindgen_ty_287 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_NEST_UNSPEC: _bindgen_ty_288 = 0;
pub const ETHTOOL_A_CABLE_NEST_RESULT: _bindgen_ty_288 = 1;
pub const ETHTOOL_A_CABLE_NEST_FAULT_LENGTH: _bindgen_ty_288 = 2;
pub const __ETHTOOL_A_CABLE_NEST_CNT: _bindgen_ty_288 = 3;
pub const ETHTOOL_A_CABLE_NEST_MAX: _bindgen_ty_288 = 2;
pub type _bindgen_ty_288 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_TEST_UNSPEC: _bindgen_ty_289 = 0;
pub const ETHTOOL_A_CABLE_TEST_HEADER: _bindgen_ty_289 = 1;
pub const __ETHTOOL_A_CABLE_TEST_CNT: _bindgen_ty_289 = 2;
pub const ETHTOOL_A_CABLE_TEST_MAX: _bindgen_ty_289 = 1;
pub type _bindgen_ty_289 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_TEST_NTF_UNSPEC: _bindgen_ty_290 = 0;
pub const ETHTOOL_A_CABLE_TEST_NTF_HEADER: _bindgen_ty_290 = 1;
pub const ETHTOOL_A_CABLE_TEST_NTF_STATUS: _bindgen_ty_290 = 2;
pub const ETHTOOL_A_CABLE_TEST_NTF_NEST: _bindgen_ty_290 = 3;
pub const __ETHTOOL_A_CABLE_TEST_NTF_CNT: _bindgen_ty_290 = 4;
pub const ETHTOOL_A_CABLE_TEST_NTF_MAX: _bindgen_ty_290 = 3;
pub type _bindgen_ty_290 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC: _bindgen_ty_291 = 0;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST: _bindgen_ty_291 = 1;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST: _bindgen_ty_291 = 2;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP: _bindgen_ty_291 = 3;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR: _bindgen_ty_291 = 4;
pub const __ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT: _bindgen_ty_291 = 5;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX: _bindgen_ty_291 = 4;
pub type _bindgen_ty_291 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_TEST_TDR_NTF_UNSPEC: _bindgen_ty_292 = 0;
pub const ETHTOOL_A_CABLE_TEST_TDR_NTF_HEADER: _bindgen_ty_292 = 1;
pub const ETHTOOL_A_CABLE_TEST_TDR_NTF_STATUS: _bindgen_ty_292 = 2;
pub const ETHTOOL_A_CABLE_TEST_TDR_NTF_NEST: _bindgen_ty_292 = 3;
pub const __ETHTOOL_A_CABLE_TEST_TDR_NTF_CNT: _bindgen_ty_292 = 4;
pub const ETHTOOL_A_CABLE_TEST_TDR_NTF_MAX: _bindgen_ty_292 = 3;
pub type _bindgen_ty_292 = ffi::c_uint;
pub const ETHTOOL_A_CABLE_TEST_TDR_UNSPEC: _bindgen_ty_293 = 0;
pub const ETHTOOL_A_CABLE_TEST_TDR_HEADER: _bindgen_ty_293 = 1;
pub const ETHTOOL_A_CABLE_TEST_TDR_CFG: _bindgen_ty_293 = 2;
pub const __ETHTOOL_A_CABLE_TEST_TDR_CNT: _bindgen_ty_293 = 3;
pub const ETHTOOL_A_CABLE_TEST_TDR_MAX: _bindgen_ty_293 = 2;
pub type _bindgen_ty_293 = ffi::c_uint;
pub const ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC: _bindgen_ty_294 = 0;
pub const ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT: _bindgen_ty_294 = 1;
pub const ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE: _bindgen_ty_294 = 2;
pub const __ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT: _bindgen_ty_294 = 3;
pub const ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX: _bindgen_ty_294 = 2;
pub type _bindgen_ty_294 = ffi::c_uint;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC: _bindgen_ty_295 = 0;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE: _bindgen_ty_295 = 1;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES: _bindgen_ty_295 = 2;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY: _bindgen_ty_295 = 3;
pub const __ETHTOOL_A_TUNNEL_UDP_TABLE_CNT: _bindgen_ty_295 = 4;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE_MAX: _bindgen_ty_295 = 3;
pub type _bindgen_ty_295 = ffi::c_uint;
pub const ETHTOOL_A_TUNNEL_UDP_UNSPEC: _bindgen_ty_296 = 0;
pub const ETHTOOL_A_TUNNEL_UDP_TABLE: _bindgen_ty_296 = 1;
pub const __ETHTOOL_A_TUNNEL_UDP_CNT: _bindgen_ty_296 = 2;
pub const ETHTOOL_A_TUNNEL_UDP_MAX: _bindgen_ty_296 = 1;
pub type _bindgen_ty_296 = ffi::c_uint;
pub const ETHTOOL_A_TUNNEL_INFO_UNSPEC: _bindgen_ty_297 = 0;
pub const ETHTOOL_A_TUNNEL_INFO_HEADER: _bindgen_ty_297 = 1;
pub const ETHTOOL_A_TUNNEL_INFO_UDP_PORTS: _bindgen_ty_297 = 2;
pub const __ETHTOOL_A_TUNNEL_INFO_CNT: _bindgen_ty_297 = 3;
pub const ETHTOOL_A_TUNNEL_INFO_MAX: _bindgen_ty_297 = 2;
pub type _bindgen_ty_297 = ffi::c_uint;
pub const ETHTOOL_A_FEC_STAT_UNSPEC: _bindgen_ty_298 = 0;
pub const ETHTOOL_A_FEC_STAT_PAD: _bindgen_ty_298 = 1;
pub const ETHTOOL_A_FEC_STAT_CORRECTED: _bindgen_ty_298 = 2;
pub const ETHTOOL_A_FEC_STAT_UNCORR: _bindgen_ty_298 = 3;
pub const ETHTOOL_A_FEC_STAT_CORR_BITS: _bindgen_ty_298 = 4;
pub const __ETHTOOL_A_FEC_STAT_CNT: _bindgen_ty_298 = 5;
pub const ETHTOOL_A_FEC_STAT_MAX: _bindgen_ty_298 = 4;
pub type _bindgen_ty_298 = ffi::c_uint;
pub const ETHTOOL_A_FEC_UNSPEC: _bindgen_ty_299 = 0;
pub const ETHTOOL_A_FEC_HEADER: _bindgen_ty_299 = 1;
pub const ETHTOOL_A_FEC_MODES: _bindgen_ty_299 = 2;
pub const ETHTOOL_A_FEC_AUTO: _bindgen_ty_299 = 3;
pub const ETHTOOL_A_FEC_ACTIVE: _bindgen_ty_299 = 4;
pub const ETHTOOL_A_FEC_STATS: _bindgen_ty_299 = 5;
pub const __ETHTOOL_A_FEC_CNT: _bindgen_ty_299 = 6;
pub const ETHTOOL_A_FEC_MAX: _bindgen_ty_299 = 5;
pub type _bindgen_ty_299 = ffi::c_uint;
pub const ETHTOOL_A_MODULE_EEPROM_UNSPEC: _bindgen_ty_300 = 0;
pub const ETHTOOL_A_MODULE_EEPROM_HEADER: _bindgen_ty_300 = 1;
pub const ETHTOOL_A_MODULE_EEPROM_OFFSET: _bindgen_ty_300 = 2;
pub const ETHTOOL_A_MODULE_EEPROM_LENGTH: _bindgen_ty_300 = 3;
pub const ETHTOOL_A_MODULE_EEPROM_PAGE: _bindgen_ty_300 = 4;
pub const ETHTOOL_A_MODULE_EEPROM_BANK: _bindgen_ty_300 = 5;
pub const ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS: _bindgen_ty_300 = 6;
pub const ETHTOOL_A_MODULE_EEPROM_DATA: _bindgen_ty_300 = 7;
pub const __ETHTOOL_A_MODULE_EEPROM_CNT: _bindgen_ty_300 = 8;
pub const ETHTOOL_A_MODULE_EEPROM_MAX: _bindgen_ty_300 = 7;
pub type _bindgen_ty_300 = ffi::c_uint;
pub const ETHTOOL_A_STATS_GRP_UNSPEC: _bindgen_ty_301 = 0;
pub const ETHTOOL_A_STATS_GRP_PAD: _bindgen_ty_301 = 1;
pub const ETHTOOL_A_STATS_GRP_ID: _bindgen_ty_301 = 2;
pub const ETHTOOL_A_STATS_GRP_SS_ID: _bindgen_ty_301 = 3;
pub const ETHTOOL_A_STATS_GRP_STAT: _bindgen_ty_301 = 4;
pub const ETHTOOL_A_STATS_GRP_HIST_RX: _bindgen_ty_301 = 5;
pub const ETHTOOL_A_STATS_GRP_HIST_TX: _bindgen_ty_301 = 6;
pub const ETHTOOL_A_STATS_GRP_HIST_BKT_LOW: _bindgen_ty_301 = 7;
pub const ETHTOOL_A_STATS_GRP_HIST_BKT_HI: _bindgen_ty_301 = 8;
pub const ETHTOOL_A_STATS_GRP_HIST_VAL: _bindgen_ty_301 = 9;
pub const __ETHTOOL_A_STATS_GRP_CNT: _bindgen_ty_301 = 10;
pub const ETHTOOL_A_STATS_GRP_MAX: _bindgen_ty_301 = 9;
pub type _bindgen_ty_301 = ffi::c_uint;
pub const ETHTOOL_A_STATS_UNSPEC: _bindgen_ty_302 = 0;
pub const ETHTOOL_A_STATS_PAD: _bindgen_ty_302 = 1;
pub const ETHTOOL_A_STATS_HEADER: _bindgen_ty_302 = 2;
pub const ETHTOOL_A_STATS_GROUPS: _bindgen_ty_302 = 3;
pub const ETHTOOL_A_STATS_GRP: _bindgen_ty_302 = 4;
pub const ETHTOOL_A_STATS_SRC: _bindgen_ty_302 = 5;
pub const __ETHTOOL_A_STATS_CNT: _bindgen_ty_302 = 6;
pub const ETHTOOL_A_STATS_MAX: _bindgen_ty_302 = 5;
pub type _bindgen_ty_302 = ffi::c_uint;
pub const ETHTOOL_A_PHC_VCLOCKS_UNSPEC: _bindgen_ty_303 = 0;
pub const ETHTOOL_A_PHC_VCLOCKS_HEADER: _bindgen_ty_303 = 1;
pub const ETHTOOL_A_PHC_VCLOCKS_NUM: _bindgen_ty_303 = 2;
pub const ETHTOOL_A_PHC_VCLOCKS_INDEX: _bindgen_ty_303 = 3;
pub const __ETHTOOL_A_PHC_VCLOCKS_CNT: _bindgen_ty_303 = 4;
pub const ETHTOOL_A_PHC_VCLOCKS_MAX: _bindgen_ty_303 = 3;
pub type _bindgen_ty_303 = ffi::c_uint;
pub const ETHTOOL_A_MODULE_UNSPEC: _bindgen_ty_304 = 0;
pub const ETHTOOL_A_MODULE_HEADER: _bindgen_ty_304 = 1;
pub const ETHTOOL_A_MODULE_POWER_MODE_POLICY: _bindgen_ty_304 = 2;
pub const ETHTOOL_A_MODULE_POWER_MODE: _bindgen_ty_304 = 3;
pub const __ETHTOOL_A_MODULE_CNT: _bindgen_ty_304 = 4;
pub const ETHTOOL_A_MODULE_MAX: _bindgen_ty_304 = 3;
pub type _bindgen_ty_304 = ffi::c_uint;
pub const ETHTOOL_A_C33_PSE_PW_LIMIT_UNSPEC: _bindgen_ty_305 = 0;
pub const ETHTOOL_A_C33_PSE_PW_LIMIT_MIN: _bindgen_ty_305 = 1;
pub const ETHTOOL_A_C33_PSE_PW_LIMIT_MAX: _bindgen_ty_305 = 2;
pub const __ETHTOOL_A_C33_PSE_PW_LIMIT_CNT: _bindgen_ty_305 = 3;
pub const __ETHTOOL_A_C33_PSE_PW_LIMIT_MAX: _bindgen_ty_305 = 2;
pub type _bindgen_ty_305 = ffi::c_uint;
pub const ETHTOOL_A_PSE_UNSPEC: _bindgen_ty_306 = 0;
pub const ETHTOOL_A_PSE_HEADER: _bindgen_ty_306 = 1;
pub const ETHTOOL_A_PODL_PSE_ADMIN_STATE: _bindgen_ty_306 = 2;
pub const ETHTOOL_A_PODL_PSE_ADMIN_CONTROL: _bindgen_ty_306 = 3;
pub const ETHTOOL_A_PODL_PSE_PW_D_STATUS: _bindgen_ty_306 = 4;
pub const ETHTOOL_A_C33_PSE_ADMIN_STATE: _bindgen_ty_306 = 5;
pub const ETHTOOL_A_C33_PSE_ADMIN_CONTROL: _bindgen_ty_306 = 6;
pub const ETHTOOL_A_C33_PSE_PW_D_STATUS: _bindgen_ty_306 = 7;
pub const ETHTOOL_A_C33_PSE_PW_CLASS: _bindgen_ty_306 = 8;
pub const ETHTOOL_A_C33_PSE_ACTUAL_PW: _bindgen_ty_306 = 9;
pub const ETHTOOL_A_C33_PSE_EXT_STATE: _bindgen_ty_306 = 10;
pub const ETHTOOL_A_C33_PSE_EXT_SUBSTATE: _bindgen_ty_306 = 11;
pub const ETHTOOL_A_C33_PSE_AVAIL_PW_LIMIT: _bindgen_ty_306 = 12;
pub const ETHTOOL_A_C33_PSE_PW_LIMIT_RANGES: _bindgen_ty_306 = 13;
pub const ETHTOOL_A_PSE_PW_D_ID: _bindgen_ty_306 = 14;
pub const ETHTOOL_A_PSE_PRIO_MAX: _bindgen_ty_306 = 15;
pub const ETHTOOL_A_PSE_PRIO: _bindgen_ty_306 = 16;
pub const __ETHTOOL_A_PSE_CNT: _bindgen_ty_306 = 17;
pub const ETHTOOL_A_PSE_MAX: _bindgen_ty_306 = 16;
pub type _bindgen_ty_306 = ffi::c_uint;
pub const ETHTOOL_A_FLOW_ETHER: _bindgen_ty_307 = 1;
pub const ETHTOOL_A_FLOW_IP4: _bindgen_ty_307 = 2;
pub const ETHTOOL_A_FLOW_IP6: _bindgen_ty_307 = 3;
pub const ETHTOOL_A_FLOW_TCP4: _bindgen_ty_307 = 4;
pub const ETHTOOL_A_FLOW_TCP6: _bindgen_ty_307 = 5;
pub const ETHTOOL_A_FLOW_UDP4: _bindgen_ty_307 = 6;
pub const ETHTOOL_A_FLOW_UDP6: _bindgen_ty_307 = 7;
pub const ETHTOOL_A_FLOW_SCTP4: _bindgen_ty_307 = 8;
pub const ETHTOOL_A_FLOW_SCTP6: _bindgen_ty_307 = 9;
pub const ETHTOOL_A_FLOW_AH4: _bindgen_ty_307 = 10;
pub const ETHTOOL_A_FLOW_AH6: _bindgen_ty_307 = 11;
pub const ETHTOOL_A_FLOW_ESP4: _bindgen_ty_307 = 12;
pub const ETHTOOL_A_FLOW_ESP6: _bindgen_ty_307 = 13;
pub const ETHTOOL_A_FLOW_AH_ESP4: _bindgen_ty_307 = 14;
pub const ETHTOOL_A_FLOW_AH_ESP6: _bindgen_ty_307 = 15;
pub const ETHTOOL_A_FLOW_GTPU4: _bindgen_ty_307 = 16;
pub const ETHTOOL_A_FLOW_GTPU6: _bindgen_ty_307 = 17;
pub const ETHTOOL_A_FLOW_GTPC4: _bindgen_ty_307 = 18;
pub const ETHTOOL_A_FLOW_GTPC6: _bindgen_ty_307 = 19;
pub const ETHTOOL_A_FLOW_GTPC_TEID4: _bindgen_ty_307 = 20;
pub const ETHTOOL_A_FLOW_GTPC_TEID6: _bindgen_ty_307 = 21;
pub const ETHTOOL_A_FLOW_GTPU_EH4: _bindgen_ty_307 = 22;
pub const ETHTOOL_A_FLOW_GTPU_EH6: _bindgen_ty_307 = 23;
pub const ETHTOOL_A_FLOW_GTPU_UL4: _bindgen_ty_307 = 24;
pub const ETHTOOL_A_FLOW_GTPU_UL6: _bindgen_ty_307 = 25;
pub const ETHTOOL_A_FLOW_GTPU_DL4: _bindgen_ty_307 = 26;
pub const ETHTOOL_A_FLOW_GTPU_DL6: _bindgen_ty_307 = 27;
pub const __ETHTOOL_A_FLOW_CNT: _bindgen_ty_307 = 28;
pub const ETHTOOL_A_FLOW_MAX: _bindgen_ty_307 = 27;
pub type _bindgen_ty_307 = ffi::c_uint;
pub const ETHTOOL_A_RSS_UNSPEC: _bindgen_ty_308 = 0;
pub const ETHTOOL_A_RSS_HEADER: _bindgen_ty_308 = 1;
pub const ETHTOOL_A_RSS_CONTEXT: _bindgen_ty_308 = 2;
pub const ETHTOOL_A_RSS_HFUNC: _bindgen_ty_308 = 3;
pub const ETHTOOL_A_RSS_INDIR: _bindgen_ty_308 = 4;
pub const ETHTOOL_A_RSS_HKEY: _bindgen_ty_308 = 5;
pub const ETHTOOL_A_RSS_INPUT_XFRM: _bindgen_ty_308 = 6;
pub const ETHTOOL_A_RSS_START_CONTEXT: _bindgen_ty_308 = 7;
pub const ETHTOOL_A_RSS_FLOW_HASH: _bindgen_ty_308 = 8;
pub const __ETHTOOL_A_RSS_CNT: _bindgen_ty_308 = 9;
pub const ETHTOOL_A_RSS_MAX: _bindgen_ty_308 = 8;
pub type _bindgen_ty_308 = ffi::c_uint;
pub const ETHTOOL_A_PLCA_UNSPEC: _bindgen_ty_309 = 0;
pub const ETHTOOL_A_PLCA_HEADER: _bindgen_ty_309 = 1;
pub const ETHTOOL_A_PLCA_VERSION: _bindgen_ty_309 = 2;
pub const ETHTOOL_A_PLCA_ENABLED: _bindgen_ty_309 = 3;
pub const ETHTOOL_A_PLCA_STATUS: _bindgen_ty_309 = 4;
pub const ETHTOOL_A_PLCA_NODE_CNT: _bindgen_ty_309 = 5;
pub const ETHTOOL_A_PLCA_NODE_ID: _bindgen_ty_309 = 6;
pub const ETHTOOL_A_PLCA_TO_TMR: _bindgen_ty_309 = 7;
pub const ETHTOOL_A_PLCA_BURST_CNT: _bindgen_ty_309 = 8;
pub const ETHTOOL_A_PLCA_BURST_TMR: _bindgen_ty_309 = 9;
pub const __ETHTOOL_A_PLCA_CNT: _bindgen_ty_309 = 10;
pub const ETHTOOL_A_PLCA_MAX: _bindgen_ty_309 = 9;
pub type _bindgen_ty_309 = ffi::c_uint;
pub const ETHTOOL_A_MODULE_FW_FLASH_UNSPEC: _bindgen_ty_310 = 0;
pub const ETHTOOL_A_MODULE_FW_FLASH_HEADER: _bindgen_ty_310 = 1;
pub const ETHTOOL_A_MODULE_FW_FLASH_FILE_NAME: _bindgen_ty_310 = 2;
pub const ETHTOOL_A_MODULE_FW_FLASH_PASSWORD: _bindgen_ty_310 = 3;
pub const ETHTOOL_A_MODULE_FW_FLASH_STATUS: _bindgen_ty_310 = 4;
pub const ETHTOOL_A_MODULE_FW_FLASH_STATUS_MSG: _bindgen_ty_310 = 5;
pub const ETHTOOL_A_MODULE_FW_FLASH_DONE: _bindgen_ty_310 = 6;
pub const ETHTOOL_A_MODULE_FW_FLASH_TOTAL: _bindgen_ty_310 = 7;
pub const __ETHTOOL_A_MODULE_FW_FLASH_CNT: _bindgen_ty_310 = 8;
pub const ETHTOOL_A_MODULE_FW_FLASH_MAX: _bindgen_ty_310 = 7;
pub type _bindgen_ty_310 = ffi::c_uint;
pub const ETHTOOL_A_PHY_UNSPEC: _bindgen_ty_311 = 0;
pub const ETHTOOL_A_PHY_HEADER: _bindgen_ty_311 = 1;
pub const ETHTOOL_A_PHY_INDEX: _bindgen_ty_311 = 2;
pub const ETHTOOL_A_PHY_DRVNAME: _bindgen_ty_311 = 3;
pub const ETHTOOL_A_PHY_NAME: _bindgen_ty_311 = 4;
pub const ETHTOOL_A_PHY_UPSTREAM_TYPE: _bindgen_ty_311 = 5;
pub const ETHTOOL_A_PHY_UPSTREAM_INDEX: _bindgen_ty_311 = 6;
pub const ETHTOOL_A_PHY_UPSTREAM_SFP_NAME: _bindgen_ty_311 = 7;
pub const ETHTOOL_A_PHY_DOWNSTREAM_SFP_NAME: _bindgen_ty_311 = 8;
pub const __ETHTOOL_A_PHY_CNT: _bindgen_ty_311 = 9;
pub const ETHTOOL_A_PHY_MAX: _bindgen_ty_311 = 8;
pub type _bindgen_ty_311 = ffi::c_uint;
pub const ETHTOOL_A_TSCONFIG_UNSPEC: _bindgen_ty_312 = 0;
pub const ETHTOOL_A_TSCONFIG_HEADER: _bindgen_ty_312 = 1;
pub const ETHTOOL_A_TSCONFIG_HWTSTAMP_PROVIDER: _bindgen_ty_312 = 2;
pub const ETHTOOL_A_TSCONFIG_TX_TYPES: _bindgen_ty_312 = 3;
pub const ETHTOOL_A_TSCONFIG_RX_FILTERS: _bindgen_ty_312 = 4;
pub const ETHTOOL_A_TSCONFIG_HWTSTAMP_FLAGS: _bindgen_ty_312 = 5;
pub const __ETHTOOL_A_TSCONFIG_CNT: _bindgen_ty_312 = 6;
pub const ETHTOOL_A_TSCONFIG_MAX: _bindgen_ty_312 = 5;
pub type _bindgen_ty_312 = ffi::c_uint;
pub const ETHTOOL_A_PSE_NTF_HEADER: _bindgen_ty_313 = 1;
pub const ETHTOOL_A_PSE_NTF_EVENTS: _bindgen_ty_313 = 2;
pub const __ETHTOOL_A_PSE_NTF_CNT: _bindgen_ty_313 = 3;
pub const ETHTOOL_A_PSE_NTF_MAX: _bindgen_ty_313 = 2;
pub type _bindgen_ty_313 = ffi::c_uint;
pub const ETHTOOL_MSG_USER_NONE: _bindgen_ty_314 = 0;
pub const ETHTOOL_MSG_STRSET_GET: _bindgen_ty_314 = 1;
pub const ETHTOOL_MSG_LINKINFO_GET: _bindgen_ty_314 = 2;
pub const ETHTOOL_MSG_LINKINFO_SET: _bindgen_ty_314 = 3;
pub const ETHTOOL_MSG_LINKMODES_GET: _bindgen_ty_314 = 4;
pub const ETHTOOL_MSG_LINKMODES_SET: _bindgen_ty_314 = 5;
pub const ETHTOOL_MSG_LINKSTATE_GET: _bindgen_ty_314 = 6;
pub const ETHTOOL_MSG_DEBUG_GET: _bindgen_ty_314 = 7;
pub const ETHTOOL_MSG_DEBUG_SET: _bindgen_ty_314 = 8;
pub const ETHTOOL_MSG_WOL_GET: _bindgen_ty_314 = 9;
pub const ETHTOOL_MSG_WOL_SET: _bindgen_ty_314 = 10;
pub const ETHTOOL_MSG_FEATURES_GET: _bindgen_ty_314 = 11;
pub const ETHTOOL_MSG_FEATURES_SET: _bindgen_ty_314 = 12;
pub const ETHTOOL_MSG_PRIVFLAGS_GET: _bindgen_ty_314 = 13;
pub const ETHTOOL_MSG_PRIVFLAGS_SET: _bindgen_ty_314 = 14;
pub const ETHTOOL_MSG_RINGS_GET: _bindgen_ty_314 = 15;
pub const ETHTOOL_MSG_RINGS_SET: _bindgen_ty_314 = 16;
pub const ETHTOOL_MSG_CHANNELS_GET: _bindgen_ty_314 = 17;
pub const ETHTOOL_MSG_CHANNELS_SET: _bindgen_ty_314 = 18;
pub const ETHTOOL_MSG_COALESCE_GET: _bindgen_ty_314 = 19;
pub const ETHTOOL_MSG_COALESCE_SET: _bindgen_ty_314 = 20;
pub const ETHTOOL_MSG_PAUSE_GET: _bindgen_ty_314 = 21;
pub const ETHTOOL_MSG_PAUSE_SET: _bindgen_ty_314 = 22;
pub const ETHTOOL_MSG_EEE_GET: _bindgen_ty_314 = 23;
pub const ETHTOOL_MSG_EEE_SET: _bindgen_ty_314 = 24;
pub const ETHTOOL_MSG_TSINFO_GET: _bindgen_ty_314 = 25;
pub const ETHTOOL_MSG_CABLE_TEST_ACT: _bindgen_ty_314 = 26;
pub const ETHTOOL_MSG_CABLE_TEST_TDR_ACT: _bindgen_ty_314 = 27;
pub const ETHTOOL_MSG_TUNNEL_INFO_GET: _bindgen_ty_314 = 28;
pub const ETHTOOL_MSG_FEC_GET: _bindgen_ty_314 = 29;
pub const ETHTOOL_MSG_FEC_SET: _bindgen_ty_314 = 30;
pub const ETHTOOL_MSG_MODULE_EEPROM_GET: _bindgen_ty_314 = 31;
pub const ETHTOOL_MSG_STATS_GET: _bindgen_ty_314 = 32;
pub const ETHTOOL_MSG_PHC_VCLOCKS_GET: _bindgen_ty_314 = 33;
pub const ETHTOOL_MSG_MODULE_GET: _bindgen_ty_314 = 34;
pub const ETHTOOL_MSG_MODULE_SET: _bindgen_ty_314 = 35;
pub const ETHTOOL_MSG_PSE_GET: _bindgen_ty_314 = 36;
pub const ETHTOOL_MSG_PSE_SET: _bindgen_ty_314 = 37;
pub const ETHTOOL_MSG_RSS_GET: _bindgen_ty_314 = 38;
pub const ETHTOOL_MSG_PLCA_GET_CFG: _bindgen_ty_314 = 39;
pub const ETHTOOL_MSG_PLCA_SET_CFG: _bindgen_ty_314 = 40;
pub const ETHTOOL_MSG_PLCA_GET_STATUS: _bindgen_ty_314 = 41;
pub const ETHTOOL_MSG_MM_GET: _bindgen_ty_314 = 42;
pub const ETHTOOL_MSG_MM_SET: _bindgen_ty_314 = 43;
pub const ETHTOOL_MSG_MODULE_FW_FLASH_ACT: _bindgen_ty_314 = 44;
pub const ETHTOOL_MSG_PHY_GET: _bindgen_ty_314 = 45;
pub const ETHTOOL_MSG_TSCONFIG_GET: _bindgen_ty_314 = 46;
pub const ETHTOOL_MSG_TSCONFIG_SET: _bindgen_ty_314 = 47;
pub const ETHTOOL_MSG_RSS_SET: _bindgen_ty_314 = 48;
pub const ETHTOOL_MSG_RSS_CREATE_ACT: _bindgen_ty_314 = 49;
pub const ETHTOOL_MSG_RSS_DELETE_ACT: _bindgen_ty_314 = 50;
pub const __ETHTOOL_MSG_USER_CNT: _bindgen_ty_314 = 51;
pub const ETHTOOL_MSG_USER_MAX: _bindgen_ty_314 = 50;
pub type _bindgen_ty_314 = ffi::c_uint;
pub const ETHTOOL_MSG_KERNEL_NONE: _bindgen_ty_315 = 0;
pub const ETHTOOL_MSG_STRSET_GET_REPLY: _bindgen_ty_315 = 1;
pub const ETHTOOL_MSG_LINKINFO_GET_REPLY: _bindgen_ty_315 = 2;
pub const ETHTOOL_MSG_LINKINFO_NTF: _bindgen_ty_315 = 3;
pub const ETHTOOL_MSG_LINKMODES_GET_REPLY: _bindgen_ty_315 = 4;
pub const ETHTOOL_MSG_LINKMODES_NTF: _bindgen_ty_315 = 5;
pub const ETHTOOL_MSG_LINKSTATE_GET_REPLY: _bindgen_ty_315 = 6;
pub const ETHTOOL_MSG_DEBUG_GET_REPLY: _bindgen_ty_315 = 7;
pub const ETHTOOL_MSG_DEBUG_NTF: _bindgen_ty_315 = 8;
pub const ETHTOOL_MSG_WOL_GET_REPLY: _bindgen_ty_315 = 9;
pub const ETHTOOL_MSG_WOL_NTF: _bindgen_ty_315 = 10;
pub const ETHTOOL_MSG_FEATURES_GET_REPLY: _bindgen_ty_315 = 11;
pub const ETHTOOL_MSG_FEATURES_SET_REPLY: _bindgen_ty_315 = 12;
pub const ETHTOOL_MSG_FEATURES_NTF: _bindgen_ty_315 = 13;
pub const ETHTOOL_MSG_PRIVFLAGS_GET_REPLY: _bindgen_ty_315 = 14;
pub const ETHTOOL_MSG_PRIVFLAGS_NTF: _bindgen_ty_315 = 15;
pub const ETHTOOL_MSG_RINGS_GET_REPLY: _bindgen_ty_315 = 16;
pub const ETHTOOL_MSG_RINGS_NTF: _bindgen_ty_315 = 17;
pub const ETHTOOL_MSG_CHANNELS_GET_REPLY: _bindgen_ty_315 = 18;
pub const ETHTOOL_MSG_CHANNELS_NTF: _bindgen_ty_315 = 19;
pub const ETHTOOL_MSG_COALESCE_GET_REPLY: _bindgen_ty_315 = 20;
pub const ETHTOOL_MSG_COALESCE_NTF: _bindgen_ty_315 = 21;
pub const ETHTOOL_MSG_PAUSE_GET_REPLY: _bindgen_ty_315 = 22;
pub const ETHTOOL_MSG_PAUSE_NTF: _bindgen_ty_315 = 23;
pub const ETHTOOL_MSG_EEE_GET_REPLY: _bindgen_ty_315 = 24;
pub const ETHTOOL_MSG_EEE_NTF: _bindgen_ty_315 = 25;
pub const ETHTOOL_MSG_TSINFO_GET_REPLY: _bindgen_ty_315 = 26;
pub const ETHTOOL_MSG_CABLE_TEST_NTF: _bindgen_ty_315 = 27;
pub const ETHTOOL_MSG_CABLE_TEST_TDR_NTF: _bindgen_ty_315 = 28;
pub const ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY: _bindgen_ty_315 = 29;
pub const ETHTOOL_MSG_FEC_GET_REPLY: _bindgen_ty_315 = 30;
pub const ETHTOOL_MSG_FEC_NTF: _bindgen_ty_315 = 31;
pub const ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY: _bindgen_ty_315 = 32;
pub const ETHTOOL_MSG_STATS_GET_REPLY: _bindgen_ty_315 = 33;
pub const ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY: _bindgen_ty_315 = 34;
pub const ETHTOOL_MSG_MODULE_GET_REPLY: _bindgen_ty_315 = 35;
pub const ETHTOOL_MSG_MODULE_NTF: _bindgen_ty_315 = 36;
pub const ETHTOOL_MSG_PSE_GET_REPLY: _bindgen_ty_315 = 37;
pub const ETHTOOL_MSG_RSS_GET_REPLY: _bindgen_ty_315 = 38;
pub const ETHTOOL_MSG_PLCA_GET_CFG_REPLY: _bindgen_ty_315 = 39;
pub const ETHTOOL_MSG_PLCA_GET_STATUS_REPLY: _bindgen_ty_315 = 40;
pub const ETHTOOL_MSG_PLCA_NTF: _bindgen_ty_315 = 41;
pub const ETHTOOL_MSG_MM_GET_REPLY: _bindgen_ty_315 = 42;
pub const ETHTOOL_MSG_MM_NTF: _bindgen_ty_315 = 43;
pub const ETHTOOL_MSG_MODULE_FW_FLASH_NTF: _bindgen_ty_315 = 44;
pub const ETHTOOL_MSG_PHY_GET_REPLY: _bindgen_ty_315 = 45;
pub const ETHTOOL_MSG_PHY_NTF: _bindgen_ty_315 = 46;
pub const ETHTOOL_MSG_TSCONFIG_GET_REPLY: _bindgen_ty_315 = 47;
pub const ETHTOOL_MSG_TSCONFIG_SET_REPLY: _bindgen_ty_315 = 48;
pub const ETHTOOL_MSG_PSE_NTF: _bindgen_ty_315 = 49;
pub const ETHTOOL_MSG_RSS_NTF: _bindgen_ty_315 = 50;
pub const ETHTOOL_MSG_RSS_CREATE_ACT_REPLY: _bindgen_ty_315 = 51;
pub const ETHTOOL_MSG_RSS_CREATE_NTF: _bindgen_ty_315 = 52;
pub const ETHTOOL_MSG_RSS_DELETE_NTF: _bindgen_ty_315 = 53;
pub const __ETHTOOL_MSG_KERNEL_CNT: _bindgen_ty_315 = 54;
pub const ETHTOOL_MSG_KERNEL_MAX: _bindgen_ty_315 = 53;
pub type _bindgen_ty_315 = ffi::c_uint;
pub const hwtstamp_provider_qualifier_HWTSTAMP_PROVIDER_QUALIFIER_PRECISE:
    hwtstamp_provider_qualifier = 0;
pub const hwtstamp_provider_qualifier_HWTSTAMP_PROVIDER_QUALIFIER_APPROX:
    hwtstamp_provider_qualifier = 1;
pub const hwtstamp_provider_qualifier_HWTSTAMP_PROVIDER_QUALIFIER_CNT: hwtstamp_provider_qualifier =
    2;
pub type hwtstamp_provider_qualifier = ffi::c_uint;
pub const SOF_TIMESTAMPING_TX_HARDWARE: _bindgen_ty_316 = 1;
pub const SOF_TIMESTAMPING_TX_SOFTWARE: _bindgen_ty_316 = 2;
pub const SOF_TIMESTAMPING_RX_HARDWARE: _bindgen_ty_316 = 4;
pub const SOF_TIMESTAMPING_RX_SOFTWARE: _bindgen_ty_316 = 8;
pub const SOF_TIMESTAMPING_SOFTWARE: _bindgen_ty_316 = 16;
pub const SOF_TIMESTAMPING_SYS_HARDWARE: _bindgen_ty_316 = 32;
pub const SOF_TIMESTAMPING_RAW_HARDWARE: _bindgen_ty_316 = 64;
pub const SOF_TIMESTAMPING_OPT_ID: _bindgen_ty_316 = 128;
pub const SOF_TIMESTAMPING_TX_SCHED: _bindgen_ty_316 = 256;
pub const SOF_TIMESTAMPING_TX_ACK: _bindgen_ty_316 = 512;
pub const SOF_TIMESTAMPING_OPT_CMSG: _bindgen_ty_316 = 1024;
pub const SOF_TIMESTAMPING_OPT_TSONLY: _bindgen_ty_316 = 2048;
pub const SOF_TIMESTAMPING_OPT_STATS: _bindgen_ty_316 = 4096;
pub const SOF_TIMESTAMPING_OPT_PKTINFO: _bindgen_ty_316 = 8192;
pub const SOF_TIMESTAMPING_OPT_TX_SWHW: _bindgen_ty_316 = 16384;
pub const SOF_TIMESTAMPING_BIND_PHC: _bindgen_ty_316 = 32768;
pub const SOF_TIMESTAMPING_OPT_ID_TCP: _bindgen_ty_316 = 65536;
pub const SOF_TIMESTAMPING_OPT_RX_FILTER: _bindgen_ty_316 = 131072;
pub const SOF_TIMESTAMPING_TX_COMPLETION: _bindgen_ty_316 = 262144;
pub const SOF_TIMESTAMPING_LAST: _bindgen_ty_316 = 262144;
pub const SOF_TIMESTAMPING_MASK: _bindgen_ty_316 = 524287;
pub type _bindgen_ty_316 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct so_timestamping {
    pub flags: ffi::c_int,
    pub bind_phc: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hwtstamp_config {
    pub flags: ffi::c_int,
    pub tx_type: ffi::c_int,
    pub rx_filter: ffi::c_int,
}
pub const hwtstamp_flags_HWTSTAMP_FLAG_BONDED_PHC_INDEX: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_LAST: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_MASK: hwtstamp_flags = 1;
pub type hwtstamp_flags = ffi::c_uint;
pub const hwtstamp_tx_types_HWTSTAMP_TX_OFF: hwtstamp_tx_types = 0;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ON: hwtstamp_tx_types = 1;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_SYNC: hwtstamp_tx_types = 2;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_P2P: hwtstamp_tx_types = 3;
pub const hwtstamp_tx_types___HWTSTAMP_TX_CNT: hwtstamp_tx_types = 4;
pub type hwtstamp_tx_types = ffi::c_uint;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NONE: hwtstamp_rx_filters = 0;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_ALL: hwtstamp_rx_filters = 1;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_SOME: hwtstamp_rx_filters = 2;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_EVENT: hwtstamp_rx_filters = 3;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_SYNC: hwtstamp_rx_filters = 4;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ: hwtstamp_rx_filters = 5;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_EVENT: hwtstamp_rx_filters = 6;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_SYNC: hwtstamp_rx_filters = 7;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ: hwtstamp_rx_filters = 8;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_EVENT: hwtstamp_rx_filters = 9;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_SYNC: hwtstamp_rx_filters = 10;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ: hwtstamp_rx_filters = 11;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_EVENT: hwtstamp_rx_filters = 12;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_SYNC: hwtstamp_rx_filters = 13;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_DELAY_REQ: hwtstamp_rx_filters = 14;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NTP_ALL: hwtstamp_rx_filters = 15;
pub const hwtstamp_rx_filters___HWTSTAMP_FILTER_CNT: hwtstamp_rx_filters = 16;
pub type hwtstamp_rx_filters = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_ts_pktinfo {
    pub if_index: __u32,
    pub pkt_length: __u32,
    pub reserved: [__u32; 2usize],
}
pub const txtime_flags_SOF_TXTIME_DEADLINE_MODE: txtime_flags = 1;
pub const txtime_flags_SOF_TXTIME_REPORT_ERRORS: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_LAST: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_MASK: txtime_flags = 3;
pub type txtime_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_txtime {
    pub clockid: __kernel_clockid_t,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_ethtool_rx_flow_spec {
    pub flow_type: u32_,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: compat_u64,
    pub location: u32_,
}
impl Default for compat_ethtool_rx_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct compat_ethtool_rxnfc {
    pub cmd: u32_,
    pub flow_type: u32_,
    pub data: compat_u64,
    pub fs: compat_ethtool_rx_flow_spec,
    pub rule_cnt: u32_,
    pub rule_locs: __IncompleteArrayField<u32_>,
}
impl Default for compat_ethtool_rxnfc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ethtool_phys_id_state_ETHTOOL_ID_INACTIVE: ethtool_phys_id_state = 0;
pub const ethtool_phys_id_state_ETHTOOL_ID_ACTIVE: ethtool_phys_id_state = 1;
pub const ethtool_phys_id_state_ETHTOOL_ID_ON: ethtool_phys_id_state = 2;
pub const ethtool_phys_id_state_ETHTOOL_ID_OFF: ethtool_phys_id_state = 3;
pub type ethtool_phys_id_state = ffi::c_uint;
pub const ETH_RSS_HASH_TOP_BIT: _bindgen_ty_317 = 0;
pub const ETH_RSS_HASH_XOR_BIT: _bindgen_ty_317 = 1;
pub const ETH_RSS_HASH_CRC32_BIT: _bindgen_ty_317 = 2;
pub const ETH_RSS_HASH_FUNCS_COUNT: _bindgen_ty_317 = 3;
pub type _bindgen_ty_317 = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_ethtool_ringparam {
    pub rx_buf_len: u32_,
    pub tcp_data_split: u8_,
    pub tx_push: u8_,
    pub rx_push: u8_,
    pub cqe_size: u32_,
    pub tx_push_buf_len: u32_,
    pub tx_push_buf_max_len: u32_,
    pub hds_thresh: u32_,
    pub hds_thresh_max: u32_,
}
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_RX_BUF_LEN: ethtool_supported_ring_param =
    1;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_CQE_SIZE: ethtool_supported_ring_param = 2;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TX_PUSH: ethtool_supported_ring_param = 4;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_RX_PUSH: ethtool_supported_ring_param = 8;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TX_PUSH_BUF_LEN:
    ethtool_supported_ring_param = 16;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TCP_DATA_SPLIT:
    ethtool_supported_ring_param = 32;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_HDS_THRS: ethtool_supported_ring_param = 64;
pub type ethtool_supported_ring_param = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_link_ext_state_info {
    pub link_ext_state: ethtool_link_ext_state,
    pub __bindgen_anon_1: ethtool_link_ext_state_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_link_ext_state_info__bindgen_ty_1 {
    pub autoneg: ethtool_link_ext_substate_autoneg,
    pub link_training: ethtool_link_ext_substate_link_training,
    pub link_logical_mismatch: ethtool_link_ext_substate_link_logical_mismatch,
    pub bad_signal_integrity: ethtool_link_ext_substate_bad_signal_integrity,
    pub cable_issue: ethtool_link_ext_substate_cable_issue,
    pub module: ethtool_link_ext_substate_module,
    pub __link_ext_substate: u32_,
}
impl Default for ethtool_link_ext_state_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_link_ext_state_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_ext_stats {
    pub link_down_events: u64_,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct ethtool_rxfh_context {
    pub indir_size: u32_,
    pub key_size: u32_,
    pub priv_size: u16_,
    pub hfunc: u8_,
    pub input_xfrm: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub key_off: u32_,
    pub __bindgen_padding_0: [u8; 4usize],
    pub data: __IncompleteArrayField<u8_>,
}
impl ethtool_rxfh_context {
    #[inline]
    pub fn indir_configured(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indir_configured(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn indir_configured_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_indir_configured_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn key_configured(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_key_configured(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_configured_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_key_configured_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        indir_configured: u8_,
        key_configured: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let indir_configured: u8 = unsafe { ::core::mem::transmute(indir_configured) };
            indir_configured as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let key_configured: u8 = unsafe { ::core::mem::transmute(key_configured) };
            key_configured as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct link_mode_info {
    pub speed: ffi::c_int,
    pub lanes: u8_,
    pub duplex: u8_,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_ksettings {
    pub base: ethtool_link_settings,
    pub link_modes: ethtool_link_ksettings__bindgen_ty_1,
    pub lanes: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_ksettings__bindgen_ty_1 {
    pub supported: [ffi::c_ulong; 2usize],
    pub advertising: [ffi::c_ulong; 2usize],
    pub lp_advertising: [ffi::c_ulong; 2usize],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_keee {
    pub supported: [ffi::c_ulong; 2usize],
    pub advertised: [ffi::c_ulong; 2usize],
    pub lp_advertised: [ffi::c_ulong; 2usize],
    pub tx_lpi_timer: u32_,
    pub tx_lpi_enabled: bool_,
    pub eee_active: bool_,
    pub eee_enabled: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_ethtool_coalesce {
    pub use_cqe_mode_tx: u8_,
    pub use_cqe_mode_rx: u8_,
    pub tx_aggr_max_bytes: u32_,
    pub tx_aggr_max_frames: u32_,
    pub tx_aggr_time_usecs: u32_,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_mac_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_mac_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_mac_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_1 {
    pub FramesTransmittedOK: u64_,
    pub SingleCollisionFrames: u64_,
    pub MultipleCollisionFrames: u64_,
    pub FramesReceivedOK: u64_,
    pub FrameCheckSequenceErrors: u64_,
    pub AlignmentErrors: u64_,
    pub OctetsTransmittedOK: u64_,
    pub FramesWithDeferredXmissions: u64_,
    pub LateCollisions: u64_,
    pub FramesAbortedDueToXSColls: u64_,
    pub FramesLostDueToIntMACXmitError: u64_,
    pub CarrierSenseErrors: u64_,
    pub OctetsReceivedOK: u64_,
    pub FramesLostDueToIntMACRcvError: u64_,
    pub MulticastFramesXmittedOK: u64_,
    pub BroadcastFramesXmittedOK: u64_,
    pub FramesWithExcessiveDeferral: u64_,
    pub MulticastFramesReceivedOK: u64_,
    pub BroadcastFramesReceivedOK: u64_,
    pub InRangeLengthErrors: u64_,
    pub OutOfRangeLengthField: u64_,
    pub FrameTooLongErrors: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_2 {
    pub FramesTransmittedOK: u64_,
    pub SingleCollisionFrames: u64_,
    pub MultipleCollisionFrames: u64_,
    pub FramesReceivedOK: u64_,
    pub FrameCheckSequenceErrors: u64_,
    pub AlignmentErrors: u64_,
    pub OctetsTransmittedOK: u64_,
    pub FramesWithDeferredXmissions: u64_,
    pub LateCollisions: u64_,
    pub FramesAbortedDueToXSColls: u64_,
    pub FramesLostDueToIntMACXmitError: u64_,
    pub CarrierSenseErrors: u64_,
    pub OctetsReceivedOK: u64_,
    pub FramesLostDueToIntMACRcvError: u64_,
    pub MulticastFramesXmittedOK: u64_,
    pub BroadcastFramesXmittedOK: u64_,
    pub FramesWithExcessiveDeferral: u64_,
    pub MulticastFramesReceivedOK: u64_,
    pub BroadcastFramesReceivedOK: u64_,
    pub InRangeLengthErrors: u64_,
    pub OutOfRangeLengthField: u64_,
    pub FrameTooLongErrors: u64_,
}
impl Default for ethtool_eth_mac_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_mac_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_phy_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_phy_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_phy_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_1 {
    pub SymbolErrorDuringCarrier: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_2 {
    pub SymbolErrorDuringCarrier: u64_,
}
impl Default for ethtool_eth_phy_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_phy_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_phy_stats {
    pub rx_packets: u64_,
    pub rx_bytes: u64_,
    pub rx_errors: u64_,
    pub tx_packets: u64_,
    pub tx_bytes: u64_,
    pub tx_errors: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_ctrl_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_ctrl_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_ctrl_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_1 {
    pub MACControlFramesTransmitted: u64_,
    pub MACControlFramesReceived: u64_,
    pub UnsupportedOpcodesReceived: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_2 {
    pub MACControlFramesTransmitted: u64_,
    pub MACControlFramesReceived: u64_,
    pub UnsupportedOpcodesReceived: u64_,
}
impl Default for ethtool_eth_ctrl_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_ctrl_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_pause_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_pause_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_pause_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_pause_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_pause_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pause_stats__bindgen_ty_1__bindgen_ty_1 {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pause_stats__bindgen_ty_1__bindgen_ty_2 {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
impl Default for ethtool_pause_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_pause_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fec_stats {
    pub corrected_blocks: ethtool_fec_stats_ethtool_fec_stat,
    pub uncorrectable_blocks: ethtool_fec_stats_ethtool_fec_stat,
    pub corrected_bits: ethtool_fec_stats_ethtool_fec_stat,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fec_stats_ethtool_fec_stat {
    pub total: u64_,
    pub lanes: [u64_; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_hist_range {
    pub low: u16_,
    pub high: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rmon_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_rmon_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rmon_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_1 {
    pub undersize_pkts: u64_,
    pub oversize_pkts: u64_,
    pub fragments: u64_,
    pub jabbers: u64_,
    pub hist: [u64_; 11usize],
    pub hist_tx: [u64_; 11usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_2 {
    pub undersize_pkts: u64_,
    pub oversize_pkts: u64_,
    pub fragments: u64_,
    pub jabbers: u64_,
    pub hist: [u64_; 11usize],
    pub hist_tx: [u64_; 11usize],
}
impl Default for ethtool_rmon_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rmon_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_ts_stats {
    pub __bindgen_anon_1: ethtool_ts_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_ts_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_ts_stats__bindgen_ty_1__bindgen_ty_1,
    pub tx_stats: ethtool_ts_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ts_stats__bindgen_ty_1__bindgen_ty_1 {
    pub pkts: u64_,
    pub onestep_pkts_unconfirmed: u64_,
    pub lost: u64_,
    pub err: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ts_stats__bindgen_ty_1__bindgen_ty_2 {
    pub pkts: u64_,
    pub onestep_pkts_unconfirmed: u64_,
    pub lost: u64_,
    pub err: u64_,
}
impl Default for ethtool_ts_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_ts_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_module_eeprom {
    pub offset: u32_,
    pub length: u32_,
    pub page: u8_,
    pub bank: u8_,
    pub i2c_address: u8_,
    pub data: *mut u8_,
}
impl Default for ethtool_module_eeprom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_module_power_mode_params {
    pub policy: ethtool_module_power_mode_policy,
    pub mode: ethtool_module_power_mode,
}
impl Default for ethtool_module_power_mode_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_mm_state {
    pub verify_time: u32_,
    pub max_verify_time: u32_,
    pub verify_status: ethtool_mm_verify_status,
    pub tx_enabled: bool_,
    pub tx_active: bool_,
    pub pmac_enabled: bool_,
    pub verify_enabled: bool_,
    pub tx_min_frag_size: u32_,
    pub rx_min_frag_size: u32_,
}
impl Default for ethtool_mm_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_mm_cfg {
    pub verify_time: u32_,
    pub verify_enabled: bool_,
    pub tx_enabled: bool_,
    pub pmac_enabled: bool_,
    pub tx_min_frag_size: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_mm_stats {
    pub MACMergeFrameAssErrorCount: u64_,
    pub MACMergeFrameSmdErrorCount: u64_,
    pub MACMergeFrameAssOkCount: u64_,
    pub MACMergeFragCountRx: u64_,
    pub MACMergeFragCountTx: u64_,
    pub MACMergeHoldCount: u64_,
}
pub const ethtool_mmsv_event_ETHTOOL_MMSV_LP_SENT_VERIFY_MPACKET: ethtool_mmsv_event = 0;
pub const ethtool_mmsv_event_ETHTOOL_MMSV_LD_SENT_VERIFY_MPACKET: ethtool_mmsv_event = 1;
pub const ethtool_mmsv_event_ETHTOOL_MMSV_LP_SENT_RESPONSE_MPACKET: ethtool_mmsv_event = 2;
pub type ethtool_mmsv_event = ffi::c_uint;
pub const ethtool_mpacket_ETHTOOL_MPACKET_VERIFY: ethtool_mpacket = 0;
pub const ethtool_mpacket_ETHTOOL_MPACKET_RESPONSE: ethtool_mpacket = 1;
pub type ethtool_mpacket = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_mmsv_ops {
    pub configure_tx:
        ::core::option::Option<unsafe extern "C" fn(mmsv: *mut ethtool_mmsv, tx_active: bool_)>,
    pub configure_pmac:
        ::core::option::Option<unsafe extern "C" fn(mmsv: *mut ethtool_mmsv, pmac_enabled: bool_)>,
    pub send_mpacket: ::core::option::Option<
        unsafe extern "C" fn(mmsv: *mut ethtool_mmsv, mpacket: ethtool_mpacket),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_mmsv {
    pub ops: *const ethtool_mmsv_ops,
    pub dev: *mut net_device,
    pub lock: spinlock_t,
    pub status: ethtool_mm_verify_status,
    pub verify_timer: timer_list,
    pub verify_enabled: bool_,
    pub verify_retries: ffi::c_int,
    pub pmac_enabled: bool_,
    pub verify_time: u32_,
    pub tx_enabled: bool_,
}
impl Default for ethtool_mmsv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rxfh_param {
    pub hfunc: u8_,
    pub indir_size: u32_,
    pub indir: *mut u32_,
    pub key_size: u32_,
    pub key: *mut u8_,
    pub rss_context: u32_,
    pub rss_delete: u8_,
    pub input_xfrm: u8_,
}
impl Default for ethtool_rxfh_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rxfh_fields {
    pub data: u32_,
    pub flow_type: u32_,
    pub rss_context: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_ethtool_ts_info {
    pub cmd: u32_,
    pub so_timestamping: u32_,
    pub phc_index: ffi::c_int,
    pub phc_qualifier: hwtstamp_provider_qualifier,
    pub phc_source: hwtstamp_source,
    pub phc_phyindex: ffi::c_int,
    pub tx_types: u32_,
    pub rx_filters: u32_,
}
impl Default for kernel_ethtool_ts_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ops {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub rxfh_indir_space: u32_,
    pub rxfh_key_space: u16_,
    pub rxfh_priv_size: u16_,
    pub rxfh_max_num_contexts: u32_,
    pub supported_coalesce_params: u32_,
    pub supported_ring_params: u32_,
    pub supported_hwtstamp_qualifiers: u32_,
    pub get_drvinfo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
    >,
    pub get_regs_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ffi::c_int>,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_regs,
            arg3: *mut ffi::c_void,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo) -> ffi::c_int,
    >,
    pub get_msglevel: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_msglevel:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>,
    pub nway_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ffi::c_int>,
    pub get_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_link_ext_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ext_state_info,
        ) -> ffi::c_int,
    >,
    pub get_link_ext_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, stats: *mut ethtool_link_ext_stats),
    >,
    pub get_eeprom_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ffi::c_int>,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ffi::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ffi::c_int,
    >,
    pub get_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub set_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ),
    >,
    pub set_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_pause_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, pause_stats: *mut ethtool_pause_stats),
    >,
    pub get_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
    >,
    pub set_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam) -> ffi::c_int,
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, stringset: u32_, arg2: *mut u8_),
    >,
    pub set_phys_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ethtool_phys_id_state) -> ffi::c_int,
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub get_priv_flags: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_priv_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> ffi::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
            rule_locs: *mut u32_,
        ) -> ffi::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_rxnfc) -> ffi::c_int,
    >,
    pub flash_device: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_flash) -> ffi::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> ffi::c_int,
    >,
    pub get_rxfh_key_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh_indir_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_rxfh_param) -> ffi::c_int,
    >,
    pub set_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxfh_param,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_rxfh_fields: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_rxfh_fields) -> ffi::c_int,
    >,
    pub set_rxfh_fields: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_rxfh_fields,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub create_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            ctx: *mut ethtool_rxfh_context,
            rxfh: *const ethtool_rxfh_param,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub modify_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            ctx: *mut ethtool_rxfh_context,
            rxfh: *const ethtool_rxfh_param,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub remove_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            ctx: *mut ethtool_rxfh_context,
            rss_context: u32_,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
    >,
    pub set_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels) -> ffi::c_int,
    >,
    pub get_dump_flag: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> ffi::c_int,
    >,
    pub get_dump_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
            arg3: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub set_dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> ffi::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut kernel_ethtool_ts_info,
        ) -> ffi::c_int,
    >,
    pub get_ts_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ts_stats: *mut ethtool_ts_stats),
    >,
    pub get_module_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_modinfo) -> ffi::c_int,
    >,
    pub get_module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ffi::c_int,
    >,
    pub get_eee: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, eee: *mut ethtool_keee) -> ffi::c_int,
    >,
    pub set_eee: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, eee: *mut ethtool_keee) -> ffi::c_int,
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub get_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ffi::c_int,
    >,
    pub set_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ffi::c_int,
    >,
    pub get_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ksettings,
        ) -> ffi::c_int,
    >,
    pub set_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_link_ksettings,
        ) -> ffi::c_int,
    >,
    pub get_fec_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, fec_stats: *mut ethtool_fec_stats),
    >,
    pub get_fecparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_fecparam) -> ffi::c_int,
    >,
    pub set_fecparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_fecparam) -> ffi::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub set_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub get_module_eeprom_by_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            page: *const ethtool_module_eeprom,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub set_module_eeprom_by_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            page: *const ethtool_module_eeprom,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_eth_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, phy_stats: *mut ethtool_eth_phy_stats),
    >,
    pub get_eth_mac_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, mac_stats: *mut ethtool_eth_mac_stats),
    >,
    pub get_eth_ctrl_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ctrl_stats: *mut ethtool_eth_ctrl_stats),
    >,
    pub get_rmon_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            rmon_stats: *mut ethtool_rmon_stats,
            ranges: *mut *const ethtool_rmon_hist_range,
        ),
    >,
    pub get_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            params: *mut ethtool_module_power_mode_params,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub set_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            params: *const ethtool_module_power_mode_params,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_mm: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, state: *mut ethtool_mm_state) -> ffi::c_int,
    >,
    pub set_mm: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            cfg: *mut ethtool_mm_cfg,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_mm_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, stats: *mut ethtool_mm_stats),
    >,
}
impl ethtool_ops {
    #[inline]
    pub fn supported_input_xfrm(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_supported_input_xfrm(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn supported_input_xfrm_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_supported_input_xfrm_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cap_link_lanes_supported(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_link_lanes_supported(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cap_link_lanes_supported_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cap_link_lanes_supported_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxfh_per_ctx_fields(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfh_per_ctx_fields(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxfh_per_ctx_fields_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxfh_per_ctx_fields_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxfh_per_ctx_key(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfh_per_ctx_key(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxfh_per_ctx_key_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxfh_per_ctx_key_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cap_rss_rxnfc_adds(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_rss_rxnfc_adds(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cap_rss_rxnfc_adds_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cap_rss_rxnfc_adds_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported_input_xfrm: u32_,
        cap_link_lanes_supported: u32_,
        rxfh_per_ctx_fields: u32_,
        rxfh_per_ctx_key: u32_,
        cap_rss_rxnfc_adds: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let supported_input_xfrm: u32 = unsafe { ::core::mem::transmute(supported_input_xfrm) };
            supported_input_xfrm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cap_link_lanes_supported: u32 =
                unsafe { ::core::mem::transmute(cap_link_lanes_supported) };
            cap_link_lanes_supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rxfh_per_ctx_fields: u32 = unsafe { ::core::mem::transmute(rxfh_per_ctx_fields) };
            rxfh_per_ctx_fields as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rxfh_per_ctx_key: u32 = unsafe { ::core::mem::transmute(rxfh_per_ctx_key) };
            rxfh_per_ctx_key as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cap_rss_rxnfc_adds: u32 = unsafe { ::core::mem::transmute(cap_rss_rxnfc_adds) };
            cap_rss_rxnfc_adds as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
pub struct ethtool_rx_flow_rule {
    pub rule: *mut flow_rule,
    pub priv_: __IncompleteArrayField<ffi::c_ulong>,
}
impl Default for ethtool_rx_flow_rule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec_input {
    pub fs: *const ethtool_rx_flow_spec,
    pub rss_ctx: u32_,
}
impl Default for ethtool_rx_flow_spec_input {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_netdev_state {
    pub rss_ctx: xarray,
    pub rss_lock: mutex,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for ethtool_netdev_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ethtool_netdev_state {
    #[inline]
    pub fn wol_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wol_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wol_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn module_fw_flash_in_progress(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_module_fw_flash_in_progress(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn module_fw_flash_in_progress_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_module_fw_flash_in_progress_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wol_enabled: ffi::c_uint,
        module_fw_flash_in_progress: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let module_fw_flash_in_progress: u32 =
                unsafe { ::core::mem::transmute(module_fw_flash_in_progress) };
            module_fw_flash_in_progress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_phy_ops {
    pub get_sset_count:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, data: *mut u8_) -> ffi::c_int,
    >,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            stats: *mut ethtool_stats,
            data: *mut u64_,
        ) -> ffi::c_int,
    >,
    pub get_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_cfg: *mut phy_plca_cfg) -> ffi::c_int,
    >,
    pub set_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            plca_cfg: *const phy_plca_cfg,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub get_plca_status: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_st: *mut phy_plca_status) -> ffi::c_int,
    >,
    pub start_cable_test: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, extack: *mut netlink_ext_ack) -> ffi::c_int,
    >,
    pub start_cable_test_tdr: ::core::option::Option<
        unsafe extern "C" fn(
            phydev: *mut phy_device,
            extack: *mut netlink_ext_ack,
            config: *const phy_tdr_config,
        ) -> ffi::c_int,
    >,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_forced_speed_map {
    pub speed: u32_,
    pub caps: [ffi::c_ulong; 2usize],
    pub cap_arr: *const u32_,
    pub arr_size: u32_,
}
impl Default for ethtool_forced_speed_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct firmware {
    pub size: usize,
    pub data: *const u8_,
    pub priv_: *mut ffi::c_void,
}
impl Default for firmware {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const fw_upload_err_FW_UPLOAD_ERR_NONE: fw_upload_err = 0;
pub const fw_upload_err_FW_UPLOAD_ERR_HW_ERROR: fw_upload_err = 1;
pub const fw_upload_err_FW_UPLOAD_ERR_TIMEOUT: fw_upload_err = 2;
pub const fw_upload_err_FW_UPLOAD_ERR_CANCELED: fw_upload_err = 3;
pub const fw_upload_err_FW_UPLOAD_ERR_BUSY: fw_upload_err = 4;
pub const fw_upload_err_FW_UPLOAD_ERR_INVALID_SIZE: fw_upload_err = 5;
pub const fw_upload_err_FW_UPLOAD_ERR_RW_ERROR: fw_upload_err = 6;
pub const fw_upload_err_FW_UPLOAD_ERR_WEAROUT: fw_upload_err = 7;
pub const fw_upload_err_FW_UPLOAD_ERR_FW_INVALID: fw_upload_err = 8;
pub const fw_upload_err_FW_UPLOAD_ERR_MAX: fw_upload_err = 9;
pub type fw_upload_err = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fw_upload {
    pub dd_handle: *mut ffi::c_void,
    pub priv_: *mut ffi::c_void,
}
impl Default for fw_upload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fw_upload_ops {
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(
            fw_upload: *mut fw_upload,
            data: *const u8_,
            size: u32_,
        ) -> fw_upload_err,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            fw_upload: *mut fw_upload,
            data: *const u8_,
            offset: u32_,
            size: u32_,
            written: *mut u32_,
        ) -> fw_upload_err,
    >,
    pub poll_complete:
        ::core::option::Option<unsafe extern "C" fn(fw_upload: *mut fw_upload) -> fw_upload_err>,
    pub cancel: ::core::option::Option<unsafe extern "C" fn(fw_upload: *mut fw_upload)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(fw_upload: *mut fw_upload)>,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mii_ioctl_data {
    pub phy_id: __u16,
    pub reg_num: __u16,
    pub val_in: __u16,
    pub val_out: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_if_info {
    pub phy_id: ffi::c_int,
    pub advertising: ffi::c_int,
    pub phy_id_mask: ffi::c_int,
    pub reg_num_mask: ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dev: *mut net_device,
    pub mdio_read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            phy_id: ffi::c_int,
            location: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub mdio_write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            phy_id: ffi::c_int,
            location: ffi::c_int,
            val: ffi::c_int,
        ),
    >,
}
impl Default for mii_if_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl mii_if_info {
    #[inline]
    pub fn full_duplex(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_full_duplex(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn full_duplex_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_full_duplex_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn force_media(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_media(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_media_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_force_media_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn supports_gmii(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_gmii(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn supports_gmii_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_supports_gmii_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        full_duplex: ffi::c_uint,
        force_media: ffi::c_uint,
        supports_gmii: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let full_duplex: u32 = unsafe { ::core::mem::transmute(full_duplex) };
            full_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_media: u32 = unsafe { ::core::mem::transmute(force_media) };
            force_media as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supports_gmii: u32 = unsafe { ::core::mem::transmute(supports_gmii) };
            supports_gmii as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reset_control {
    _unused: [u8; 0],
}
pub const mdio_mutex_lock_class_MDIO_MUTEX_NORMAL: mdio_mutex_lock_class = 0;
pub const mdio_mutex_lock_class_MDIO_MUTEX_MUX: mdio_mutex_lock_class = 1;
pub const mdio_mutex_lock_class_MDIO_MUTEX_NESTED: mdio_mutex_lock_class = 2;
pub type mdio_mutex_lock_class = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_device {
    pub dev: device,
    pub bus: *mut mii_bus,
    pub modalias: [ffi::c_char; 32usize],
    pub bus_match: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *const device_driver) -> ffi::c_int,
    >,
    pub device_free: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub device_remove: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub addr: ffi::c_int,
    pub flags: ffi::c_int,
    pub reset_state: ffi::c_int,
    pub reset_gpio: *mut gpio_desc,
    pub reset_ctrl: *mut reset_control,
    pub reset_assert_delay: ffi::c_uint,
    pub reset_deassert_delay: ffi::c_uint,
}
impl Default for mdio_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_driver_common {
    pub driver: device_driver,
    pub flags: ffi::c_int,
}
impl Default for mdio_driver_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_driver {
    pub mdiodrv: mdio_driver_common,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device) -> ffi::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
}
impl Default for mdio_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_if_info {
    pub prtad: ffi::c_int,
    pub mmds: u32_,
    pub mode_support: ffi::c_uint,
    pub dev: *mut net_device,
    pub mdio_read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            prtad: ffi::c_int,
            devad: ffi::c_int,
            addr: u16_,
        ) -> ffi::c_int,
    >,
    pub mdio_write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            prtad: ffi::c_int,
            devad: ffi::c_int,
            addr: u16_,
            val: u16_,
        ) -> ffi::c_int,
    >,
}
impl Default for mdio_if_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct miscdevice {
    pub minor: ffi::c_int,
    pub name: *const ffi::c_char,
    pub fops: *const file_operations,
    pub list: list_head,
    pub parent: *mut device,
    pub this_device: *mut device,
    pub groups: *mut *const attribute_group,
    pub nodename: *const ffi::c_char,
    pub mode: umode_t,
}
impl Default for miscdevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const msi_domain_ids_MSI_DEFAULT_DOMAIN: msi_domain_ids = 0;
pub const msi_domain_ids_MSI_MAX_DEVICE_IRQDOMAINS: msi_domain_ids = 1;
pub type msi_domain_ids = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_instance_cookie {
    pub value: u64_,
    pub ptr: *mut ffi::c_void,
}
impl Default for msi_instance_cookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msi_map {
    pub index: ffi::c_int,
    pub virq: ffi::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_slot {
    pub bus: *mut pci_bus,
    pub list: list_head,
    pub hotplug: *mut hotplug_slot,
    pub number: ffi::c_uchar,
    pub kobj: kobject,
}
impl Default for pci_slot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pci_mmap_state_pci_mmap_io: pci_mmap_state = 0;
pub const pci_mmap_state_pci_mmap_mem: pci_mmap_state = 1;
pub type pci_mmap_state = ffi::c_uint;
pub const PCI_STD_RESOURCES: _bindgen_ty_318 = 0;
pub const PCI_STD_RESOURCE_END: _bindgen_ty_318 = 5;
pub const PCI_ROM_RESOURCE: _bindgen_ty_318 = 6;
pub const PCI_BRIDGE_RESOURCES: _bindgen_ty_318 = 7;
pub const PCI_BRIDGE_RESOURCE_END: _bindgen_ty_318 = 10;
pub const PCI_NUM_RESOURCES: _bindgen_ty_318 = 11;
pub const DEVICE_COUNT_RESOURCE: _bindgen_ty_318 = 11;
pub type _bindgen_ty_318 = ffi::c_uint;
pub const pci_interrupt_pin_PCI_INTERRUPT_UNKNOWN: pci_interrupt_pin = 0;
pub const pci_interrupt_pin_PCI_INTERRUPT_INTA: pci_interrupt_pin = 1;
pub const pci_interrupt_pin_PCI_INTERRUPT_INTB: pci_interrupt_pin = 2;
pub const pci_interrupt_pin_PCI_INTERRUPT_INTC: pci_interrupt_pin = 3;
pub const pci_interrupt_pin_PCI_INTERRUPT_INTD: pci_interrupt_pin = 4;
pub type pci_interrupt_pin = ffi::c_uint;
pub type pci_power_t = ffi::c_int;

pub type pci_channel_state_t = ffi::c_uint;
pub const pci_channel_io_normal: _bindgen_ty_319 = 1;
pub const pci_channel_io_frozen: _bindgen_ty_319 = 2;
pub const pci_channel_io_perm_failure: _bindgen_ty_319 = 3;
pub type _bindgen_ty_319 = ffi::c_uint;
pub type pcie_reset_state_t = ffi::c_uint;
pub const pcie_reset_state_pcie_deassert_reset: pcie_reset_state = 1;
pub const pcie_reset_state_pcie_warm_reset: pcie_reset_state = 2;
pub const pcie_reset_state_pcie_hot_reset: pcie_reset_state = 3;
pub type pcie_reset_state = ffi::c_uint;
pub type pci_dev_flags_t = ffi::c_ushort;
pub const pci_dev_flags_PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG: pci_dev_flags = 1;
pub const pci_dev_flags_PCI_DEV_FLAGS_NO_D3: pci_dev_flags = 2;
pub const pci_dev_flags_PCI_DEV_FLAGS_ASSIGNED: pci_dev_flags = 4;
pub const pci_dev_flags_PCI_DEV_FLAGS_ACS_ENABLED_QUIRK: pci_dev_flags = 8;
pub const pci_dev_flags_PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS: pci_dev_flags = 32;
pub const pci_dev_flags_PCI_DEV_FLAGS_NO_BUS_RESET: pci_dev_flags = 64;
pub const pci_dev_flags_PCI_DEV_FLAGS_NO_PM_RESET: pci_dev_flags = 128;
pub const pci_dev_flags_PCI_DEV_FLAGS_VPD_REF_F0: pci_dev_flags = 256;
pub const pci_dev_flags_PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT: pci_dev_flags = 512;
pub const pci_dev_flags_PCI_DEV_FLAGS_NO_FLR_RESET: pci_dev_flags = 1024;
pub const pci_dev_flags_PCI_DEV_FLAGS_NO_RELAXED_ORDERING: pci_dev_flags = 2048;
pub const pci_dev_flags_PCI_DEV_FLAGS_HAS_MSI_MASKING: pci_dev_flags = 4096;
pub const pci_dev_flags_PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST: pci_dev_flags = 8192;
pub type pci_dev_flags = ffi::c_uint;
pub const pci_irq_reroute_variant_INTEL_IRQ_REROUTE_VARIANT: pci_irq_reroute_variant = 1;
pub const pci_irq_reroute_variant_MAX_IRQ_REROUTE_VARIANTS: pci_irq_reroute_variant = 3;
pub type pci_irq_reroute_variant = ffi::c_uint;
pub type pci_bus_flags_t = ffi::c_ushort;
pub const pci_bus_flags_PCI_BUS_FLAGS_NO_MSI: pci_bus_flags = 1;
pub const pci_bus_flags_PCI_BUS_FLAGS_NO_MMRBC: pci_bus_flags = 2;
pub const pci_bus_flags_PCI_BUS_FLAGS_NO_AERSID: pci_bus_flags = 4;
pub const pci_bus_flags_PCI_BUS_FLAGS_NO_EXTCFG: pci_bus_flags = 8;
pub type pci_bus_flags = ffi::c_uint;
pub const pcie_link_width_PCIE_LNK_WIDTH_RESRV: pcie_link_width = 0;
pub const pcie_link_width_PCIE_LNK_X1: pcie_link_width = 1;
pub const pcie_link_width_PCIE_LNK_X2: pcie_link_width = 2;
pub const pcie_link_width_PCIE_LNK_X4: pcie_link_width = 4;
pub const pcie_link_width_PCIE_LNK_X8: pcie_link_width = 8;
pub const pcie_link_width_PCIE_LNK_X12: pcie_link_width = 12;
pub const pcie_link_width_PCIE_LNK_X16: pcie_link_width = 16;
pub const pcie_link_width_PCIE_LNK_X32: pcie_link_width = 32;
pub const pcie_link_width_PCIE_LNK_WIDTH_UNKNOWN: pcie_link_width = 255;
pub type pcie_link_width = ffi::c_uint;
pub const pci_bus_speed_PCI_SPEED_33MHz: pci_bus_speed = 0;
pub const pci_bus_speed_PCI_SPEED_66MHz: pci_bus_speed = 1;
pub const pci_bus_speed_PCI_SPEED_66MHz_PCIX: pci_bus_speed = 2;
pub const pci_bus_speed_PCI_SPEED_100MHz_PCIX: pci_bus_speed = 3;
pub const pci_bus_speed_PCI_SPEED_133MHz_PCIX: pci_bus_speed = 4;
pub const pci_bus_speed_PCI_SPEED_66MHz_PCIX_ECC: pci_bus_speed = 5;
pub const pci_bus_speed_PCI_SPEED_100MHz_PCIX_ECC: pci_bus_speed = 6;
pub const pci_bus_speed_PCI_SPEED_133MHz_PCIX_ECC: pci_bus_speed = 7;
pub const pci_bus_speed_PCI_SPEED_66MHz_PCIX_266: pci_bus_speed = 9;
pub const pci_bus_speed_PCI_SPEED_100MHz_PCIX_266: pci_bus_speed = 10;
pub const pci_bus_speed_PCI_SPEED_133MHz_PCIX_266: pci_bus_speed = 11;
pub const pci_bus_speed_AGP_UNKNOWN: pci_bus_speed = 12;
pub const pci_bus_speed_AGP_1X: pci_bus_speed = 13;
pub const pci_bus_speed_AGP_2X: pci_bus_speed = 14;
pub const pci_bus_speed_AGP_4X: pci_bus_speed = 15;
pub const pci_bus_speed_AGP_8X: pci_bus_speed = 16;
pub const pci_bus_speed_PCI_SPEED_66MHz_PCIX_533: pci_bus_speed = 17;
pub const pci_bus_speed_PCI_SPEED_100MHz_PCIX_533: pci_bus_speed = 18;
pub const pci_bus_speed_PCI_SPEED_133MHz_PCIX_533: pci_bus_speed = 19;
pub const pci_bus_speed_PCIE_SPEED_2_5GT: pci_bus_speed = 20;
pub const pci_bus_speed_PCIE_SPEED_5_0GT: pci_bus_speed = 21;
pub const pci_bus_speed_PCIE_SPEED_8_0GT: pci_bus_speed = 22;
pub const pci_bus_speed_PCIE_SPEED_16_0GT: pci_bus_speed = 23;
pub const pci_bus_speed_PCIE_SPEED_32_0GT: pci_bus_speed = 24;
pub const pci_bus_speed_PCIE_SPEED_64_0GT: pci_bus_speed = 25;
pub const pci_bus_speed_PCI_SPEED_UNKNOWN: pci_bus_speed = 255;
pub type pci_bus_speed = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_vpd {
    pub lock: mutex,
    pub len: ffi::c_uint,
    pub cap: u8_,
}
impl Default for pci_vpd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcie_bwctrl_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcie_link_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_sriov {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_p2pdma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcec_ea {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_dev {
    pub bus_list: list_head,
    pub bus: *mut pci_bus,
    pub subordinate: *mut pci_bus,
    pub sysdata: *mut ffi::c_void,
    pub procent: *mut proc_dir_entry,
    pub slot: *mut pci_slot,
    pub devfn: ffi::c_uint,
    pub vendor: ffi::c_ushort,
    pub device: ffi::c_ushort,
    pub subsystem_vendor: ffi::c_ushort,
    pub subsystem_device: ffi::c_ushort,
    pub class: ffi::c_uint,
    pub revision: u8_,
    pub hdr_type: u8_,
    pub rcec_ea: *mut rcec_ea,
    pub rcec: *mut pci_dev,
    pub devcap: u32_,
    pub rebar_cap: u16_,
    pub pcie_cap: u8_,
    pub msi_cap: u8_,
    pub msix_cap: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rom_base_reg: u8_,
    pub pin: u8_,
    pub pcie_flags_reg: u16_,
    pub dma_alias_mask: *mut ffi::c_ulong,
    pub driver: *mut pci_driver,
    pub dma_mask: u64_,
    pub dma_parms: device_dma_parameters,
    pub current_state: pci_power_t,
    pub pm_cap: u8_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub d3hot_delay: ffi::c_uint,
    pub d3cold_delay: ffi::c_uint,
    pub l1ss: u16_,
    pub link_state: *mut pcie_link_state,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub error_state: pci_channel_state_t,
    pub dev: device,
    pub cfg_size: ffi::c_int,
    pub irq: ffi::c_uint,
    pub resource: [resource; 11usize],
    pub driver_exclusive_resource: resource,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub dev_flags: pci_dev_flags_t,
    pub enable_cnt: atomic_t,
    pub pcie_cap_lock: spinlock_t,
    pub saved_config_space: [u32_; 16usize],
    pub saved_cap_space: hlist_head,
    pub res_attr: [*mut bin_attribute; 11usize],
    pub res_attr_wc: [*mut bin_attribute; 11usize],
    pub msix_base: *mut ffi::c_void,
    pub msi_lock: raw_spinlock_t,
    pub vpd: pci_vpd,
    pub link_bwctrl: *mut pcie_bwctrl_data,
    pub acs_cap: u16_,
    pub supported_speeds: u8_,
    pub rom: phys_addr_t,
    pub romlen: usize,
    pub driver_override: *const ffi::c_char,
    pub priv_flags: ffi::c_ulong,
    pub reset_methods: [u8_; 8usize],
}
impl Default for pci_dev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl pci_dev {
    #[inline]
    pub fn pcie_mpss(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pcie_mpss(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pcie_mpss_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pcie_mpss_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcie_mpss: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pcie_mpss: u8 = unsafe { ::core::mem::transmute(pcie_mpss) };
            pcie_mpss as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pme_support(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pme_support(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pme_support_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pme_support_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pme_poll(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pme_poll(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pme_poll_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pme_poll_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pinned(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pinned_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pinned_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn config_rrs_sv(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_config_rrs_sv(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn config_rrs_sv_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_config_rrs_sv_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn imm_ready(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_imm_ready(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn imm_ready_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_imm_ready_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn d1_support(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_d1_support(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn d1_support_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_d1_support_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn d2_support(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_d2_support(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn d2_support_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_d2_support_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_d1d2(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_d1d2(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_d1d2_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_d1d2_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_d3cold(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_d3cold(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_d3cold_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_d3cold_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bridge_d3(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bridge_d3(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bridge_d3_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bridge_d3_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn d3cold_allowed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_d3cold_allowed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn d3cold_allowed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_d3cold_allowed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmio_always_on(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmio_always_on(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmio_always_on_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmio_always_on_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wakeup_prepared(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_prepared(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wakeup_prepared_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wakeup_prepared_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_bus_pm(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_bus_pm(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_bus_pm_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_bus_pm_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_hotplug(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_hotplug(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_hotplug_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_hotplug_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hotplug_user_indicators(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hotplug_user_indicators(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hotplug_user_indicators_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hotplug_user_indicators_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clear_retrain_link(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clear_retrain_link(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clear_retrain_link_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_clear_retrain_link_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        pme_support: ffi::c_uint,
        pme_poll: ffi::c_uint,
        pinned: ffi::c_uint,
        config_rrs_sv: ffi::c_uint,
        imm_ready: ffi::c_uint,
        d1_support: ffi::c_uint,
        d2_support: ffi::c_uint,
        no_d1d2: ffi::c_uint,
        no_d3cold: ffi::c_uint,
        bridge_d3: ffi::c_uint,
        d3cold_allowed: ffi::c_uint,
        mmio_always_on: ffi::c_uint,
        wakeup_prepared: ffi::c_uint,
        skip_bus_pm: ffi::c_uint,
        ignore_hotplug: ffi::c_uint,
        hotplug_user_indicators: ffi::c_uint,
        clear_retrain_link: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let pme_support: u32 = unsafe { ::core::mem::transmute(pme_support) };
            pme_support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pme_poll: u32 = unsafe { ::core::mem::transmute(pme_poll) };
            pme_poll as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pinned: u32 = unsafe { ::core::mem::transmute(pinned) };
            pinned as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let config_rrs_sv: u32 = unsafe { ::core::mem::transmute(config_rrs_sv) };
            config_rrs_sv as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let imm_ready: u32 = unsafe { ::core::mem::transmute(imm_ready) };
            imm_ready as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let d1_support: u32 = unsafe { ::core::mem::transmute(d1_support) };
            d1_support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let d2_support: u32 = unsafe { ::core::mem::transmute(d2_support) };
            d2_support as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let no_d1d2: u32 = unsafe { ::core::mem::transmute(no_d1d2) };
            no_d1d2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_d3cold: u32 = unsafe { ::core::mem::transmute(no_d3cold) };
            no_d3cold as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let bridge_d3: u32 = unsafe { ::core::mem::transmute(bridge_d3) };
            bridge_d3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let d3cold_allowed: u32 = unsafe { ::core::mem::transmute(d3cold_allowed) };
            d3cold_allowed as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let mmio_always_on: u32 = unsafe { ::core::mem::transmute(mmio_always_on) };
            mmio_always_on as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let wakeup_prepared: u32 = unsafe { ::core::mem::transmute(wakeup_prepared) };
            wakeup_prepared as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let skip_bus_pm: u32 = unsafe { ::core::mem::transmute(skip_bus_pm) };
            skip_bus_pm as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ignore_hotplug: u32 = unsafe { ::core::mem::transmute(ignore_hotplug) };
            ignore_hotplug as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let hotplug_user_indicators: u32 =
                unsafe { ::core::mem::transmute(hotplug_user_indicators) };
            hotplug_user_indicators as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let clear_retrain_link: u32 = unsafe { ::core::mem::transmute(clear_retrain_link) };
            clear_retrain_link as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn ltr_path(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltr_path(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltr_path_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltr_path_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pasid_no_tlp(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pasid_no_tlp(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pasid_no_tlp_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pasid_no_tlp_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eetlp_prefix_max(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eetlp_prefix_max(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eetlp_prefix_max_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                2usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eetlp_prefix_max_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                2usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        ltr_path: ffi::c_uint,
        pasid_no_tlp: ffi::c_uint,
        eetlp_prefix_max: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltr_path: u32 = unsafe { ::core::mem::transmute(ltr_path) };
            ltr_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pasid_no_tlp: u32 = unsafe { ::core::mem::transmute(pasid_no_tlp) };
            pasid_no_tlp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let eetlp_prefix_max: u32 = unsafe { ::core::mem::transmute(eetlp_prefix_max) };
            eetlp_prefix_max as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn transparent(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transparent_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transparent_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_window(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_window(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_window_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_io_window_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pref_window(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pref_window(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pref_window_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pref_window_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pref_64_window(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pref_64_window(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pref_64_window_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pref_64_window_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn multifunction(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multifunction(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multifunction_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multifunction_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_busmaster(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_busmaster(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_busmaster_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_busmaster_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_msi(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_msi(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_msi_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_msi_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_64bit_msi(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_64bit_msi(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_64bit_msi_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_64bit_msi_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn block_cfg_access(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block_cfg_access(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn block_cfg_access_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_block_cfg_access_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn broken_parity_status(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_broken_parity_status(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn broken_parity_status_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_broken_parity_status_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_reroute_variant(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_irq_reroute_variant(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_reroute_variant_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                10usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_reroute_variant_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msi_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msi_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msi_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_msi_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msix_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msix_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msix_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_msix_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ari_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ari_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ari_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ari_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ats_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ats_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ats_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ats_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pasid_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pasid_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pasid_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pasid_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pri_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pri_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pri_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pri_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tph_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tph_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tph_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tph_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_managed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_managed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_managed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_managed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_msi_managed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_msi_managed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_msi_managed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_msi_managed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn needs_freset(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_freset(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn needs_freset_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_needs_freset_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_saved(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_saved(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_saved_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_saved_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_physfn(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_physfn(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_physfn_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_physfn_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_virtfn(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_virtfn(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_virtfn_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_virtfn_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hotplug_bridge(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hotplug_bridge(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hotplug_bridge_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hotplug_bridge_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_pciehp(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_pciehp(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_pciehp_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_pciehp_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shpc_managed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shpc_managed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shpc_managed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shpc_managed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_thunderbolt(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_thunderbolt(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_thunderbolt_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_thunderbolt_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn untrusted(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_untrusted(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn untrusted_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_untrusted_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn external_facing(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_external_facing(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn external_facing_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_external_facing_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn broken_intx_masking(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_broken_intx_masking(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn broken_intx_masking_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_broken_intx_masking_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_window_1k(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_window_1k(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_window_1k_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_io_window_1k_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_managed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_managed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_managed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_managed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_compliant_bars(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_compliant_bars(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_compliant_bars_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                34usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_compliant_bars_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_probed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_probed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_probed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                35usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_probed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_active_reporting(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_active_reporting(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_active_reporting_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_link_active_reporting_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_vf_scan(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_vf_scan(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_vf_scan_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_vf_scan_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_command_memory(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_command_memory(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_command_memory_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_command_memory_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rom_bar_overlap(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom_bar_overlap(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rom_bar_overlap_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rom_bar_overlap_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rom_attr_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom_attr_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rom_attr_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                40usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rom_attr_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_mappable_bars(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_mappable_bars(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_mappable_bars_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_mappable_bars_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        transparent: ffi::c_uint,
        io_window: ffi::c_uint,
        pref_window: ffi::c_uint,
        pref_64_window: ffi::c_uint,
        multifunction: ffi::c_uint,
        is_busmaster: ffi::c_uint,
        no_msi: ffi::c_uint,
        no_64bit_msi: ffi::c_uint,
        block_cfg_access: ffi::c_uint,
        broken_parity_status: ffi::c_uint,
        irq_reroute_variant: ffi::c_uint,
        msi_enabled: ffi::c_uint,
        msix_enabled: ffi::c_uint,
        ari_enabled: ffi::c_uint,
        ats_enabled: ffi::c_uint,
        pasid_enabled: ffi::c_uint,
        pri_enabled: ffi::c_uint,
        tph_enabled: ffi::c_uint,
        is_managed: ffi::c_uint,
        is_msi_managed: ffi::c_uint,
        needs_freset: ffi::c_uint,
        state_saved: ffi::c_uint,
        is_physfn: ffi::c_uint,
        is_virtfn: ffi::c_uint,
        is_hotplug_bridge: ffi::c_uint,
        is_pciehp: ffi::c_uint,
        shpc_managed: ffi::c_uint,
        is_thunderbolt: ffi::c_uint,
        untrusted: ffi::c_uint,
        external_facing: ffi::c_uint,
        broken_intx_masking: ffi::c_uint,
        io_window_1k: ffi::c_uint,
        irq_managed: ffi::c_uint,
        non_compliant_bars: ffi::c_uint,
        is_probed: ffi::c_uint,
        link_active_reporting: ffi::c_uint,
        no_vf_scan: ffi::c_uint,
        no_command_memory: ffi::c_uint,
        rom_bar_overlap: ffi::c_uint,
        rom_attr_enabled: ffi::c_uint,
        non_mappable_bars: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let transparent: u32 = unsafe { ::core::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_window: u32 = unsafe { ::core::mem::transmute(io_window) };
            io_window as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pref_window: u32 = unsafe { ::core::mem::transmute(pref_window) };
            pref_window as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pref_64_window: u32 = unsafe { ::core::mem::transmute(pref_64_window) };
            pref_64_window as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let multifunction: u32 = unsafe { ::core::mem::transmute(multifunction) };
            multifunction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_busmaster: u32 = unsafe { ::core::mem::transmute(is_busmaster) };
            is_busmaster as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_msi: u32 = unsafe { ::core::mem::transmute(no_msi) };
            no_msi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_64bit_msi: u32 = unsafe { ::core::mem::transmute(no_64bit_msi) };
            no_64bit_msi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let block_cfg_access: u32 = unsafe { ::core::mem::transmute(block_cfg_access) };
            block_cfg_access as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let broken_parity_status: u32 = unsafe { ::core::mem::transmute(broken_parity_status) };
            broken_parity_status as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let irq_reroute_variant: u32 = unsafe { ::core::mem::transmute(irq_reroute_variant) };
            irq_reroute_variant as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let msi_enabled: u32 = unsafe { ::core::mem::transmute(msi_enabled) };
            msi_enabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let msix_enabled: u32 = unsafe { ::core::mem::transmute(msix_enabled) };
            msix_enabled as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ari_enabled: u32 = unsafe { ::core::mem::transmute(ari_enabled) };
            ari_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ats_enabled: u32 = unsafe { ::core::mem::transmute(ats_enabled) };
            ats_enabled as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pasid_enabled: u32 = unsafe { ::core::mem::transmute(pasid_enabled) };
            pasid_enabled as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pri_enabled: u32 = unsafe { ::core::mem::transmute(pri_enabled) };
            pri_enabled as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tph_enabled: u32 = unsafe { ::core::mem::transmute(tph_enabled) };
            tph_enabled as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let is_managed: u32 = unsafe { ::core::mem::transmute(is_managed) };
            is_managed as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let is_msi_managed: u32 = unsafe { ::core::mem::transmute(is_msi_managed) };
            is_msi_managed as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let needs_freset: u32 = unsafe { ::core::mem::transmute(needs_freset) };
            needs_freset as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let state_saved: u32 = unsafe { ::core::mem::transmute(state_saved) };
            state_saved as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let is_physfn: u32 = unsafe { ::core::mem::transmute(is_physfn) };
            is_physfn as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let is_virtfn: u32 = unsafe { ::core::mem::transmute(is_virtfn) };
            is_virtfn as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let is_hotplug_bridge: u32 = unsafe { ::core::mem::transmute(is_hotplug_bridge) };
            is_hotplug_bridge as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let is_pciehp: u32 = unsafe { ::core::mem::transmute(is_pciehp) };
            is_pciehp as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let shpc_managed: u32 = unsafe { ::core::mem::transmute(shpc_managed) };
            shpc_managed as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let is_thunderbolt: u32 = unsafe { ::core::mem::transmute(is_thunderbolt) };
            is_thunderbolt as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let untrusted: u32 = unsafe { ::core::mem::transmute(untrusted) };
            untrusted as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let external_facing: u32 = unsafe { ::core::mem::transmute(external_facing) };
            external_facing as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let broken_intx_masking: u32 = unsafe { ::core::mem::transmute(broken_intx_masking) };
            broken_intx_masking as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let io_window_1k: u32 = unsafe { ::core::mem::transmute(io_window_1k) };
            io_window_1k as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let irq_managed: u32 = unsafe { ::core::mem::transmute(irq_managed) };
            irq_managed as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let non_compliant_bars: u32 = unsafe { ::core::mem::transmute(non_compliant_bars) };
            non_compliant_bars as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let is_probed: u32 = unsafe { ::core::mem::transmute(is_probed) };
            is_probed as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let link_active_reporting: u32 =
                unsafe { ::core::mem::transmute(link_active_reporting) };
            link_active_reporting as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_vf_scan: u32 = unsafe { ::core::mem::transmute(no_vf_scan) };
            no_vf_scan as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let no_command_memory: u32 = unsafe { ::core::mem::transmute(no_command_memory) };
            no_command_memory as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let rom_bar_overlap: u32 = unsafe { ::core::mem::transmute(rom_bar_overlap) };
            rom_bar_overlap as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let rom_attr_enabled: u32 = unsafe { ::core::mem::transmute(rom_attr_enabled) };
            rom_attr_enabled as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let non_mappable_bars: u32 = unsafe { ::core::mem::transmute(non_mappable_bars) };
            non_mappable_bars as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[repr(align(64))]
pub struct pci_host_bridge {
    pub dev: device,
    pub bus: *mut pci_bus,
    pub ops: *mut pci_ops,
    pub child_ops: *mut pci_ops,
    pub sysdata: *mut ffi::c_void,
    pub busnr: ffi::c_int,
    pub domain_nr: ffi::c_int,
    pub windows: list_head,
    pub dma_ranges: list_head,
    pub swizzle_irq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pci_dev, arg2: *mut u8_) -> u8_>,
    pub map_irq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const pci_dev, arg2: u8_, arg3: u8_) -> ffi::c_int,
    >,
    pub release_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pci_host_bridge)>,
    pub enable_device: ::core::option::Option<
        unsafe extern "C" fn(bridge: *mut pci_host_bridge, dev: *mut pci_dev) -> ffi::c_int,
    >,
    pub disable_device: ::core::option::Option<
        unsafe extern "C" fn(bridge: *mut pci_host_bridge, dev: *mut pci_dev),
    >,
    pub release_data: *mut ffi::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub align_resource: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut pci_dev,
            res: *const resource,
            start: resource_size_t,
            size: resource_size_t,
            align: resource_size_t,
        ) -> resource_size_t,
    >,
    pub __bindgen_padding_0: [u64; 2usize],
    pub private: __IncompleteArrayField<ffi::c_ulong>,
}
impl Default for pci_host_bridge {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl pci_host_bridge {
    #[inline]
    pub fn ignore_reset_delay(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_reset_delay(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_reset_delay_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_reset_delay_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_ext_tags(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ext_tags(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_ext_tags_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_ext_tags_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_inc_mrrs(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_inc_mrrs(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_inc_mrrs_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_inc_mrrs_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_aer(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_aer(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_aer_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_aer_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_pcie_hotplug(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_pcie_hotplug(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_pcie_hotplug_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_pcie_hotplug_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_shpc_hotplug(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_shpc_hotplug(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_shpc_hotplug_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_shpc_hotplug_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_pme(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_pme(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_pme_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_pme_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_ltr(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_ltr(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_ltr_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_ltr_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_dpc(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_dpc(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_dpc_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_dpc_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn native_cxl_error(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native_cxl_error(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn native_cxl_error_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_native_cxl_error_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn preserve_config(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_config(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn preserve_config_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_preserve_config_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn size_windows(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_size_windows(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn size_windows_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_size_windows_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msi_domain(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msi_domain(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msi_domain_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_msi_domain_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ignore_reset_delay: ffi::c_uint,
        no_ext_tags: ffi::c_uint,
        no_inc_mrrs: ffi::c_uint,
        native_aer: ffi::c_uint,
        native_pcie_hotplug: ffi::c_uint,
        native_shpc_hotplug: ffi::c_uint,
        native_pme: ffi::c_uint,
        native_ltr: ffi::c_uint,
        native_dpc: ffi::c_uint,
        native_cxl_error: ffi::c_uint,
        preserve_config: ffi::c_uint,
        size_windows: ffi::c_uint,
        msi_domain: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ignore_reset_delay: u32 = unsafe { ::core::mem::transmute(ignore_reset_delay) };
            ignore_reset_delay as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_ext_tags: u32 = unsafe { ::core::mem::transmute(no_ext_tags) };
            no_ext_tags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_inc_mrrs: u32 = unsafe { ::core::mem::transmute(no_inc_mrrs) };
            no_inc_mrrs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let native_aer: u32 = unsafe { ::core::mem::transmute(native_aer) };
            native_aer as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let native_pcie_hotplug: u32 = unsafe { ::core::mem::transmute(native_pcie_hotplug) };
            native_pcie_hotplug as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let native_shpc_hotplug: u32 = unsafe { ::core::mem::transmute(native_shpc_hotplug) };
            native_shpc_hotplug as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let native_pme: u32 = unsafe { ::core::mem::transmute(native_pme) };
            native_pme as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let native_ltr: u32 = unsafe { ::core::mem::transmute(native_ltr) };
            native_ltr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let native_dpc: u32 = unsafe { ::core::mem::transmute(native_dpc) };
            native_dpc as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let native_cxl_error: u32 = unsafe { ::core::mem::transmute(native_cxl_error) };
            native_cxl_error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let preserve_config: u32 = unsafe { ::core::mem::transmute(preserve_config) };
            preserve_config as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let size_windows: u32 = unsafe { ::core::mem::transmute(size_windows) };
            size_windows as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let msi_domain: u32 = unsafe { ::core::mem::transmute(msi_domain) };
            msi_domain as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_bus {
    pub node: list_head,
    pub parent: *mut pci_bus,
    pub children: list_head,
    pub devices: list_head,
    pub self_: *mut pci_dev,
    pub slots: list_head,
    pub resource: [*mut resource; 4usize],
    pub resources: list_head,
    pub busn_res: resource,
    pub ops: *mut pci_ops,
    pub sysdata: *mut ffi::c_void,
    pub procdir: *mut proc_dir_entry,
    pub number: ffi::c_uchar,
    pub primary: ffi::c_uchar,
    pub max_bus_speed: ffi::c_uchar,
    pub cur_bus_speed: ffi::c_uchar,
    pub domain_nr: ffi::c_int,
    pub name: [ffi::c_char; 48usize],
    pub bridge_ctl: ffi::c_ushort,
    pub bus_flags: pci_bus_flags_t,
    pub bridge: *mut device,
    pub dev: device,
    pub legacy_io: *mut bin_attribute,
    pub legacy_mem: *mut bin_attribute,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for pci_bus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl pci_bus {
    #[inline]
    pub fn is_added(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_added(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_added_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_added_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unsafe_warn(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unsafe_warn(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unsafe_warn_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unsafe_warn_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flit_mode(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flit_mode(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flit_mode_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flit_mode_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_added: ffi::c_uint,
        unsafe_warn: ffi::c_uint,
        flit_mode: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_added: u32 = unsafe { ::core::mem::transmute(is_added) };
            is_added as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unsafe_warn: u32 = unsafe { ::core::mem::transmute(unsafe_warn) };
            unsafe_warn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let flit_mode: u32 = unsafe { ::core::mem::transmute(flit_mode) };
            flit_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_ops {
    pub add_bus: ::core::option::Option<unsafe extern "C" fn(bus: *mut pci_bus) -> ffi::c_int>,
    pub remove_bus: ::core::option::Option<unsafe extern "C" fn(bus: *mut pci_bus)>,
    pub map_bus: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut pci_bus,
            devfn: ffi::c_uint,
            where_: ffi::c_int,
        ) -> *mut ffi::c_void,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut pci_bus,
            devfn: ffi::c_uint,
            where_: ffi::c_int,
            size: ffi::c_int,
            val: *mut u32_,
        ) -> ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut pci_bus,
            devfn: ffi::c_uint,
            where_: ffi::c_int,
            size: ffi::c_int,
            val: u32_,
        ) -> ffi::c_int,
    >,
}

pub type pci_bus_addr_t = u64_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_bus_region {
    pub start: pci_bus_addr_t,
    pub end: pci_bus_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_dynids {
    pub lock: spinlock_t,
    pub list: list_head,
}
impl Default for pci_dynids {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pci_ers_result_t = ffi::c_uint;
pub const pci_ers_result_PCI_ERS_RESULT_NONE: pci_ers_result = 1;
pub const pci_ers_result_PCI_ERS_RESULT_CAN_RECOVER: pci_ers_result = 2;
pub const pci_ers_result_PCI_ERS_RESULT_NEED_RESET: pci_ers_result = 3;
pub const pci_ers_result_PCI_ERS_RESULT_DISCONNECT: pci_ers_result = 4;
pub const pci_ers_result_PCI_ERS_RESULT_RECOVERED: pci_ers_result = 5;
pub const pci_ers_result_PCI_ERS_RESULT_NO_AER_DRIVER: pci_ers_result = 6;
pub type pci_ers_result = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_error_handlers {
    pub error_detected: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut pci_dev, error: pci_channel_state_t) -> pci_ers_result_t,
    >,
    pub mmio_enabled:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev) -> pci_ers_result_t>,
    pub slot_reset:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev) -> pci_ers_result_t>,
    pub reset_prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub reset_done: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub cor_error_detected: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_driver {
    pub name: *const ffi::c_char,
    pub id_table: *const pci_device_id,
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut pci_dev, id: *const pci_device_id) -> ffi::c_int,
    >,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut pci_dev, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev) -> ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub sriov_configure: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut pci_dev, num_vfs: ffi::c_int) -> ffi::c_int,
    >,
    pub sriov_set_msix_vec_count: ::core::option::Option<
        unsafe extern "C" fn(vf: *mut pci_dev, msix_vec_count: ffi::c_int) -> ffi::c_int,
    >,
    pub sriov_get_vf_total_msix:
        ::core::option::Option<unsafe extern "C" fn(pf: *mut pci_dev) -> u32_>,
    pub err_handler: *const pci_error_handlers,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub driver: device_driver,
    pub dynids: pci_dynids,
    pub driver_managed_dma: bool_,
}
impl Default for pci_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PCI_REASSIGN_ALL_RSRC: _bindgen_ty_320 = 1;
pub const PCI_REASSIGN_ALL_BUS: _bindgen_ty_320 = 2;
pub const PCI_PROBE_ONLY: _bindgen_ty_320 = 4;
pub const PCI_CAN_SKIP_ISA_ALIGN: _bindgen_ty_320 = 8;
pub const PCI_ENABLE_PROC_DOMAINS: _bindgen_ty_320 = 16;
pub const PCI_COMPAT_DOMAIN_0: _bindgen_ty_320 = 32;
pub const PCI_SCAN_ALL_PCIE_DEVS: _bindgen_ty_320 = 64;
pub type _bindgen_ty_320 = ffi::c_uint;

pub const pcie_bus_config_types_PCIE_BUS_TUNE_OFF: pcie_bus_config_types = 0;
pub const pcie_bus_config_types_PCIE_BUS_DEFAULT: pcie_bus_config_types = 1;
pub const pcie_bus_config_types_PCIE_BUS_SAFE: pcie_bus_config_types = 2;
pub const pcie_bus_config_types_PCIE_BUS_PERFORMANCE: pcie_bus_config_types = 3;
pub const pcie_bus_config_types_PCIE_BUS_PEER2PEER: pcie_bus_config_types = 4;
pub type pcie_bus_config_types = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_saved_state {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct dma_pool {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msix_entry {
    pub vector: u32_,
    pub entry: u16_,
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pcie_ptm_ops {
    pub check_capability:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> ffi::c_int>,
    pub context_update_write: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, mode: u8_) -> ffi::c_int,
    >,
    pub context_update_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, mode: *mut u8_) -> ffi::c_int,
    >,
    pub context_valid_write: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, valid: bool_) -> ffi::c_int,
    >,
    pub context_valid_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, valid: *mut bool_) -> ffi::c_int,
    >,
    pub local_clock_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub master_clock_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub t1_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub t2_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub t3_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub t4_read: ::core::option::Option<
        unsafe extern "C" fn(drvdata: *mut ffi::c_void, clock: *mut u64_) -> ffi::c_int,
    >,
    pub context_update_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub context_valid_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub local_clock_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub master_clock_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub t1_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub t2_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub t3_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
    pub t4_visible:
        ::core::option::Option<unsafe extern "C" fn(drvdata: *mut ffi::c_void) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_ptm_debugfs {
    pub debugfs: *mut dentry,
    pub ops: *const pcie_ptm_ops,
    pub lock: mutex,
    pub pdata: *mut ffi::c_void,
}
impl Default for pci_ptm_debugfs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type class_pci_dev_t = *mut pci_dev;
pub const class_pci_dev_is_conditional: bool_ = false;

pub type arch_set_vga_state_t = ::core::option::Option<
    unsafe extern "C" fn(
        pdev: *mut pci_dev,
        decode: bool_,
        command_bits: ffi::c_uint,
        flags: u32_,
    ) -> ffi::c_int,
>;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_fixup {
    pub vendor: u16_,
    pub device: u16_,
    pub class: u32_,
    pub class_shift: ffi::c_uint,
    pub hook: ::core::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
}
pub const pci_fixup_pass_pci_fixup_early: pci_fixup_pass = 0;
pub const pci_fixup_pass_pci_fixup_header: pci_fixup_pass = 1;
pub const pci_fixup_pass_pci_fixup_final: pci_fixup_pass = 2;
pub const pci_fixup_pass_pci_fixup_enable: pci_fixup_pass = 3;
pub const pci_fixup_pass_pci_fixup_resume: pci_fixup_pass = 4;
pub const pci_fixup_pass_pci_fixup_suspend: pci_fixup_pass = 5;
pub const pci_fixup_pass_pci_fixup_resume_early: pci_fixup_pass = 6;
pub const pci_fixup_pass_pci_fixup_suspend_late: pci_fixup_pass = 7;
pub type pci_fixup_pass = ffi::c_uint;

pub const led_brightness_LED_OFF: led_brightness = 0;
pub const led_brightness_LED_ON: led_brightness = 1;
pub const led_brightness_LED_HALF: led_brightness = 127;
pub const led_brightness_LED_FULL: led_brightness = 255;
pub type led_brightness = ffi::c_uint;
pub const led_default_state_LEDS_DEFSTATE_OFF: led_default_state = 0;
pub const led_default_state_LEDS_DEFSTATE_ON: led_default_state = 1;
pub const led_default_state_LEDS_DEFSTATE_KEEP: led_default_state = 2;
pub type led_default_state = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_lookup_data {
    pub list: list_head,
    pub provider: *const ffi::c_char,
    pub dev_id: *const ffi::c_char,
    pub con_id: *const ffi::c_char,
}
impl Default for led_lookup_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_init_data {
    pub fwnode: *mut fwnode_handle,
    pub default_label: *const ffi::c_char,
    pub devicename: *const ffi::c_char,
    pub devname_mandatory: bool_,
}
impl Default for led_init_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct led_hw_trigger_type {
    pub dummy: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_classdev {
    pub name: *const ffi::c_char,
    pub brightness: ffi::c_uint,
    pub max_brightness: ffi::c_uint,
    pub color: ffi::c_uint,
    pub flags: ffi::c_int,
    pub work_flags: ffi::c_ulong,
    pub brightness_set: ::core::option::Option<
        unsafe extern "C" fn(led_cdev: *mut led_classdev, brightness: led_brightness),
    >,
    pub brightness_set_blocking: ::core::option::Option<
        unsafe extern "C" fn(led_cdev: *mut led_classdev, brightness: led_brightness) -> ffi::c_int,
    >,
    pub brightness_get:
        ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev) -> led_brightness>,
    pub blink_set: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            delay_on: *mut ffi::c_ulong,
            delay_off: *mut ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub pattern_set: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            pattern: *mut led_pattern,
            len: u32_,
            repeat: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub pattern_clear:
        ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev) -> ffi::c_int>,
    pub dev: *mut device,
    pub groups: *mut *const attribute_group,
    pub node: list_head,
    pub default_trigger: *const ffi::c_char,
    pub blink_delay_on: ffi::c_ulong,
    pub blink_delay_off: ffi::c_ulong,
    pub blink_timer: timer_list,
    pub blink_brightness: ffi::c_int,
    pub new_blink_brightness: ffi::c_int,
    pub flash_resume: ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev)>,
    pub wq: *mut workqueue_struct,
    pub set_brightness_work: work_struct,
    pub delayed_set_value: ffi::c_int,
    pub delayed_delay_on: ffi::c_ulong,
    pub delayed_delay_off: ffi::c_ulong,
    pub led_access: mutex,
}
impl Default for led_classdev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct led_trigger {}
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK: led_trigger_netdev_modes = 0;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_10: led_trigger_netdev_modes = 1;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_100: led_trigger_netdev_modes = 2;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_1000: led_trigger_netdev_modes = 3;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_2500: led_trigger_netdev_modes = 4;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_5000: led_trigger_netdev_modes = 5;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_10000: led_trigger_netdev_modes = 6;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_HALF_DUPLEX: led_trigger_netdev_modes = 7;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_FULL_DUPLEX: led_trigger_netdev_modes = 8;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_TX: led_trigger_netdev_modes = 9;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_RX: led_trigger_netdev_modes = 10;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_TX_ERR: led_trigger_netdev_modes = 11;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_RX_ERR: led_trigger_netdev_modes = 12;
pub const led_trigger_netdev_modes___TRIGGER_NETDEV_MAX: led_trigger_netdev_modes = 13;
pub type led_trigger_netdev_modes = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_info {
    pub name: *const ffi::c_char,
    pub default_trigger: *const ffi::c_char,
    pub flags: ffi::c_int,
}
impl Default for led_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_platform_data {
    pub num_leds: ffi::c_int,
    pub leds: *mut led_info,
}
impl Default for led_platform_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_properties {
    pub color: u32_,
    pub color_present: bool_,
    pub function: *const ffi::c_char,
    pub func_enum: u32_,
    pub func_enum_present: bool_,
    pub label: *const ffi::c_char,
}
impl Default for led_properties {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gpio_blink_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        desc: *mut gpio_desc,
        state: ffi::c_int,
        delay_on: *mut ffi::c_ulong,
        delay_off: *mut ffi::c_ulong,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_led {
    pub name: *const ffi::c_char,
    pub default_trigger: *const ffi::c_char,
    pub gpio: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub gpiod: *mut gpio_desc,
}
impl Default for gpio_led {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl gpio_led {
    #[inline]
    pub fn active_low(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_low_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_active_low_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn retain_state_suspended(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retain_state_suspended(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn retain_state_suspended_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_retain_state_suspended_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn panic_indicator(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_panic_indicator(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn panic_indicator_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_panic_indicator_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_state(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_default_state(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_state_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_default_state_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn retain_state_shutdown(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retain_state_shutdown(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn retain_state_shutdown_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_retain_state_shutdown_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_low: ffi::c_uint,
        retain_state_suspended: ffi::c_uint,
        panic_indicator: ffi::c_uint,
        default_state: ffi::c_uint,
        retain_state_shutdown: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let retain_state_suspended: u32 =
                unsafe { ::core::mem::transmute(retain_state_suspended) };
            retain_state_suspended as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let panic_indicator: u32 = unsafe { ::core::mem::transmute(panic_indicator) };
            panic_indicator as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let default_state: u32 = unsafe { ::core::mem::transmute(default_state) };
            default_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let retain_state_shutdown: u32 =
                unsafe { ::core::mem::transmute(retain_state_shutdown) };
            retain_state_shutdown as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_led_platform_data {
    pub num_leds: ffi::c_int,
    pub leds: *const gpio_led,
    pub gpio_blink_set: gpio_blink_set_t,
}
impl Default for gpio_led_platform_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const cpu_led_event_CPU_LED_IDLE_START: cpu_led_event = 0;
pub const cpu_led_event_CPU_LED_IDLE_END: cpu_led_event = 1;
pub const cpu_led_event_CPU_LED_START: cpu_led_event = 2;
pub const cpu_led_event_CPU_LED_STOP: cpu_led_event = 3;
pub const cpu_led_event_CPU_LED_HALTED: cpu_led_event = 4;
pub type cpu_led_event = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct led_pattern {
    pub delta_t: u32_,
    pub brightness: ffi::c_int,
}
pub const led_audio_LED_AUDIO_MUTE: led_audio = 0;
pub const led_audio_LED_AUDIO_MICMUTE: led_audio = 1;
pub const led_audio_NUM_AUDIO_LEDS: led_audio = 2;
pub type led_audio = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwtstamp_provider_desc {
    pub index: ffi::c_int,
    pub qualifier: hwtstamp_provider_qualifier,
}
impl Default for hwtstamp_provider_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwtstamp_provider {
    pub callback_head: callback_head,
    pub source: hwtstamp_source,
    pub phydev: *mut phy_device,
    pub desc: hwtstamp_provider_desc,
}
impl Default for hwtstamp_provider {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_hwtstamp_config {
    pub flags: ffi::c_int,
    pub tx_type: ffi::c_int,
    pub rx_filter: ffi::c_int,
    pub ifr: *mut ifreq,
    pub copied_to_user: bool_,
    pub source: hwtstamp_source,
    pub qualifier: hwtstamp_provider_qualifier,
}
impl Default for kernel_hwtstamp_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_timestamper {
    pub rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            skb: *mut sk_buff,
            type_: ffi::c_int,
        ) -> bool_,
    >,
    pub txtstamp: ::core::option::Option<
        unsafe extern "C" fn(mii_ts: *mut mii_timestamper, skb: *mut sk_buff, type_: ffi::c_int),
    >,
    pub hwtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            kernel_config: *mut kernel_hwtstamp_config,
            extack: *mut netlink_ext_ack,
        ) -> ffi::c_int,
    >,
    pub link_state: ::core::option::Option<
        unsafe extern "C" fn(mii_ts: *mut mii_timestamper, phydev: *mut phy_device),
    >,
    pub ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            ts_info: *mut kernel_ethtool_ts_info,
        ) -> ffi::c_int,
    >,
    pub device: *mut device,
}
impl Default for mii_timestamper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mii_timestamping_ctrl {
    pub probe_channel: ::core::option::Option<
        unsafe extern "C" fn(device: *mut device, port: ffi::c_uint) -> *mut mii_timestamper,
    >,
    pub release_channel: ::core::option::Option<
        unsafe extern "C" fn(device: *mut device, mii_ts: *mut mii_timestamper),
    >,
}

pub const max_slack_shift: ffi::c_uint = 2;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct eee_config {
    pub tx_lpi_timer: u32_,
    pub tx_lpi_enabled: bool_,
    pub eee_enabled: bool_,
}

pub const phy_interface_t_PHY_INTERFACE_MODE_NA: phy_interface_t = 0;
pub const phy_interface_t_PHY_INTERFACE_MODE_INTERNAL: phy_interface_t = 1;
pub const phy_interface_t_PHY_INTERFACE_MODE_MII: phy_interface_t = 2;
pub const phy_interface_t_PHY_INTERFACE_MODE_GMII: phy_interface_t = 3;
pub const phy_interface_t_PHY_INTERFACE_MODE_SGMII: phy_interface_t = 4;
pub const phy_interface_t_PHY_INTERFACE_MODE_TBI: phy_interface_t = 5;
pub const phy_interface_t_PHY_INTERFACE_MODE_REVMII: phy_interface_t = 6;
pub const phy_interface_t_PHY_INTERFACE_MODE_RMII: phy_interface_t = 7;
pub const phy_interface_t_PHY_INTERFACE_MODE_REVRMII: phy_interface_t = 8;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII: phy_interface_t = 9;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_ID: phy_interface_t = 10;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_RXID: phy_interface_t = 11;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_TXID: phy_interface_t = 12;
pub const phy_interface_t_PHY_INTERFACE_MODE_RTBI: phy_interface_t = 13;
pub const phy_interface_t_PHY_INTERFACE_MODE_SMII: phy_interface_t = 14;
pub const phy_interface_t_PHY_INTERFACE_MODE_XGMII: phy_interface_t = 15;
pub const phy_interface_t_PHY_INTERFACE_MODE_XLGMII: phy_interface_t = 16;
pub const phy_interface_t_PHY_INTERFACE_MODE_MOCA: phy_interface_t = 17;
pub const phy_interface_t_PHY_INTERFACE_MODE_PSGMII: phy_interface_t = 18;
pub const phy_interface_t_PHY_INTERFACE_MODE_QSGMII: phy_interface_t = 19;
pub const phy_interface_t_PHY_INTERFACE_MODE_TRGMII: phy_interface_t = 20;
pub const phy_interface_t_PHY_INTERFACE_MODE_100BASEX: phy_interface_t = 21;
pub const phy_interface_t_PHY_INTERFACE_MODE_1000BASEX: phy_interface_t = 22;
pub const phy_interface_t_PHY_INTERFACE_MODE_2500BASEX: phy_interface_t = 23;
pub const phy_interface_t_PHY_INTERFACE_MODE_5GBASER: phy_interface_t = 24;
pub const phy_interface_t_PHY_INTERFACE_MODE_RXAUI: phy_interface_t = 25;
pub const phy_interface_t_PHY_INTERFACE_MODE_XAUI: phy_interface_t = 26;
pub const phy_interface_t_PHY_INTERFACE_MODE_10GBASER: phy_interface_t = 27;
pub const phy_interface_t_PHY_INTERFACE_MODE_25GBASER: phy_interface_t = 28;
pub const phy_interface_t_PHY_INTERFACE_MODE_USXGMII: phy_interface_t = 29;
pub const phy_interface_t_PHY_INTERFACE_MODE_10GKR: phy_interface_t = 30;
pub const phy_interface_t_PHY_INTERFACE_MODE_QUSGMII: phy_interface_t = 31;
pub const phy_interface_t_PHY_INTERFACE_MODE_1000BASEKX: phy_interface_t = 32;
pub const phy_interface_t_PHY_INTERFACE_MODE_10G_QXGMII: phy_interface_t = 33;
pub const phy_interface_t_PHY_INTERFACE_MODE_50GBASER: phy_interface_t = 34;
pub const phy_interface_t_PHY_INTERFACE_MODE_LAUI: phy_interface_t = 35;
pub const phy_interface_t_PHY_INTERFACE_MODE_100GBASEP: phy_interface_t = 36;
pub const phy_interface_t_PHY_INTERFACE_MODE_MIILITE: phy_interface_t = 37;
pub const phy_interface_t_PHY_INTERFACE_MODE_MAX: phy_interface_t = 38;
pub type phy_interface_t = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phylink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_bus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_upstream_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mdio_bus_stats {
    pub transfers: u64_stats_t,
    pub errors: u64_stats_t,
    pub writes: u64_stats_t,
    pub reads: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_bus {
    pub owner: *mut module,
    pub name: *const ffi::c_char,
    pub id: [ffi::c_char; 61usize],
    pub priv_: *mut ffi::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(bus: *mut mii_bus, addr: ffi::c_int, regnum: ffi::c_int) -> ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: ffi::c_int,
            regnum: ffi::c_int,
            val: u16_,
        ) -> ffi::c_int,
    >,
    pub read_c45: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: ffi::c_int,
            devnum: ffi::c_int,
            regnum: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub write_c45: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: ffi::c_int,
            devnum: ffi::c_int,
            regnum: ffi::c_int,
            val: u16_,
        ) -> ffi::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(bus: *mut mii_bus) -> ffi::c_int>,
    pub stats: [mdio_bus_stats; 32usize],
    pub mdio_lock: mutex,
    pub parent: *mut device,
    pub state: mii_bus__bindgen_ty_1,
    pub dev: device,
    pub mdio_map: [*mut mdio_device; 32usize],
    pub phy_mask: u32_,
    pub phy_ignore_ta_mask: u32_,
    pub irq: [ffi::c_int; 32usize],
    pub reset_delay_us: ffi::c_int,
    pub reset_post_delay_us: ffi::c_int,
    pub reset_gpiod: *mut gpio_desc,
    pub shared_lock: mutex,
    pub shared: [*mut phy_package_shared; 32usize],
}
pub const mii_bus_MDIOBUS_ALLOCATED: mii_bus__bindgen_ty_1 = 1;
pub const mii_bus_MDIOBUS_REGISTERED: mii_bus__bindgen_ty_1 = 2;
pub const mii_bus_MDIOBUS_UNREGISTERED: mii_bus__bindgen_ty_1 = 3;
pub const mii_bus_MDIOBUS_RELEASED: mii_bus__bindgen_ty_1 = 4;
pub type mii_bus__bindgen_ty_1 = ffi::c_uint;
impl Default for mii_bus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const phy_state_PHY_DOWN: phy_state = 0;
pub const phy_state_PHY_READY: phy_state = 1;
pub const phy_state_PHY_HALTED: phy_state = 2;
pub const phy_state_PHY_ERROR: phy_state = 3;
pub const phy_state_PHY_UP: phy_state = 4;
pub const phy_state_PHY_RUNNING: phy_state = 5;
pub const phy_state_PHY_NOLINK: phy_state = 6;
pub const phy_state_PHY_CABLETEST: phy_state = 7;
pub type phy_state = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_c45_device_ids {
    pub devices_in_package: u32_,
    pub mmds_present: u32_,
    pub device_ids: [u32_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_device {
    pub mdio: mdio_device,
    pub drv: *const phy_driver,
    pub devlink: *mut device_link,
    pub phyindex: u32_,
    pub phy_id: u32_,
    pub c45_ids: phy_c45_device_ids,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub rate_matching: ffi::c_int,
    pub state: phy_state,
    pub dev_flags: u32_,
    pub interface: phy_interface_t,
    pub possible_interfaces: [ffi::c_ulong; 1usize],
    pub speed: ffi::c_int,
    pub duplex: ffi::c_int,
    pub port: ffi::c_int,
    pub pause: ffi::c_int,
    pub asym_pause: ffi::c_int,
    pub master_slave_get: u8_,
    pub master_slave_set: u8_,
    pub master_slave_state: u8_,
    pub supported: [ffi::c_ulong; 2usize],
    pub advertising: [ffi::c_ulong; 2usize],
    pub lp_advertising: [ffi::c_ulong; 2usize],
    pub adv_old: [ffi::c_ulong; 2usize],
    pub supported_eee: [ffi::c_ulong; 2usize],
    pub advertising_eee: [ffi::c_ulong; 2usize],
    pub eee_disabled_modes: [ffi::c_ulong; 2usize],
    pub enable_tx_lpi: bool_,
    pub eee_active: bool_,
    pub eee_cfg: eee_config,
    pub host_interfaces: [ffi::c_ulong; 1usize],
    pub leds: list_head,
    pub irq: ffi::c_int,
    pub priv_: *mut ffi::c_void,
    pub shared: *mut phy_package_shared,
    pub skb: *mut sk_buff,
    pub ehdr: *mut ffi::c_void,
    pub nest: *mut nlattr,
    pub state_queue: delayed_work,
    pub lock: mutex,
    pub sfp_bus_attached: bool_,
    pub sfp_bus: *mut sfp_bus,
    pub phylink: *mut phylink,
    pub attached_dev: *mut net_device,
    pub mii_ts: *mut mii_timestamper,
    pub psec: *mut pse_control,
    pub mdix: u8_,
    pub mdix_ctrl: u8_,
    pub pma_extable: ffi::c_int,
    pub link_down_events: ffi::c_uint,
    pub phy_link_change:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device, up: bool_)>,
    pub adjust_link: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
}
impl Default for phy_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl phy_device {
    #[inline]
    pub fn is_c45(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_c45(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_c45_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_c45_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_internal(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_internal(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_internal_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_internal_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_pseudo_fixed_link(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_pseudo_fixed_link(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_pseudo_fixed_link_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_pseudo_fixed_link_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_gigabit_capable(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_gigabit_capable(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_gigabit_capable_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_gigabit_capable_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_fixups(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fixups(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_fixups_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_fixups_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn suspended(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn suspended_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_suspended_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn suspended_by_mdio_bus(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended_by_mdio_bus(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn suspended_by_mdio_bus_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_suspended_by_mdio_bus_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sysfs_links(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysfs_links(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sysfs_links_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sysfs_links_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn loopback_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn loopback_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_loopback_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn downshifted_rate(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downshifted_rate(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn downshifted_rate_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_downshifted_rate_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_on_sfp_module(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_on_sfp_module(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_on_sfp_module_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_on_sfp_module_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mac_managed_pm(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mac_managed_pm(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mac_managed_pm_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mac_managed_pm_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wol_enabled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wol_enabled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wol_enabled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_genphy_driven(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_genphy_driven(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_genphy_driven_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_genphy_driven_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn autoneg(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn autoneg_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_autoneg_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_link_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn autoneg_complete(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg_complete(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn autoneg_complete_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_autoneg_complete_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interrupts(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupts(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interrupts_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_interrupts_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_suspended(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_suspended(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_suspended_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_suspended_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_rerun(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_rerun(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_rerun_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_rerun_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_timestamp(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_default_timestamp(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_timestamp_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_default_timestamp_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_c45: ffi::c_uint,
        is_internal: ffi::c_uint,
        is_pseudo_fixed_link: ffi::c_uint,
        is_gigabit_capable: ffi::c_uint,
        has_fixups: ffi::c_uint,
        suspended: ffi::c_uint,
        suspended_by_mdio_bus: ffi::c_uint,
        sysfs_links: ffi::c_uint,
        loopback_enabled: ffi::c_uint,
        downshifted_rate: ffi::c_uint,
        is_on_sfp_module: ffi::c_uint,
        mac_managed_pm: ffi::c_uint,
        wol_enabled: ffi::c_uint,
        is_genphy_driven: ffi::c_uint,
        autoneg: ffi::c_uint,
        link: ffi::c_uint,
        autoneg_complete: ffi::c_uint,
        interrupts: ffi::c_uint,
        irq_suspended: ffi::c_uint,
        irq_rerun: ffi::c_uint,
        default_timestamp: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_c45: u32 = unsafe { ::core::mem::transmute(is_c45) };
            is_c45 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_internal: u32 = unsafe { ::core::mem::transmute(is_internal) };
            is_internal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_pseudo_fixed_link: u32 = unsafe { ::core::mem::transmute(is_pseudo_fixed_link) };
            is_pseudo_fixed_link as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_gigabit_capable: u32 = unsafe { ::core::mem::transmute(is_gigabit_capable) };
            is_gigabit_capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fixups: u32 = unsafe { ::core::mem::transmute(has_fixups) };
            has_fixups as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let suspended: u32 = unsafe { ::core::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let suspended_by_mdio_bus: u32 =
                unsafe { ::core::mem::transmute(suspended_by_mdio_bus) };
            suspended_by_mdio_bus as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sysfs_links: u32 = unsafe { ::core::mem::transmute(sysfs_links) };
            sysfs_links as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let loopback_enabled: u32 = unsafe { ::core::mem::transmute(loopback_enabled) };
            loopback_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downshifted_rate: u32 = unsafe { ::core::mem::transmute(downshifted_rate) };
            downshifted_rate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_on_sfp_module: u32 = unsafe { ::core::mem::transmute(is_on_sfp_module) };
            is_on_sfp_module as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mac_managed_pm: u32 = unsafe { ::core::mem::transmute(mac_managed_pm) };
            mac_managed_pm as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let is_genphy_driven: u32 = unsafe { ::core::mem::transmute(is_genphy_driven) };
            is_genphy_driven as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let autoneg: u32 = unsafe { ::core::mem::transmute(autoneg) };
            autoneg as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let autoneg_complete: u32 = unsafe { ::core::mem::transmute(autoneg_complete) };
            autoneg_complete as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let interrupts: u32 = unsafe { ::core::mem::transmute(interrupts) };
            interrupts as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let irq_suspended: u32 = unsafe { ::core::mem::transmute(irq_suspended) };
            irq_suspended as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let irq_rerun: u32 = unsafe { ::core::mem::transmute(irq_rerun) };
            irq_rerun as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let default_timestamp: u32 = unsafe { ::core::mem::transmute(default_timestamp) };
            default_timestamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_tdr_config {
    pub first: u32_,
    pub last: u32_,
    pub step: u32_,
    pub pair: s8,
}
pub const link_inband_signalling_LINK_INBAND_DISABLE: link_inband_signalling = 1;
pub const link_inband_signalling_LINK_INBAND_ENABLE: link_inband_signalling = 2;
pub const link_inband_signalling_LINK_INBAND_BYPASS: link_inband_signalling = 4;
pub type link_inband_signalling = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_plca_cfg {
    pub version: ffi::c_int,
    pub enabled: ffi::c_int,
    pub node_id: ffi::c_int,
    pub node_cnt: ffi::c_int,
    pub to_tmr: ffi::c_int,
    pub burst_cnt: ffi::c_int,
    pub burst_tmr: ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_plca_status {
    pub pst: bool_,
}
pub const phy_led_modes_PHY_LED_ACTIVE_HIGH: phy_led_modes = 0;
pub const phy_led_modes_PHY_LED_ACTIVE_LOW: phy_led_modes = 1;
pub const phy_led_modes_PHY_LED_INACTIVE_HIGH_IMPEDANCE: phy_led_modes = 2;
pub const phy_led_modes___PHY_LED_MODES_NUM: phy_led_modes = 3;
pub type phy_led_modes = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_led {
    pub list: list_head,
    pub phydev: *mut phy_device,
    pub led_cdev: led_classdev,
    pub index: u8_,
}
impl Default for phy_led {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_driver {
    pub mdiodrv: mdio_driver_common,
    pub phy_id: u32_,
    pub name: *mut ffi::c_char,
    pub phy_id_mask: u32_,
    pub features: *const ffi::c_ulong,
    pub flags: u32_,
    pub driver_data: *const ffi::c_void,
    pub soft_reset:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub config_init:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub probe: ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub get_features:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub inband_caps: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, interface: phy_interface_t) -> ffi::c_uint,
    >,
    pub config_inband: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, modes: ffi::c_uint) -> ffi::c_int,
    >,
    pub get_rate_matching: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, iface: phy_interface_t) -> ffi::c_int,
    >,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub config_aneg:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub aneg_done:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub read_status:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub config_intr:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> ffi::c_int>,
    pub handle_interrupt:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> irqreturn_t>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device)>,
    pub match_phy_device: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, phydrv: *const phy_driver) -> ffi::c_int,
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, wol: *mut ethtool_wolinfo) -> ffi::c_int,
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, wol: *mut ethtool_wolinfo),
    >,
    pub link_change_notify: ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device)>,
    pub read_mmd: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, devnum: ffi::c_int, regnum: u16_) -> ffi::c_int,
    >,
    pub write_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            devnum: ffi::c_int,
            regnum: u16_,
            val: u16_,
        ) -> ffi::c_int,
    >,
    pub read_page: ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub write_page: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, page: ffi::c_int) -> ffi::c_int,
    >,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, modinfo: *mut ethtool_modinfo) -> ffi::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            ee: *mut ethtool_eeprom,
            data: *mut u8_,
        ) -> ffi::c_int,
    >,
    pub cable_test_start:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub cable_test_tdr_start: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, config: *const phy_tdr_config) -> ffi::c_int,
    >,
    pub cable_test_get_status: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, finished: *mut bool_) -> ffi::c_int,
    >,
    pub get_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            eth_stats: *mut ethtool_eth_phy_stats,
            stats: *mut ethtool_phy_stats,
        ),
    >,
    pub get_link_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, link_stats: *mut ethtool_link_ext_stats),
    >,
    pub update_stats:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub get_sset_count:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub get_strings:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device, data: *mut u8_)>,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, stats: *mut ethtool_stats, data: *mut u64_),
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            tuna: *mut ethtool_tunable,
            data: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            tuna: *mut ethtool_tunable,
            data: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub set_loopback: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, enable: bool_, speed: ffi::c_int) -> ffi::c_int,
    >,
    pub get_sqi: ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub get_sqi_max:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_int>,
    pub get_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_cfg: *mut phy_plca_cfg) -> ffi::c_int,
    >,
    pub set_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_cfg: *const phy_plca_cfg) -> ffi::c_int,
    >,
    pub get_plca_status: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_st: *mut phy_plca_status) -> ffi::c_int,
    >,
    pub led_brightness_set: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, index: u8_, value: led_brightness) -> ffi::c_int,
    >,
    pub led_blink_set: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            delay_on: *mut ffi::c_ulong,
            delay_off: *mut ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub led_hw_is_supported: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, index: u8_, rules: ffi::c_ulong) -> ffi::c_int,
    >,
    pub led_hw_control_set: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, index: u8_, rules: ffi::c_ulong) -> ffi::c_int,
    >,
    pub led_hw_control_get: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            rules: *mut ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub led_polarity_set: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: ffi::c_int,
            modes: ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub get_next_update_time:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> ffi::c_uint>,
}
impl Default for phy_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_board_info {
    pub bus_id: *const ffi::c_char,
    pub modalias: [ffi::c_char; 32usize],
    pub mdio_addr: ffi::c_int,
    pub platform_data: *const ffi::c_void,
}
impl Default for mdio_board_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_pin {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mfd_cell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_device {
    pub name: *const ffi::c_char,
    pub id: ffi::c_int,
    pub id_auto: bool_,
    pub dev: device,
    pub platform_dma_mask: u64_,
    pub dma_parms: device_dma_parameters,
    pub num_resources: u32_,
    pub resource: *mut resource,
    pub id_entry: *const platform_device_id,
    pub driver_override: *const ffi::c_char,
    pub mfd_cell: *mut mfd_cell,
    pub archdata: pdev_archdata,
}
impl Default for platform_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_device_info {
    pub parent: *mut device,
    pub fwnode: *mut fwnode_handle,
    pub of_node_reused: bool_,
    pub name: *const ffi::c_char,
    pub id: ffi::c_int,
    pub res: *const resource,
    pub num_res: ffi::c_uint,
    pub data: *const ffi::c_void,
    pub size_data: usize,
    pub dma_mask: u64_,
    pub properties: *const property_entry,
}
impl Default for platform_device_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_driver {
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut platform_device) -> ffi::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut platform_device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut platform_device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut platform_device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut platform_device) -> ffi::c_int>,
    pub driver: device_driver,
    pub id_table: *const platform_device_id,
    pub prevent_deferred_probe: bool_,
    pub driver_managed_dma: bool_,
}
impl Default for platform_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pollfd {
    pub fd: ffi::c_int,
    pub events: ffi::c_short,
    pub revents: ffi::c_short,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct epoll_event {
    pub events: __poll_t,
    pub data: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct epoll_params {
    pub busy_poll_usecs: __u32,
    pub busy_poll_budget: __u16,
    pub prefer_busy_poll: __u8,
    pub __pad: __u8,
}
pub type poll_queue_proc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut wait_queue_head_t,
        arg3: *mut poll_table_struct,
    ),
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct poll_table_struct {
    pub _qproc: poll_queue_proc,
    pub _key: __poll_t,
}
pub type poll_table = poll_table_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_table_entry {
    pub filp: *mut file,
    pub key: __poll_t,
    pub wait: wait_queue_entry_t,
    pub wait_address: *mut wait_queue_head_t,
}
impl Default for poll_table_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_wqueues {
    pub pt: poll_table,
    pub table: *mut poll_table_page,
    pub polling_task: *mut task_struct,
    pub triggered: ffi::c_int,
    pub error: ffi::c_int,
    pub inline_index: ffi::c_int,
    pub inline_entries: [poll_table_entry; 9usize],
}
impl Default for poll_wqueues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const mapping_flags_AS_EIO: mapping_flags = 0;
pub const mapping_flags_AS_ENOSPC: mapping_flags = 1;
pub const mapping_flags_AS_MM_ALL_LOCKS: mapping_flags = 2;
pub const mapping_flags_AS_UNEVICTABLE: mapping_flags = 3;
pub const mapping_flags_AS_EXITING: mapping_flags = 4;
pub const mapping_flags_AS_NO_WRITEBACK_TAGS: mapping_flags = 5;
pub const mapping_flags_AS_RELEASE_ALWAYS: mapping_flags = 6;
pub const mapping_flags_AS_STABLE_WRITES: mapping_flags = 7;
pub const mapping_flags_AS_INACCESSIBLE: mapping_flags = 8;
pub const mapping_flags_AS_WRITEBACK_MAY_DEADLOCK_ON_RECLAIM: mapping_flags = 9;
pub const mapping_flags_AS_FOLIO_ORDER_BITS: mapping_flags = 5;
pub const mapping_flags_AS_FOLIO_ORDER_MIN: mapping_flags = 16;
pub const mapping_flags_AS_FOLIO_ORDER_MAX: mapping_flags = 21;
pub type mapping_flags = ffi::c_uint;

pub type filler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ffi::c_int>;

pub type fgf_t = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_page_key {
    pub folio: *mut folio,
    pub bit_nr: ffi::c_int,
    pub page_match: ffi::c_int,
}
impl Default for wait_page_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_page_queue {
    pub folio: *mut folio,
    pub bit_nr: ffi::c_int,
    pub wait: wait_queue_entry_t,
}
impl Default for wait_page_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct readahead_control {
    pub file: *mut file,
    pub mapping: *mut address_space,
    pub ra: *mut file_ra_state,
    pub _index: ffi::c_ulong,
    pub _nr_pages: ffi::c_uint,
    pub _batch_count: ffi::c_uint,
    pub dropbehind: bool_,
    pub _workingset: bool_,
    pub _pflags: ffi::c_ulong,
}
impl Default for readahead_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const MPOL_DEFAULT: _bindgen_ty_321 = 0;
pub const MPOL_PREFERRED: _bindgen_ty_321 = 1;
pub const MPOL_BIND: _bindgen_ty_321 = 2;
pub const MPOL_INTERLEAVE: _bindgen_ty_321 = 3;
pub const MPOL_LOCAL: _bindgen_ty_321 = 4;
pub const MPOL_PREFERRED_MANY: _bindgen_ty_321 = 5;
pub const MPOL_WEIGHTED_INTERLEAVE: _bindgen_ty_321 = 6;
pub const MPOL_MAX: _bindgen_ty_321 = 7;
pub type _bindgen_ty_321 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pagevec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union swap_header {
    pub magic: swap_header__bindgen_ty_1,
    pub info: swap_header__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_header__bindgen_ty_1 {
    pub reserved: [ffi::c_char; 4086usize],
    pub magic: [ffi::c_char; 10usize],
}
impl Default for swap_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_header__bindgen_ty_2 {
    pub bootbits: [ffi::c_char; 1024usize],
    pub version: __u32,
    pub last_page: __u32,
    pub nr_badpages: __u32,
    pub sws_uuid: [ffi::c_uchar; 16usize],
    pub sws_volume: [ffi::c_uchar; 16usize],
    pub padding: [__u32; 117usize],
    pub badpages: [__u32; 1usize],
}
impl Default for swap_header__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for swap_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reclaim_state {
    pub reclaimed: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_extent {
    pub rb_node: rb_node,
    pub start_page: ffi::c_ulong,
    pub nr_pages: ffi::c_ulong,
    pub start_block: sector_t,
}
impl Default for swap_extent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SWP_USED: _bindgen_ty_322 = 1;
pub const SWP_WRITEOK: _bindgen_ty_322 = 2;
pub const SWP_DISCARDABLE: _bindgen_ty_322 = 4;
pub const SWP_DISCARDING: _bindgen_ty_322 = 8;
pub const SWP_SOLIDSTATE: _bindgen_ty_322 = 16;
pub const SWP_CONTINUED: _bindgen_ty_322 = 32;
pub const SWP_BLKDEV: _bindgen_ty_322 = 64;
pub const SWP_ACTIVATED: _bindgen_ty_322 = 128;
pub const SWP_FS_OPS: _bindgen_ty_322 = 256;
pub const SWP_AREA_DISCARD: _bindgen_ty_322 = 512;
pub const SWP_PAGE_DISCARD: _bindgen_ty_322 = 1024;
pub const SWP_STABLE_WRITES: _bindgen_ty_322 = 2048;
pub const SWP_SYNCHRONOUS_IO: _bindgen_ty_322 = 4096;
pub type _bindgen_ty_322 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_cluster_info {
    pub lock: spinlock_t,
    pub count: u16_,
    pub flags: u8_,
    pub order: u8_,
    pub list: list_head,
}
impl Default for swap_cluster_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const swap_cluster_flags_CLUSTER_FLAG_NONE: swap_cluster_flags = 0;
pub const swap_cluster_flags_CLUSTER_FLAG_FREE: swap_cluster_flags = 1;
pub const swap_cluster_flags_CLUSTER_FLAG_NONFULL: swap_cluster_flags = 2;
pub const swap_cluster_flags_CLUSTER_FLAG_FRAG: swap_cluster_flags = 3;
pub const swap_cluster_flags_CLUSTER_FLAG_USABLE: swap_cluster_flags = 3;
pub const swap_cluster_flags_CLUSTER_FLAG_FULL: swap_cluster_flags = 4;
pub const swap_cluster_flags_CLUSTER_FLAG_DISCARD: swap_cluster_flags = 5;
pub const swap_cluster_flags_CLUSTER_FLAG_MAX: swap_cluster_flags = 6;
pub type swap_cluster_flags = ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swap_sequential_cluster {
    pub next: [ffi::c_uint; 1usize],
}
#[repr(C)]
pub struct swap_info_struct {
    pub users: percpu_ref,
    pub flags: ffi::c_ulong,
    pub prio: ffi::c_short,
    pub list: plist_node,
    pub type_: ffi::c_schar,
    pub max: ffi::c_uint,
    pub swap_map: *mut ffi::c_uchar,
    pub zeromap: *mut ffi::c_ulong,
    pub cluster_info: *mut swap_cluster_info,
    pub free_clusters: list_head,
    pub full_clusters: list_head,
    pub nonfull_clusters: [list_head; 1usize],
    pub frag_clusters: [list_head; 1usize],
    pub frag_cluster_nr: [atomic_long_t; 1usize],
    pub pages: ffi::c_uint,
    pub inuse_pages: atomic_long_t,
    pub global_cluster: *mut swap_sequential_cluster,
    pub global_cluster_lock: spinlock_t,
    pub swap_extent_root: rb_root,
    pub bdev: *mut block_device,
    pub swap_file: *mut file,
    pub comp: completion,
    pub lock: spinlock_t,
    pub cont_lock: spinlock_t,
    pub discard_work: work_struct,
    pub reclaim_work: work_struct,
    pub discard_clusters: list_head,
    pub avail_lists: __IncompleteArrayField<plist_node>,
}
impl Default for swap_info_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub type suspend_state_t = ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_suspend_ops {
    pub valid: ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> ffi::c_int>,
    pub begin: ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> ffi::c_int>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub prepare_late: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub enter: ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> ffi::c_int>,
    pub wake: ::core::option::Option<unsafe extern "C" fn()>,
    pub finish: ::core::option::Option<unsafe extern "C" fn()>,
    pub suspend_again: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
    pub recover: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_s2idle_ops {
    pub begin: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub prepare_late: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub check: ::core::option::Option<unsafe extern "C" fn()>,
    pub wake: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub restore_early: ::core::option::Option<unsafe extern "C" fn()>,
    pub restore: ::core::option::Option<unsafe extern "C" fn()>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
}

pub const s2idle_states_S2IDLE_STATE_NONE: s2idle_states = 0;
pub const s2idle_states_S2IDLE_STATE_ENTER: s2idle_states = 1;
pub const s2idle_states_S2IDLE_STATE_WAKE: s2idle_states = 2;
pub type s2idle_states = ffi::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pbe {
    pub address: *mut ffi::c_void,
    pub orig_address: *mut ffi::c_void,
    pub next: *mut pbe,
}
impl Default for pbe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_hibernation_ops {
    pub begin: ::core::option::Option<unsafe extern "C" fn(stage: pm_message_t) -> ffi::c_int>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_snapshot: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub finish: ::core::option::Option<unsafe extern "C" fn()>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub enter: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub leave: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_restore: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub restore_cleanup: ::core::option::Option<unsafe extern "C" fn()>,
    pub recover: ::core::option::Option<unsafe extern "C" fn()>,
}

pub const suspend_stat_step_SUSPEND_WORKING: suspend_stat_step = 0;
pub const suspend_stat_step_SUSPEND_FREEZE: suspend_stat_step = 1;
pub const suspend_stat_step_SUSPEND_PREPARE: suspend_stat_step = 2;
pub const suspend_stat_step_SUSPEND_SUSPEND: suspend_stat_step = 3;
pub const suspend_stat_step_SUSPEND_SUSPEND_LATE: suspend_stat_step = 4;
pub const suspend_stat_step_SUSPEND_SUSPEND_NOIRQ: suspend_stat_step = 5;
pub const suspend_stat_step_SUSPEND_RESUME_NOIRQ: suspend_stat_step = 6;
pub const suspend_stat_step_SUSPEND_RESUME_EARLY: suspend_stat_step = 7;
pub const suspend_stat_step_SUSPEND_RESUME: suspend_stat_step = 8;
pub type suspend_stat_step = ffi::c_uint;

#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reg_genl_event {
    pub reg_name: [ffi::c_char; 32usize],
    pub event: u64,
}
pub const REG_GENL_ATTR_UNSPEC: _bindgen_ty_323 = 0;
pub const REG_GENL_ATTR_EVENT: _bindgen_ty_323 = 1;
pub const __REG_GENL_ATTR_MAX: _bindgen_ty_323 = 2;
pub type _bindgen_ty_323 = ffi::c_uint;
pub const REG_GENL_CMD_UNSPEC: _bindgen_ty_324 = 0;
pub const REG_GENL_CMD_EVENT: _bindgen_ty_324 = 1;
pub const __REG_GENL_CMD_MAX: _bindgen_ty_324 = 2;
pub type _bindgen_ty_324 = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pre_voltage_change_data {
    pub old_uV: ffi::c_ulong,
    pub min_uV: ffi::c_ulong,
    pub max_uV: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator_bulk_data {
    pub supply: *const ffi::c_char,
    pub consumer: *mut regulator,
    pub init_load_uA: ffi::c_int,
    pub ret: ffi::c_int,
}
impl Default for regulator_bulk_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_eval_map {
    pub system: *const ffi::c_char,
    pub eval_string: *const ffi::c_char,
    pub eval_value: ffi::c_ulong,
}
impl Default for trace_eval_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct tp_module {
    pub list: list_head,
    pub mod_: *mut module,
}
impl Default for tp_module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

pub const ARCH_SLAB_MINALIGN: usize = 8;
pub const PAGE_SIZE: usize = 4096;
pub const GFP_ATOMIC: gfp_t = 2080;
pub const GFP_KERNEL: gfp_t = 3264;
pub const GFP_KERNEL_ACCOUNT: gfp_t = 4197568;
pub const GFP_NOWAIT: gfp_t = 10240;
pub const __GFP_ZERO: gfp_t = 256;
pub const __GFP_HIGHMEM: gfp_t = 2;
pub const __GFP_NOWARN: gfp_t = 8192;
pub const BLK_FEAT_ROTATIONAL: blk_features_t = 4;
pub const FOP_UNSIGNED_OFFSET: fop_flags_t = 32;
pub const XA_PRESENT: xa_mark_t = 8;
pub const XA_FLAGS_ALLOC: gfp_t = 33554436;
pub const XA_FLAGS_ALLOC1: gfp_t = 12;
pub type __builtin_va_list = *mut ffi::c_void;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_symbol {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_pnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_enode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct files_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_root {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_group_capacity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msgbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_undo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_clock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_lock_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bus_dma_region {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_coherent_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_tlb_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_framebuffer {
    pub _address: u8,
}
pub type drm_mode_status = i32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_property {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct drm_mode_config_helper_funcs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct disk_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bio_alloc_cache {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timer_rand_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdrom_device_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct throtl_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpufreq_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thermal_cooling_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct time_namespace {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_kfunc_btf_tab {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_fprog_kern {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_cgroup_storage {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_policy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_rule {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hotplug_slot {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_package_shared {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pse_control {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct poll_table_page {
    pub _address: u8,
}
